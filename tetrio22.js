window.TETRIO_ENV = {
	"mode": "production",
	"version": "4.0.4",
	"countdown": false,
	"commit": {
		"id": "ac5820f",
		"time": 1594330587000
	},
	"serverCycle": "gO84kY1_3",
	"build": {
		"id": "WhLhQpCGR",
		"time": 1594330668104
	}
};
window.TETRIO_SE_SHEET = {
	"allclear": [0, 2800.2721088435374],
	"applause": [4000, 7401.0204081632655],
	"boardappear": [13000, 1598.9795918367342],
	"btb_1": [16000, 1000],
	"btb_2": [18000, 1000],
	"btb_3": [20000, 1000],
	"btb_break": [22000, 1000],
	"clearbtb": [24000, 1799.7278911564613],
	"clearline": [27000, 1100.0453514739233],
	"clearquad": [30000, 2001.1791383219943],
	"clearspin": [34000, 2599.569160997731],
	"clutch": [38000, 340.9070294784584],
	"combo_1_power": [40000, 997.9365079365082],
	"combo_1": [42000, 992.7891156462607],
	"combo_10_power": [44000, 1000],
	"combo_10": [46000, 1000],
	"combo_11_power": [48000, 1000],
	"combo_11": [50000, 1000],
	"combo_12_power": [52000, 1000],
	"combo_12": [54000, 1000],
	"combo_13_power": [56000, 1000],
	"combo_13": [58000, 1000],
	"combo_14_power": [60000, 1000],
	"combo_14": [62000, 1000],
	"combo_15_power": [64000, 1000],
	"combo_15": [66000, 1000],
	"combo_16_power": [68000, 2000],
	"combo_16": [71000, 1000],
	"combo_2_power": [73000, 1000.0453514739291],
	"combo_2": [76000, 1000],
	"combo_3_power": [78000, 1000],
	"combo_3": [80000, 1000],
	"combo_4_power": [82000, 1000.1133786848015],
	"combo_4": [85000, 1000],
	"combo_5_power": [87000, 999.8866213151985],
	"combo_5": [89000, 1000],
	"combo_6_power": [91000, 1000],
	"combo_6": [93000, 1000],
	"combo_7_power": [95000, 1000],
	"combo_7": [97000, 999.9773242630425],
	"combo_8_power": [99000, 1000],
	"combo_8": [101000, 1000.0226757369575],
	"combo_9_power": [104000, 1000],
	"combo_9": [106000, 1000],
	"combobreak": [108000, 900.362811791382],
	"countdown1": [110000, 1000],
	"countdown2": [112000, 1000],
	"countdown3": [114000, 1000],
	"countdown4": [116000, 1000],
	"countdown5": [118000, 1000],
	"counter": [120000, 1000],
	"damage_alert": [122000, 1500],
	"damage_large": [125000, 1200.0000000000027],
	"damage_medium": [128000, 1000],
	"damage_small": [130000, 800.0000000000114],
	"death": [132000, 599.9999999999943],
	"detonate1": [134000, 100.45351473922892],
	"detonate2": [136000, 199.31972789115093],
	"detonated": [138000, 2701.020408163259],
	"elim": [142000, 500],
	"exchange": [144000, 700.4081632653083],
	"failure": [146000, 3099.7959183673347],
	"finessefault": [151000, 699.9999999999886],
	"finish": [153000, 2697.278911564638],
	"fire": [157000, 9906.757369614525],
	"floor": [168000, 501.08843537415737],
	"gameover": [170000, 3500],
	"garbage_in_large": [175000, 1199.9999999999886],
	"garbage_in_medium": [178000, 1199.9999999999886],
	"garbage_in_small": [181000, 699.9999999999886],
	"garbage_out_large": [183000, 1000],
	"garbage_out_medium": [185000, 1000],
	"garbage_out_small": [187000, 1000.0680272108866],
	"garbagerise": [190000, 1199.1383219954628],
	"garbagesmash": [193000, 2100.408163265314],
	"go": [197000, 2900.226757369609],
	"harddrop": [201000, 399.6825396825443],
	"hit": [203000, 300.13605442175617],
	"hold": [205000, 399.79591836734585],
	"hyperalert": [207000, 1699.659863945584],
	"i": [210000, 1000],
	"impact": [212000, 1199.9999999999886],
	"j": [215000, 1000],
	"l": [217000, 1000],
	"level1": [219000, 5000],
	"level10": [225000, 5000],
	"level100": [231000, 5000],
	"level500": [237000, 5000],
	"levelup": [243000, 1400.6349206349284],
	"losestock": [246000, 1500.0226757369717],
	"maintenance": [249000, 1099.591836734703],
	"matchintro": [252000, 16500],
	"menuback": [270000, 599.9319727891361],
	"menuclick": [272000, 1099.9773242630226],
	"menuconfirm": [275000, 2699.9999999999886],
	"menuhit1": [279000, 1200.0680272108752],
	"menuhit2": [282000, 1200.4081632653083],
	"menuhit3": [285000, 1199.501133786839],
	"menuhover": [288000, 200.1814058957052],
	"menutap": [290000, 99.65986394558968],
	"mission_free": [292000, 3399.9999999999773],
	"mission_league": [297000, 11199.818594104328],
	"mission_versus": [310000, 4899.999999999977],
	"mission": [316000, 5999.773242630397],
	"mmstart": [323000, 2500.3628117913763],
	"move": [327000, 199.8639455782154],
	"no": [329000, 188.1859410430593],
	"notify": [331000, 200.4081632653083],
	"o": [333000, 1000],
	"offset": [335000, 399.99999999997726],
	"personalbest": [337000, 3498.8662131519277],
	"ranklower": [342000, 3300.0000000000114],
	"rankraise": [347000, 9200.02267573699],
	"ratinglower": [358000, 2699.9999999999886],
	"ratingraise": [362000, 2199.9999999999886],
	"ribbon_off": [366000, 587.5736961451139],
	"ribbon_on": [368000, 714.8299319728153],
	"ribbon_tap": [370000, 758.6621315192588],
	"ribbon": [372000, 241.24716553285452],
	"rotate": [374000, 199.68253968255567],
	"rsg_go": [376000, 2900.090702947864],
	"rsg": [380000, 899.7505668934309],
	"s": [382000, 1000],
	"scoreslide_in": [384000, 499.90929705217013],
	"scoreslide_out": [386000, 899.863945578204],
	"shatter": [388000, 3000],
	"showscore": [392000, 4599.95464852608],
	"sidehit": [398000, 297.80045351475337],
	"softdrop": [400000, 99.90929705213603],
	"spin": [402000, 2000.0907029478299],
	"spinend": [406000, 799.5691609977484],
	"t": [408000, 1000],
	"target": [410000, 299.97732426301127],
	"thunder1": [412000, 3300.0000000000114],
	"thunder2": [417000, 4600.000000000023],
	"thunder3": [423000, 3000],
	"thunder4": [427000, 3000],
	"thunder5": [431000, 5000],
	"thunder6": [437000, 5000],
	"timer1": [443000, 498.73015873015447],
	"timer2": [445000, 399.2970521541679],
	"topout": [447000, 4600.136054421796],
	"userjoin": [453000, 699.591836734669],
	"userleave": [455000, 299.5918367346917],
	"victory": [457000, 7499.750566893397],
	"warning": [466000, 1200.158730158705],
	"warp": [469000, 10531.29251700682],
	"worldrecord": [481000, 3701.4965986394373],
	"z": [486000, 1000]
};

/*!
 * pixi.js - v5.2.2
 * Compiled Tue, 21 Apr 2020 03:53:51 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PIXI = function (t) {
	"use strict";
	var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

	function r(t, e) {
		return t(e = {
			exports: {}
		}, e.exports), e.exports
	}
	var i = r(function (t, r) {
			! function (t) {
				var e = t.Promise,
					i = e && "resolve" in e && "reject" in e && "all" in e && "race" in e && function () {
						var t;
						return new e(function (e) {
							t = e
						}), "function" == typeof t
					}();
				r ? (r.Promise = i ? e : T, r.Polyfill = T) : i || (t.Promise = T);
				var n = "pending",
					o = "sealed",
					s = "fulfilled",
					a = "rejected",
					h = function () {};

				function u(t) {
					return "[object Array]" === Object.prototype.toString.call(t)
				}
				var l, c = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
					d = [];

				function p() {
					for (var t = 0; t < d.length; t++) d[t][0](d[t][1]);
					d = [], l = !1
				}

				function f(t, e) {
					d.push([t, e]), l || (l = !0, c(p, 0))
				}

				function v(t) {
					var e = t.owner,
						r = e.state_,
						i = e.data_,
						n = t[r],
						o = t.then;
					if ("function" == typeof n) {
						r = s;
						try {
							i = n(i)
						} catch (t) {
							_(o, t)
						}
					}
					m(o, i) || (r === s && g(o, i), r === a && _(o, i))
				}

				function m(t, e) {
					var r;
					try {
						if (t === e) throw new TypeError("A promises callback cannot return that same promise.");
						if (e && ("function" == typeof e || "object" == typeof e)) {
							var i = e.then;
							if ("function" == typeof i) return i.call(e, function (i) {
								r || (r = !0, e !== i ? g(t, i) : y(t, i))
							}, function (e) {
								r || (r = !0, _(t, e))
							}), !0
						}
					} catch (e) {
						return r || _(t, e), !0
					}
					return !1
				}

				function g(t, e) {
					t !== e && m(t, e) || y(t, e)
				}

				function y(t, e) {
					t.state_ === n && (t.state_ = o, t.data_ = e, f(b, t))
				}

				function _(t, e) {
					t.state_ === n && (t.state_ = o, t.data_ = e, f(E, t))
				}

				function x(t) {
					var e = t.then_;
					t.then_ = void 0;
					for (var r = 0; r < e.length; r++) v(e[r])
				}

				function b(t) {
					t.state_ = s, x(t)
				}

				function E(t) {
					t.state_ = a, x(t)
				}

				function T(t) {
					if ("function" != typeof t) throw new TypeError("Promise constructor takes a function argument");
					if (this instanceof T == !1) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
					this.then_ = [],
						function (t, e) {
							function r(t) {
								_(e, t)
							}
							try {
								t(function (t) {
									g(e, t)
								}, r)
							} catch (t) {
								r(t)
							}
						}(t, this)
				}
				T.prototype = {
					constructor: T,
					state_: n,
					then_: null,
					data_: void 0,
					then: function (t, e) {
						var r = {
							owner: this,
							then: new this.constructor(h),
							fulfilled: t,
							rejected: e
						};
						return this.state_ === s || this.state_ === a ? f(v, r) : this.then_.push(r), r.then
					},
					catch: function (t) {
						return this.then(null, t)
					}
				}, T.all = function (t) {
					if (!u(t)) throw new TypeError("You must pass an array to Promise.all().");
					return new this(function (e, r) {
						var i = [],
							n = 0;

						function o(t) {
							return n++,
								function (r) {
									i[t] = r, --n || e(i)
								}
						}
						for (var s, a = 0; a < t.length; a++)(s = t[a]) && "function" == typeof s.then ? s.then(o(a), r) : i[a] = s;
						n || e(i)
					})
				}, T.race = function (t) {
					if (!u(t)) throw new TypeError("You must pass an array to Promise.race().");
					return new this(function (e, r) {
						for (var i, n = 0; n < t.length; n++)(i = t[n]) && "function" == typeof i.then ? i.then(e, r) : e(i)
					})
				}, T.resolve = function (t) {
					return t && "object" == typeof t && t.constructor === this ? t : new this(function (e) {
						e(t)
					})
				}, T.reject = function (t) {
					return new this(function (e, r) {
						r(t)
					})
				}
			}("undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : e)
		}),
		n = (i.Promise, i.Polyfill),
		o = Object.getOwnPropertySymbols,
		s = Object.prototype.hasOwnProperty,
		a = Object.prototype.propertyIsEnumerable;
	var h = function () {
		try {
			if (!Object.assign) return !1;
			var t = new String("abc");
			if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
			for (var e = {}, r = 0; r < 10; r++) e["_" + String.fromCharCode(r)] = r;
			if ("0123456789" !== Object.getOwnPropertyNames(e).map(function (t) {
					return e[t]
				}).join("")) return !1;
			var i = {};
			return "abcdefghijklmnopqrst".split("").forEach(function (t) {
				i[t] = t
			}), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("")
		} catch (t) {
			return !1
		}
	}() ? Object.assign : function (t, e) {
		for (var r, i, n = arguments, h = function (t) {
				if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
				return Object(t)
			}(t), u = 1; u < arguments.length; u++) {
			for (var l in r = Object(n[u])) s.call(r, l) && (h[l] = r[l]);
			if (o) {
				i = o(r);
				for (var c = 0; c < i.length; c++) a.call(r, i[c]) && (h[i[c]] = r[i[c]])
			}
		}
		return h
	};
	window.Promise || (window.Promise = n), Object.assign || (Object.assign = h);
	var u = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
	if (Date.now && Date.prototype.getTime || (Date.now = function () {
			return (new Date).getTime()
		}), !u.performance || !u.performance.now) {
		var l = Date.now();
		u.performance || (u.performance = {}), u.performance.now = function () {
			return Date.now() - l
		}
	}
	for (var c = Date.now(), d = ["ms", "moz", "webkit", "o"], p = 0; p < d.length && !u.requestAnimationFrame; ++p) {
		var f = d[p];
		u.requestAnimationFrame = u[f + "RequestAnimationFrame"], u.cancelAnimationFrame = u[f + "CancelAnimationFrame"] || u[f + "CancelRequestAnimationFrame"]
	}
	u.requestAnimationFrame || (u.requestAnimationFrame = function (t) {
		if ("function" != typeof t) throw new TypeError(t + "is not a function");
		var e = Date.now(),
			r = 16 + c - e;
		return r < 0 && (r = 0), c = e, setTimeout(function () {
			c = Date.now(), t(performance.now())
		}, r)
	}), u.cancelAnimationFrame || (u.cancelAnimationFrame = function (t) {
		return clearTimeout(t)
	}), Math.sign || (Math.sign = function (t) {
		return 0 === (t = Number(t)) || isNaN(t) ? t : t > 0 ? 1 : -1
	}), Number.isInteger || (Number.isInteger = function (t) {
		return "number" == typeof t && isFinite(t) && Math.floor(t) === t
	}), window.ArrayBuffer || (window.ArrayBuffer = Array), window.Float32Array || (window.Float32Array = Array), window.Uint32Array || (window.Uint32Array = Array), window.Uint16Array || (window.Uint16Array = Array), window.Uint8Array || (window.Uint8Array = Array), window.Int32Array || (window.Int32Array = Array);
	var v = /iPhone/i,
		m = /iPod/i,
		g = /iPad/i,
		y = /\biOS-universal(?:.+)Mac\b/i,
		_ = /\bAndroid(?:.+)Mobile\b/i,
		x = /Android/i,
		b = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
		E = /Silk/i,
		T = /Windows Phone/i,
		w = /\bWindows(?:.+)ARM\b/i,
		S = /BlackBerry/i,
		I = /BB10/i,
		P = /Opera Mini/i,
		A = /\b(CriOS|Chrome)(?:.+)Mobile/i,
		O = /Mobile(?:.+)Firefox\b/i,
		D = function (t) {
			return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
		};
	var C = function (t) {
		var e = {
			userAgent: "",
			platform: "",
			maxTouchPoints: 0
		};
		t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
			userAgent: t.userAgent,
			platform: t.platform,
			maxTouchPoints: t.maxTouchPoints || 0
		}) : e = {
			userAgent: navigator.userAgent,
			platform: navigator.platform,
			maxTouchPoints: navigator.maxTouchPoints || 0
		};
		var r = e.userAgent,
			i = r.split("[FBAN");
		void 0 !== i[1] && (r = i[0]), void 0 !== (i = r.split("Twitter"))[1] && (r = i[0]);
		var n = function (t) {
				return function (e) {
					return e.test(t)
				}
			}(r),
			o = {
				apple: {
					phone: n(v) && !n(T),
					ipod: n(m),
					tablet: !n(v) && (n(g) || D(e)) && !n(T),
					universal: n(y),
					device: (n(v) || n(m) || n(g) || n(y) || D(e)) && !n(T)
				},
				amazon: {
					phone: n(b),
					tablet: !n(b) && n(E),
					device: n(b) || n(E)
				},
				android: {
					phone: !n(T) && n(b) || !n(T) && n(_),
					tablet: !n(T) && !n(b) && !n(_) && (n(E) || n(x)),
					device: !n(T) && (n(b) || n(E) || n(_) || n(x)) || n(/\bokhttp\b/i)
				},
				windows: {
					phone: n(T),
					tablet: n(w),
					device: n(T) || n(w)
				},
				other: {
					blackberry: n(S),
					blackberry10: n(I),
					opera: n(P),
					firefox: n(O),
					chrome: n(A),
					device: n(S) || n(I) || n(P) || n(O) || n(A)
				},
				any: !1,
				phone: !1,
				tablet: !1
			};
		return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o
	}(window.navigator);
	var M = {
			MIPMAP_TEXTURES: 1,
			ANISOTROPIC_LEVEL: 0,
			RESOLUTION: 1,
			FILTER_RESOLUTION: 1,
			SPRITE_MAX_TEXTURES: function (t) {
				var e = !0;
				if (C.tablet || C.phone) {
					if (e = !1, C.apple.device) {
						var r = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
						r && parseInt(r[1], 10) >= 11 && (e = !0)
					}
					if (C.android.device) {
						var i = navigator.userAgent.match(/Android\s([0-9.]*)/);
						i && parseInt(i[1], 10) >= 7 && (e = !0)
					}
				}
				return e ? t : 4
			}(32),
			SPRITE_BATCH_SIZE: 4096,
			RENDER_OPTIONS: {
				view: null,
				antialias: !1,
				forceFXAA: !1,
				autoDensity: !1,
				transparent: !1,
				backgroundColor: 0,
				clearBeforeRender: !0,
				preserveDrawingBuffer: !1,
				width: 800,
				height: 600,
				legacy: !1
			},
			GC_MODE: 0,
			GC_MAX_IDLE: 3600,
			GC_MAX_CHECK_COUNT: 600,
			WRAP_MODE: 33071,
			SCALE_MODE: 1,
			PRECISION_VERTEX: "highp",
			PRECISION_FRAGMENT: C.apple.device ? "highp" : "mediump",
			CAN_UPLOAD_SAME_BUFFER: !C.apple.device,
			CREATE_IMAGE_BITMAP: !1,
			ROUND_PIXELS: !1
		},
		R = r(function (t) {
			var e = Object.prototype.hasOwnProperty,
				r = "~";

			function i() {}

			function n(t, e, r) {
				this.fn = t, this.context = e, this.once = r || !1
			}

			function o(t, e, i, o, s) {
				if ("function" != typeof i) throw new TypeError("The listener must be a function");
				var a = new n(i, o || t, s),
					h = r ? r + e : e;
				return t._events[h] ? t._events[h].fn ? t._events[h] = [t._events[h], a] : t._events[h].push(a) : (t._events[h] = a, t._eventsCount++), t
			}

			function s(t, e) {
				0 == --t._eventsCount ? t._events = new i : delete t._events[e]
			}

			function a() {
				this._events = new i, this._eventsCount = 0
			}
			Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (r = !1)), a.prototype.eventNames = function () {
				var t, i, n = [];
				if (0 === this._eventsCount) return n;
				for (i in t = this._events) e.call(t, i) && n.push(r ? i.slice(1) : i);
				return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n
			}, a.prototype.listeners = function (t) {
				var e = r ? r + t : t,
					i = this._events[e];
				if (!i) return [];
				if (i.fn) return [i.fn];
				for (var n = 0, o = i.length, s = new Array(o); n < o; n++) s[n] = i[n].fn;
				return s
			}, a.prototype.listenerCount = function (t) {
				var e = r ? r + t : t,
					i = this._events[e];
				return i ? i.fn ? 1 : i.length : 0
			}, a.prototype.emit = function (t, e, i, n, o, s) {
				var a = arguments,
					h = r ? r + t : t;
				if (!this._events[h]) return !1;
				var u, l, c = this._events[h],
					d = arguments.length;
				if (c.fn) {
					switch (c.once && this.removeListener(t, c.fn, void 0, !0), d) {
						case 1:
							return c.fn.call(c.context), !0;
						case 2:
							return c.fn.call(c.context, e), !0;
						case 3:
							return c.fn.call(c.context, e, i), !0;
						case 4:
							return c.fn.call(c.context, e, i, n), !0;
						case 5:
							return c.fn.call(c.context, e, i, n, o), !0;
						case 6:
							return c.fn.call(c.context, e, i, n, o, s), !0
					}
					for (l = 1, u = new Array(d - 1); l < d; l++) u[l - 1] = a[l];
					c.fn.apply(c.context, u)
				} else {
					var p, f = c.length;
					for (l = 0; l < f; l++) switch (c[l].once && this.removeListener(t, c[l].fn, void 0, !0), d) {
						case 1:
							c[l].fn.call(c[l].context);
							break;
						case 2:
							c[l].fn.call(c[l].context, e);
							break;
						case 3:
							c[l].fn.call(c[l].context, e, i);
							break;
						case 4:
							c[l].fn.call(c[l].context, e, i, n);
							break;
						default:
							if (!u)
								for (p = 1, u = new Array(d - 1); p < d; p++) u[p - 1] = a[p];
							c[l].fn.apply(c[l].context, u)
					}
				}
				return !0
			}, a.prototype.on = function (t, e, r) {
				return o(this, t, e, r, !1)
			}, a.prototype.once = function (t, e, r) {
				return o(this, t, e, r, !0)
			}, a.prototype.removeListener = function (t, e, i, n) {
				var o = r ? r + t : t;
				if (!this._events[o]) return this;
				if (!e) return s(this, o), this;
				var a = this._events[o];
				if (a.fn) a.fn !== e || n && !a.once || i && a.context !== i || s(this, o);
				else {
					for (var h = 0, u = [], l = a.length; h < l; h++)(a[h].fn !== e || n && !a[h].once || i && a[h].context !== i) && u.push(a[h]);
					u.length ? this._events[o] = 1 === u.length ? u[0] : u : s(this, o)
				}
				return this
			}, a.prototype.removeAllListeners = function (t) {
				var e;
				return t ? (e = r ? r + t : t, this._events[e] && s(this, e)) : (this._events = new i, this._eventsCount = 0), this
			}, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a
		}),
		L = F,
		N = F;

	function F(t, e, r) {
		r = r || 2;
		var i, n, o, s, a, h, u, l = e && e.length,
			c = l ? e[0] * r : t.length,
			d = B(t, 0, c, r, !0),
			p = [];
		if (!d || d.next === d.prev) return p;
		if (l && (d = function (t, e, r, i) {
				var n, o, s, a, h, u = [];
				for (n = 0, o = e.length; n < o; n++) s = e[n] * i, a = n < o - 1 ? e[n + 1] * i : t.length, (h = B(t, s, a, i, !1)) === h.next && (h.steiner = !0), u.push(q(h));
				for (u.sort(Y), n = 0; n < u.length; n++) V(u[n], r), r = U(r, r.next);
				return r
			}(t, e, d, r)), t.length > 80 * r) {
			i = o = t[0], n = s = t[1];
			for (var f = r; f < c; f += r)(a = t[f]) < i && (i = a), (h = t[f + 1]) < n && (n = h), a > o && (o = a), h > s && (s = h);
			u = 0 !== (u = Math.max(o - i, s - n)) ? 1 / u : 0
		}
		return k(d, p, r, i, n, u), p
	}

	function B(t, e, r, i, n) {
		var o, s;
		if (n === at(t, e, r, i) > 0)
			for (o = e; o < r; o += i) s = nt(o, t[o], t[o + 1], s);
		else
			for (o = r - i; o >= e; o -= i) s = nt(o, t[o], t[o + 1], s);
		return s && Q(s, s.next) && (ot(s), s = s.next), s
	}

	function U(t, e) {
		if (!t) return t;
		e || (e = t);
		var r, i = t;
		do {
			if (r = !1, i.steiner || !Q(i, i.next) && 0 !== J(i.prev, i, i.next)) i = i.next;
			else {
				if (ot(i), (i = e = i.prev) === i.next) break;
				r = !0
			}
		} while (r || i !== e);
		return e
	}

	function k(t, e, r, i, n, o, s) {
		if (t) {
			!s && o && function (t, e, r, i) {
				var n = t;
				do {
					null === n.z && (n.z = W(n.x, n.y, e, r, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next
				} while (n !== t);
				n.prevZ.nextZ = null, n.prevZ = null,
					function (t) {
						var e, r, i, n, o, s, a, h, u = 1;
						do {
							for (r = t, t = null, o = null, s = 0; r;) {
								for (s++, i = r, a = 0, e = 0; e < u && (a++, i = i.nextZ); e++);
								for (h = u; a > 0 || h > 0 && i;) 0 !== a && (0 === h || !i || r.z <= i.z) ? (n = r, r = r.nextZ, a--) : (n = i, i = i.nextZ, h--), o ? o.nextZ = n : t = n, n.prevZ = o, o = n;
								r = i
							}
							o.nextZ = null, u *= 2
						} while (s > 1)
					}(n)
			}(t, i, n, o);
			for (var a, h, u = t; t.prev !== t.next;)
				if (a = t.prev, h = t.next, o ? j(t, i, n, o) : X(t)) e.push(a.i / r), e.push(t.i / r), e.push(h.i / r), ot(t), t = h.next, u = h.next;
				else if ((t = h) === u) {
				s ? 1 === s ? k(t = H(U(t), e, r), e, r, i, n, o, 2) : 2 === s && G(t, e, r, i, n, o) : k(U(t), e, r, i, n, o, 1);
				break
			}
		}
	}

	function X(t) {
		var e = t.prev,
			r = t,
			i = t.next;
		if (J(e, r, i) >= 0) return !1;
		for (var n = t.next.next; n !== t.prev;) {
			if (K(e.x, e.y, r.x, r.y, i.x, i.y, n.x, n.y) && J(n.prev, n, n.next) >= 0) return !1;
			n = n.next
		}
		return !0
	}

	function j(t, e, r, i) {
		var n = t.prev,
			o = t,
			s = t.next;
		if (J(n, o, s) >= 0) return !1;
		for (var a = n.x < o.x ? n.x < s.x ? n.x : s.x : o.x < s.x ? o.x : s.x, h = n.y < o.y ? n.y < s.y ? n.y : s.y : o.y < s.y ? o.y : s.y, u = n.x > o.x ? n.x > s.x ? n.x : s.x : o.x > s.x ? o.x : s.x, l = n.y > o.y ? n.y > s.y ? n.y : s.y : o.y > s.y ? o.y : s.y, c = W(a, h, e, r, i), d = W(u, l, e, r, i), p = t.prevZ, f = t.nextZ; p && p.z >= c && f && f.z <= d;) {
			if (p !== t.prev && p !== t.next && K(n.x, n.y, o.x, o.y, s.x, s.y, p.x, p.y) && J(p.prev, p, p.next) >= 0) return !1;
			if (p = p.prevZ, f !== t.prev && f !== t.next && K(n.x, n.y, o.x, o.y, s.x, s.y, f.x, f.y) && J(f.prev, f, f.next) >= 0) return !1;
			f = f.nextZ
		}
		for (; p && p.z >= c;) {
			if (p !== t.prev && p !== t.next && K(n.x, n.y, o.x, o.y, s.x, s.y, p.x, p.y) && J(p.prev, p, p.next) >= 0) return !1;
			p = p.prevZ
		}
		for (; f && f.z <= d;) {
			if (f !== t.prev && f !== t.next && K(n.x, n.y, o.x, o.y, s.x, s.y, f.x, f.y) && J(f.prev, f, f.next) >= 0) return !1;
			f = f.nextZ
		}
		return !0
	}

	function H(t, e, r) {
		var i = t;
		do {
			var n = i.prev,
				o = i.next.next;
			!Q(n, o) && $(n, i, i.next, o) && rt(n, o) && rt(o, n) && (e.push(n.i / r), e.push(i.i / r), e.push(o.i / r), ot(i), ot(i.next), i = t = o), i = i.next
		} while (i !== t);
		return U(i)
	}

	function G(t, e, r, i, n, o) {
		var s = t;
		do {
			for (var a = s.next.next; a !== s.prev;) {
				if (s.i !== a.i && Z(s, a)) {
					var h = it(s, a);
					return s = U(s, s.next), h = U(h, h.next), k(s, e, r, i, n, o), void k(h, e, r, i, n, o)
				}
				a = a.next
			}
			s = s.next
		} while (s !== t)
	}

	function Y(t, e) {
		return t.x - e.x
	}

	function V(t, e) {
		if (e = function (t, e) {
				var r, i = e,
					n = t.x,
					o = t.y,
					s = -1 / 0;
				do {
					if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
						var a = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
						if (a <= n && a > s) {
							if (s = a, a === n) {
								if (o === i.y) return i;
								if (o === i.next.y) return i.next
							}
							r = i.x < i.next.x ? i : i.next
						}
					}
					i = i.next
				} while (i !== e);
				if (!r) return null;
				if (n === s) return r;
				var h, u = r,
					l = r.x,
					c = r.y,
					d = 1 / 0;
				i = r;
				do {
					n >= i.x && i.x >= l && n !== i.x && K(o < c ? n : s, o, l, c, o < c ? s : n, o, i.x, i.y) && (h = Math.abs(o - i.y) / (n - i.x), rt(i, t) && (h < d || h === d && (i.x > r.x || i.x === r.x && z(r, i))) && (r = i, d = h)), i = i.next
				} while (i !== u);
				return r
			}(t, e)) {
			var r = it(e, t);
			U(e, e.next), U(r, r.next)
		}
	}

	function z(t, e) {
		return J(t.prev, t, e.prev) < 0 && J(e.next, t, t.next) < 0
	}

	function W(t, e, r, i, n) {
		return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
	}

	function q(t) {
		var e = t,
			r = t;
		do {
			(e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next
		} while (e !== t);
		return r
	}

	function K(t, e, r, i, n, o, s, a) {
		return (n - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (r - s) * (e - a) >= 0 && (r - s) * (o - a) - (n - s) * (i - a) >= 0
	}

	function Z(t, e) {
		return t.next.i !== e.i && t.prev.i !== e.i && ! function (t, e) {
			var r = t;
			do {
				if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && $(r, r.next, t, e)) return !0;
				r = r.next
			} while (r !== t);
			return !1
		}(t, e) && (rt(t, e) && rt(e, t) && function (t, e) {
			var r = t,
				i = !1,
				n = (t.x + e.x) / 2,
				o = (t.y + e.y) / 2;
			do {
				r.y > o != r.next.y > o && r.next.y !== r.y && n < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (i = !i), r = r.next
			} while (r !== t);
			return i
		}(t, e) && (J(t.prev, t, e.prev) || J(t, e.prev, e)) || Q(t, e) && J(t.prev, t, t.next) > 0 && J(e.prev, e, e.next) > 0)
	}

	function J(t, e, r) {
		return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y)
	}

	function Q(t, e) {
		return t.x === e.x && t.y === e.y
	}

	function $(t, e, r, i) {
		var n = et(J(t, e, r)),
			o = et(J(t, e, i)),
			s = et(J(r, i, t)),
			a = et(J(r, i, e));
		return n !== o && s !== a || (!(0 !== n || !tt(t, r, e)) || (!(0 !== o || !tt(t, i, e)) || (!(0 !== s || !tt(r, t, i)) || !(0 !== a || !tt(r, e, i)))))
	}

	function tt(t, e, r) {
		return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y)
	}

	function et(t) {
		return t > 0 ? 1 : t < 0 ? -1 : 0
	}

	function rt(t, e) {
		return J(t.prev, t, t.next) < 0 ? J(t, e, t.next) >= 0 && J(t, t.prev, e) >= 0 : J(t, e, t.prev) < 0 || J(t, t.next, e) < 0
	}

	function it(t, e) {
		var r = new st(t.i, t.x, t.y),
			i = new st(e.i, e.x, e.y),
			n = t.next,
			o = e.prev;
		return t.next = e, e.prev = t, r.next = n, n.prev = r, i.next = r, r.prev = i, o.next = i, i.prev = o, i
	}

	function nt(t, e, r, i) {
		var n = new st(t, e, r);
		return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n
	}

	function ot(t) {
		t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
	}

	function st(t, e, r) {
		this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
	}

	function at(t, e, r, i) {
		for (var n = 0, o = e, s = r - i; o < r; o += i) n += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
		return n
	}
	F.deviation = function (t, e, r, i) {
		var n = e && e.length,
			o = n ? e[0] * r : t.length,
			s = Math.abs(at(t, 0, o, r));
		if (n)
			for (var a = 0, h = e.length; a < h; a++) {
				var u = e[a] * r,
					l = a < h - 1 ? e[a + 1] * r : t.length;
				s -= Math.abs(at(t, u, l, r))
			}
		var c = 0;
		for (a = 0; a < i.length; a += 3) {
			var d = i[a] * r,
				p = i[a + 1] * r,
				f = i[a + 2] * r;
			c += Math.abs((t[d] - t[f]) * (t[p + 1] - t[d + 1]) - (t[d] - t[p]) * (t[f + 1] - t[d + 1]))
		}
		return 0 === s && 0 === c ? 0 : Math.abs((c - s) / s)
	}, F.flatten = function (t) {
		for (var e = t[0][0].length, r = {
				vertices: [],
				holes: [],
				dimensions: e
			}, i = 0, n = 0; n < t.length; n++) {
			for (var o = 0; o < t[n].length; o++)
				for (var s = 0; s < e; s++) r.vertices.push(t[n][o][s]);
			n > 0 && (i += t[n - 1].length, r.holes.push(i))
		}
		return r
	}, L.default = N;
	var ht = r(function (t, r) {
			! function (i) {
				var n = r && !r.nodeType && r,
					o = t && !t.nodeType && t,
					s = "object" == typeof e && e;
				s.global !== s && s.window !== s && s.self !== s || (i = s);
				var a, h, u = 2147483647,
					l = 36,
					c = 1,
					d = 26,
					p = 38,
					f = 700,
					v = 72,
					m = 128,
					g = "-",
					y = /^xn--/,
					_ = /[^\x20-\x7E]/,
					x = /[\x2E\u3002\uFF0E\uFF61]/g,
					b = {
						overflow: "Overflow: input needs wider integers to process",
						"not-basic": "Illegal input >= 0x80 (not a basic code point)",
						"invalid-input": "Invalid input"
					},
					E = l - c,
					T = Math.floor,
					w = String.fromCharCode;

				function S(t) {
					throw RangeError(b[t])
				}

				function I(t, e) {
					for (var r = t.length, i = []; r--;) i[r] = e(t[r]);
					return i
				}

				function P(t, e) {
					var r = t.split("@"),
						i = "";
					return r.length > 1 && (i = r[0] + "@", t = r[1]), i + I((t = t.replace(x, ".")).split("."), e).join(".")
				}

				function A(t) {
					for (var e, r, i = [], n = 0, o = t.length; n < o;)(e = t.charCodeAt(n++)) >= 55296 && e <= 56319 && n < o ? 56320 == (64512 & (r = t.charCodeAt(n++))) ? i.push(((1023 & e) << 10) + (1023 & r) + 65536) : (i.push(e), n--) : i.push(e);
					return i
				}

				function O(t) {
					return I(t, function (t) {
						var e = "";
						return t > 65535 && (e += w((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += w(t)
					}).join("")
				}

				function D(t, e) {
					return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
				}

				function C(t, e, r) {
					var i = 0;
					for (t = r ? T(t / f) : t >> 1, t += T(t / e); t > E * d >> 1; i += l) t = T(t / E);
					return T(i + (E + 1) * t / (t + p))
				}

				function M(t) {
					var e, r, i, n, o, s, a, h, p, f, y, _ = [],
						x = t.length,
						b = 0,
						E = m,
						w = v;
					for ((r = t.lastIndexOf(g)) < 0 && (r = 0), i = 0; i < r; ++i) t.charCodeAt(i) >= 128 && S("not-basic"), _.push(t.charCodeAt(i));
					for (n = r > 0 ? r + 1 : 0; n < x;) {
						for (o = b, s = 1, a = l; n >= x && S("invalid-input"), ((h = (y = t.charCodeAt(n++)) - 48 < 10 ? y - 22 : y - 65 < 26 ? y - 65 : y - 97 < 26 ? y - 97 : l) >= l || h > T((u - b) / s)) && S("overflow"), b += h * s, !(h < (p = a <= w ? c : a >= w + d ? d : a - w)); a += l) s > T(u / (f = l - p)) && S("overflow"), s *= f;
						w = C(b - o, e = _.length + 1, 0 == o), T(b / e) > u - E && S("overflow"), E += T(b / e), b %= e, _.splice(b++, 0, E)
					}
					return O(_)
				}

				function R(t) {
					var e, r, i, n, o, s, a, h, p, f, y, _, x, b, E, I = [];
					for (_ = (t = A(t)).length, e = m, r = 0, o = v, s = 0; s < _; ++s)(y = t[s]) < 128 && I.push(w(y));
					for (i = n = I.length, n && I.push(g); i < _;) {
						for (a = u, s = 0; s < _; ++s)(y = t[s]) >= e && y < a && (a = y);
						for (a - e > T((u - r) / (x = i + 1)) && S("overflow"), r += (a - e) * x, e = a, s = 0; s < _; ++s)
							if ((y = t[s]) < e && ++r > u && S("overflow"), y == e) {
								for (h = r, p = l; !(h < (f = p <= o ? c : p >= o + d ? d : p - o)); p += l) E = h - f, b = l - f, I.push(w(D(f + E % b, 0))), h = T(E / b);
								I.push(w(D(h, 0))), o = C(r, x, i == n), r = 0, ++i
							}++ r, ++e
					}
					return I.join("")
				}
				if (a = {
						version: "1.3.2",
						ucs2: {
							decode: A,
							encode: O
						},
						decode: M,
						encode: R,
						toASCII: function (t) {
							return P(t, function (t) {
								return _.test(t) ? "xn--" + R(t) : t
							})
						},
						toUnicode: function (t) {
							return P(t, function (t) {
								return y.test(t) ? M(t.slice(4).toLowerCase()) : t
							})
						}
					}, n && o)
					if (t.exports == n) o.exports = a;
					else
						for (h in a) a.hasOwnProperty(h) && (n[h] = a[h]);
				else i.punycode = a
			}(e)
		}),
		ut = {
			isString: function (t) {
				return "string" == typeof t
			},
			isObject: function (t) {
				return "object" == typeof t && null !== t
			},
			isNull: function (t) {
				return null === t
			},
			isNullOrUndefined: function (t) {
				return null == t
			}
		};
	ut.isString, ut.isObject, ut.isNull, ut.isNullOrUndefined;

	function lt(t, e) {
		return Object.prototype.hasOwnProperty.call(t, e)
	}
	var ct = function (t, e, r, i) {
			e = e || "&", r = r || "=";
			var n = {};
			if ("string" != typeof t || 0 === t.length) return n;
			var o = /\+/g;
			t = t.split(e);
			var s = 1e3;
			i && "number" == typeof i.maxKeys && (s = i.maxKeys);
			var a = t.length;
			s > 0 && a > s && (a = s);
			for (var h = 0; h < a; ++h) {
				var u, l, c, d, p = t[h].replace(o, "%20"),
					f = p.indexOf(r);
				f >= 0 ? (u = p.substr(0, f), l = p.substr(f + 1)) : (u = p, l = ""), c = decodeURIComponent(u), d = decodeURIComponent(l), lt(n, c) ? Array.isArray(n[c]) ? n[c].push(d) : n[c] = [n[c], d] : n[c] = d
			}
			return n
		},
		dt = function (t) {
			switch (typeof t) {
				case "string":
					return t;
				case "boolean":
					return t ? "true" : "false";
				case "number":
					return isFinite(t) ? t : "";
				default:
					return ""
			}
		},
		pt = function (t, e, r, i) {
			return e = e || "&", r = r || "=", null === t && (t = void 0), "object" == typeof t ? Object.keys(t).map(function (i) {
				var n = encodeURIComponent(dt(i)) + r;
				return Array.isArray(t[i]) ? t[i].map(function (t) {
					return n + encodeURIComponent(dt(t))
				}).join(e) : n + encodeURIComponent(dt(t[i]))
			}).join(e) : i ? encodeURIComponent(dt(i)) + r + encodeURIComponent(dt(t)) : ""
		},
		ft = r(function (t, e) {
			e.decode = e.parse = ct, e.encode = e.stringify = pt
		}),
		vt = (ft.decode, ft.parse, ft.encode, ft.stringify, Rt),
		mt = function (t, e) {
			return Rt(t, !1, !0).resolve(e)
		},
		gt = function (t, e) {
			if (!t) return e;
			return Rt(t, !1, !0).resolveObject(e)
		},
		yt = function (t) {
			ut.isString(t) && (t = Rt(t));
			if (!(t instanceof xt)) return xt.prototype.format.call(t);
			return t.format()
		},
		_t = xt;

	function xt() {
		this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
	}
	var bt = /^([a-z0-9.+-]+:)/i,
		Et = /:[0-9]*$/,
		Tt = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
		wt = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
		St = ["'"].concat(wt),
		It = ["%", "/", "?", ";", "#"].concat(St),
		Pt = ["/", "?", "#"],
		At = /^[+a-z0-9A-Z_-]{0,63}$/,
		Ot = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
		Dt = {
			javascript: !0,
			"javascript:": !0
		},
		Ct = {
			javascript: !0,
			"javascript:": !0
		},
		Mt = {
			http: !0,
			https: !0,
			ftp: !0,
			gopher: !0,
			file: !0,
			"http:": !0,
			"https:": !0,
			"ftp:": !0,
			"gopher:": !0,
			"file:": !0
		};

	function Rt(t, e, r) {
		if (t && ut.isObject(t) && t instanceof xt) return t;
		var i = new xt;
		return i.parse(t, e, r), i
	}
	xt.prototype.parse = function (t, e, r) {
		if (!ut.isString(t)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
		var i = t.indexOf("?"),
			n = -1 !== i && i < t.indexOf("#") ? "?" : "#",
			o = t.split(n);
		o[0] = o[0].replace(/\\/g, "/");
		var s = t = o.join(n);
		if (s = s.trim(), !r && 1 === t.split("#").length) {
			var a = Tt.exec(s);
			if (a) return this.path = s, this.href = s, this.pathname = a[1], a[2] ? (this.search = a[2], this.query = e ? ft.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this
		}
		var h = bt.exec(s);
		if (h) {
			var u = (h = h[0]).toLowerCase();
			this.protocol = u, s = s.substr(h.length)
		}
		if (r || h || s.match(/^\/\/[^@\/]+@[^@\/]+/)) {
			var l = "//" === s.substr(0, 2);
			!l || h && Ct[h] || (s = s.substr(2), this.slashes = !0)
		}
		if (!Ct[h] && (l || h && !Mt[h])) {
			for (var c, d, p = -1, f = 0; f < Pt.length; f++) {
				-1 !== (v = s.indexOf(Pt[f])) && (-1 === p || v < p) && (p = v)
			} - 1 !== (d = -1 === p ? s.lastIndexOf("@") : s.lastIndexOf("@", p)) && (c = s.slice(0, d), s = s.slice(d + 1), this.auth = decodeURIComponent(c)), p = -1;
			for (f = 0; f < It.length; f++) {
				var v; - 1 !== (v = s.indexOf(It[f])) && (-1 === p || v < p) && (p = v)
			} - 1 === p && (p = s.length), this.host = s.slice(0, p), s = s.slice(p), this.parseHost(), this.hostname = this.hostname || "";
			var m = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
			if (!m)
				for (var g = this.hostname.split(/\./), y = (f = 0, g.length); f < y; f++) {
					var _ = g[f];
					if (_ && !_.match(At)) {
						for (var x = "", b = 0, E = _.length; b < E; b++) _.charCodeAt(b) > 127 ? x += "x" : x += _[b];
						if (!x.match(At)) {
							var T = g.slice(0, f),
								w = g.slice(f + 1),
								S = _.match(Ot);
							S && (T.push(S[1]), w.unshift(S[2])), w.length && (s = "/" + w.join(".") + s), this.hostname = T.join(".");
							break
						}
					}
				}
			this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m || (this.hostname = ht.toASCII(this.hostname));
			var I = this.port ? ":" + this.port : "",
				P = this.hostname || "";
			this.host = P + I, this.href += this.host, m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== s[0] && (s = "/" + s))
		}
		if (!Dt[u])
			for (f = 0, y = St.length; f < y; f++) {
				var A = St[f];
				if (-1 !== s.indexOf(A)) {
					var O = encodeURIComponent(A);
					O === A && (O = escape(A)), s = s.split(A).join(O)
				}
			}
		var D = s.indexOf("#"); - 1 !== D && (this.hash = s.substr(D), s = s.slice(0, D));
		var C = s.indexOf("?");
		if (-1 !== C ? (this.search = s.substr(C), this.query = s.substr(C + 1), e && (this.query = ft.parse(this.query)), s = s.slice(0, C)) : e && (this.search = "", this.query = {}), s && (this.pathname = s), Mt[u] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
			I = this.pathname || "";
			var M = this.search || "";
			this.path = I + M
		}
		return this.href = this.format(), this
	}, xt.prototype.format = function () {
		var t = this.auth || "";
		t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
		var e = this.protocol || "",
			r = this.pathname || "",
			i = this.hash || "",
			n = !1,
			o = "";
		this.host ? n = t + this.host : this.hostname && (n = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && ut.isObject(this.query) && Object.keys(this.query).length && (o = ft.stringify(this.query));
		var s = this.search || o && "?" + o || "";
		return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || Mt[e]) && !1 !== n ? (n = "//" + (n || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : n || (n = ""), i && "#" !== i.charAt(0) && (i = "#" + i), s && "?" !== s.charAt(0) && (s = "?" + s), e + n + (r = r.replace(/[?#]/g, function (t) {
			return encodeURIComponent(t)
		})) + (s = s.replace("#", "%23")) + i
	}, xt.prototype.resolve = function (t) {
		return this.resolveObject(Rt(t, !1, !0)).format()
	}, xt.prototype.resolveObject = function (t) {
		if (ut.isString(t)) {
			var e = new xt;
			e.parse(t, !1, !0), t = e
		}
		for (var r = new xt, i = Object.keys(this), n = 0; n < i.length; n++) {
			var o = i[n];
			r[o] = this[o]
		}
		if (r.hash = t.hash, "" === t.href) return r.href = r.format(), r;
		if (t.slashes && !t.protocol) {
			for (var s = Object.keys(t), a = 0; a < s.length; a++) {
				var h = s[a];
				"protocol" !== h && (r[h] = t[h])
			}
			return Mt[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r
		}
		if (t.protocol && t.protocol !== r.protocol) {
			if (!Mt[t.protocol]) {
				for (var u = Object.keys(t), l = 0; l < u.length; l++) {
					var c = u[l];
					r[c] = t[c]
				}
				return r.href = r.format(), r
			}
			if (r.protocol = t.protocol, t.host || Ct[t.protocol]) r.pathname = t.pathname;
			else {
				for (var d = (t.pathname || "").split("/"); d.length && !(t.host = d.shift()););
				t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== d[0] && d.unshift(""), d.length < 2 && d.unshift(""), r.pathname = d.join("/")
			}
			if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
				var p = r.pathname || "",
					f = r.search || "";
				r.path = p + f
			}
			return r.slashes = r.slashes || t.slashes, r.href = r.format(), r
		}
		var v = r.pathname && "/" === r.pathname.charAt(0),
			m = t.host || t.pathname && "/" === t.pathname.charAt(0),
			g = m || v || r.host && t.pathname,
			y = g,
			_ = r.pathname && r.pathname.split("/") || [],
			x = (d = t.pathname && t.pathname.split("/") || [], r.protocol && !Mt[r.protocol]);
		if (x && (r.hostname = "", r.port = null, r.host && ("" === _[0] ? _[0] = r.host : _.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === d[0] ? d[0] = t.host : d.unshift(t.host)), t.host = null), g = g && ("" === d[0] || "" === _[0])), m) r.host = t.host || "" === t.host ? t.host : r.host, r.hostname = t.hostname || "" === t.hostname ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, _ = d;
		else if (d.length) _ || (_ = []), _.pop(), _ = _.concat(d), r.search = t.search, r.query = t.query;
		else if (!ut.isNullOrUndefined(t.search)) {
			if (x) r.hostname = r.host = _.shift(), (S = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = S.shift(), r.host = r.hostname = S.shift());
			return r.search = t.search, r.query = t.query, ut.isNull(r.pathname) && ut.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r
		}
		if (!_.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
		for (var b = _.slice(-1)[0], E = (r.host || t.host || _.length > 1) && ("." === b || ".." === b) || "" === b, T = 0, w = _.length; w >= 0; w--) "." === (b = _[w]) ? _.splice(w, 1) : ".." === b ? (_.splice(w, 1), T++) : T && (_.splice(w, 1), T--);
		if (!g && !y)
			for (; T--; T) _.unshift("..");
		!g || "" === _[0] || _[0] && "/" === _[0].charAt(0) || _.unshift(""), E && "/" !== _.join("/").substr(-1) && _.push("");
		var S, I = "" === _[0] || _[0] && "/" === _[0].charAt(0);
		x && (r.hostname = r.host = I ? "" : _.length ? _.shift() : "", (S = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = S.shift(), r.host = r.hostname = S.shift()));
		return (g = g || r.host && _.length) && !I && _.unshift(""), _.length ? r.pathname = _.join("/") : (r.pathname = null, r.path = null), ut.isNull(r.pathname) && ut.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r
	}, xt.prototype.parseHost = function () {
		var t = this.host,
			e = Et.exec(t);
		e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
	};
	var Lt, Nt, Ft, Bt, Ut, kt, Xt, jt, Ht, Gt, Yt, Vt, zt, Wt, qt = {
		parse: vt,
		resolve: mt,
		resolveObject: gt,
		format: yt,
		Url: _t
	};
	(Lt = t.ENV || (t.ENV = {}))[Lt.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", Lt[Lt.WEBGL = 1] = "WEBGL", Lt[Lt.WEBGL2 = 2] = "WEBGL2", (Nt = t.RENDERER_TYPE || (t.RENDERER_TYPE = {}))[Nt.UNKNOWN = 0] = "UNKNOWN", Nt[Nt.WEBGL = 1] = "WEBGL", Nt[Nt.CANVAS = 2] = "CANVAS", (Ft = t.BLEND_MODES || (t.BLEND_MODES = {}))[Ft.NORMAL = 0] = "NORMAL", Ft[Ft.ADD = 1] = "ADD", Ft[Ft.MULTIPLY = 2] = "MULTIPLY", Ft[Ft.SCREEN = 3] = "SCREEN", Ft[Ft.OVERLAY = 4] = "OVERLAY", Ft[Ft.DARKEN = 5] = "DARKEN", Ft[Ft.LIGHTEN = 6] = "LIGHTEN", Ft[Ft.COLOR_DODGE = 7] = "COLOR_DODGE", Ft[Ft.COLOR_BURN = 8] = "COLOR_BURN", Ft[Ft.HARD_LIGHT = 9] = "HARD_LIGHT", Ft[Ft.SOFT_LIGHT = 10] = "SOFT_LIGHT", Ft[Ft.DIFFERENCE = 11] = "DIFFERENCE", Ft[Ft.EXCLUSION = 12] = "EXCLUSION", Ft[Ft.HUE = 13] = "HUE", Ft[Ft.SATURATION = 14] = "SATURATION", Ft[Ft.COLOR = 15] = "COLOR", Ft[Ft.LUMINOSITY = 16] = "LUMINOSITY", Ft[Ft.NORMAL_NPM = 17] = "NORMAL_NPM", Ft[Ft.ADD_NPM = 18] = "ADD_NPM", Ft[Ft.SCREEN_NPM = 19] = "SCREEN_NPM", Ft[Ft.NONE = 20] = "NONE", Ft[Ft.SRC_OVER = 0] = "SRC_OVER", Ft[Ft.SRC_IN = 21] = "SRC_IN", Ft[Ft.SRC_OUT = 22] = "SRC_OUT", Ft[Ft.SRC_ATOP = 23] = "SRC_ATOP", Ft[Ft.DST_OVER = 24] = "DST_OVER", Ft[Ft.DST_IN = 25] = "DST_IN", Ft[Ft.DST_OUT = 26] = "DST_OUT", Ft[Ft.DST_ATOP = 27] = "DST_ATOP", Ft[Ft.ERASE = 26] = "ERASE", Ft[Ft.SUBTRACT = 28] = "SUBTRACT", Ft[Ft.XOR = 29] = "XOR", (Bt = t.DRAW_MODES || (t.DRAW_MODES = {}))[Bt.POINTS = 0] = "POINTS", Bt[Bt.LINES = 1] = "LINES", Bt[Bt.LINE_LOOP = 2] = "LINE_LOOP", Bt[Bt.LINE_STRIP = 3] = "LINE_STRIP", Bt[Bt.TRIANGLES = 4] = "TRIANGLES", Bt[Bt.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", Bt[Bt.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", (Ut = t.FORMATS || (t.FORMATS = {}))[Ut.RGBA = 6408] = "RGBA", Ut[Ut.RGB = 6407] = "RGB", Ut[Ut.ALPHA = 6406] = "ALPHA", Ut[Ut.LUMINANCE = 6409] = "LUMINANCE", Ut[Ut.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", Ut[Ut.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", Ut[Ut.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", (kt = t.TARGETS || (t.TARGETS = {}))[kt.TEXTURE_2D = 3553] = "TEXTURE_2D", kt[kt.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", kt[kt.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", kt[kt.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", kt[kt.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", kt[kt.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", kt[kt.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", kt[kt.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", kt[kt.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", (Xt = t.TYPES || (t.TYPES = {}))[Xt.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", Xt[Xt.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", Xt[Xt.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", Xt[Xt.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", Xt[Xt.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", Xt[Xt.FLOAT = 5126] = "FLOAT", Xt[Xt.HALF_FLOAT = 36193] = "HALF_FLOAT", (jt = t.SCALE_MODES || (t.SCALE_MODES = {}))[jt.NEAREST = 0] = "NEAREST", jt[jt.LINEAR = 1] = "LINEAR", (Ht = t.WRAP_MODES || (t.WRAP_MODES = {}))[Ht.CLAMP = 33071] = "CLAMP", Ht[Ht.REPEAT = 10497] = "REPEAT", Ht[Ht.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", (Gt = t.MIPMAP_MODES || (t.MIPMAP_MODES = {}))[Gt.OFF = 0] = "OFF", Gt[Gt.POW2 = 1] = "POW2", Gt[Gt.ON = 2] = "ON", (Yt = t.ALPHA_MODES || (t.ALPHA_MODES = {}))[Yt.NPM = 0] = "NPM", Yt[Yt.UNPACK = 1] = "UNPACK", Yt[Yt.PMA = 2] = "PMA", Yt[Yt.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", Yt[Yt.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", Yt[Yt.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", (Vt = t.GC_MODES || (t.GC_MODES = {}))[Vt.AUTO = 0] = "AUTO", Vt[Vt.MANUAL = 1] = "MANUAL", (zt = t.PRECISION || (t.PRECISION = {})).LOW = "lowp", zt.MEDIUM = "mediump", zt.HIGH = "highp", (Wt = t.MASK_TYPES || (t.MASK_TYPES = {}))[Wt.NONE = 0] = "NONE", Wt[Wt.SCISSOR = 1] = "SCISSOR", Wt[Wt.STENCIL = 2] = "STENCIL", Wt[Wt.SPRITE = 3] = "SPRITE", M.RETINA_PREFIX = /@([0-9\.]+)x/, M.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !0;
	var Kt, Zt = !1,
		Jt = "5.2.2";

	function Qt(t) {
		var e;
		if (!Zt) {
			if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
				var r = ["\n %c %c %c PixiJS " + Jt + " - ✰ " + t + " ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
				(e = window.console).log.apply(e, r)
			} else window.console && window.console.log("PixiJS " + Jt + " - " + t + " - http://www.pixijs.com/");
			Zt = !0
		}
	}

	function $t() {
		return void 0 === Kt && (Kt = function () {
			var t = {
				stencil: !0,
				failIfMajorPerformanceCaveat: M.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
			};
			try {
				if (!window.WebGLRenderingContext) return !1;
				var e = document.createElement("canvas"),
					r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t),
					i = !(!r || !r.getContextAttributes().stencil);
				if (r) {
					var n = r.getExtension("WEBGL_lose_context");
					n && n.loseContext()
				}
				return r = null, i
			} catch (t) {
				return !1
			}
		}()), Kt
	}

	function te(t, e) {
		return (e = e || [])[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e
	}

	function ee(t) {
		var e = t.toString(16);
		return "#" + (e = "000000".substr(0, 6 - e.length) + e)
	}

	function re(t) {
		return "string" == typeof t && "#" === t[0] && (t = t.substr(1)), parseInt(t, 16)
	}
	var ie = function () {
		for (var e = [], r = [], i = 0; i < 32; i++) e[i] = i, r[i] = i;
		e[t.BLEND_MODES.NORMAL_NPM] = t.BLEND_MODES.NORMAL, e[t.BLEND_MODES.ADD_NPM] = t.BLEND_MODES.ADD, e[t.BLEND_MODES.SCREEN_NPM] = t.BLEND_MODES.SCREEN, r[t.BLEND_MODES.NORMAL] = t.BLEND_MODES.NORMAL_NPM, r[t.BLEND_MODES.ADD] = t.BLEND_MODES.ADD_NPM, r[t.BLEND_MODES.SCREEN] = t.BLEND_MODES.SCREEN_NPM;
		var n = [];
		return n.push(r), n.push(e), n
	}();

	function ne(t, e) {
		return ie[e ? 1 : 0][t]
	}

	function oe(t, e, r, i) {
		return r = r || new Float32Array(4), i || void 0 === i ? (r[0] = t[0] * e, r[1] = t[1] * e, r[2] = t[2] * e) : (r[0] = t[0], r[1] = t[1], r[2] = t[2]), r[3] = e, r
	}

	function se(t, e) {
		if (1 === e) return (255 * e << 24) + t;
		if (0 === e) return 0;
		var r = t >> 16 & 255,
			i = t >> 8 & 255,
			n = 255 & t;
		return (255 * e << 24) + ((r = r * e + .5 | 0) << 16) + ((i = i * e + .5 | 0) << 8) + (n = n * e + .5 | 0)
	}

	function ae(t, e, r, i) {
		return (r = r || new Float32Array(4))[0] = (t >> 16 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (255 & t) / 255, (i || void 0 === i) && (r[0] *= e, r[1] *= e, r[2] *= e), r[3] = e, r
	}

	function he(t, e) {
		void 0 === e && (e = null);
		var r = 6 * t;
		if ((e = e || new Uint16Array(r)).length !== r) throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + r);
		for (var i = 0, n = 0; i < r; i += 6, n += 4) e[i + 0] = n + 0, e[i + 1] = n + 1, e[i + 2] = n + 2, e[i + 3] = n + 0, e[i + 4] = n + 2, e[i + 5] = n + 3;
		return e
	}

	function ue(t) {
		if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
		if (2 === t.BYTES_PER_ELEMENT) {
			if (t instanceof Uint16Array) return "Uint16Array"
		} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
		return null
	}
	var le = {
		Float32Array: Float32Array,
		Uint32Array: Uint32Array,
		Int32Array: Int32Array,
		Uint8Array: Uint8Array
	};

	function ce(t) {
		return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) + 1
	}

	function de(t) {
		return !(t & t - 1 || !t)
	}

	function pe(t) {
		var e = (t > 65535 ? 1 : 0) << 4,
			r = ((t >>>= e) > 255 ? 1 : 0) << 3;
		return e |= r, e |= r = ((t >>>= r) > 15 ? 1 : 0) << 2, (e |= r = ((t >>>= r) > 3 ? 1 : 0) << 1) | (t >>>= r) >> 1
	}

	function fe(t, e, r) {
		var i, n = t.length;
		if (!(e >= n || 0 === r)) {
			var o = n - (r = e + r > n ? n - e : r);
			for (i = e; i < o; ++i) t[i] = t[i + r];
			t.length = o
		}
	}

	function ve(t) {
		return 0 === t ? 0 : t < 0 ? -1 : 1
	}
	var me = 0;

	function ge() {
		return ++me
	}
	var ye = {};

	function _e(t, e, r) {
		if (void 0 === r && (r = 3), !ye[e]) {
			var i = (new Error).stack;
			void 0 === i ? console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t) : (i = i.split("\n").splice(r).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + "\nDeprecated since v" + t), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t), console.warn(i))), ye[e] = !0
		}
	}
	var xe = {},
		be = Object.create(null),
		Ee = Object.create(null);
	var Te = function () {
		function t(t, e, r) {
			this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = r || M.RESOLUTION, this.resize(t, e)
		}
		return t.prototype.clear = function () {
			this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
		}, t.prototype.resize = function (t, e) {
			this.canvas.width = t * this.resolution, this.canvas.height = e * this.resolution
		}, t.prototype.destroy = function () {
			this.context = null, this.canvas = null
		}, Object.defineProperty(t.prototype, "width", {
			get: function () {
				return this.canvas.width
			},
			set: function (t) {
				this.canvas.width = t
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "height", {
			get: function () {
				return this.canvas.height
			},
			set: function (t) {
				this.canvas.height = t
			},
			enumerable: !0,
			configurable: !0
		}), t
	}();

	function we(t) {
		var e, r, i, n = t.width,
			o = t.height,
			s = t.getContext("2d"),
			a = s.getImageData(0, 0, n, o).data,
			h = a.length,
			u = {
				top: null,
				left: null,
				right: null,
				bottom: null
			},
			l = null;
		for (e = 0; e < h; e += 4) 0 !== a[e + 3] && (r = e / 4 % n, i = ~~(e / 4 / n), null === u.top && (u.top = i), null === u.left ? u.left = r : r < u.left && (u.left = r), null === u.right ? u.right = r + 1 : u.right < r && (u.right = r + 1), null === u.bottom ? u.bottom = i : u.bottom < i && (u.bottom = i));
		return null !== u.top && (n = u.right - u.left, o = u.bottom - u.top + 1, l = s.getImageData(u.left, u.top, n, o)), {
			height: o,
			width: n,
			data: l
		}
	}
	var Se, Ie = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

	function Pe(t, e) {
		if (void 0 === e && (e = window.location), 0 === t.indexOf("data:")) return "";
		e = e || window.location, Se || (Se = document.createElement("a")), Se.href = t;
		var r = vt(Se.href),
			i = !r.port && "" === e.port || r.port === e.port;
		return r.hostname === e.hostname && i && r.protocol === e.protocol ? "" : "anonymous"
	}

	function Ae(t, e) {
		var r = M.RETINA_PREFIX.exec(t);
		return r ? parseFloat(r[1]) : void 0 !== e ? e : 1
	}
	var Oe, De = {
			BaseTextureCache: Ee,
			CanvasRenderTarget: Te,
			DATA_URI: Ie,
			ProgramCache: xe,
			TextureCache: be,
			clearTextureCache: function () {
				var t;
				for (t in be) delete be[t];
				for (t in Ee) delete Ee[t]
			},
			correctBlendMode: ne,
			createIndicesForQuads: he,
			decomposeDataUri: function (t) {
				var e = Ie.exec(t);
				if (e) return {
					mediaType: e[1] ? e[1].toLowerCase() : void 0,
					subType: e[2] ? e[2].toLowerCase() : void 0,
					charset: e[3] ? e[3].toLowerCase() : void 0,
					encoding: e[4] ? e[4].toLowerCase() : void 0,
					data: e[5]
				}
			},
			deprecation: _e,
			destroyTextureCache: function () {
				var t;
				for (t in be) be[t].destroy();
				for (t in Ee) Ee[t].destroy()
			},
			determineCrossOrigin: Pe,
			getBufferType: ue,
			getResolutionOfUrl: Ae,
			hex2rgb: te,
			hex2string: ee,
			interleaveTypedArrays: function (t, e) {
				for (var r = 0, i = 0, n = {}, o = 0; o < t.length; o++) i += e[o], r += t[o].length;
				var s = new ArrayBuffer(4 * r),
					a = null,
					h = 0;
				for (o = 0; o < t.length; o++) {
					var u = e[o],
						l = t[o],
						c = ue(l);
					n[c] || (n[c] = new le[c](s)), a = n[c];
					for (var d = 0; d < l.length; d++) a[(d / u | 0) * i + h + d % u] = l[d];
					h += u
				}
				return new Float32Array(s)
			},
			isPow2: de,
			isWebGLSupported: $t,
			log2: pe,
			nextPow2: ce,
			premultiplyBlendMode: ie,
			premultiplyRgba: oe,
			premultiplyTint: se,
			premultiplyTintToRgba: ae,
			removeItems: fe,
			rgb2hex: function (t) {
				return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0)
			},
			sayHello: Qt,
			sign: ve,
			skipHello: function () {
				Zt = !0
			},
			string2hex: re,
			trimCanvas: we,
			uid: ge,
			isMobile: C,
			EventEmitter: R,
			earcut: L,
			url: qt
		},
		Ce = function () {
			function t(t, e) {
				void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
			}
			return t.prototype.clone = function () {
				return new t(this.x, this.y)
			}, t.prototype.copyFrom = function (t) {
				return this.set(t.x, t.y), this
			}, t.prototype.copyTo = function (t) {
				return t.set(this.x, this.y), t
			}, t.prototype.equals = function (t) {
				return t.x === this.x && t.y === this.y
			}, t.prototype.set = function (t, e) {
				return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
			}, t
		}(),
		Me = function () {
			function t(t, e, r, i) {
				void 0 === r && (r = 0), void 0 === i && (i = 0), this._x = r, this._y = i, this.cb = t, this.scope = e
			}
			return t.prototype.clone = function (e, r) {
				return void 0 === e && (e = this.cb), void 0 === r && (r = this.scope), new t(e, r, this._x, this._y)
			}, t.prototype.set = function (t, e) {
				return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this
			}, t.prototype.copyFrom = function (t) {
				return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
			}, t.prototype.copyTo = function (t) {
				return t.set(this._x, this._y), t
			}, t.prototype.equals = function (t) {
				return t.x === this._x && t.y === this._y
			}, Object.defineProperty(t.prototype, "x", {
				get: function () {
					return this._x
				},
				set: function (t) {
					this._x !== t && (this._x = t, this.cb.call(this.scope))
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "y", {
				get: function () {
					return this._y
				},
				set: function (t) {
					this._y !== t && (this._y = t, this.cb.call(this.scope))
				},
				enumerable: !0,
				configurable: !0
			}), t
		}(),
		Re = 2 * Math.PI,
		Le = 180 / Math.PI,
		Ne = Math.PI / 180;
	(Oe = t.SHAPES || (t.SHAPES = {}))[Oe.POLY = 0] = "POLY", Oe[Oe.RECT = 1] = "RECT", Oe[Oe.CIRC = 2] = "CIRC", Oe[Oe.ELIP = 3] = "ELIP", Oe[Oe.RREC = 4] = "RREC";
	var Fe = function () {
			function t(t, e, r, i, n, o) {
				void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = o
			}
			return t.prototype.fromArray = function (t) {
				this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
			}, t.prototype.set = function (t, e, r, i, n, o) {
				return this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = o, this
			}, t.prototype.toArray = function (t, e) {
				this.array || (this.array = new Float32Array(9));
				var r = e || this.array;
				return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r
			}, t.prototype.apply = function (t, e) {
				e = e || new Ce;
				var r = t.x,
					i = t.y;
				return e.x = this.a * r + this.c * i + this.tx, e.y = this.b * r + this.d * i + this.ty, e
			}, t.prototype.applyInverse = function (t, e) {
				e = e || new Ce;
				var r = 1 / (this.a * this.d + this.c * -this.b),
					i = t.x,
					n = t.y;
				return e.x = this.d * r * i + -this.c * r * n + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * n + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r, e
			}, t.prototype.translate = function (t, e) {
				return this.tx += t, this.ty += e, this
			}, t.prototype.scale = function (t, e) {
				return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
			}, t.prototype.rotate = function (t) {
				var e = Math.cos(t),
					r = Math.sin(t),
					i = this.a,
					n = this.c,
					o = this.tx;
				return this.a = i * e - this.b * r, this.b = i * r + this.b * e, this.c = n * e - this.d * r, this.d = n * r + this.d * e, this.tx = o * e - this.ty * r, this.ty = o * r + this.ty * e, this
			}, t.prototype.append = function (t) {
				var e = this.a,
					r = this.b,
					i = this.c,
					n = this.d;
				return this.a = t.a * e + t.b * i, this.b = t.a * r + t.b * n, this.c = t.c * e + t.d * i, this.d = t.c * r + t.d * n, this.tx = t.tx * e + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * n + this.ty, this
			}, t.prototype.setTransform = function (t, e, r, i, n, o, s, a, h) {
				return this.a = Math.cos(s + h) * n, this.b = Math.sin(s + h) * n, this.c = -Math.sin(s - a) * o, this.d = Math.cos(s - a) * o, this.tx = t - (r * this.a + i * this.c), this.ty = e - (r * this.b + i * this.d), this
			}, t.prototype.prepend = function (t) {
				var e = this.tx;
				if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
					var r = this.a,
						i = this.c;
					this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d
				}
				return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
			}, t.prototype.decompose = function (t) {
				var e = this.a,
					r = this.b,
					i = this.c,
					n = this.d,
					o = -Math.atan2(-i, n),
					s = Math.atan2(r, e),
					a = Math.abs(o + s);
				return a < 1e-5 || Math.abs(Re - a) < 1e-5 ? (t.rotation = s, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = s), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(i * i + n * n), t.position.x = this.tx, t.position.y = this.ty, t
			}, t.prototype.invert = function () {
				var t = this.a,
					e = this.b,
					r = this.c,
					i = this.d,
					n = this.tx,
					o = t * i - e * r;
				return this.a = i / o, this.b = -e / o, this.c = -r / o, this.d = t / o, this.tx = (r * this.ty - i * n) / o, this.ty = -(t * this.ty - e * n) / o, this
			}, t.prototype.identity = function () {
				return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
			}, t.prototype.clone = function () {
				var e = new t;
				return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
			}, t.prototype.copyTo = function (t) {
				return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
			}, t.prototype.copyFrom = function (t) {
				return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
			}, Object.defineProperty(t, "IDENTITY", {
				get: function () {
					return new t
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "TEMP_MATRIX", {
				get: function () {
					return new t
				},
				enumerable: !0,
				configurable: !0
			}), t
		}(),
		Be = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
		Ue = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
		ke = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
		Xe = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
		je = [],
		He = [],
		Ge = Math.sign;
	! function () {
		for (var t = 0; t < 16; t++) {
			var e = [];
			je.push(e);
			for (var r = 0; r < 16; r++)
				for (var i = Ge(Be[t] * Be[r] + ke[t] * Ue[r]), n = Ge(Ue[t] * Be[r] + Xe[t] * Ue[r]), o = Ge(Be[t] * ke[r] + ke[t] * Xe[r]), s = Ge(Ue[t] * ke[r] + Xe[t] * Xe[r]), a = 0; a < 16; a++)
					if (Be[a] === i && Ue[a] === n && ke[a] === o && Xe[a] === s) {
						e.push(a);
						break
					}
		}
		for (t = 0; t < 16; t++) {
			var h = new Fe;
			h.set(Be[t], Ue[t], ke[t], Xe[t], 0, 0), He.push(h)
		}
	}();
	var Ye = {
			E: 0,
			SE: 1,
			S: 2,
			SW: 3,
			W: 4,
			NW: 5,
			N: 6,
			NE: 7,
			MIRROR_VERTICAL: 8,
			MAIN_DIAGONAL: 10,
			MIRROR_HORIZONTAL: 12,
			REVERSE_DIAGONAL: 14,
			uX: function (t) {
				return Be[t]
			},
			uY: function (t) {
				return Ue[t]
			},
			vX: function (t) {
				return ke[t]
			},
			vY: function (t) {
				return Xe[t]
			},
			inv: function (t) {
				return 8 & t ? 15 & t : 7 & -t
			},
			add: function (t, e) {
				return je[t][e]
			},
			sub: function (t, e) {
				return je[t][Ye.inv(e)]
			},
			rotate180: function (t) {
				return 4 ^ t
			},
			isVertical: function (t) {
				return 2 == (3 & t)
			},
			byDirection: function (t, e) {
				return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? Ye.S : Ye.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? Ye.E : Ye.W : e > 0 ? t > 0 ? Ye.SE : Ye.SW : t > 0 ? Ye.NE : Ye.NW
			},
			matrixAppendRotationInv: function (t, e, r, i) {
				void 0 === r && (r = 0), void 0 === i && (i = 0);
				var n = He[Ye.inv(e)];
				n.tx = r, n.ty = i, t.append(n)
			}
		},
		Ve = function () {
			function t() {
				this.worldTransform = new Fe, this.localTransform = new Fe, this.position = new Me(this.onChange, this, 0, 0), this.scale = new Me(this.onChange, this, 1, 1), this.pivot = new Me(this.onChange, this, 0, 0), this.skew = new Me(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
			}
			return t.prototype.onChange = function () {
				this._localID++
			}, t.prototype.updateSkew = function () {
				this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
			}, t.prototype.updateLocalTransform = function () {
				var t = this.localTransform;
				this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
			}, t.prototype.updateTransform = function (t) {
				var e = this.localTransform;
				if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
					var r = t.worldTransform,
						i = this.worldTransform;
					i.a = e.a * r.a + e.b * r.c, i.b = e.a * r.b + e.b * r.d, i.c = e.c * r.a + e.d * r.c, i.d = e.c * r.b + e.d * r.d, i.tx = e.tx * r.a + e.ty * r.c + r.tx, i.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++
				}
			}, t.prototype.setFromMatrix = function (t) {
				t.decompose(this), this._localID++
			}, Object.defineProperty(t.prototype, "rotation", {
				get: function () {
					return this._rotation
				},
				set: function (t) {
					this._rotation !== t && (this._rotation = t, this.updateSkew())
				},
				enumerable: !0,
				configurable: !0
			}), t.IDENTITY = new t, t
		}(),
		ze = function () {
			function e(e, r, i, n) {
				void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = Number(e), this.y = Number(r), this.width = Number(i), this.height = Number(n), this.type = t.SHAPES.RECT
			}
			return Object.defineProperty(e.prototype, "left", {
				get: function () {
					return this.x
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "right", {
				get: function () {
					return this.x + this.width
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "top", {
				get: function () {
					return this.y
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "bottom", {
				get: function () {
					return this.y + this.height
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e, "EMPTY", {
				get: function () {
					return new e(0, 0, 0, 0)
				},
				enumerable: !0,
				configurable: !0
			}), e.prototype.clone = function () {
				return new e(this.x, this.y, this.width, this.height)
			}, e.prototype.copyFrom = function (t) {
				return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
			}, e.prototype.copyTo = function (t) {
				return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
			}, e.prototype.contains = function (t, e) {
				return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height)
			}, e.prototype.pad = function (t, e) {
				return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this
			}, e.prototype.fit = function (t) {
				var e = Math.max(this.x, t.x),
					r = Math.min(this.x + this.width, t.x + t.width),
					i = Math.max(this.y, t.y),
					n = Math.min(this.y + this.height, t.y + t.height);
				return this.x = e, this.width = Math.max(r - e, 0), this.y = i, this.height = Math.max(n - i, 0), this
			}, e.prototype.ceil = function (t, e) {
				void 0 === t && (t = 1), void 0 === e && (e = .001);
				var r = Math.ceil((this.x + this.width - e) * t) / t,
					i = Math.ceil((this.y + this.height - e) * t) / t;
				return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = i - this.y, this
			}, e.prototype.enlarge = function (t) {
				var e = Math.min(this.x, t.x),
					r = Math.max(this.x + this.width, t.x + t.width),
					i = Math.min(this.y, t.y),
					n = Math.max(this.y + this.height, t.y + t.height);
				return this.x = e, this.width = r - e, this.y = i, this.height = n - i, this
			}, e
		}(),
		We = function () {
			function e(e, r, i) {
				void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), this.x = e, this.y = r, this.radius = i, this.type = t.SHAPES.CIRC
			}
			return e.prototype.clone = function () {
				return new e(this.x, this.y, this.radius)
			}, e.prototype.contains = function (t, e) {
				if (this.radius <= 0) return !1;
				var r = this.radius * this.radius,
					i = this.x - t,
					n = this.y - e;
				return (i *= i) + (n *= n) <= r
			}, e.prototype.getBounds = function () {
				return new ze(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
			}, e
		}(),
		qe = function () {
			function e(e, r, i, n) {
				void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = e, this.y = r, this.width = i, this.height = n, this.type = t.SHAPES.ELIP
			}
			return e.prototype.clone = function () {
				return new e(this.x, this.y, this.width, this.height)
			}, e.prototype.contains = function (t, e) {
				if (this.width <= 0 || this.height <= 0) return !1;
				var r = (t - this.x) / this.width,
					i = (e - this.y) / this.height;
				return (r *= r) + (i *= i) <= 1
			}, e.prototype.getBounds = function () {
				return new ze(this.x - this.width, this.y - this.height, this.width, this.height)
			}, e
		}(),
		Ke = function () {
			function e() {
				for (var e = arguments, r = [], i = 0; i < arguments.length; i++) r[i] = e[i];
				if (Array.isArray(r[0]) && (r = r[0]), r[0] instanceof Ce) {
					for (var n = [], o = 0, s = (r = r).length; o < s; o++) n.push(r[o].x, r[o].y);
					r = n
				}
				this.points = r, this.type = t.SHAPES.POLY, this.closeStroke = !0
			}
			return e.prototype.clone = function () {
				var t = new e(this.points.slice());
				return t.closeStroke = this.closeStroke, t
			}, e.prototype.contains = function (t, e) {
				for (var r = !1, i = this.points.length / 2, n = 0, o = i - 1; n < i; o = n++) {
					var s = this.points[2 * n],
						a = this.points[2 * n + 1],
						h = this.points[2 * o],
						u = this.points[2 * o + 1];
					a > e != u > e && t < (e - a) / (u - a) * (h - s) + s && (r = !r)
				}
				return r
			}, e
		}(),
		Ze = function () {
			function e(e, r, i, n, o) {
				void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 20), this.x = e, this.y = r, this.width = i, this.height = n, this.radius = o, this.type = t.SHAPES.RREC
			}
			return e.prototype.clone = function () {
				return new e(this.x, this.y, this.width, this.height, this.radius)
			}, e.prototype.contains = function (t, e) {
				if (this.width <= 0 || this.height <= 0) return !1;
				if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
					if (e >= this.y + this.radius && e <= this.y + this.height - this.radius || t >= this.x + this.radius && t <= this.x + this.width - this.radius) return !0;
					var r = t - (this.x + this.radius),
						i = e - (this.y + this.radius),
						n = this.radius * this.radius;
					if (r * r + i * i <= n) return !0;
					if ((r = t - (this.x + this.width - this.radius)) * r + i * i <= n) return !0;
					if (r * r + (i = e - (this.y + this.height - this.radius)) * i <= n) return !0;
					if ((r = t - (this.x + this.radius)) * r + i * i <= n) return !0
				}
				return !1
			}, e
		}();
	M.SORTABLE_CHILDREN = !1;
	var Je = function () {
		this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null
	};
	Je.prototype.isEmpty = function () {
		return this.minX > this.maxX || this.minY > this.maxY
	}, Je.prototype.clear = function () {
		this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
	}, Je.prototype.getRectangle = function (t) {
		return this.minX > this.maxX || this.minY > this.maxY ? ze.EMPTY : ((t = t || new ze(0, 0, 1, 1)).x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
	}, Je.prototype.addPoint = function (t) {
		this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
	}, Je.prototype.addQuad = function (t) {
		var e = this.minX,
			r = this.minY,
			i = this.maxX,
			n = this.maxY,
			o = t[0],
			s = t[1];
		e = o < e ? o : e, r = s < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, e = (o = t[2]) < e ? o : e, r = (s = t[3]) < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, e = (o = t[4]) < e ? o : e, r = (s = t[5]) < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, e = (o = t[6]) < e ? o : e, r = (s = t[7]) < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, this.minX = e, this.minY = r, this.maxX = i, this.maxY = n
	}, Je.prototype.addFrame = function (t, e, r, i, n) {
		this.addFrameMatrix(t.worldTransform, e, r, i, n)
	}, Je.prototype.addFrameMatrix = function (t, e, r, i, n) {
		var o = t.a,
			s = t.b,
			a = t.c,
			h = t.d,
			u = t.tx,
			l = t.ty,
			c = this.minX,
			d = this.minY,
			p = this.maxX,
			f = this.maxY,
			v = o * e + a * r + u,
			m = s * e + h * r + l;
		c = v < c ? v : c, d = m < d ? m : d, p = v > p ? v : p, f = m > f ? m : f, c = (v = o * i + a * r + u) < c ? v : c, d = (m = s * i + h * r + l) < d ? m : d, p = v > p ? v : p, f = m > f ? m : f, c = (v = o * e + a * n + u) < c ? v : c, d = (m = s * e + h * n + l) < d ? m : d, p = v > p ? v : p, f = m > f ? m : f, c = (v = o * i + a * n + u) < c ? v : c, d = (m = s * i + h * n + l) < d ? m : d, p = v > p ? v : p, f = m > f ? m : f, this.minX = c, this.minY = d, this.maxX = p, this.maxY = f
	}, Je.prototype.addVertexData = function (t, e, r) {
		for (var i = this.minX, n = this.minY, o = this.maxX, s = this.maxY, a = e; a < r; a += 2) {
			var h = t[a],
				u = t[a + 1];
			i = h < i ? h : i, n = u < n ? u : n, o = h > o ? h : o, s = u > s ? u : s
		}
		this.minX = i, this.minY = n, this.maxX = o, this.maxY = s
	}, Je.prototype.addVertices = function (t, e, r, i) {
		this.addVerticesMatrix(t.worldTransform, e, r, i)
	}, Je.prototype.addVerticesMatrix = function (t, e, r, i, n, o) {
		var s = t.a,
			a = t.b,
			h = t.c,
			u = t.d,
			l = t.tx,
			c = t.ty;
		n = n || 0, o = o || 0;
		for (var d = this.minX, p = this.minY, f = this.maxX, v = this.maxY, m = r; m < i; m += 2) {
			var g = e[m],
				y = e[m + 1],
				_ = s * g + h * y + l,
				x = u * y + a * g + c;
			d = Math.min(d, _ - n), f = Math.max(f, _ + n), p = Math.min(p, x - o), v = Math.max(v, x + o)
		}
		this.minX = d, this.minY = p, this.maxX = f, this.maxY = v
	}, Je.prototype.addBounds = function (t) {
		var e = this.minX,
			r = this.minY,
			i = this.maxX,
			n = this.maxY;
		this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > i ? t.maxX : i, this.maxY = t.maxY > n ? t.maxY : n
	}, Je.prototype.addBoundsMask = function (t, e) {
		var r = t.minX > e.minX ? t.minX : e.minX,
			i = t.minY > e.minY ? t.minY : e.minY,
			n = t.maxX < e.maxX ? t.maxX : e.maxX,
			o = t.maxY < e.maxY ? t.maxY : e.maxY;
		if (r <= n && i <= o) {
			var s = this.minX,
				a = this.minY,
				h = this.maxX,
				u = this.maxY;
			this.minX = r < s ? r : s, this.minY = i < a ? i : a, this.maxX = n > h ? n : h, this.maxY = o > u ? o : u
		}
	}, Je.prototype.addBoundsMatrix = function (t, e) {
		this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
	}, Je.prototype.addBoundsArea = function (t, e) {
		var r = t.minX > e.x ? t.minX : e.x,
			i = t.minY > e.y ? t.minY : e.y,
			n = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
			o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
		if (r <= n && i <= o) {
			var s = this.minX,
				a = this.minY,
				h = this.maxX,
				u = this.maxY;
			this.minX = r < s ? r : s, this.minY = i < a ? i : a, this.maxX = n > h ? n : h, this.maxY = o > u ? o : u
		}
	}, Je.prototype.pad = function (t, e) {
		t = t || 0, e = e || (0 !== e ? t : 0), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e)
	}, Je.prototype.addFramePad = function (t, e, r, i, n, o) {
		t -= n, e -= o, r += n, i += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > i ? this.maxY : i
	};
	var Qe = function (t) {
		function e() {
			t.call(this), this.tempDisplayObjectParent = null, this.transform = new Ve, this.alpha = 1, this.visible = !0, this.renderable = !0, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Je, this._boundsID = 0, this._lastBoundsID = -1, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._destroyed = !1, this.isSprite = !1, this.isMask = !1
		}
		t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
		var r = {
			_tempDisplayObjectParent: {
				configurable: !0
			},
			x: {
				configurable: !0
			},
			y: {
				configurable: !0
			},
			worldTransform: {
				configurable: !0
			},
			localTransform: {
				configurable: !0
			},
			position: {
				configurable: !0
			},
			scale: {
				configurable: !0
			},
			pivot: {
				configurable: !0
			},
			skew: {
				configurable: !0
			},
			rotation: {
				configurable: !0
			},
			angle: {
				configurable: !0
			},
			zIndex: {
				configurable: !0
			},
			worldVisible: {
				configurable: !0
			},
			mask: {
				configurable: !0
			}
		};
		return e.mixin = function (t) {
			for (var r = Object.keys(t), i = 0; i < r.length; ++i) {
				var n = r[i];
				Object.defineProperty(e.prototype, n, Object.getOwnPropertyDescriptor(t, n))
			}
		}, r._tempDisplayObjectParent.get = function () {
			return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new e), this.tempDisplayObjectParent
		}, e.prototype.updateTransform = function () {
			this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
		}, e.prototype.calculateBounds = function () {}, e.prototype._recursivePostUpdateTransform = function () {
			this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
		}, e.prototype.getBounds = function (t, e) {
			return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._boundsID !== this._lastBoundsID && (this.calculateBounds(), this._lastBoundsID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new ze), e = this._boundsRect), this._bounds.getRectangle(e)
		}, e.prototype.getLocalBounds = function (t) {
			var e = this.transform,
				r = this.parent;
			this.parent = null, this.transform = this._tempDisplayObjectParent.transform, t || (this._localBoundsRect || (this._localBoundsRect = new ze), t = this._localBoundsRect);
			var i = this.getBounds(!1, t);
			return this.parent = r, this.transform = e, i
		}, e.prototype.toGlobal = function (t, e, r) {
			return void 0 === r && (r = !1), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e)
		}, e.prototype.toLocal = function (t, e, r, i) {
			return e && (t = e.toGlobal(t, r, i)), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, r)
		}, e.prototype.render = function (t) {}, e.prototype.setParent = function (t) {
			if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
			return t.addChild(this), t
		}, e.prototype.setTransform = function (t, e, r, i, n, o, s, a, h) {
			return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 1), void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), this.position.x = t, this.position.y = e, this.scale.x = r || 1, this.scale.y = i || 1, this.rotation = n, this.skew.x = o, this.skew.y = s, this.pivot.x = a, this.pivot.y = h, this
		}, e.prototype.destroy = function () {
			this.parent && this.parent.removeChild(this), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this._currentBounds = null, this._mask = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0
		}, r.x.get = function () {
			return this.position.x
		}, r.x.set = function (t) {
			this.transform.position.x = t
		}, r.y.get = function () {
			return this.position.y
		}, r.y.set = function (t) {
			this.transform.position.y = t
		}, r.worldTransform.get = function () {
			return this.transform.worldTransform
		}, r.localTransform.get = function () {
			return this.transform.localTransform
		}, r.position.get = function () {
			return this.transform.position
		}, r.position.set = function (t) {
			this.transform.position.copyFrom(t)
		}, r.scale.get = function () {
			return this.transform.scale
		}, r.scale.set = function (t) {
			this.transform.scale.copyFrom(t)
		}, r.pivot.get = function () {
			return this.transform.pivot
		}, r.pivot.set = function (t) {
			this.transform.pivot.copyFrom(t)
		}, r.skew.get = function () {
			return this.transform.skew
		}, r.skew.set = function (t) {
			this.transform.skew.copyFrom(t)
		}, r.rotation.get = function () {
			return this.transform.rotation
		}, r.rotation.set = function (t) {
			this.transform.rotation = t
		}, r.angle.get = function () {
			return this.transform.rotation * Le
		}, r.angle.set = function (t) {
			this.transform.rotation = t * Ne
		}, r.zIndex.get = function () {
			return this._zIndex
		}, r.zIndex.set = function (t) {
			this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
		}, r.worldVisible.get = function () {
			var t = this;
			do {
				if (!t.visible) return !1;
				t = t.parent
			} while (t);
			return !0
		}, r.mask.get = function () {
			return this._mask
		}, r.mask.set = function (t) {
			if (this._mask) {
				var e = this._mask.maskObject || this._mask;
				e.renderable = !0, e.isMask = !1
			}
			if (this._mask = t, this._mask) {
				var r = this._mask.maskObject || this._mask;
				r.renderable = !1, r.isMask = !0
			}
		}, Object.defineProperties(e.prototype, r), e
	}(R);

	function $e(t, e) {
		return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
	}
	Qe.prototype.displayObjectUpdateTransform = Qe.prototype.updateTransform;
	var tr = function (t) {
		function e() {
			t.call(this), this.children = [], this.sortableChildren = M.SORTABLE_CHILDREN, this.sortDirty = !1
		}
		t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
		var r = {
			width: {
				configurable: !0
			},
			height: {
				configurable: !0
			}
		};
		return e.prototype.onChildrenChange = function () {}, e.prototype.addChild = function (t) {
			var e = arguments,
				r = arguments.length;
			if (r > 1)
				for (var i = 0; i < r; i++) this.addChild(e[i]);
			else t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.push(t), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this);
			return t
		}, e.prototype.addChildAt = function (t, e) {
			if (e < 0 || e > this.children.length) throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
			return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t
		}, e.prototype.swapChildren = function (t, e) {
			if (t !== e) {
				var r = this.getChildIndex(t),
					i = this.getChildIndex(e);
				this.children[r] = e, this.children[i] = t, this.onChildrenChange(r < i ? r : i)
			}
		}, e.prototype.getChildIndex = function (t) {
			var e = this.children.indexOf(t);
			if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
			return e
		}, e.prototype.setChildIndex = function (t, e) {
			if (e < 0 || e >= this.children.length) throw new Error("The index " + e + " supplied is out of bounds " + this.children.length);
			var r = this.getChildIndex(t);
			fe(this.children, r, 1), this.children.splice(e, 0, t), this.onChildrenChange(e)
		}, e.prototype.getChildAt = function (t) {
			if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Index (" + t + ") does not exist.");
			return this.children[t]
		}, e.prototype.removeChild = function (t) {
			var e = arguments,
				r = arguments.length;
			if (r > 1)
				for (var i = 0; i < r; i++) this.removeChild(e[i]);
			else {
				var n = this.children.indexOf(t);
				if (-1 === n) return null;
				t.parent = null, t.transform._parentID = -1, fe(this.children, n, 1), this._boundsID++, this.onChildrenChange(n), t.emit("removed", this), this.emit("childRemoved", t, this, n)
			}
			return t
		}, e.prototype.removeChildAt = function (t) {
			var e = this.getChildAt(t);
			return e.parent = null, e.transform._parentID = -1, fe(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e
		}, e.prototype.removeChildren = function (t, e) {
			void 0 === t && (t = 0);
			var r, i = t,
				n = "number" == typeof e ? e : this.children.length,
				o = n - i;
			if (o > 0 && o <= n) {
				r = this.children.splice(i, o);
				for (var s = 0; s < r.length; ++s) r[s].parent = null, r[s].transform && (r[s].transform._parentID = -1);
				this._boundsID++, this.onChildrenChange(t);
				for (var a = 0; a < r.length; ++a) r[a].emit("removed", this), this.emit("childRemoved", r[a], this, a);
				return r
			}
			if (0 === o && 0 === this.children.length) return [];
			throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
		}, e.prototype.sortChildren = function () {
			for (var t = !1, e = 0, r = this.children.length; e < r; ++e) {
				var i = this.children[e];
				i._lastSortedIndex = e, t || 0 === i.zIndex || (t = !0)
			}
			t && this.children.length > 1 && this.children.sort($e), this.sortDirty = !1
		}, e.prototype.updateTransform = function () {
			this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
			for (var t = 0, e = this.children.length; t < e; ++t) {
				var r = this.children[t];
				r.visible && r.updateTransform()
			}
		}, e.prototype.calculateBounds = function () {
			this._bounds.clear(), this._calculateBounds();
			for (var t = 0; t < this.children.length; t++) {
				var e = this.children[t];
				if (e.visible && e.renderable)
					if (e.calculateBounds(), e._mask) {
						var r = e._mask.maskObject || e._mask;
						r.calculateBounds(), this._bounds.addBoundsMask(e._bounds, r._bounds)
					} else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
			}
			this._lastBoundsID = this._boundsID
		}, e.prototype._calculateBounds = function () {}, e.prototype.render = function (t) {
			if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
				if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t);
				else {
					this._render(t);
					for (var e = 0, r = this.children.length; e < r; ++e) this.children[e].render(t)
				}
		}, e.prototype.renderAdvanced = function (t) {
			t.batch.flush();
			var e = this.filters,
				r = this._mask;
			if (e) {
				this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
				for (var i = 0; i < e.length; i++) e[i].enabled && this._enabledFilters.push(e[i]);
				this._enabledFilters.length && t.filter.push(this, this._enabledFilters)
			}
			r && t.mask.push(this, this._mask), this._render(t);
			for (var n = 0, o = this.children.length; n < o; n++) this.children[n].render(t);
			t.batch.flush(), r && t.mask.pop(this, this._mask), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop()
		}, e.prototype._render = function (t) {}, e.prototype.destroy = function (e) {
			t.prototype.destroy.call(this), this.sortDirty = !1;
			var r = "boolean" == typeof e ? e : e && e.children,
				i = this.removeChildren(0, this.children.length);
			if (r)
				for (var n = 0; n < i.length; ++n) i[n].destroy(e)
		}, r.width.get = function () {
			return this.scale.x * this.getLocalBounds().width
		}, r.width.set = function (t) {
			var e = this.getLocalBounds().width;
			this.scale.x = 0 !== e ? t / e : 1, this._width = t
		}, r.height.get = function () {
			return this.scale.y * this.getLocalBounds().height
		}, r.height.set = function (t) {
			var e = this.getLocalBounds().height;
			this.scale.y = 0 !== e ? t / e : 1, this._height = t
		}, Object.defineProperties(e.prototype, r), e
	}(Qe);
	tr.prototype.containerUpdateTransform = tr.prototype.updateTransform;
	var er = {
		accessible: !1,
		accessibleTitle: null,
		accessibleHint: null,
		tabIndex: 0,
		_accessibleActive: !1,
		_accessibleDiv: !1,
		accessibleType: "button",
		accessiblePointerEvents: "auto",
		accessibleChildren: !0
	};
	Qe.mixin(er);
	var rr = function (t) {
		this._hookDiv = null, (C.tablet || C.phone) && this.createTouchHook();
		var e = document.createElement("div");
		e.style.width = "100px", e.style.height = "100px", e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.zIndex = 2, this.div = e, this.pool = [], this.renderId = 0, this.debug = !1, this.renderer = t, this.children = [], this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this.isActive = !1, this.isMobileAccessibility = !1, this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, window.addEventListener("keydown", this._onKeyDown, !1)
	};
	rr.prototype.createTouchHook = function () {
		var t = this,
			e = document.createElement("button");
		e.style.width = "1px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.style.zIndex = 2, e.style.backgroundColor = "#FF0000", e.title = "select to enable accessability for this content", e.addEventListener("focus", function () {
			t.isMobileAccessibility = !0, t.activate(), t.destroyTouchHook()
		}), document.body.appendChild(e), this._hookDiv = e
	}, rr.prototype.destroyTouchHook = function () {
		this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
	}, rr.prototype.activate = function () {
		this.isActive || (this.isActive = !0, window.document.addEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode && this.renderer.view.parentNode.appendChild(this.div))
	}, rr.prototype.deactivate = function () {
		this.isActive && !this.isMobileAccessibility && (this.isActive = !1, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode && this.div.parentNode.removeChild(this.div))
	}, rr.prototype.updateAccessibleObjects = function (t) {
		if (t.visible && t.accessibleChildren) {
			t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
			for (var e = t.children, r = 0; r < e.length; r++) this.updateAccessibleObjects(e[r])
		}
	}, rr.prototype.update = function () {
		var t = performance.now();
		if (!(C.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
			this.updateAccessibleObjects(this.renderer._lastObjectRendered);
			var e = this.renderer.view.getBoundingClientRect(),
				r = this.renderer.resolution,
				i = e.width / this.renderer.width * r,
				n = e.height / this.renderer.height * r,
				o = this.div;
			o.style.left = e.left + "px", o.style.top = e.top + "px", o.style.width = this.renderer.width + "px", o.style.height = this.renderer.height + "px";
			for (var s = 0; s < this.children.length; s++) {
				var a = this.children[s];
				if (a.renderId !== this.renderId) a._accessibleActive = !1, fe(this.children, s, 1), this.div.removeChild(a._accessibleDiv), this.pool.push(a._accessibleDiv), a._accessibleDiv = null, s--;
				else {
					o = a._accessibleDiv;
					var h = a.hitArea,
						u = a.worldTransform;
					a.hitArea ? (o.style.left = (u.tx + h.x * u.a) * i + "px", o.style.top = (u.ty + h.y * u.d) * n + "px", o.style.width = h.width * u.a * i + "px", o.style.height = h.height * u.d * n + "px") : (h = a.getBounds(), this.capHitArea(h), o.style.left = h.x * i + "px", o.style.top = h.y * n + "px", o.style.width = h.width * i + "px", o.style.height = h.height * n + "px", o.title !== a.accessibleTitle && null !== a.accessibleTitle && (o.title = a.accessibleTitle), o.getAttribute("aria-label") !== a.accessibleHint && null !== a.accessibleHint && o.setAttribute("aria-label", a.accessibleHint)), a.accessibleTitle === o.title && a.tabIndex === o.tabIndex || (o.title = a.accessibleTitle, o.tabIndex = a.tabIndex, this.debug && this.updateDebugHTML(o))
				}
			}
			this.renderId++
		}
	}, rr.prototype.updateDebugHTML = function (t) {
		t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex
	}, rr.prototype.capHitArea = function (t) {
		t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0), t.x + t.width > this.renderer.width && (t.width = this.renderer.width - t.x), t.y + t.height > this.renderer.height && (t.height = this.renderer.height - t.y)
	}, rr.prototype.addChild = function (t) {
		var e = this.pool.pop();
		e || ((e = document.createElement("button")).style.width = "100px", e.style.height = "100px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = 2, e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = "displayObject " + t.tabIndex), t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
	}, rr.prototype._onClick = function (t) {
		var e = this.renderer.plugins.interaction;
		e.dispatchEvent(t.target.displayObject, "click", e.eventData), e.dispatchEvent(t.target.displayObject, "pointertap", e.eventData), e.dispatchEvent(t.target.displayObject, "tap", e.eventData)
	}, rr.prototype._onFocus = function (t) {
		t.target.getAttribute("aria-live", "off") || t.target.setAttribute("aria-live", "assertive");
		var e = this.renderer.plugins.interaction;
		e.dispatchEvent(t.target.displayObject, "mouseover", e.eventData)
	}, rr.prototype._onFocusOut = function (t) {
		t.target.getAttribute("aria-live", "off") || t.target.setAttribute("aria-live", "polite");
		var e = this.renderer.plugins.interaction;
		e.dispatchEvent(t.target.displayObject, "mouseout", e.eventData)
	}, rr.prototype._onKeyDown = function (t) {
		9 === t.keyCode && this.activate()
	}, rr.prototype._onMouseMove = function (t) {
		0 === t.movementX && 0 === t.movementY || this.deactivate()
	}, rr.prototype.destroy = function () {
		this.destroyTouchHook(), this.div = null;
		for (var t = 0; t < this.children.length; t++) this.children[t].div = null;
		window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
	};
	var ir, nr = {
		AccessibilityManager: rr,
		accessibleTarget: er
	};
	M.TARGET_FPMS = .06, (ir = t.UPDATE_PRIORITY || (t.UPDATE_PRIORITY = {}))[ir.INTERACTION = 50] = "INTERACTION", ir[ir.HIGH = 25] = "HIGH", ir[ir.NORMAL = 0] = "NORMAL", ir[ir.LOW = -25] = "LOW", ir[ir.UTILITY = -50] = "UTILITY";
	var or = function () {
			function t(t, e, r, i) {
				void 0 === e && (e = null), void 0 === r && (r = 0), void 0 === i && (i = !1), this.fn = t, this.context = e, this.priority = r, this.once = i, this.next = null, this.previous = null, this._destroyed = !1
			}
			return t.prototype.match = function (t, e) {
				return void 0 === e && (e = null), this.fn === t && this.context === e
			}, t.prototype.emit = function (t) {
				this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
				var e = this.next;
				return this.once && this.destroy(!0), this._destroyed && (this.next = null), e
			}, t.prototype.connect = function (t) {
				this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
			}, t.prototype.destroy = function (t) {
				void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
				var e = this.next;
				return this.next = t ? null : e, this.previous = null, e
			}, t
		}(),
		sr = function () {
			function e() {
				var t = this;
				this._head = new or(null, null, 1 / 0), this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this.autoStart = !1, this.deltaTime = 1, this.deltaMS = 1 / M.TARGET_FPMS, this.elapsedMS = 1 / M.TARGET_FPMS, this.lastTime = -1, this.speed = 1, this.started = !1, this._protected = !1, this._lastFrame = -1, this._tick = function (e) {
					t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._head.next && (t._requestId = requestAnimationFrame(t._tick)))
				}
			}
			return e.prototype._requestIfNeeded = function () {
				null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
			}, e.prototype._cancelIfNeeded = function () {
				null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null)
			}, e.prototype._startIfPossible = function () {
				this.started ? this._requestIfNeeded() : this.autoStart && this.start()
			}, e.prototype.add = function (e, r, i) {
				return void 0 === i && (i = t.UPDATE_PRIORITY.NORMAL), this._addListener(new or(e, r, i))
			}, e.prototype.addOnce = function (e, r, i) {
				return void 0 === i && (i = t.UPDATE_PRIORITY.NORMAL), this._addListener(new or(e, r, i, !0))
			}, e.prototype._addListener = function (t) {
				var e = this._head.next,
					r = this._head;
				if (e) {
					for (; e;) {
						if (t.priority > e.priority) {
							t.connect(r);
							break
						}
						r = e, e = e.next
					}
					t.previous || t.connect(r)
				} else t.connect(r);
				return this._startIfPossible(), this
			}, e.prototype.remove = function (t, e) {
				for (var r = this._head.next; r;) r = r.match(t, e) ? r.destroy() : r.next;
				return this._head.next || this._cancelIfNeeded(), this
			}, Object.defineProperty(e.prototype, "count", {
				get: function () {
					if (!this._head) return 0;
					for (var t = 0, e = this._head; e = e.next;) t++;
					return t
				},
				enumerable: !0,
				configurable: !0
			}), e.prototype.start = function () {
				this.started || (this.started = !0, this._requestIfNeeded())
			}, e.prototype.stop = function () {
				this.started && (this.started = !1, this._cancelIfNeeded())
			}, e.prototype.destroy = function () {
				if (!this._protected) {
					this.stop();
					for (var t = this._head.next; t;) t = t.destroy(!0);
					this._head.destroy(), this._head = null
				}
			}, e.prototype.update = function (t) {
				var e;
				if (void 0 === t && (t = performance.now()), t > this.lastTime) {
					if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
						var r = t - this._lastFrame | 0;
						if (r < this._minElapsedMS) return;
						this._lastFrame = t - r % this._minElapsedMS
					}
					this.deltaMS = e, this.deltaTime = this.deltaMS * M.TARGET_FPMS;
					for (var i = this._head, n = i.next; n;) n = n.emit(this.deltaTime);
					i.next || this._cancelIfNeeded()
				} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
				this.lastTime = t
			}, Object.defineProperty(e.prototype, "FPS", {
				get: function () {
					return 1e3 / this.elapsedMS
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "minFPS", {
				get: function () {
					return 1e3 / this._maxElapsedMS
				},
				set: function (t) {
					var e = Math.min(this.maxFPS, t),
						r = Math.min(Math.max(0, e) / 1e3, M.TARGET_FPMS);
					this._maxElapsedMS = 1 / r
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "maxFPS", {
				get: function () {
					return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
				},
				set: function (t) {
					if (0 === t) this._minElapsedMS = 0;
					else {
						var e = Math.max(this.minFPS, t);
						this._minElapsedMS = 1 / (e / 1e3)
					}
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e, "shared", {
				get: function () {
					if (!e._shared) {
						var t = e._shared = new e;
						t.autoStart = !0, t._protected = !0
					}
					return e._shared
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e, "system", {
				get: function () {
					if (!e._system) {
						var t = e._system = new e;
						t.autoStart = !0, t._protected = !0
					}
					return e._system
				},
				enumerable: !0,
				configurable: !0
			}), e
		}(),
		ar = function () {
			function e() {}
			return e.init = function (e) {
				var r = this;
				e = Object.assign({
					autoStart: !0,
					sharedTicker: !1
				}, e), Object.defineProperty(this, "ticker", {
					set: function (e) {
						this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, t.UPDATE_PRIORITY.LOW)
					},
					get: function () {
						return this._ticker
					}
				}), this.stop = function () {
					r._ticker.stop()
				}, this.start = function () {
					r._ticker.start()
				}, this._ticker = null, this.ticker = e.sharedTicker ? sr.shared : new sr, e.autoStart && this.start()
			}, e.destroy = function () {
				if (this._ticker) {
					var t = this._ticker;
					this.ticker = null, t.destroy()
				}
			}, e
		}(),
		hr = function () {
			this.global = new Ce, this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0
		},
		ur = {
			pointerId: {
				configurable: !0
			}
		};
	ur.pointerId.get = function () {
		return this.identifier
	}, hr.prototype.getLocalPosition = function (t, e, r) {
		return t.worldTransform.applyInverse(r || this.global, e)
	}, hr.prototype.copyEvent = function (t) {
		t.isPrimary && (this.isPrimary = !0), this.button = t.button, this.buttons = Number.isInteger(t.buttons) ? t.buttons : t.which, this.width = t.width, this.height = t.height, this.tiltX = t.tiltX, this.tiltY = t.tiltY, this.pointerType = t.pointerType, this.pressure = t.pressure, this.rotationAngle = t.rotationAngle, this.twist = t.twist || 0, this.tangentialPressure = t.tangentialPressure || 0
	}, hr.prototype.reset = function () {
		this.isPrimary = !1
	}, Object.defineProperties(hr.prototype, ur);
	var lr = function () {
		this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null
	};
	lr.prototype.stopPropagation = function () {
		this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget
	}, lr.prototype.reset = function () {
		this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null
	};
	var cr = function t(e) {
			this._pointerId = e, this._flags = t.FLAGS.NONE
		},
		dr = {
			pointerId: {
				configurable: !0
			},
			flags: {
				configurable: !0
			},
			none: {
				configurable: !0
			},
			over: {
				configurable: !0
			},
			rightDown: {
				configurable: !0
			},
			leftDown: {
				configurable: !0
			}
		};
	cr.prototype._doSet = function (t, e) {
		this._flags = e ? this._flags | t : this._flags & ~t
	}, dr.pointerId.get = function () {
		return this._pointerId
	}, dr.flags.get = function () {
		return this._flags
	}, dr.flags.set = function (t) {
		this._flags = t
	}, dr.none.get = function () {
		return this._flags === this.constructor.FLAGS.NONE
	}, dr.over.get = function () {
		return 0 != (this._flags & this.constructor.FLAGS.OVER)
	}, dr.over.set = function (t) {
		this._doSet(this.constructor.FLAGS.OVER, t)
	}, dr.rightDown.get = function () {
		return 0 != (this._flags & this.constructor.FLAGS.RIGHT_DOWN)
	}, dr.rightDown.set = function (t) {
		this._doSet(this.constructor.FLAGS.RIGHT_DOWN, t)
	}, dr.leftDown.get = function () {
		return 0 != (this._flags & this.constructor.FLAGS.LEFT_DOWN)
	}, dr.leftDown.set = function (t) {
		this._doSet(this.constructor.FLAGS.LEFT_DOWN, t)
	}, Object.defineProperties(cr.prototype, dr), cr.FLAGS = Object.freeze({
		NONE: 0,
		OVER: 1,
		LEFT_DOWN: 2,
		RIGHT_DOWN: 4
	});
	var pr = function () {
		this._tempPoint = new Ce
	};
	pr.prototype.recursiveFindHit = function (t, e, r, i, n) {
		if (!e || !e.visible) return !1;
		var o = t.data.global,
			s = !1,
			a = n = e.interactive || n,
			h = !0;
		if (e.hitArea ? (i && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s = !0 : (i = !1, h = !1)), a = !1) : e._mask && i && (e._mask.containsPoint && e._mask.containsPoint(o) || (i = !1)), h && e.interactiveChildren && e.children)
			for (var u = e.children, l = u.length - 1; l >= 0; l--) {
				var c = u[l],
					d = this.recursiveFindHit(t, c, r, i, a);
				if (d) {
					if (!c.parent) continue;
					a = !1, d && (t.target && (i = !1), s = !0)
				}
			}
		return n && (i && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (s = !0), e.interactive && (s && !t.target && (t.target = e), r && r(t, e, !!s))), s
	}, pr.prototype.findHit = function (t, e, r, i) {
		this.recursiveFindHit(t, e, r, i, !1)
	};
	var fr = {
		interactive: !1,
		interactiveChildren: !0,
		hitArea: null,
		get buttonMode() {
			return "pointer" === this.cursor
		},
		set buttonMode(t) {
			t ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null)
		},
		cursor: null,
		get trackedPointers() {
			return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers
		},
		_trackedPointers: void 0
	};
	Qe.mixin(fr);
	var vr = 1,
		mr = {
			target: null,
			data: {
				global: null
			}
		},
		gr = function (e) {
			function r(t, r) {
				e.call(this), r = r || {}, this.renderer = t, this.autoPreventDefault = void 0 === r.autoPreventDefault || r.autoPreventDefault, this.interactionFrequency = r.interactionFrequency || 10, this.mouse = new hr, this.mouse.identifier = vr, this.mouse.global.set(-999999), this.activeInteractionData = {}, this.activeInteractionData[vr] = this.mouse, this.interactionDataPool = [], this.eventData = new lr, this.interactionDOMElement = null, this.moveWhenInside = !1, this.eventsAdded = !1, this.tickerAdded = !1, this.mouseOverRenderer = !1, this.supportsTouchEvents = "ontouchstart" in window, this.supportsPointerEvents = !!window.PointerEvent, this.onPointerUp = this.onPointerUp.bind(this), this.processPointerUp = this.processPointerUp.bind(this), this.onPointerCancel = this.onPointerCancel.bind(this), this.processPointerCancel = this.processPointerCancel.bind(this), this.onPointerDown = this.onPointerDown.bind(this), this.processPointerDown = this.processPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.processPointerMove = this.processPointerMove.bind(this), this.onPointerOut = this.onPointerOut.bind(this), this.processPointerOverOut = this.processPointerOverOut.bind(this), this.onPointerOver = this.onPointerOver.bind(this), this.cursorStyles = {
					default: "inherit",
					pointer: "pointer"
				}, this.currentCursorMode = null, this.cursor = null, this.resolution = 1, this.delayedEvents = [], this.search = new pr, this._useSystemTicker = void 0 === r.useSystemTicker || r.useSystemTicker, this.setTargetElement(this.renderer.view, this.renderer.resolution)
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				useSystemTicker: {
					configurable: !0
				}
			};
			return i.useSystemTicker.get = function () {
				return this._useSystemTicker
			}, i.useSystemTicker.set = function (t) {
				this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener()
			}, r.prototype.hitTest = function (t, e) {
				return mr.target = null, mr.data.global = t, e || (e = this.renderer._lastObjectRendered), this.processInteractive(mr, e, null, !0), mr.target
			}, r.prototype.setTargetElement = function (t, e) {
				void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener()
			}, r.prototype.addTickerListener = function () {
				!this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (sr.system.add(this.tickerUpdate, this, t.UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0)
			}, r.prototype.removeTickerListener = function () {
				this.tickerAdded && (sr.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
			}, r.prototype.addEvents = function () {
				!this.eventsAdded && this.interactionDOMElement && (window.navigator.msPointerEnabled ? (this.interactionDOMElement.style["-ms-content-zooming"] = "none", this.interactionDOMElement.style["-ms-touch-action"] = "none") : this.supportsPointerEvents && (this.interactionDOMElement.style["touch-action"] = "none"), this.supportsPointerEvents ? (window.document.addEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, !0), window.addEventListener("pointercancel", this.onPointerCancel, !0), window.addEventListener("pointerup", this.onPointerUp, !0)) : (window.document.addEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, !0), window.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, !0)), this.eventsAdded = !0)
			}, r.prototype.removeEvents = function () {
				this.eventsAdded && this.interactionDOMElement && (window.navigator.msPointerEnabled ? (this.interactionDOMElement.style["-ms-content-zooming"] = "", this.interactionDOMElement.style["-ms-touch-action"] = "") : this.supportsPointerEvents && (this.interactionDOMElement.style["touch-action"] = ""), this.supportsPointerEvents ? (window.document.removeEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, !0), window.removeEventListener("pointercancel", this.onPointerCancel, !0), window.removeEventListener("pointerup", this.onPointerUp, !0)) : (window.document.removeEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, !0), window.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.interactionDOMElement = null, this.eventsAdded = !1)
			}, r.prototype.tickerUpdate = function (t) {
				this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update())
			}, r.prototype.update = function () {
				if (this.interactionDOMElement)
					if (this.didMove) this.didMove = !1;
					else {
						for (var t in this.cursor = null, this.activeInteractionData)
							if (this.activeInteractionData.hasOwnProperty(t)) {
								var e = this.activeInteractionData[t];
								if (e.originalEvent && "touch" !== e.pointerType) {
									var r = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e);
									this.processInteractive(r, this.renderer._lastObjectRendered, this.processPointerOverOut, !0)
								}
							} this.setCursorMode(this.cursor)
					}
			}, r.prototype.setCursorMode = function (t) {
				if (t = t || "default", this.currentCursorMode !== t) {
					this.currentCursorMode = t;
					var e = this.cursorStyles[t];
					if (e) switch (typeof e) {
						case "string":
							this.interactionDOMElement.style.cursor = e;
							break;
						case "function":
							e(t);
							break;
						case "object":
							Object.assign(this.interactionDOMElement.style, e)
					} else "string" != typeof t || Object.prototype.hasOwnProperty.call(this.cursorStyles, t) || (this.interactionDOMElement.style.cursor = t)
				}
			}, r.prototype.dispatchEvent = function (t, e, r) {
				r.stopPropagationHint && t !== r.stopsPropagatingAt || (r.currentTarget = t, r.type = e, t.emit(e, r), t[e] && t[e](r))
			}, r.prototype.delayDispatchEvent = function (t, e, r) {
				this.delayedEvents.push({
					displayObject: t,
					eventString: e,
					eventData: r
				})
			}, r.prototype.mapPositionToPoint = function (t, e, r) {
				var i;
				i = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : {
					x: 0,
					y: 0,
					width: 0,
					height: 0
				};
				var n = 1 / this.resolution;
				t.x = (e - i.left) * (this.interactionDOMElement.width / i.width) * n, t.y = (r - i.top) * (this.interactionDOMElement.height / i.height) * n
			}, r.prototype.processInteractive = function (t, e, r, i) {
				var n = this.search.findHit(t, e, r, i),
					o = this.delayedEvents;
				if (!o.length) return n;
				t.stopPropagationHint = !1;
				var s = o.length;
				this.delayedEvents = [];
				for (var a = 0; a < s; a++) {
					var h = o[a],
						u = h.displayObject,
						l = h.eventString,
						c = h.eventData;
					c.stopsPropagatingAt === u && (c.stopPropagationHint = !0), this.dispatchEvent(u, l, c)
				}
				return n
			}, r.prototype.onPointerDown = function (t) {
				if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
					var e = this.normalizeToPointerData(t);
					if (this.autoPreventDefault && e[0].isNormalized)(t.cancelable || !("cancelable" in t)) && t.preventDefault();
					for (var r = e.length, i = 0; i < r; i++) {
						var n = e[i],
							o = this.getInteractionDataForPointerId(n),
							s = this.configureInteractionEventForDOMEvent(this.eventData, n, o);
						if (s.data.originalEvent = t, this.processInteractive(s, this.renderer._lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", s), "touch" === n.pointerType) this.emit("touchstart", s);
						else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
							var a = 2 === n.button;
							this.emit(a ? "rightdown" : "mousedown", this.eventData)
						}
					}
				}
			}, r.prototype.processPointerDown = function (t, e, r) {
				var i = t.data,
					n = t.data.identifier;
				if (r)
					if (e.trackedPointers[n] || (e.trackedPointers[n] = new cr(n)), this.dispatchEvent(e, "pointerdown", t), "touch" === i.pointerType) this.dispatchEvent(e, "touchstart", t);
					else if ("mouse" === i.pointerType || "pen" === i.pointerType) {
					var o = 2 === i.button;
					o ? e.trackedPointers[n].rightDown = !0 : e.trackedPointers[n].leftDown = !0, this.dispatchEvent(e, o ? "rightdown" : "mousedown", t)
				}
			}, r.prototype.onPointerComplete = function (t, e, r) {
				for (var i = this.normalizeToPointerData(t), n = i.length, o = t.target !== this.interactionDOMElement ? "outside" : "", s = 0; s < n; s++) {
					var a = i[s],
						h = this.getInteractionDataForPointerId(a),
						u = this.configureInteractionEventForDOMEvent(this.eventData, a, h);
					if (u.data.originalEvent = t, this.processInteractive(u, this.renderer._lastObjectRendered, r, e || !o), this.emit(e ? "pointercancel" : "pointerup" + o, u), "mouse" === a.pointerType || "pen" === a.pointerType) {
						var l = 2 === a.button;
						this.emit(l ? "rightup" + o : "mouseup" + o, u)
					} else "touch" === a.pointerType && (this.emit(e ? "touchcancel" : "touchend" + o, u), this.releaseInteractionDataForPointerId(a.pointerId, h))
				}
			}, r.prototype.onPointerCancel = function (t) {
				this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !0, this.processPointerCancel)
			}, r.prototype.processPointerCancel = function (t, e) {
				var r = t.data,
					i = t.data.identifier;
				void 0 !== e.trackedPointers[i] && (delete e.trackedPointers[i], this.dispatchEvent(e, "pointercancel", t), "touch" === r.pointerType && this.dispatchEvent(e, "touchcancel", t))
			}, r.prototype.onPointerUp = function (t) {
				this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !1, this.processPointerUp)
			}, r.prototype.processPointerUp = function (t, e, r) {
				var i = t.data,
					n = t.data.identifier,
					o = e.trackedPointers[n],
					s = "touch" === i.pointerType,
					a = "mouse" === i.pointerType || "pen" === i.pointerType,
					h = !1;
				if (a) {
					var u = 2 === i.button,
						l = cr.FLAGS,
						c = u ? l.RIGHT_DOWN : l.LEFT_DOWN,
						d = void 0 !== o && o.flags & c;
					r ? (this.dispatchEvent(e, u ? "rightup" : "mouseup", t), d && (this.dispatchEvent(e, u ? "rightclick" : "click", t), h = !0)) : d && this.dispatchEvent(e, u ? "rightupoutside" : "mouseupoutside", t), o && (u ? o.rightDown = !1 : o.leftDown = !1)
				}
				r ? (this.dispatchEvent(e, "pointerup", t), s && this.dispatchEvent(e, "touchend", t), o && (a && !h || this.dispatchEvent(e, "pointertap", t), s && (this.dispatchEvent(e, "tap", t), o.over = !1))) : o && (this.dispatchEvent(e, "pointerupoutside", t), s && this.dispatchEvent(e, "touchendoutside", t)), o && o.none && delete e.trackedPointers[n]
			}, r.prototype.onPointerMove = function (t) {
				if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
					var e = this.normalizeToPointerData(t);
					"mouse" !== e[0].pointerType && "pen" !== e[0].pointerType || (this.didMove = !0, this.cursor = null);
					for (var r = e.length, i = 0; i < r; i++) {
						var n = e[i],
							o = this.getInteractionDataForPointerId(n),
							s = this.configureInteractionEventForDOMEvent(this.eventData, n, o);
						s.data.originalEvent = t, this.processInteractive(s, this.renderer._lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", s), "touch" === n.pointerType && this.emit("touchmove", s), "mouse" !== n.pointerType && "pen" !== n.pointerType || this.emit("mousemove", s)
					}
					"mouse" === e[0].pointerType && this.setCursorMode(this.cursor)
				}
			}, r.prototype.processPointerMove = function (t, e, r) {
				var i = t.data,
					n = "touch" === i.pointerType,
					o = "mouse" === i.pointerType || "pen" === i.pointerType;
				o && this.processPointerOverOut(t, e, r), this.moveWhenInside && !r || (this.dispatchEvent(e, "pointermove", t), n && this.dispatchEvent(e, "touchmove", t), o && this.dispatchEvent(e, "mousemove", t))
			}, r.prototype.onPointerOut = function (t) {
				if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
					var e = this.normalizeToPointerData(t)[0];
					"mouse" === e.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null));
					var r = this.getInteractionDataForPointerId(e),
						i = this.configureInteractionEventForDOMEvent(this.eventData, e, r);
					i.data.originalEvent = e, this.processInteractive(i, this.renderer._lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", i), "mouse" === e.pointerType || "pen" === e.pointerType ? this.emit("mouseout", i) : this.releaseInteractionDataForPointerId(r.identifier)
				}
			}, r.prototype.processPointerOverOut = function (t, e, r) {
				var i = t.data,
					n = t.data.identifier,
					o = "mouse" === i.pointerType || "pen" === i.pointerType,
					s = e.trackedPointers[n];
				r && !s && (s = e.trackedPointers[n] = new cr(n)), void 0 !== s && (r && this.mouseOverRenderer ? (s.over || (s.over = !0, this.delayDispatchEvent(e, "pointerover", t), o && this.delayDispatchEvent(e, "mouseover", t)), o && null === this.cursor && (this.cursor = e.cursor)) : s.over && (s.over = !1, this.dispatchEvent(e, "pointerout", this.eventData), o && this.dispatchEvent(e, "mouseout", t), s.none && delete e.trackedPointers[n]))
			}, r.prototype.onPointerOver = function (t) {
				var e = this.normalizeToPointerData(t)[0],
					r = this.getInteractionDataForPointerId(e),
					i = this.configureInteractionEventForDOMEvent(this.eventData, e, r);
				i.data.originalEvent = e, "mouse" === e.pointerType && (this.mouseOverRenderer = !0), this.emit("pointerover", i), "mouse" !== e.pointerType && "pen" !== e.pointerType || this.emit("mouseover", i)
			}, r.prototype.getInteractionDataForPointerId = function (t) {
				var e, r = t.pointerId;
				return r === vr || "mouse" === t.pointerType ? e = this.mouse : this.activeInteractionData[r] ? e = this.activeInteractionData[r] : ((e = this.interactionDataPool.pop() || new hr).identifier = r, this.activeInteractionData[r] = e), e.copyEvent(t), e
			}, r.prototype.releaseInteractionDataForPointerId = function (t) {
				var e = this.activeInteractionData[t];
				e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e))
			}, r.prototype.configureInteractionEventForDOMEvent = function (t, e, r) {
				return t.data = r, this.mapPositionToPoint(r.global, e.clientX, e.clientY), "touch" === e.pointerType && (e.globalX = r.global.x, e.globalY = r.global.y), r.originalEvent = e, t.reset(), t
			}, r.prototype.normalizeToPointerData = function (t) {
				var e = [];
				if (this.supportsTouchEvents && t instanceof TouchEvent)
					for (var r = 0, i = t.changedTouches.length; r < i; r++) {
						var n = t.changedTouches[r];
						void 0 === n.button && (n.button = t.touches.length ? 1 : 0), void 0 === n.buttons && (n.buttons = t.touches.length ? 1 : 0), void 0 === n.isPrimary && (n.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === n.width && (n.width = n.radiusX || 1), void 0 === n.height && (n.height = n.radiusY || 1), void 0 === n.tiltX && (n.tiltX = 0), void 0 === n.tiltY && (n.tiltY = 0), void 0 === n.pointerType && (n.pointerType = "touch"), void 0 === n.pointerId && (n.pointerId = n.identifier || 0), void 0 === n.pressure && (n.pressure = n.force || .5), void 0 === n.twist && (n.twist = 0), void 0 === n.tangentialPressure && (n.tangentialPressure = 0), void 0 === n.layerX && (n.layerX = n.offsetX = n.clientX), void 0 === n.layerY && (n.layerY = n.offsetY = n.clientY), n.isNormalized = !0, e.push(n)
					} else !(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof window.PointerEvent ? e.push(t) : (void 0 === t.isPrimary && (t.isPrimary = !0), void 0 === t.width && (t.width = 1), void 0 === t.height && (t.height = 1), void 0 === t.tiltX && (t.tiltX = 0), void 0 === t.tiltY && (t.tiltY = 0), void 0 === t.pointerType && (t.pointerType = "mouse"), void 0 === t.pointerId && (t.pointerId = vr), void 0 === t.pressure && (t.pressure = .5), void 0 === t.twist && (t.twist = 0), void 0 === t.tangentialPressure && (t.tangentialPressure = 0), t.isNormalized = !0, e.push(t));
				return e
			}, r.prototype.destroy = function () {
				this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null
			}, Object.defineProperties(r.prototype, i), r
		}(R),
		yr = {
			InteractionData: hr,
			InteractionEvent: lr,
			InteractionManager: gr,
			InteractionTrackingData: cr,
			interactiveTarget: fr
		},
		_r = function () {
			function t(t) {
				this.items = [], this._name = t, this._aliasCount = 0
			}
			return t.prototype.emit = function (t, e, r, i, n, o, s, a) {
				if (arguments.length > 8) throw new Error("max arguments reached");
				var h = this.name,
					u = this.items;
				this._aliasCount++;
				for (var l = 0, c = u.length; l < c; l++) u[l][h](t, e, r, i, n, o, s, a);
				return u === this.items && this._aliasCount--, this
			}, t.prototype.ensureNonAliasedItems = function () {
				this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
			}, t.prototype.add = function (t) {
				return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
			}, t.prototype.remove = function (t) {
				var e = this.items.indexOf(t);
				return -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
			}, t.prototype.contains = function (t) {
				return -1 !== this.items.indexOf(t)
			}, t.prototype.removeAll = function () {
				return this.ensureNonAliasedItems(), this.items.length = 0, this
			}, t.prototype.destroy = function () {
				this.removeAll(), this.items = null, this._name = null
			}, Object.defineProperty(t.prototype, "empty", {
				get: function () {
					return 0 === this.items.length
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "name", {
				get: function () {
					return this._name
				},
				enumerable: !0,
				configurable: !0
			}), t
		}();
	Object.defineProperties(_r.prototype, {
		dispatch: {
			value: _r.prototype.emit
		},
		run: {
			value: _r.prototype.emit
		}
	});
	var xr = function (t, e) {
			void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new _r("setRealSize", 2), this.onUpdate = new _r("update"), this.onError = new _r("onError", 1)
		},
		br = {
			valid: {
				configurable: !0
			},
			width: {
				configurable: !0
			},
			height: {
				configurable: !0
			}
		};
	xr.prototype.bind = function (t) {
		this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.run(this._width, this._height)
	}, xr.prototype.unbind = function (t) {
		this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
	}, xr.prototype.resize = function (t, e) {
		t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.run(t, e))
	}, br.valid.get = function () {
		return !!this._width && !!this._height
	}, xr.prototype.update = function () {
		this.destroyed || this.onUpdate.run()
	}, xr.prototype.load = function () {
		return Promise.resolve()
	}, br.width.get = function () {
		return this._width
	}, br.height.get = function () {
		return this._height
	}, xr.prototype.upload = function (t, e, r) {
		return !1
	}, xr.prototype.style = function (t, e, r) {
		return !1
	}, xr.prototype.dispose = function () {}, xr.prototype.destroy = function () {
		this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
	}, Object.defineProperties(xr.prototype, br);
	var Er = function (e) {
			function r(t) {
				var r = t.naturalWidth || t.videoWidth || t.width,
					i = t.naturalHeight || t.videoHeight || t.height;
				e.call(this, r, i), this.source = t, this.noSubImage = !1
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.crossOrigin = function (t, e, r) {
				void 0 === r && 0 !== e.indexOf("data:") ? t.crossOrigin = Pe(e) : !1 !== r && (t.crossOrigin = "string" == typeof r ? r : "anonymous")
			}, r.prototype.upload = function (e, r, i, n) {
				var o = e.gl,
					s = r.realWidth,
					a = r.realHeight;
				return n = n || this.source, o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === t.ALPHA_MODES.UNPACK), this.noSubImage || r.target !== o.TEXTURE_2D || i.width !== s || i.height !== a ? (i.width = s, i.height = a, o.texImage2D(r.target, 0, r.format, r.format, r.type, n)) : o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, r.format, r.type, n), !0
			}, r.prototype.update = function () {
				if (!this.destroyed) {
					var t = this.source.naturalWidth || this.source.videoWidth || this.source.width,
						r = this.source.naturalHeight || this.source.videoHeight || this.source.height;
					this.resize(t, r), e.prototype.update.call(this)
				}
			}, r.prototype.dispose = function () {
				this.source = null
			}, r
		}(xr),
		Tr = function (e) {
			function r(t, r) {
				if (r = r || {}, !(t instanceof HTMLImageElement)) {
					var i = new Image;
					e.crossOrigin(i, t, r.crossorigin), i.src = t, t = i
				}
				e.call(this, t), !t.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = t.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (void 0 !== r.createBitmap ? r.createBitmap : M.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap, this.alphaMode = "number" == typeof r.alphaMode ? r.alphaMode : null, void 0 !== r.premultiplyAlpha && (this.premultiplyAlpha = r.premultiplyAlpha), this.bitmap = null, this._load = null, !1 !== r.autoLoad && this.load()
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.load = function (t) {
				var e = this;
				return this._load ? this._load : (void 0 !== t && (this.createBitmap = t), this._load = new Promise(function (t, r) {
					e.url = e.source.src;
					var i = e.source,
						n = function () {
							e.destroyed || (i.onload = null, i.onerror = null, e.resize(i.width, i.height), e._load = null, e.createBitmap ? t(e.process()) : t(e))
						};
					i.complete && i.src ? n() : (i.onload = n, i.onerror = function (t) {
						r(t), e.onError.emit(t)
					})
				}), this._load)
			}, r.prototype.process = function () {
				var e = this;
				return null !== this._process ? this._process : null === this.bitmap && window.createImageBitmap ? (this._process = window.createImageBitmap(this.source, 0, 0, this.source.width, this.source.height, {
					premultiplyAlpha: this.premultiplyAlpha === t.ALPHA_MODES.UNPACK ? "premultiply" : "none"
				}).then(function (t) {
					return e.destroyed ? Promise.reject() : (e.bitmap = t, e.update(), e._process = null, Promise.resolve(e))
				}), this._process) : Promise.resolve(this)
			}, r.prototype.upload = function (t, r, i) {
				if ("number" == typeof this.alphaMode && (r.alphaMode = this.alphaMode), !this.createBitmap) return e.prototype.upload.call(this, t, r, i);
				if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
				if (e.prototype.upload.call(this, t, r, i, this.bitmap), !this.preserveBitmap) {
					var n = !0;
					for (var o in r._glTextures) {
						var s = r._glTextures[o];
						if (s !== i && s.dirtyId !== r.dirtyId) {
							n = !1;
							break
						}
					}
					n && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
				}
				return !0
			}, r.prototype.dispose = function () {
				this.source.onload = null, this.source.onerror = null, e.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
			}, r
		}(Er),
		wr = [];

	function Sr(t, e) {
		if (!t) return null;
		var r = "";
		if ("string" == typeof t) {
			var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
			i && (r = i[1].toLowerCase())
		}
		for (var n = wr.length - 1; n >= 0; --n) {
			var o = wr[n];
			if (o.test && o.test(t, r)) return new o(t, e)
		}
		return new Tr(t, e)
	}
	var Ir = function (e) {
			function r(t, r) {
				var i = r || {},
					n = i.width,
					o = i.height;
				if (!n || !o) throw new Error("BufferResource width or height invalid");
				e.call(this, n, o), this.data = t
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.upload = function (e, r, i) {
				var n = e.gl;
				return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === t.ALPHA_MODES.UNPACK), i.width === r.width && i.height === r.height ? n.texSubImage2D(r.target, 0, 0, 0, r.width, r.height, r.format, r.type, this.data) : (i.width = r.width, i.height = r.height, n.texImage2D(r.target, 0, i.internalFormat, r.width, r.height, 0, r.format, i.type, this.data)), !0
			}, r.prototype.dispose = function () {
				this.data = null
			}, r.test = function (t) {
				return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
			}, r
		}(xr),
		Pr = {
			scaleMode: t.SCALE_MODES.NEAREST,
			format: t.FORMATS.RGBA,
			alphaMode: t.ALPHA_MODES.NPM
		},
		Ar = function (e) {
			function r(r, i) {
				void 0 === r && (r = null), void 0 === i && (i = null), e.call(this);
				var n = (i = i || {}).alphaMode,
					o = i.mipmap,
					s = i.anisotropicLevel,
					a = i.scaleMode,
					h = i.width,
					u = i.height,
					l = i.wrapMode,
					c = i.format,
					d = i.type,
					p = i.target,
					f = i.resolution,
					v = i.resourceOptions;
				!r || r instanceof xr || ((r = Sr(r, v)).internal = !0), this.width = h || 0, this.height = u || 0, this.resolution = f || M.RESOLUTION, this.mipmap = void 0 !== o ? o : M.MIPMAP_TEXTURES, this.anisotropicLevel = void 0 !== s ? s : M.ANISOTROPIC_LEVEL, this.wrapMode = l || M.WRAP_MODE, this.scaleMode = void 0 !== a ? a : M.SCALE_MODE, this.format = c || t.FORMATS.RGBA, this.type = d || t.TYPES.UNSIGNED_BYTE, this.target = p || t.TARGETS.TEXTURE_2D, this.alphaMode = void 0 !== n ? n : t.ALPHA_MODES.UNPACK, void 0 !== i.premultiplyAlpha && (this.premultiplyAlpha = i.premultiplyAlpha), this.uid = ge(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = h > 0 && u > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.setResource(r)
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				realWidth: {
					configurable: !0
				},
				realHeight: {
					configurable: !0
				}
			};
			return i.realWidth.get = function () {
				return Math.ceil(this.width * this.resolution - 1e-4)
			}, i.realHeight.get = function () {
				return Math.ceil(this.height * this.resolution - 1e-4)
			}, r.prototype.setStyle = function (t, e) {
				var r;
				return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, r = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, r = !0), r && this.dirtyStyleId++, this
			}, r.prototype.setSize = function (t, e, r) {
				return this.resolution = r || this.resolution, this.width = t, this.height = e, this._refreshPOT(), this.update(), this
			}, r.prototype.setRealSize = function (t, e, r) {
				return this.resolution = r || this.resolution, this.width = t / this.resolution, this.height = e / this.resolution, this._refreshPOT(), this.update(), this
			}, r.prototype._refreshPOT = function () {
				this.isPowerOfTwo = de(this.realWidth) && de(this.realHeight)
			}, r.prototype.setResolution = function (t) {
				var e = this.resolution;
				return e === t ? this : (this.resolution = t, this.valid && (this.width = this.width * e / t, this.height = this.height * e / t, this.emit("update", this)), this._refreshPOT(), this)
			}, r.prototype.setResource = function (t) {
				if (this.resource === t) return this;
				if (this.resource) throw new Error("Resource can be set only once");
				return t.bind(this), this.resource = t, this
			}, r.prototype.update = function () {
				this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
			}, r.prototype.onError = function (t) {
				this.emit("error", this, t)
			}, r.prototype.destroy = function () {
				this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Ee[this.cacheId], delete be[this.cacheId], this.cacheId = null), this.dispose(), r.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
			}, r.prototype.dispose = function () {
				this.emit("dispose", this)
			}, r.from = function (t, e, i) {
				void 0 === i && (i = M.STRICT_TEXTURE_CACHE);
				var n = "string" == typeof t,
					o = null;
				n ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + ge()), o = t._pixiId);
				var s = Ee[o];
				if (n && i && !s) throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.');
				return s || ((s = new r(t, e)).cacheId = o, r.addToCache(s, o)), s
			}, r.fromBuffer = function (e, i, n, o) {
				e = e || new Float32Array(i * n * 4);
				var s = new Ir(e, {
						width: i,
						height: n
					}),
					a = e instanceof Float32Array ? t.TYPES.FLOAT : t.TYPES.UNSIGNED_BYTE;
				return new r(s, Object.assign(Pr, o || {
					width: i,
					height: n,
					type: a
				}))
			}, r.addToCache = function (t, e) {
				e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), Ee[e] && console.warn("BaseTexture added to the cache with an id [" + e + "] that already had an entry"), Ee[e] = t)
			}, r.removeFromCache = function (t) {
				if ("string" == typeof t) {
					var e = Ee[t];
					if (e) {
						var r = e.textureCacheIds.indexOf(t);
						return r > -1 && e.textureCacheIds.splice(r, 1), delete Ee[t], e
					}
				} else if (t && t.textureCacheIds) {
					for (var i = 0; i < t.textureCacheIds.length; ++i) delete Ee[t.textureCacheIds[i]];
					return t.textureCacheIds.length = 0, t
				}
				return null
			}, Object.defineProperties(r.prototype, i), r
		}(R);
	Ar._globalBatch = 0;
	var Or = function (e) {
			function r(t, r) {
				var i;
				r = r || {};
				var n = t;
				Array.isArray(t) && (i = t, n = t.length), e.call(this, r.width, r.height), this.items = [], this.itemDirtyIds = [];
				for (var o = 0; o < n; o++) {
					var s = new Ar;
					this.items.push(s), this.itemDirtyIds.push(-1)
				}
				if (this.length = n, this._load = null, i)
					for (var a = 0; a < n; a++) this.addResourceAt(Sr(i[a], r), a)
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.dispose = function () {
				for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
				this.items = null, this.itemDirtyIds = null, this._load = null
			}, r.prototype.addResourceAt = function (t, e) {
				if (!this.items[e]) throw new Error("Index " + e + " is out of bounds");
				return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
			}, r.prototype.bind = function (r) {
				e.prototype.bind.call(this, r), r.target = t.TARGETS.TEXTURE_2D_ARRAY;
				for (var i = 0; i < this.length; i++) this.items[i].on("update", r.update, r)
			}, r.prototype.unbind = function (t) {
				e.prototype.unbind.call(this, t);
				for (var r = 0; r < this.length; r++) this.items[r].off("update", t.update, t)
			}, r.prototype.load = function () {
				var t = this;
				if (this._load) return this._load;
				var e = this.items.map(function (t) {
						return t.resource
					}),
					r = e.map(function (t) {
						return t.load()
					});
				return this._load = Promise.all(r).then(function () {
					var r = e[0],
						i = r.width,
						n = r.height;
					return t.resize(i, n), Promise.resolve(t)
				}), this._load
			}, r.prototype.upload = function (t, e, r) {
				var i = this.length,
					n = this.itemDirtyIds,
					o = this.items,
					s = t.gl;
				r.dirtyId < 0 && s.texImage3D(s.TEXTURE_2D_ARRAY, 0, e.format, this._width, this._height, i, 0, e.format, e.type, null);
				for (var a = 0; a < i; a++) {
					var h = o[a];
					n[a] < h.dirtyId && (n[a] = h.dirtyId, h.valid && s.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, a, h.resource.width, h.resource.height, 1, e.format, e.type, h.resource.source))
				}
				return !0
			}, r
		}(xr),
		Dr = function (t) {
			function e() {
				t.apply(this, arguments)
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.test = function (t) {
				var e = window.OffscreenCanvas;
				return !!(e && t instanceof e) || t instanceof HTMLCanvasElement
			}, e
		}(Er),
		Cr = function (e) {
			function r(i, n) {
				if (n = n || {}, e.call(this, i, n), this.length !== r.SIDES) throw new Error("Invalid length. Got " + this.length + ", expected 6");
				for (var o = 0; o < r.SIDES; o++) this.items[o].target = t.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + o;
				!1 !== n.autoLoad && this.load()
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.bind = function (r) {
				e.prototype.bind.call(this, r), r.target = t.TARGETS.TEXTURE_CUBE_MAP
			}, r.prototype.upload = function (t, e, i) {
				for (var n = this.itemDirtyIds, o = 0; o < r.SIDES; o++) {
					var s = this.items[o];
					n[o] < s.dirtyId && (n[o] = s.dirtyId, s.valid && s.resource.upload(t, s, i))
				}
				return !0
			}, r
		}(Or);
	Cr.SIDES = 6;
	var Mr = function (t) {
		function e(e, r) {
			r = r || {}, t.call(this, document.createElement("canvas")), this._width = 0, this._height = 0, this.svg = e, this.scale = r.scale || 1, this._overrideWidth = r.width, this._overrideHeight = r.height, this._resolve = null, this._crossorigin = r.crossorigin, this._load = null, !1 !== r.autoLoad && this.load()
		}
		return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.load = function () {
			var t = this;
			return this._load ? this._load : (this._load = new Promise(function (e) {
				if (t._resolve = function () {
						t.resize(t.source.width, t.source.height), e(t)
					}, /^\<svg/.test(t.svg.trim())) {
					if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
					t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg)))
				}
				t._loadSvg()
			}), this._load)
		}, e.prototype._loadSvg = function () {
			var e = this,
				r = new Image;
			t.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function (t) {
				e._resolve && (r.onerror = null, e.onError.run(t))
			}, r.onload = function () {
				if (e._resolve) {
					var t = r.width,
						i = r.height;
					if (!t || !i) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
					var n = t * e.scale,
						o = i * e.scale;
					(e._overrideWidth || e._overrideHeight) && (n = e._overrideWidth || e._overrideHeight / i * t, o = e._overrideHeight || e._overrideWidth / t * i), n = Math.round(n), o = Math.round(o);
					var s = e.source;
					s.width = n, s.height = o, s._pixiId = "canvas_" + ge(), s.getContext("2d").drawImage(r, 0, 0, t, i, 0, 0, n, o), e._resolve(), e._resolve = null
				}
			}
		}, e.getSize = function (t) {
			var r = e.SVG_SIZE.exec(t),
				i = {};
			return r && (i[r[1]] = Math.round(parseFloat(r[3])), i[r[5]] = Math.round(parseFloat(r[7]))), i
		}, e.prototype.dispose = function () {
			t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null
		}, e.test = function (t, e) {
			return "svg" === e || "string" == typeof t && 0 === t.indexOf("data:image/svg+xml;base64") || "string" == typeof t && 0 === t.indexOf("<svg")
		}, e
	}(Er);
	Mr.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
	var Rr = function (t) {
		function e(e, r) {
			if (r = r || {}, !(e instanceof HTMLVideoElement)) {
				var i = document.createElement("video");
				i.setAttribute("preload", "auto"), i.setAttribute("webkit-playsinline", ""), i.setAttribute("playsinline", ""), "string" == typeof e && (e = [e]), t.crossOrigin(i, e[0].src || e[0], r.crossorigin);
				for (var n = 0; n < e.length; ++n) {
					var o = document.createElement("source"),
						s = e[n],
						a = s.src,
						h = s.mime,
						u = (a = a || e[n]).split("?").shift().toLowerCase(),
						l = u.substr(u.lastIndexOf(".") + 1);
					h = h || "video/" + l, o.src = a, o.type = h, i.appendChild(o)
				}
				e = i
			}
			t.call(this, e), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = r.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = !1 !== r.autoPlay, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), !1 !== r.autoLoad && this.load()
		}
		t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
		var r = {
			autoUpdate: {
				configurable: !0
			},
			updateFPS: {
				configurable: !0
			}
		};
		return e.prototype.update = function (e) {
			if (void 0 === e && (e = 0), !this.destroyed) {
				var r = sr.shared.elapsedMS * this.source.playbackRate;
				this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this, e), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
			}
		}, e.prototype.load = function () {
			var t = this;
			if (this._load) return this._load;
			var e = this.source;
			return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise(function (r) {
				t.valid ? r(t) : (t._resolve = r, e.load())
			}), this._load
		}, e.prototype._onError = function () {
			this.source.removeEventListener("error", this._onError, !0), this.onError.run(event)
		}, e.prototype._isSourcePlaying = function () {
			var t = this.source;
			return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2
		}, e.prototype._isSourceReady = function () {
			return 3 === this.source.readyState || 4 === this.source.readyState
		}, e.prototype._onPlayStart = function () {
			this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (sr.shared.add(this.update, this), this._isConnectedToTicker = !0)
		}, e.prototype._onPlayStop = function () {
			this._isConnectedToTicker && (sr.shared.remove(this.update, this), this._isConnectedToTicker = !1)
		}, e.prototype._onCanPlay = function () {
			var t = this.source;
			t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
			var e = this.valid;
			this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
		}, e.prototype.dispose = function () {
			this._isConnectedToTicker && sr.shared.remove(this.update, this), this.source && (this.source.removeEventListener("error", this._onError, !0), this.source.pause(), this.source.src = "", this.source.load()), t.prototype.dispose.call(this)
		}, r.autoUpdate.get = function () {
			return this._autoUpdate
		}, r.autoUpdate.set = function (t) {
			t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (sr.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (sr.shared.add(this.update, this), this._isConnectedToTicker = !0))
		}, r.updateFPS.get = function () {
			return this._updateFPS
		}, r.updateFPS.set = function (t) {
			t !== this._updateFPS && (this._updateFPS = t)
		}, e.test = function (t, r) {
			return t instanceof HTMLVideoElement || e.TYPES.indexOf(r) > -1
		}, Object.defineProperties(e.prototype, r), e
	}(Er);
	Rr.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
	var Lr = function (t) {
		function e() {
			t.apply(this, arguments)
		}
		return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.test = function (t) {
			return !!window.createImageBitmap && t instanceof ImageBitmap
		}, e
	}(Er);
	wr.push(Tr, Lr, Dr, Rr, Mr, Ir, Cr, Or);
	var Nr = {
			INSTALLED: wr,
			autoDetectResource: Sr,
			ArrayResource: Or,
			BufferResource: Ir,
			CanvasResource: Dr,
			CubeResource: Cr,
			ImageResource: Tr,
			ImageBitmapResource: Lr,
			SVGResource: Mr,
			VideoResource: Rr,
			Resource: xr,
			BaseImageResource: Er
		},
		Fr = function (t) {
			this.renderer = t
		};
	Fr.prototype.destroy = function () {
		this.renderer = null
	};
	var Br = function (e) {
			function r() {
				e.apply(this, arguments)
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.upload = function (e, r, i) {
				var n = e.gl;
				return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === t.ALPHA_MODES.UNPACK), i.width === r.width && i.height === r.height ? n.texSubImage2D(r.target, 0, 0, 0, r.width, r.height, r.format, r.type, this.data) : (i.width = r.width, i.height = r.height, n.texImage2D(r.target, 0, 1 === e.context.webGLVersion ? n.DEPTH_COMPONENT : n.DEPTH_COMPONENT16, r.width, r.height, 0, r.format, r.type, this.data)), !0
			}, r
		}(Ir),
		Ur = function (t, e) {
			this.width = Math.ceil(t || 100), this.height = Math.ceil(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new _r("disposeFramebuffer", 2)
		},
		kr = {
			colorTexture: {
				configurable: !0
			}
		};
	kr.colorTexture.get = function () {
		return this.colorTextures[0]
	}, Ur.prototype.addColorTexture = function (e, r) {
		return void 0 === e && (e = 0), this.colorTextures[e] = r || new Ar(null, {
			scaleMode: t.SCALE_MODES.NEAREST,
			resolution: 1,
			mipmap: !1,
			width: this.width,
			height: this.height
		}), this.dirtyId++, this.dirtyFormat++, this
	}, Ur.prototype.addDepthTexture = function (e) {
		return this.depthTexture = e || new Ar(new Br(null, {
			width: this.width,
			height: this.height
		}), {
			scaleMode: t.SCALE_MODES.NEAREST,
			resolution: 1,
			width: this.width,
			height: this.height,
			mipmap: !1,
			format: t.FORMATS.DEPTH_COMPONENT,
			type: t.TYPES.UNSIGNED_SHORT
		}), this.dirtyId++, this.dirtyFormat++, this
	}, Ur.prototype.enableDepth = function () {
		return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
	}, Ur.prototype.enableStencil = function () {
		return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
	}, Ur.prototype.resize = function (t, e) {
		if (t = Math.ceil(t), e = Math.ceil(e), t !== this.width || e !== this.height) {
			this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
			for (var r = 0; r < this.colorTextures.length; r++) {
				var i = this.colorTextures[r],
					n = i.resolution;
				i.setSize(t / n, e / n)
			}
			if (this.depthTexture) {
				var o = this.depthTexture.resolution;
				this.depthTexture.setSize(t / o, e / o)
			}
		}
	}, Ur.prototype.dispose = function () {
		this.disposeRunner.run(this, !1)
	}, Object.defineProperties(Ur.prototype, kr);
	var Xr = function (t) {
			function e(e) {
				"number" == typeof e && (e = {
					width: arguments[0],
					height: arguments[1],
					scaleMode: arguments[2],
					resolution: arguments[3]
				});
				t.call(this, null, e);
				var r = e || {},
					i = r.width,
					n = r.height;
				this.mipmap = !1, this.width = Math.ceil(i) || 100, this.height = Math.ceil(n) || 100, this.valid = !0, this._canvasRenderTarget = null, this.clearColor = [0, 0, 0, 0], this.framebuffer = new Ur(this.width * this.resolution, this.height * this.resolution).addColorTexture(0, this), this.maskStack = [], this.filterStack = [{}]
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.resize = function (t, e) {
				t = Math.ceil(t), e = Math.ceil(e), this.framebuffer.resize(t * this.resolution, e * this.resolution)
			}, e.prototype.dispose = function () {
				this.framebuffer.dispose(), t.prototype.dispose.call(this)
			}, e.prototype.destroy = function () {
				t.prototype.destroy.call(this, !0), this.framebuffer = null
			}, e
		}(Ar),
		jr = function () {
			this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
		};
	jr.prototype.set = function (t, e, r) {
		var i = e.width,
			n = e.height;
		if (r) {
			var o = t.width / 2 / i,
				s = t.height / 2 / n,
				a = t.x / i + o,
				h = t.y / n + s;
			r = Ye.add(r, Ye.NW), this.x0 = a + o * Ye.uX(r), this.y0 = h + s * Ye.uY(r), r = Ye.add(r, 2), this.x1 = a + o * Ye.uX(r), this.y1 = h + s * Ye.uY(r), r = Ye.add(r, 2), this.x2 = a + o * Ye.uX(r), this.y2 = h + s * Ye.uY(r), r = Ye.add(r, 2), this.x3 = a + o * Ye.uX(r), this.y3 = h + s * Ye.uY(r)
		} else this.x0 = t.x / i, this.y0 = t.y / n, this.x1 = (t.x + t.width) / i, this.y1 = t.y / n, this.x2 = (t.x + t.width) / i, this.y2 = (t.y + t.height) / n, this.x3 = t.x / i, this.y3 = (t.y + t.height) / n;
		this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
	};
	var Hr = new jr,
		Gr = function (t) {
			function e(r, i, n, o, s, a) {
				if (t.call(this), this.noFrame = !1, i || (this.noFrame = !0, i = new ze(0, 0, 1, 1)), r instanceof e && (r = r.baseTexture), this.baseTexture = r, this._frame = i, this.trim = o, this.valid = !1, this.requiresUpdate = !1, this._uvs = Hr, this.uvMatrix = null, this.orig = n || i, this._rotate = Number(s || 0), !0 === s) this._rotate = 2;
				else if (this._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
				this.defaultAnchor = a ? new Ce(a.x, a.y) : new Ce(0, 0), this._updateID = 0, this.textureCacheIds = [], r.valid ? this.noFrame ? r.valid && this.onBaseTextureUpdated(r) : this.frame = i : r.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && r.on("update", this.onBaseTextureUpdated, this)
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				resolution: {
					configurable: !0
				},
				frame: {
					configurable: !0
				},
				rotate: {
					configurable: !0
				},
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				}
			};
			return e.prototype.update = function () {
				this.baseTexture.resource && this.baseTexture.resource.update()
			}, e.prototype.onBaseTextureUpdated = function (t) {
				if (this.noFrame) {
					if (!this.baseTexture.valid) return;
					this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
				} else this.frame = this._frame;
				this.emit("update", this)
			}, e.prototype.destroy = function (t) {
				if (this.baseTexture) {
					if (t) {
						var r = this.baseTexture.resource;
						r && be[r.url] && e.removeFromCache(r.url), this.baseTexture.destroy()
					}
					this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
				}
				this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null
			}, e.prototype.clone = function () {
				return new e(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor)
			}, e.prototype.updateUvs = function () {
				this._uvs === Hr && (this._uvs = new jr), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
			}, e.from = function (t, r, i) {
				void 0 === r && (r = {}), void 0 === i && (i = M.STRICT_TEXTURE_CACHE);
				var n = "string" == typeof t,
					o = null;
				n ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + ge()), o = t._pixiId);
				var s = be[o];
				if (n && i && !s) throw new Error('The cacheId "' + o + '" does not exist in TextureCache.');
				return s || (r.resolution || (r.resolution = Ae(t)), (s = new e(new Ar(t, r))).baseTexture.cacheId = o, Ar.addToCache(s.baseTexture, o), e.addToCache(s, o)), s
			}, e.fromBuffer = function (t, r, i, n) {
				return new e(Ar.fromBuffer(t, r, i, n))
			}, e.fromLoader = function (t, r, i) {
				var n = new Tr(t);
				n.url = r;
				var o = new e(new Ar(n, {
					scaleMode: M.SCALE_MODE,
					resolution: Ae(r)
				}));
				return i || (i = r), Ar.addToCache(o.baseTexture, i), e.addToCache(o, i), i !== r && (Ar.addToCache(o.baseTexture, r), e.addToCache(o, r)), o
			}, e.addToCache = function (t, e) {
				e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), be[e] && console.warn("Texture added to the cache with an id [" + e + "] that already had an entry"), be[e] = t)
			}, e.removeFromCache = function (t) {
				if ("string" == typeof t) {
					var e = be[t];
					if (e) {
						var r = e.textureCacheIds.indexOf(t);
						return r > -1 && e.textureCacheIds.splice(r, 1), delete be[t], e
					}
				} else if (t && t.textureCacheIds) {
					for (var i = 0; i < t.textureCacheIds.length; ++i) be[t.textureCacheIds[i]] === t && delete be[t.textureCacheIds[i]];
					return t.textureCacheIds.length = 0, t
				}
				return null
			}, r.resolution.get = function () {
				return this.baseTexture.resolution
			}, r.frame.get = function () {
				return this._frame
			}, r.frame.set = function (t) {
				this._frame = t, this.noFrame = !1;
				var e = t.x,
					r = t.y,
					i = t.width,
					n = t.height,
					o = e + i > this.baseTexture.width,
					s = r + n > this.baseTexture.height;
				if (o || s) {
					var a = o && s ? "and" : "or",
						h = "X: " + e + " + " + i + " = " + (e + i) + " > " + this.baseTexture.width,
						u = "Y: " + r + " + " + n + " = " + (r + n) + " > " + this.baseTexture.height;
					throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + h + " " + a + " " + u)
				}
				this.valid = i && n && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs()
			}, r.rotate.get = function () {
				return this._rotate
			}, r.rotate.set = function (t) {
				this._rotate = t, this.valid && this.updateUvs()
			}, r.width.get = function () {
				return this.orig.width
			}, r.height.get = function () {
				return this.orig.height
			}, Object.defineProperties(e.prototype, r), e
		}(R);

	function Yr(t) {
		t.destroy = function () {}, t.on = function () {}, t.once = function () {}, t.emit = function () {}
	}
	Gr.EMPTY = new Gr(new Ar), Yr(Gr.EMPTY), Yr(Gr.EMPTY.baseTexture), Gr.WHITE = function () {
		var t = document.createElement("canvas");
		t.width = 16, t.height = 16;
		var e = t.getContext("2d");
		return e.fillStyle = "white", e.fillRect(0, 0, 16, 16), new Gr(new Ar(new Dr(t)))
	}(), Yr(Gr.WHITE), Yr(Gr.WHITE.baseTexture);
	var Vr = function (t) {
			function e(e, r) {
				var i = null;
				if (!(e instanceof Xr)) {
					var n = arguments[1],
						o = arguments[2],
						s = arguments[3],
						a = arguments[4];
					console.warn("Please use RenderTexture.create(" + n + ", " + o + ") instead of the ctor directly."), i = arguments[0], r = null, e = new Xr({
						width: n,
						height: o,
						scaleMode: s,
						resolution: a
					})
				}
				t.call(this, e, r), this.legacyRenderer = i, this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs()
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.resize = function (t, e, r) {
				void 0 === r && (r = !0), t = Math.ceil(t), e = Math.ceil(e), this.valid = t > 0 && e > 0, this._frame.width = this.orig.width = t, this._frame.height = this.orig.height = e, r && this.baseTexture.resize(t, e), this.updateUvs()
			}, e.prototype.setResolution = function (t) {
				var e = this.baseTexture;
				e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
			}, e.create = function (t) {
				return "number" == typeof t && (t = {
					width: t,
					height: arguments[1],
					scaleMode: arguments[2],
					resolution: arguments[3]
				}), new e(new Xr(t))
			}, e
		}(Gr),
		zr = function (t) {
			this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
		};
	zr.prototype.createTexture = function (t, e) {
		var r = new Xr(Object.assign({
			width: t,
			height: e,
			resolution: 1
		}, this.textureOptions));
		return new Vr(r)
	}, zr.prototype.getOptimalTexture = function (t, e, r) {
		void 0 === r && (r = 1);
		var i = zr.SCREEN_KEY;
		t *= r, e *= r, this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight || (i = (65535 & (t = ce(t))) << 16 | 65535 & (e = ce(e))), this.texturePool[i] || (this.texturePool[i] = []);
		var n = this.texturePool[i].pop();
		return n || (n = this.createTexture(t, e)), n.filterPoolKey = i, n.setResolution(r), n
	}, zr.prototype.getFilterTexture = function (t, e) {
		var r = this.getOptimalTexture(t.width, t.height, e || t.resolution);
		return r.filterFrame = t.filterFrame, r
	}, zr.prototype.returnTexture = function (t) {
		var e = t.filterPoolKey;
		t.filterFrame = null, this.texturePool[e].push(t)
	}, zr.prototype.returnFilterTexture = function (t) {
		this.returnTexture(t)
	}, zr.prototype.clear = function (t) {
		if (t = !1 !== t)
			for (var e in this.texturePool) {
				var r = this.texturePool[e];
				if (r)
					for (var i = 0; i < r.length; i++) r[i].destroy(!0)
			}
		this.texturePool = {}
	}, zr.prototype.setScreenSize = function (t) {
		if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) {
			var e = zr.SCREEN_KEY,
				r = this.texturePool[e];
			if (this.enableFullScreen = t.width > 0 && t.height > 0, r)
				for (var i = 0; i < r.length; i++) r[i].destroy(!0);
			this.texturePool[e] = [], this._pixelsWidth = t.width, this._pixelsHeight = t.height
		}
	}, zr.SCREEN_KEY = "screen";
	var Wr = function (t, e, r, i, n, o, s) {
		void 0 === r && (r = !1), void 0 === i && (i = 5126), this.buffer = t, this.size = e, this.normalized = r, this.type = i, this.stride = n, this.start = o, this.instance = s
	};
	Wr.prototype.destroy = function () {
		this.buffer = null
	}, Wr.from = function (t, e, r, i, n) {
		return new Wr(t, e, r, i, n)
	};
	var qr = 0,
		Kr = function (t, e, r) {
			void 0 === e && (e = !0), void 0 === r && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = qr++, this.disposeRunner = new _r("disposeBuffer", 2)
		};

	function Zr(t) {
		if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
		if (2 === t.BYTES_PER_ELEMENT) {
			if (t instanceof Uint16Array) return "Uint16Array"
		} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
		return null
	}
	Kr.prototype.update = function (t) {
		this.data = t || this.data, this._updateID++
	}, Kr.prototype.dispose = function () {
		this.disposeRunner.run(this, !1)
	}, Kr.prototype.destroy = function () {
		this.dispose(), this.data = null
	}, Kr.from = function (t) {
		return t instanceof Array && (t = new Float32Array(t)), new Kr(t)
	};
	var Jr = {
		Float32Array: Float32Array,
		Uint32Array: Uint32Array,
		Int32Array: Int32Array,
		Uint8Array: Uint8Array
	};
	var Qr = {
			5126: 4,
			5123: 2,
			5121: 1
		},
		$r = 0,
		ti = {
			Float32Array: Float32Array,
			Uint32Array: Uint32Array,
			Int32Array: Int32Array,
			Uint8Array: Uint8Array,
			Uint16Array: Uint16Array
		},
		ei = function (t, e) {
			void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = $r++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new _r("disposeGeometry", 2), this.refCount = 0
		};
	ei.prototype.addAttribute = function (t, e, r, i, n, o, s, a) {
		if (void 0 === i && (i = !1), void 0 === a && (a = !1), !e) throw new Error("You must pass a buffer when creating an attribute");
		e.data || (e instanceof Array && (e = new Float32Array(e)), e = new Kr(e));
		var h = t.split("|");
		if (h.length > 1) {
			for (var u = 0; u < h.length; u++) this.addAttribute(h[u], e, r, i, n);
			return this
		}
		var l = this.buffers.indexOf(e);
		return -1 === l && (this.buffers.push(e), l = this.buffers.length - 1), this.attributes[t] = new Wr(l, r, i, n, o, s, a), this.instanced = this.instanced || a, this
	}, ei.prototype.getAttribute = function (t) {
		return this.attributes[t]
	}, ei.prototype.getBuffer = function (t) {
		return this.buffers[this.getAttribute(t).buffer]
	}, ei.prototype.addIndex = function (t) {
		return t.data || (t instanceof Array && (t = new Uint16Array(t)), t = new Kr(t)), t.index = !0, this.indexBuffer = t, -1 === this.buffers.indexOf(t) && this.buffers.push(t), this
	}, ei.prototype.getIndex = function () {
		return this.indexBuffer
	}, ei.prototype.interleave = function () {
		if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
		var t, e = [],
			r = [],
			i = new Kr;
		for (t in this.attributes) {
			var n = this.attributes[t],
				o = this.buffers[n.buffer];
			e.push(o.data), r.push(n.size * Qr[n.type] / 4), n.buffer = 0
		}
		for (i.data = function (t, e) {
				for (var r = 0, i = 0, n = {}, o = 0; o < t.length; o++) i += e[o], r += t[o].length;
				for (var s = new ArrayBuffer(4 * r), a = null, h = 0, u = 0; u < t.length; u++) {
					var l = e[u],
						c = t[u],
						d = Zr(c);
					n[d] || (n[d] = new Jr[d](s)), a = n[d];
					for (var p = 0; p < c.length; p++) a[(p / l | 0) * i + h + p % l] = c[p];
					h += l
				}
				return new Float32Array(s)
			}(e, r), t = 0; t < this.buffers.length; t++) this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
		return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this
	}, ei.prototype.getSize = function () {
		for (var t in this.attributes) {
			var e = this.attributes[t];
			return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
		}
		return 0
	}, ei.prototype.dispose = function () {
		this.disposeRunner.run(this, !1)
	}, ei.prototype.destroy = function () {
		this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
	}, ei.prototype.clone = function () {
		for (var t = new ei, e = 0; e < this.buffers.length; e++) t.buffers[e] = new Kr(this.buffers[e].data.slice());
		for (var r in this.attributes) {
			var i = this.attributes[r];
			t.attributes[r] = new Wr(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance)
		}
		return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.index = !0), t
	}, ei.merge = function (t) {
		for (var e, r = new ei, i = [], n = [], o = [], s = 0; s < t.length; s++) {
			e = t[s];
			for (var a = 0; a < e.buffers.length; a++) n[a] = n[a] || 0, n[a] += e.buffers[a].data.length, o[a] = 0
		}
		for (var h = 0; h < e.buffers.length; h++) i[h] = new(ti[Zr(e.buffers[h].data)])(n[h]), r.buffers[h] = new Kr(i[h]);
		for (var u = 0; u < t.length; u++) {
			e = t[u];
			for (var l = 0; l < e.buffers.length; l++) i[l].set(e.buffers[l].data, o[l]), o[l] += e.buffers[l].data.length
		}
		if (r.attributes = e.attributes, e.indexBuffer) {
			r.indexBuffer = r.buffers[e.buffers.indexOf(e.indexBuffer)], r.indexBuffer.index = !0;
			for (var c = 0, d = 0, p = 0, f = 0, v = 0; v < e.buffers.length; v++)
				if (e.buffers[v] !== e.indexBuffer) {
					f = v;
					break
				} for (var m in e.attributes) {
				var g = e.attributes[m];
				(0 | g.buffer) === f && (d += g.size * Qr[g.type] / 4)
			}
			for (var y = 0; y < t.length; y++) {
				for (var _ = t[y].indexBuffer.data, x = 0; x < _.length; x++) r.indexBuffer.data[x + p] += c;
				c += e.buffers[f].data.length / d, p += _.length
			}
		}
		return r
	};
	var ri = function (t) {
			function e() {
				t.call(this), this.addAttribute("aVertexPosition", [0, 0, 1, 0, 1, 1, 0, 1]).addIndex([0, 1, 3, 2])
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
		}(ei),
		ii = function (t) {
			function e() {
				t.call(this), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new Kr(this.vertices), this.uvBuffer = new Kr(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.map = function (t, e) {
				var r = 0,
					i = 0;
				return this.uvs[0] = r, this.uvs[1] = i, this.uvs[2] = r + e.width / t.width, this.uvs[3] = i, this.uvs[4] = r + e.width / t.width, this.uvs[5] = i + e.height / t.height, this.uvs[6] = r, this.uvs[7] = i + e.height / t.height, r = e.x, i = e.y, this.vertices[0] = r, this.vertices[1] = i, this.vertices[2] = r + e.width, this.vertices[3] = i, this.vertices[4] = r + e.width, this.vertices[5] = i + e.height, this.vertices[6] = r, this.vertices[7] = i + e.height, this.invalidate(), this
			}, e.prototype.invalidate = function () {
				return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
			}, e
		}(ei),
		ni = 0,
		oi = function (t, e) {
			this.uniforms = t, this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = ni++, this.static = !!e
		};
	oi.prototype.update = function () {
		this.dirtyId++
	}, oi.prototype.add = function (t, e, r) {
		this.uniforms[t] = new oi(e, r)
	}, oi.from = function (t, e) {
		return new oi(t, e)
	};
	var si = function () {
		this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.sourceFrame = new ze, this.destinationFrame = new ze, this.filters = []
	};
	si.prototype.clear = function () {
		this.target = null, this.filters = null, this.renderTexture = null
	};
	var ai = function (e) {
			function r(t) {
				e.call(this, t), this.defaultFilterStack = [{}], this.texturePool = new zr, this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new ri, this.quadUv = new ii, this.tempRect = new ze, this.activeState = {}, this.globalUniforms = new oi({
					outputFrame: this.tempRect,
					inputSize: new Float32Array(4),
					inputPixel: new Float32Array(4),
					inputClamp: new Float32Array(4),
					resolution: 1,
					filterArea: new Float32Array(4),
					filterClamp: new Float32Array(4)
				}, !0), this.forceClear = !1, this.useMaxPadding = !1
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.push = function (t, e) {
				for (var r = this.renderer, i = this.defaultFilterStack, n = this.statePool.pop() || new si, o = e[0].resolution, s = e[0].padding, a = e[0].autoFit, h = e[0].legacy, u = 1; u < e.length; u++) {
					var l = e[u];
					o = Math.min(o, l.resolution), s = this.useMaxPadding ? Math.max(s, l.padding) : s + l.padding, a = a || l.autoFit, h = h || l.legacy
				}
				1 === i.length && (this.defaultFilterStack[0].renderTexture = r.renderTexture.current), i.push(n), n.resolution = o, n.legacy = h, n.target = t, n.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), n.sourceFrame.pad(s), a && n.sourceFrame.fit(this.renderer.renderTexture.sourceFrame), n.sourceFrame.ceil(o), n.renderTexture = this.getOptimalFilterTexture(n.sourceFrame.width, n.sourceFrame.height, o), n.filters = e, n.destinationFrame.width = n.renderTexture.width, n.destinationFrame.height = n.renderTexture.height, n.renderTexture.filterFrame = n.sourceFrame, r.renderTexture.bind(n.renderTexture, n.sourceFrame), r.renderTexture.clear()
			}, r.prototype.pop = function () {
				var t = this.defaultFilterStack,
					e = t.pop(),
					r = e.filters;
				this.activeState = e;
				var i = this.globalUniforms.uniforms;
				i.outputFrame = e.sourceFrame, i.resolution = e.resolution;
				var n = i.inputSize,
					o = i.inputPixel,
					s = i.inputClamp;
				if (n[0] = e.destinationFrame.width, n[1] = e.destinationFrame.height, n[2] = 1 / n[0], n[3] = 1 / n[1], o[0] = n[0] * e.resolution, o[1] = n[1] * e.resolution, o[2] = 1 / o[0], o[3] = 1 / o[1], s[0] = .5 * o[2], s[1] = .5 * o[3], s[2] = e.sourceFrame.width * n[2] - .5 * o[2], s[3] = e.sourceFrame.height * n[3] - .5 * o[3], e.legacy) {
					var a = i.filterArea;
					a[0] = e.destinationFrame.width, a[1] = e.destinationFrame.height, a[2] = e.sourceFrame.x, a[3] = e.sourceFrame.y, i.filterClamp = i.inputClamp
				}
				this.globalUniforms.update();
				var h = t[t.length - 1];
				if (1 === r.length) r[0].apply(this, e.renderTexture, h.renderTexture, !1, e), this.returnFilterTexture(e.renderTexture);
				else {
					var u = e.renderTexture,
						l = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
					l.filterFrame = u.filterFrame;
					var c = 0;
					for (c = 0; c < r.length - 1; ++c) {
						r[c].apply(this, u, l, !0, e);
						var d = u;
						u = l, l = d
					}
					r[c].apply(this, u, h.renderTexture, !1, e), this.returnFilterTexture(u), this.returnFilterTexture(l)
				}
				e.clear(), this.statePool.push(e)
			}, r.prototype.applyFilter = function (e, r, i, n) {
				var o = this.renderer;
				o.renderTexture.bind(i, i ? i.filterFrame : null), n && o.renderTexture.clear(), e.uniforms.uSampler = r, e.uniforms.filterGlobals = this.globalUniforms, o.state.set(e.state), o.shader.bind(e), e.legacy ? (this.quadUv.map(r._frame, r.filterFrame), o.geometry.bind(this.quadUv), o.geometry.draw(t.DRAW_MODES.TRIANGLES)) : (o.geometry.bind(this.quad), o.geometry.draw(t.DRAW_MODES.TRIANGLE_STRIP))
			}, r.prototype.calculateSpriteMatrix = function (t, e) {
				var r = this.activeState,
					i = r.sourceFrame,
					n = r.destinationFrame,
					o = e._texture.orig,
					s = t.set(n.width, 0, 0, n.height, i.x, i.y),
					a = e.worldTransform.copyTo(Fe.TEMP_MATRIX);
				return a.invert(), s.prepend(a), s.scale(1 / o.width, 1 / o.height), s.translate(e.anchor.x, e.anchor.y), s
			}, r.prototype.destroy = function () {
				this.texturePool.clear(!1)
			}, r.prototype.getOptimalFilterTexture = function (t, e, r) {
				return void 0 === r && (r = 1), this.texturePool.getOptimalTexture(t, e, r)
			}, r.prototype.getFilterTexture = function (t, e) {
				if ("number" == typeof t) {
					var r = t;
					t = e, e = r
				}
				t = t || this.activeState.renderTexture;
				var i = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution);
				return i.filterFrame = t.filterFrame, i
			}, r.prototype.returnFilterTexture = function (t) {
				this.texturePool.returnTexture(t)
			}, r.prototype.emptyPool = function () {
				this.texturePool.clear(!0)
			}, r.prototype.resize = function () {
				this.texturePool.setScreenSize(this.renderer.view)
			}, r
		}(Fr),
		hi = function (t) {
			this.renderer = t
		};
	hi.prototype.flush = function () {}, hi.prototype.destroy = function () {
		this.renderer = null
	}, hi.prototype.start = function () {}, hi.prototype.stop = function () {
		this.flush()
	}, hi.prototype.render = function (t) {};
	var ui = function (t) {
		function e(e) {
			t.call(this, e), this.emptyRenderer = new hi(e), this.currentRenderer = this.emptyRenderer
		}
		return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setObjectRenderer = function (t) {
			this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
		}, e.prototype.flush = function () {
			this.setObjectRenderer(this.emptyRenderer)
		}, e.prototype.reset = function () {
			this.setObjectRenderer(this.emptyRenderer)
		}, e.prototype.copyBoundTextures = function (t, e) {
			for (var r = this.renderer.texture.boundTextures, i = e - 1; i >= 0; --i) t[i] = r[i] || null, t[i] && (t[i]._batchLocation = i)
		}, e.prototype.boundArray = function (t, e, r, i) {
			for (var n = t.elements, o = t.ids, s = t.count, a = 0, h = 0; h < s; h++) {
				var u = n[h],
					l = u._batchLocation;
				if (l >= 0 && l < i && e[l] === u) o[h] = l;
				else
					for (; a < i;) {
						var c = e[a];
						if (!c || c._batchEnabled !== r || c._batchLocation !== a) {
							o[h] = a, u._batchLocation = a, e[a] = u;
							break
						}
						a++
					}
			}
		}, e
	}(Fr);
	M.PREFER_ENV = C.any ? t.ENV.WEBGL : t.ENV.WEBGL2, M.STRICT_TEXTURE_CACHE = !1;
	var li = 0,
		ci = function (e) {
			function r(t) {
				e.call(this, t), this.webGLVersion = 1, this.extensions = {}, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1)
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				isLost: {
					configurable: !0
				}
			};
			return i.isLost.get = function () {
				return !this.gl || this.gl.isContextLost()
			}, r.prototype.contextChange = function (t) {
				this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = li++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext()
			}, r.prototype.initFromContext = function (t) {
				this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = li++, this.renderer.runners.contextChange.run(t)
			}, r.prototype.initFromOptions = function (t) {
				var e = this.createContext(this.renderer.view, t);
				this.initFromContext(e)
			}, r.prototype.createContext = function (e, r) {
				var i;
				if (M.PREFER_ENV >= t.ENV.WEBGL2 && (i = e.getContext("webgl2", r)), i) this.webGLVersion = 2;
				else if (this.webGLVersion = 1, !(i = e.getContext("webgl", r) || e.getContext("experimental-webgl", r))) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
				return this.gl = i, this.getExtensions(), i
			}, r.prototype.getExtensions = function () {
				var t = this.gl;
				1 === this.webGLVersion ? Object.assign(this.extensions, {
					drawBuffers: t.getExtension("WEBGL_draw_buffers"),
					depthTexture: t.getExtension("WEBGL_depth_texture"),
					loseContext: t.getExtension("WEBGL_lose_context"),
					vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
					anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
					uint32ElementIndex: t.getExtension("OES_element_index_uint"),
					floatTexture: t.getExtension("OES_texture_float"),
					floatTextureLinear: t.getExtension("OES_texture_float_linear"),
					textureHalfFloat: t.getExtension("OES_texture_half_float"),
					textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
				}) : 2 === this.webGLVersion && Object.assign(this.extensions, {
					anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
					colorBufferFloat: t.getExtension("EXT_color_buffer_float"),
					floatTextureLinear: t.getExtension("OES_texture_float_linear")
				})
			}, r.prototype.handleContextLost = function (t) {
				t.preventDefault()
			}, r.prototype.handleContextRestored = function () {
				this.renderer.runners.contextChange.run(this.gl)
			}, r.prototype.destroy = function () {
				var t = this.renderer.view;
				t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
			}, r.prototype.postrender = function () {
				this.renderer.renderingToScreen && this.gl.flush()
			}, r.prototype.validateContext = function (t) {
				t.getContextAttributes().stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly")
			}, Object.defineProperties(r.prototype, i), r
		}(Fr),
		di = function (e) {
			function r(t) {
				e.call(this, t), this.managedFramebuffers = [], this.unknownFramebuffer = new Ur(10, 10)
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				size: {
					configurable: !0
				}
			};
			return r.prototype.contextChange = function () {
				var e = this.gl = this.renderer.gl;
				if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new ze, this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), 1 === this.renderer.context.webGLVersion) {
					var r = this.renderer.context.extensions.drawBuffers,
						i = this.renderer.context.extensions.depthTexture;
					M.PREFER_ENV === t.ENV.WEBGL_LEGACY && (r = null, i = null), r ? e.drawBuffers = function (t) {
						return r.drawBuffersWEBGL(t)
					} : (this.hasMRT = !1, e.drawBuffers = function () {}), i || (this.writeDepthTexture = !1)
				}
			}, r.prototype.bind = function (t, e) {
				var r = this.gl;
				if (t) {
					var i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
					this.current !== t && (this.current = t, r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)), i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId, i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat, this.updateFramebuffer(t)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
					for (var n = 0; n < t.colorTextures.length; n++) t.colorTextures[n].texturePart ? this.renderer.texture.unbind(t.colorTextures[n].texture) : this.renderer.texture.unbind(t.colorTextures[n]);
					t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, t.width, t.height)
				} else this.current && (this.current = null, r.bindFramebuffer(r.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
			}, r.prototype.setViewport = function (t, e, r, i) {
				var n = this.viewport;
				n.width === r && n.height === i && n.x === t && n.y === e || (n.x = t, n.y = e, n.width = r, n.height = i, this.gl.viewport(t, e, r, i))
			}, i.size.get = function () {
				return this.current ? {
					x: 0,
					y: 0,
					width: this.current.width,
					height: this.current.height
				} : {
					x: 0,
					y: 0,
					width: this.renderer.width,
					height: this.renderer.height
				}
			}, r.prototype.clear = function (t, e, r, i) {
				var n = this.gl;
				n.clearColor(t, e, r, i), n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT)
			}, r.prototype.initFramebuffer = function (t) {
				var e = {
					framebuffer: this.gl.createFramebuffer(),
					stencil: null,
					dirtyId: 0,
					dirtyFormat: 0,
					dirtySize: 0
				};
				return t.glFramebuffers[this.CONTEXT_UID] = e, this.managedFramebuffers.push(t), t.disposeRunner.add(this), e
			}, r.prototype.resizeFramebuffer = function (t) {
				var e = this.gl,
					r = t.glFramebuffers[this.CONTEXT_UID];
				r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
				for (var i = t.colorTextures, n = 0; n < i.length; n++) this.renderer.texture.bind(i[n], 0);
				t.depthTexture && this.renderer.texture.bind(t.depthTexture, 0)
			}, r.prototype.updateFramebuffer = function (t) {
				var e = this.gl,
					r = t.glFramebuffers[this.CONTEXT_UID],
					i = t.colorTextures.length;
				e.drawBuffers || (i = Math.min(i, 1));
				for (var n = [], o = 0; o < i; o++) {
					var s = t.colorTextures[o];
					s.texturePart ? (this.renderer.texture.bind(s.texture, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + o, e.TEXTURE_CUBE_MAP_NEGATIVE_X + s.side, s.texture._glTextures[this.CONTEXT_UID].texture, 0)) : (this.renderer.texture.bind(s, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + o, e.TEXTURE_2D, s._glTextures[this.CONTEXT_UID].texture, 0)), n.push(e.COLOR_ATTACHMENT0 + o)
				}
				if ((n.length > 1 && e.drawBuffers(n), t.depthTexture) && this.writeDepthTexture) {
					var a = t.depthTexture;
					this.renderer.texture.bind(a, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a._glTextures[this.CONTEXT_UID].texture, 0)
				}
				r.stencil || !t.stencil && !t.depth || (r.stencil = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height), t.depthTexture || e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, r.stencil))
			}, r.prototype.disposeFramebuffer = function (t, e) {
				var r = t.glFramebuffers[this.CONTEXT_UID],
					i = this.gl;
				if (r) {
					delete t.glFramebuffers[this.CONTEXT_UID];
					var n = this.managedFramebuffers.indexOf(t);
					n >= 0 && this.managedFramebuffers.splice(n, 1), t.disposeRunner.remove(this), e || (i.deleteFramebuffer(r.framebuffer), r.stencil && i.deleteRenderbuffer(r.stencil))
				}
			}, r.prototype.disposeAll = function (t) {
				var e = this.managedFramebuffers;
				this.managedFramebuffers = [];
				for (var r = 0; r < e.length; r++) this.disposeFramebuffer(e[r], t)
			}, r.prototype.forceStencil = function () {
				var t = this.current;
				if (t) {
					var e = t.glFramebuffers[this.CONTEXT_UID];
					if (e && !e.stencil) {
						t.enableStencil();
						var r = t.width,
							i = t.height,
							n = this.gl,
							o = n.createRenderbuffer();
						n.bindRenderbuffer(n.RENDERBUFFER, o), n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, r, i), e.stencil = o, n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, o)
					}
				}
			}, r.prototype.reset = function () {
				this.current = this.unknownFramebuffer, this.viewport = new ze
			}, Object.defineProperties(r.prototype, i), r
		}(Fr),
		pi = function (t) {
			this.buffer = t, this.updateID = -1, this.byteLength = -1, this.refCount = 0
		},
		fi = {
			5126: 4,
			5123: 2,
			5121: 1
		},
		vi = function (e) {
			function r(t) {
				e.call(this, t), this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.boundBuffers = {}, this.managedGeometries = {}, this.managedBuffers = {}
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.contextChange = function () {
				this.disposeAll(!0);
				var e = this.gl = this.renderer.gl,
					r = this.renderer.context;
				if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, !e.createVertexArray) {
					var i = this.renderer.context.extensions.vertexArrayObject;
					M.PREFER_ENV === t.ENV.WEBGL_LEGACY && (i = null), i ? (e.createVertexArray = function () {
						return i.createVertexArrayOES()
					}, e.bindVertexArray = function (t) {
						return i.bindVertexArrayOES(t)
					}, e.deleteVertexArray = function (t) {
						return i.deleteVertexArrayOES(t)
					}) : (this.hasVao = !1, e.createVertexArray = function () {}, e.bindVertexArray = function () {}, e.deleteVertexArray = function () {})
				}
				if (!e.vertexAttribDivisor) {
					var n = e.getExtension("ANGLE_instanced_arrays");
					n ? (e.vertexAttribDivisor = function (t, e) {
						return n.vertexAttribDivisorANGLE(t, e)
					}, e.drawElementsInstanced = function (t, e, r, i, o) {
						return n.drawElementsInstancedANGLE(t, e, r, i, o)
					}, e.drawArraysInstanced = function (t, e, r, i) {
						return n.drawArraysInstancedANGLE(t, e, r, i)
					}) : this.hasInstance = !1
				}
				this.canUseUInt32ElementIndex = 2 === r.webGLVersion || !!r.extensions.uint32ElementIndex
			}, r.prototype.bind = function (t, e) {
				e = e || this.renderer.shader.shader;
				var r = this.gl,
					i = t.glVertexArrayObjects[this.CONTEXT_UID];
				i || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = i = {});
				var n = i[e.program.id] || this.initGeometryVao(t, e.program);
				this._activeGeometry = t, this._activeVao !== n && (this._activeVao = n, this.hasVao ? r.bindVertexArray(n) : this.activateVao(t, e.program)), this.updateBuffers()
			}, r.prototype.reset = function () {
				this.unbind()
			}, r.prototype.updateBuffers = function () {
				for (var t = this._activeGeometry, e = this.gl, r = 0; r < t.buffers.length; r++) {
					var i = t.buffers[r],
						n = i._glBuffers[this.CONTEXT_UID];
					if (i._updateID !== n.updateID) {
						n.updateID = i._updateID;
						var o = i.index ? e.ELEMENT_ARRAY_BUFFER : e.ARRAY_BUFFER;
						if (e.bindBuffer(o, n.buffer), this._boundBuffer = n, n.byteLength >= i.data.byteLength) e.bufferSubData(o, 0, i.data);
						else {
							var s = i.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
							n.byteLength = i.data.byteLength, e.bufferData(o, i.data, s)
						}
					}
				}
			}, r.prototype.checkCompatibility = function (t, e) {
				var r = t.attributes,
					i = e.attributeData;
				for (var n in i)
					if (!r[n]) throw new Error('shader and geometry incompatible, geometry missing the "' + n + '" attribute')
			}, r.prototype.getSignature = function (t, e) {
				var r = t.attributes,
					i = e.attributeData,
					n = ["g", t.id];
				for (var o in r) i[o] && n.push(o);
				return n.join("-")
			}, r.prototype.initGeometryVao = function (t, e) {
				this.checkCompatibility(t, e);
				var r = this.gl,
					i = this.CONTEXT_UID,
					n = this.getSignature(t, e),
					o = t.glVertexArrayObjects[this.CONTEXT_UID],
					s = o[n];
				if (s) return o[e.id] = s, s;
				var a = t.buffers,
					h = t.attributes,
					u = {},
					l = {};
				for (var c in a) u[c] = 0, l[c] = 0;
				for (var d in h) !h[d].size && e.attributeData[d] ? h[d].size = e.attributeData[d].size : h[d].size || console.warn("PIXI Geometry attribute '" + d + "' size cannot be determined (likely the bound shader does not have the attribute)"), u[h[d].buffer] += h[d].size * fi[h[d].type];
				for (var p in h) {
					var f = h[p],
						v = f.size;
					void 0 === f.stride && (u[f.buffer] === v * fi[f.type] ? f.stride = 0 : f.stride = u[f.buffer]), void 0 === f.start && (f.start = l[f.buffer], l[f.buffer] += v * fi[f.type])
				}
				s = r.createVertexArray(), r.bindVertexArray(s);
				for (var m = 0; m < a.length; m++) {
					var g = a[m];
					g._glBuffers[i] || (g._glBuffers[i] = new pi(r.createBuffer()), this.managedBuffers[g.id] = g, g.disposeRunner.add(this)), g._glBuffers[i].refCount++
				}
				return this.activateVao(t, e), this._activeVao = s, o[e.id] = s, o[n] = s, s
			}, r.prototype.disposeBuffer = function (t, e) {
				if (this.managedBuffers[t.id]) {
					delete this.managedBuffers[t.id];
					var r = t._glBuffers[this.CONTEXT_UID],
						i = this.gl;
					t.disposeRunner.remove(this), r && (e || i.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID])
				}
			}, r.prototype.disposeGeometry = function (t, e) {
				if (this.managedGeometries[t.id]) {
					delete this.managedGeometries[t.id];
					var r = t.glVertexArrayObjects[this.CONTEXT_UID],
						i = this.gl,
						n = t.buffers;
					if (t.disposeRunner.remove(this), r) {
						for (var o = 0; o < n.length; o++) {
							var s = n[o]._glBuffers[this.CONTEXT_UID];
							s.refCount--, 0 !== s.refCount || e || this.disposeBuffer(n[o], e)
						}
						if (!e)
							for (var a in r)
								if ("g" === a[0]) {
									var h = r[a];
									this._activeVao === h && this.unbind(), i.deleteVertexArray(h)
								} delete t.glVertexArrayObjects[this.CONTEXT_UID]
					}
				}
			}, r.prototype.disposeAll = function (t) {
				for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++) this.disposeGeometry(this.managedGeometries[e[r]], t);
				e = Object.keys(this.managedBuffers);
				for (var i = 0; i < e.length; i++) this.disposeBuffer(this.managedBuffers[e[i]], t)
			}, r.prototype.activateVao = function (t, e) {
				var r = this.gl,
					i = this.CONTEXT_UID,
					n = t.buffers,
					o = t.attributes;
				t.indexBuffer && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.indexBuffer._glBuffers[i].buffer);
				var s = null;
				for (var a in o) {
					var h = o[a],
						u = n[h.buffer]._glBuffers[i];
					if (e.attributeData[a]) {
						s !== u && (r.bindBuffer(r.ARRAY_BUFFER, u.buffer), s = u);
						var l = e.attributeData[a].location;
						if (r.enableVertexAttribArray(l), r.vertexAttribPointer(l, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start), h.instance) {
							if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
							r.vertexAttribDivisor(l, 1)
						}
					}
				}
			}, r.prototype.draw = function (t, e, r, i) {
				var n = this.gl,
					o = this._activeGeometry;
				if (o.indexBuffer) {
					var s = o.indexBuffer.data.BYTES_PER_ELEMENT,
						a = 2 === s ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
					2 === s || 4 === s && this.canUseUInt32ElementIndex ? o.instanced ? n.drawElementsInstanced(t, e || o.indexBuffer.data.length, a, (r || 0) * s, i || 1) : n.drawElements(t, e || o.indexBuffer.data.length, a, (r || 0) * s) : console.warn("unsupported index buffer type: uint32")
				} else o.instanced ? n.drawArraysInstanced(t, r, e || o.getSize(), i || 1) : n.drawArrays(t, r, e || o.getSize());
				return this
			}, r.prototype.unbind = function () {
				this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
			}, r
		}(Fr),
		mi = function (e) {
			this.type = t.MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = e || null, this.pooled = !1, this.isMaskData = !0, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._target = null
		};

	function gi(t, e, r, i) {
		var n = yi(t, t.VERTEX_SHADER, e),
			o = yi(t, t.FRAGMENT_SHADER, r),
			s = t.createProgram();
		if (t.attachShader(s, n), t.attachShader(s, o), i)
			for (var a in i) t.bindAttribLocation(s, i[a], a);
		return t.linkProgram(s), t.getProgramParameter(s, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || (console.warn(e), console.error(t.getShaderInfoLog(n))), t.getShaderParameter(o, t.COMPILE_STATUS) || (console.warn(r), console.error(t.getShaderInfoLog(o))), console.error("Pixi.js Error: Could not initialize shader."), console.error("gl.VALIDATE_STATUS", t.getProgramParameter(s, t.VALIDATE_STATUS)), console.error("gl.getError()", t.getError()), "" !== t.getProgramInfoLog(s) && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(s)), t.deleteProgram(s), s = null), t.deleteShader(n), t.deleteShader(o), s
	}

	function yi(t, e, r) {
		var i = t.createShader(e);
		return t.shaderSource(i, r), t.compileShader(i), i
	}

	function _i(t, e) {
		switch (t) {
			case "float":
				return 0;
			case "vec2":
				return new Float32Array(2 * e);
			case "vec3":
				return new Float32Array(3 * e);
			case "vec4":
				return new Float32Array(4 * e);
			case "int":
			case "sampler2D":
			case "sampler2DArray":
				return 0;
			case "ivec2":
				return new Int32Array(2 * e);
			case "ivec3":
				return new Int32Array(3 * e);
			case "ivec4":
				return new Int32Array(4 * e);
			case "bool":
				return !1;
			case "bvec2":
				return xi(2 * e);
			case "bvec3":
				return xi(3 * e);
			case "bvec4":
				return xi(4 * e);
			case "mat2":
				return new Float32Array([1, 0, 0, 1]);
			case "mat3":
				return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
			case "mat4":
				return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
		}
		return null
	}

	function xi(t) {
		for (var e = new Array(t), r = 0; r < e.length; r++) e[r] = !1;
		return e
	}
	mi.prototype.reset = function () {
		this.pooled && (this.maskObject = null, this.type = t.MASK_TYPES.NONE, this.autoDetect = !0), this._target = null
	}, mi.prototype.copyCountersOrReset = function (t) {
		t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
	};
	var bi, Ei = {},
		Ti = Ei;

	function wi() {
		if (Ti === Ei || Ti && Ti.isContextLost()) {
			var e, r = document.createElement("canvas");
			M.PREFER_ENV >= t.ENV.WEBGL2 && (e = r.getContext("webgl2", {})), e || ((e = r.getContext("webgl", {}) || r.getContext("experimental-webgl", {})) ? e.getExtension("WEBGL_draw_buffers") : e = null), Ti = e
		}
		return Ti
	}

	function Si(e, r, i) {
		if ("precision" !== e.substring(0, 9)) {
			var n = r;
			return r === t.PRECISION.HIGH && i !== t.PRECISION.HIGH && (n = t.PRECISION.MEDIUM), "precision " + n + " float;\n" + e
		}
		return i !== t.PRECISION.HIGH && "precision highp" === e.substring(0, 15) ? e.replace("precision highp", "precision mediump") : e
	}
	var Ii = {
		float: 1,
		vec2: 2,
		vec3: 3,
		vec4: 4,
		int: 1,
		ivec2: 2,
		ivec3: 3,
		ivec4: 4,
		bool: 1,
		bvec2: 2,
		bvec3: 3,
		bvec4: 4,
		mat2: 4,
		mat3: 9,
		mat4: 16,
		sampler2D: 1
	};

	function Pi(t) {
		return Ii[t]
	}
	var Ai = null,
		Oi = {
			FLOAT: "float",
			FLOAT_VEC2: "vec2",
			FLOAT_VEC3: "vec3",
			FLOAT_VEC4: "vec4",
			INT: "int",
			INT_VEC2: "ivec2",
			INT_VEC3: "ivec3",
			INT_VEC4: "ivec4",
			BOOL: "bool",
			BOOL_VEC2: "bvec2",
			BOOL_VEC3: "bvec3",
			BOOL_VEC4: "bvec4",
			FLOAT_MAT2: "mat2",
			FLOAT_MAT3: "mat3",
			FLOAT_MAT4: "mat4",
			SAMPLER_2D: "sampler2D",
			SAMPLER_CUBE: "samplerCube",
			SAMPLER_2D_ARRAY: "sampler2DArray"
		};

	function Di(t, e) {
		if (!Ai) {
			var r = Object.keys(Oi);
			Ai = {};
			for (var i = 0; i < r.length; ++i) {
				var n = r[i];
				Ai[t[n]] = Oi[n]
			}
		}
		return Ai[e]
	}
	var Ci = {
			float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
			vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
			vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
			vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
			int: "gl.uniform1i(location, v)",
			ivec2: "gl.uniform2i(location, v[0], v[1])",
			ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
			ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
			bool: "gl.uniform1i(location, v)",
			bvec2: "gl.uniform2i(location, v[0], v[1])",
			bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
			bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
			mat2: "gl.uniformMatrix2fv(location, false, v)",
			mat3: "gl.uniformMatrix3fv(location, false, v)",
			mat4: "gl.uniformMatrix4fv(location, false, v)",
			sampler2D: "gl.uniform1i(location, v)",
			samplerCube: "gl.uniform1i(location, v)",
			sampler2DArray: "gl.uniform1i(location, v)"
		},
		Mi = {
			float: "gl.uniform1fv(location, v)",
			vec2: "gl.uniform2fv(location, v)",
			vec3: "gl.uniform3fv(location, v)",
			vec4: "gl.uniform4fv(location, v)",
			mat4: "gl.uniformMatrix4fv(location, false, v)",
			mat3: "gl.uniformMatrix3fv(location, false, v)",
			mat2: "gl.uniformMatrix2fv(location, false, v)",
			int: "gl.uniform1iv(location, v)",
			ivec2: "gl.uniform2iv(location, v)",
			ivec3: "gl.uniform3iv(location, v)",
			ivec4: "gl.uniform4iv(location, v)",
			bool: "gl.uniform1iv(location, v)",
			bvec2: "gl.uniform2iv(location, v)",
			bvec3: "gl.uniform3iv(location, v)",
			bvec4: "gl.uniform4iv(location, v)",
			sampler2D: "gl.uniform1iv(location, v)",
			samplerCube: "gl.uniform1iv(location, v)",
			sampler2DArray: "gl.uniform1iv(location, v)"
		};
	var Ri, Li = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");

	function Ni(t, e) {
		if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
		for (var r = e.createShader(e.FRAGMENT_SHADER);;) {
			var i = Li.replace(/%forloop%/gi, Fi(t));
			if (e.shaderSource(r, i), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS)) break;
			t = t / 2 | 0
		}
		return t
	}

	function Fi(t) {
		for (var e = "", r = 0; r < t; ++r) r > 0 && (e += "\nelse "), r < t - 1 && (e += "if(test == " + r + ".0){}");
		return e
	}
	var Bi = 0,
		Ui = {},
		ki = function e(r, i, n) {
			void 0 === n && (n = "pixi-shader"), this.id = Bi++, this.vertexSrc = r || e.defaultVertexSrc, this.fragmentSrc = i || e.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (n = n.replace(/\s+/g, "-"), Ui[n] ? (Ui[n]++, n += "-" + Ui[n]) : Ui[n] = 1, this.vertexSrc = "#define SHADER_NAME " + n + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + n + "\n" + this.fragmentSrc, this.vertexSrc = Si(this.vertexSrc, M.PRECISION_VERTEX, t.PRECISION.HIGH), this.fragmentSrc = Si(this.fragmentSrc, M.PRECISION_FRAGMENT, function () {
				if (!bi) {
					bi = t.PRECISION.MEDIUM;
					var e = wi();
					if (e && e.getShaderPrecisionFormat) {
						var r = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT);
						bi = r.precision ? t.PRECISION.HIGH : t.PRECISION.MEDIUM
					}
				}
				return bi
			}())), this.extractData(this.vertexSrc, this.fragmentSrc), this.glPrograms = {}, this.syncUniforms = null
		},
		Xi = {
			defaultVertexSrc: {
				configurable: !0
			},
			defaultFragmentSrc: {
				configurable: !0
			}
		};
	ki.prototype.extractData = function (t, e) {
		var r = wi();
		if (r) {
			var i = gi(r, t, e);
			this.attributeData = this.getAttributeData(i, r), this.uniformData = this.getUniformData(i, r), r.deleteProgram(i)
		} else this.uniformData = {}, this.attributeData = {}
	}, ki.prototype.getAttributeData = function (t, e) {
		for (var r = {}, i = [], n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), o = 0; o < n; o++) {
			var s = e.getActiveAttrib(t, o),
				a = Di(e, s.type),
				h = {
					type: a,
					name: s.name,
					size: Pi(a),
					location: 0
				};
			r[s.name] = h, i.push(h)
		}
		i.sort(function (t, e) {
			return t.name > e.name ? 1 : -1
		});
		for (var u = 0; u < i.length; u++) i[u].location = u;
		return r
	}, ki.prototype.getUniformData = function (t, e) {
		for (var r = {}, i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), n = 0; n < i; n++) {
			var o = e.getActiveUniform(t, n),
				s = o.name.replace(/\[.*?\]/, ""),
				a = o.name.match(/\[.*?\]/, ""),
				h = Di(e, o.type);
			r[s] = {
				type: h,
				size: o.size,
				isArray: a,
				value: _i(h, o.size)
			}
		}
		return r
	}, Xi.defaultVertexSrc.get = function () {
		return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
	}, Xi.defaultFragmentSrc.get = function () {
		return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
	}, ki.from = function (t, e, r) {
		var i = t + e,
			n = xe[i];
		return n || (xe[i] = n = new ki(t, e, r)), n
	}, Object.defineProperties(ki, Xi);
	var ji = function (t, e) {
			for (var r in this.program = t, this.uniformGroup = e ? e instanceof oi ? e : new oi(e) : new oi({}), t.uniformData) this.uniformGroup.uniforms[r] instanceof Array && (this.uniformGroup.uniforms[r] = new Float32Array(this.uniformGroup.uniforms[r]))
		},
		Hi = {
			uniforms: {
				configurable: !0
			}
		};
	ji.prototype.checkUniformExists = function (t, e) {
		if (e.uniforms[t]) return !0;
		for (var r in e.uniforms) {
			var i = e.uniforms[r];
			if (i.group && this.checkUniformExists(t, i)) return !0
		}
		return !1
	}, ji.prototype.destroy = function () {
		this.uniformGroup = null
	}, Hi.uniforms.get = function () {
		return this.uniformGroup.uniforms
	}, ji.from = function (t, e, r) {
		var i = ki.from(t, e);
		return new ji(i, r)
	}, Object.defineProperties(ji.prototype, Hi);
	var Gi = function () {
			this.data = 0, this.blendMode = t.BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0
		},
		Yi = {
			blend: {
				configurable: !0
			},
			offsets: {
				configurable: !0
			},
			culling: {
				configurable: !0
			},
			depthTest: {
				configurable: !0
			},
			clockwiseFrontFace: {
				configurable: !0
			},
			blendMode: {
				configurable: !0
			},
			polygonOffset: {
				configurable: !0
			}
		};
	Yi.blend.get = function () {
		return !!(1 & this.data)
	}, Yi.blend.set = function (t) {
		!!(1 & this.data) !== t && (this.data ^= 1)
	}, Yi.offsets.get = function () {
		return !!(2 & this.data)
	}, Yi.offsets.set = function (t) {
		!!(2 & this.data) !== t && (this.data ^= 2)
	}, Yi.culling.get = function () {
		return !!(4 & this.data)
	}, Yi.culling.set = function (t) {
		!!(4 & this.data) !== t && (this.data ^= 4)
	}, Yi.depthTest.get = function () {
		return !!(8 & this.data)
	}, Yi.depthTest.set = function (t) {
		!!(8 & this.data) !== t && (this.data ^= 8)
	}, Yi.clockwiseFrontFace.get = function () {
		return !!(16 & this.data)
	}, Yi.clockwiseFrontFace.set = function (t) {
		!!(16 & this.data) !== t && (this.data ^= 16)
	}, Yi.blendMode.get = function () {
		return this._blendMode
	}, Yi.blendMode.set = function (e) {
		this.blend = e !== t.BLEND_MODES.NONE, this._blendMode = e
	}, Yi.polygonOffset.get = function () {
		return this._polygonOffset
	}, Yi.polygonOffset.set = function (t) {
		this.offsets = !!t, this._polygonOffset = t
	}, Gi.for2d = function () {
		var t = new Gi;
		return t.depthTest = !1, t.blend = !0, t
	}, Object.defineProperties(Gi.prototype, Yi);
	var Vi = function (t) {
		function e(r, i, n) {
			var o = ki.from(r || e.defaultVertexSrc, i || e.defaultFragmentSrc);
			t.call(this, o, n), this.padding = 0, this.resolution = M.FILTER_RESOLUTION, this.enabled = !0, this.autoFit = !0, this.legacy = !!this.program.attributeData.aTextureCoord, this.state = new Gi
		}
		t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
		var r = {
				blendMode: {
					configurable: !0
				}
			},
			i = {
				defaultVertexSrc: {
					configurable: !0
				},
				defaultFragmentSrc: {
					configurable: !0
				}
			};
		return e.prototype.apply = function (t, e, r, i, n) {
			t.applyFilter(this, e, r, i, n)
		}, r.blendMode.get = function () {
			return this.state.blendMode
		}, r.blendMode.set = function (t) {
			this.state.blendMode = t
		}, i.defaultVertexSrc.get = function () {
			return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
		}, i.defaultFragmentSrc.get = function () {
			return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
		}, Object.defineProperties(e.prototype, r), Object.defineProperties(e, i), e
	}(ji);
	Vi.SOURCE_KEY_MAP = {};
	var zi = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n",
		Wi = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n",
		qi = new Fe,
		Ki = function (t, e) {
			this._texture = t, this.mapCoord = new Fe, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._updateID = -1, this.clampOffset = 0, this.clampMargin = void 0 === e ? .5 : e, this.isSimple = !1
		},
		Zi = {
			texture: {
				configurable: !0
			}
		};
	Zi.texture.get = function () {
		return this._texture
	}, Zi.texture.set = function (t) {
		this._texture = t, this._updateID = -1
	}, Ki.prototype.multiplyUvs = function (t, e) {
		void 0 === e && (e = t);
		for (var r = this.mapCoord, i = 0; i < t.length; i += 2) {
			var n = t[i],
				o = t[i + 1];
			e[i] = n * r.a + o * r.c + r.tx, e[i + 1] = n * r.b + o * r.d + r.ty
		}
		return e
	}, Ki.prototype.update = function (t) {
		var e = this._texture;
		if (!e || !e.valid) return !1;
		if (!t && this._updateID === e._updateID) return !1;
		this._updateID = e._updateID;
		var r = e._uvs;
		this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
		var i = e.orig,
			n = e.trim;
		n && (qi.set(i.width / n.width, 0, 0, i.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(qi));
		var o = e.baseTexture,
			s = this.uClampFrame,
			a = this.clampMargin / o.resolution,
			h = this.clampOffset;
		return s[0] = (e._frame.x + a + h) / o.width, s[1] = (e._frame.y + a + h) / o.height, s[2] = (e._frame.x + e._frame.width - a + h) / o.width, s[3] = (e._frame.y + e._frame.height - a + h) / o.height, this.uClampOffset[0] = h / o.realWidth, this.uClampOffset[1] = h / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && 0 === e.rotate, !0
	}, Object.defineProperties(Ki.prototype, Zi);
	var Ji = function (t) {
			function e(e) {
				var r = new Fe;
				t.call(this, zi, Wi), e.renderable = !1, this.maskSprite = e, this.maskMatrix = r
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.apply = function (t, e, r, i) {
				var n = this.maskSprite,
					o = this.maskSprite.texture;
				o.valid && (o.transform || (o.transform = new Ki(o, 0)), o.transform.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, n).prepend(o.transform.mapCoord), this.uniforms.alpha = n.worldAlpha, this.uniforms.maskClamp = o.transform.uClampFrame, t.applyFilter(this, e, r, i))
			}, e
		}(Vi),
		Qi = function (e) {
			function r(t) {
				e.call(this, t), this.scissorRenderTarget = null, this.enableScissor = !1, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.setMaskStack = function (t) {
				this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
			}, r.prototype.push = function (e, r) {
				if (!r.isMaskData) {
					var i = this.maskDataPool.pop() || new mi;
					i.pooled = !0, i.maskObject = r, r = i
				}
				switch (r.autoDetect && this.detect(r), r.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]), r._target = e, r.type) {
					case t.MASK_TYPES.SCISSOR:
						this.maskStack.push(r), this.renderer.scissor.push(r);
						break;
					case t.MASK_TYPES.STENCIL:
						this.maskStack.push(r), this.renderer.stencil.push(r);
						break;
					case t.MASK_TYPES.SPRITE:
						r.copyCountersOrReset(null), this.pushSpriteMask(r), this.maskStack.push(r)
				}
			}, r.prototype.pop = function (e) {
				var r = this.maskStack.pop();
				if (r && r._target === e) {
					switch (r.type) {
						case t.MASK_TYPES.SCISSOR:
							this.renderer.scissor.pop();
							break;
						case t.MASK_TYPES.STENCIL:
							this.renderer.stencil.pop(r.maskObject);
							break;
						case t.MASK_TYPES.SPRITE:
							this.popSpriteMask()
					}
					r.reset(), r.pooled && this.maskDataPool.push(r)
				}
			}, r.prototype.detect = function (e) {
				var r = e.maskObject;
				if (r.isSprite) e.type = t.MASK_TYPES.SPRITE;
				else if (e.type = t.MASK_TYPES.STENCIL, this.enableScissor && r.isFastRect && r.isFastRect()) {
					var i = r.worldTransform,
						n = Math.atan2(i.b, i.a),
						o = Math.atan2(i.d, i.c);
					n = Math.round(n * (180 / Math.PI) * 100), o = ((o = Math.round(o * (180 / Math.PI) * 100) - n) % 18e3 + 18e3) % 18e3, 0 === (n = (n % 9e3 + 9e3) % 9e3) && 9e3 === o && (e.type = t.MASK_TYPES.SCISSOR)
				}
			}, r.prototype.pushSpriteMask = function (t) {
				var e = t.maskObject,
					r = t._target,
					i = this.alphaMaskPool[this.alphaMaskIndex];
				i || (i = this.alphaMaskPool[this.alphaMaskIndex] = [new Ji(e)]), i[0].resolution = this.renderer.resolution, i[0].maskSprite = e;
				var n = r.filterArea;
				r.filterArea = e.getBounds(!0), this.renderer.filter.push(r, i), r.filterArea = n, this.alphaMaskIndex++
			}, r.prototype.popSpriteMask = function () {
				this.renderer.filter.pop(), this.alphaMaskIndex--
			}, r
		}(Fr),
		$i = function (t) {
			function e(e) {
				t.call(this, e), this.maskStack = [], this.glConst = 0
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getStackLength = function () {
				return this.maskStack.length
			}, e.prototype.setMaskStack = function (t) {
				var e = this.renderer.gl,
					r = this.getStackLength();
				this.maskStack = t;
				var i = this.getStackLength();
				i !== r && (0 === i ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()))
			}, e.prototype._useCurrent = function () {}, e.prototype.destroy = function () {
				t.prototype.destroy.call(this, this), this.maskStack = null
			}, e
		}(Fr),
		tn = function (t) {
			function e(e) {
				t.call(this, e), this.glConst = WebGLRenderingContext.SCISSOR_TEST
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getStackLength = function () {
				var t = this.maskStack[this.maskStack.length - 1];
				return t ? t._scissorCounter : 0
			}, e.prototype.push = function (t) {
				var e = t.maskObject;
				e.renderable = !0;
				var r = t._scissorRect,
					i = e.getBounds(!0),
					n = this.renderer.gl;
				e.renderable = !1, r ? i.fit(r) : n.enable(n.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = i, this._useCurrent()
			}, e.prototype.pop = function () {
				var t = this.renderer.gl;
				this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
			}, e.prototype._useCurrent = function () {
				var t = this.maskStack[this.maskStack.length - 1]._scissorRect,
					e = this.renderer.renderTexture.current,
					r = this.renderer.projection,
					i = r.transform,
					n = r.sourceFrame,
					o = r.destinationFrame,
					s = e ? e.resolution : this.renderer.resolution,
					a = (t.x - n.x) * s + o.x,
					h = (t.y - n.y) * s + o.y,
					u = t.width * s,
					l = t.height * s;
				i && (a += i.tx * s, h += i.ty * s), e || (h = this.renderer.height - l - h), this.renderer.gl.scissor(a, h, u, l)
			}, e
		}($i),
		en = function (t) {
			function e(e) {
				t.call(this, e), this.glConst = WebGLRenderingContext.STENCIL_TEST
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getStackLength = function () {
				var t = this.maskStack[this.maskStack.length - 1];
				return t ? t._stencilCounter : 0
			}, e.prototype.push = function (t) {
				var e = t.maskObject,
					r = this.renderer.gl,
					i = t._stencilCounter;
				0 === i && (this.renderer.framebuffer.forceStencil(), r.enable(r.STENCIL_TEST)), t._stencilCounter++, r.colorMask(!1, !1, !1, !1), r.stencilFunc(r.EQUAL, i, this._getBitwiseMask()), r.stencilOp(r.KEEP, r.KEEP, r.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent()
			}, e.prototype.pop = function (t) {
				var e = this.renderer.gl;
				0 === this.getStackLength() ? (e.disable(e.STENCIL_TEST), e.clear(e.STENCIL_BUFFER_BIT), e.clearStencil(0)) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent())
			}, e.prototype._useCurrent = function () {
				var t = this.renderer.gl;
				t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), this._getBitwiseMask()), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
			}, e.prototype._getBitwiseMask = function () {
				return (1 << this.getStackLength()) - 1
			}, e
		}($i),
		rn = function (t) {
			function e(e) {
				t.call(this, e), this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Fe, this.transform = null
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.update = function (t, e, r, i) {
				this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, i), this.transform && this.projectionMatrix.append(this.transform);
				var n = this.renderer;
				n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, n.globalUniforms.update(), n.shader.shader && n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)
			}, e.prototype.calculateProjection = function (t, e, r, i) {
				var n = this.projectionMatrix;
				i ? (n.a = 1 / t.width * 2 * r, n.d = -1 / t.height * 2 * r, n.tx = -1 - e.x * n.a, n.ty = 1 - e.y * n.d) : (n.a = 1 / t.width * 2 * r, n.d = 1 / t.height * 2 * r, n.tx = -1 - e.x * n.a, n.ty = -1 - e.y * n.d)
			}, e.prototype.setTransform = function () {}, e
		}(Fr),
		nn = new ze,
		on = function (t) {
			function e(e) {
				t.call(this, e), this.clearColor = e._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new ze, this.destinationFrame = new ze
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.bind = function (t, e, r) {
				void 0 === t && (t = null), this.current = t;
				var i, n = this.renderer;
				if (t) {
					var o = t.baseTexture;
					i = o.resolution, r || (nn.width = o.realWidth, nn.height = o.realHeight, r = nn), e || (e = r), this.renderer.framebuffer.bind(o.framebuffer, r), this.renderer.projection.update(r, e, i, !1), this.renderer.mask.setMaskStack(o.maskStack)
				} else i = this.renderer.resolution, r || (nn.width = n.width, nn.height = n.height, r = nn), e || (e = r), n.framebuffer.bind(null, r), this.renderer.projection.update(r, e, i, !0), this.renderer.mask.setMaskStack(this.defaultMaskStack);
				this.sourceFrame.copyFrom(e), this.destinationFrame.x = r.x / i, this.destinationFrame.y = r.y / i, this.destinationFrame.width = r.width / i, this.destinationFrame.height = r.height / i, e === r && this.sourceFrame.copyFrom(this.destinationFrame)
			}, e.prototype.clear = function (t) {
				t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor, this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3])
			}, e.prototype.resize = function () {
				this.bind(null)
			}, e.prototype.reset = function () {
				this.bind(null)
			}, e
		}(Fr),
		sn = function (t, e) {
			this.program = t, this.uniformData = e, this.uniformGroups = {}
		};
	sn.prototype.destroy = function () {
		this.uniformData = null, this.uniformGroups = null, this.program = null
	};
	var an = 0,
		hn = {
			textureCount: 0
		},
		un = function (t) {
			function e(e) {
				t.call(this, e), this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this.id = an++
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.systemCheck = function () {
				if (! function () {
						if ("boolean" == typeof Ri) return Ri;
						try {
							var t = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
							Ri = !0 === t({
								a: "b"
							}, "a", "b")
						} catch (t) {
							Ri = !1
						}
						return Ri
					}()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
			}, e.prototype.contextChange = function (t) {
				this.gl = t, this.reset()
			}, e.prototype.bind = function (t, e) {
				t.uniforms.globals = this.renderer.globalUniforms;
				var r = t.program,
					i = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(t);
				return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(i.program)), e || (hn.textureCount = 0, this.syncUniformGroup(t.uniformGroup, hn)), i
			}, e.prototype.setUniforms = function (t) {
				var e = this.shader.program,
					r = e.glPrograms[this.renderer.CONTEXT_UID];
				e.syncUniforms(r.uniformData, t, this.renderer)
			}, e.prototype.syncUniformGroup = function (t, e) {
				var r = this.getglProgram();
				t.static && t.dirtyId === r.uniformGroups[t.id] || (r.uniformGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e))
			}, e.prototype.syncUniforms = function (t, e, r) {
				(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, r)
			}, e.prototype.createSyncGroups = function (t) {
				var e = this.getSignature(t, this.shader.program.uniformData);
				return this.cache[e] || (this.cache[e] = function (t, e) {
					var r = "var v = null;\n    var cv = null\n    var t = 0;\n    var gl = renderer.gl\n    ";
					for (var i in t.uniforms) {
						var n = e[i];
						n ? "float" === n.type && 1 === n.size ? r += "\n            if(uv." + i + " !== ud." + i + ".value)\n            {\n                ud." + i + ".value = uv." + i + "\n                gl.uniform1f(ud." + i + ".location, uv." + i + ")\n            }\n" : "sampler2D" !== n.type && "samplerCube" !== n.type && "sampler2DArray" !== n.type || 1 !== n.size || n.isArray ? "mat3" === n.type && 1 === n.size ? void 0 !== t.uniforms[i].a ? r += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ".toArray(true));\n                \n" : r += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ");\n                \n" : "vec2" === n.type && 1 === n.size ? void 0 !== t.uniforms[i].x ? r += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud." + i + ".location, v.x, v.y);\n                }\n" : r += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud." + i + ".location, v[0], v[1]);\n                }\n                \n" : "vec4" === n.type && 1 === n.size ? void 0 !== t.uniforms[i].width ? r += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud." + i + ".location, v.x, v.y, v.width, v.height)\n                }\n" : r += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud." + i + ".location, v[0], v[1], v[2], v[3])\n                }\n                \n" : r += "\n            cv = ud." + i + ".value;\n            v = uv." + i + ";\n            " + (1 === n.size ? Ci : Mi)[n.type].replace("location", "ud." + i + ".location") + ";\n" : r += "\n\n            t = syncData.textureCount++;\n\n            renderer.texture.bind(uv." + i + ", t);\n            \n            if(ud." + i + ".value !== t)\n            {\n                ud." + i + ".value = t;\n                gl.uniform1i(ud." + i + ".location, t);\n; // eslint-disable-line max-len\n            }\n" : t.uniforms[i].group && (r += "\n                    renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                ")
					}
					return new Function("ud", "uv", "renderer", "syncData", r)
				}(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
			}, e.prototype.getSignature = function (t, e) {
				var r = t.uniforms,
					i = [];
				for (var n in r) i.push(n), e[n] && i.push(e[n].type);
				return i.join("-")
			}, e.prototype.getglProgram = function () {
				return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
			}, e.prototype.generateShader = function (t) {
				var e = this.gl,
					r = t.program,
					i = {};
				for (var n in r.attributeData) i[n] = r.attributeData[n].location;
				var o = gi(e, r.vertexSrc, r.fragmentSrc, i),
					s = {};
				for (var a in r.uniformData) {
					var h = r.uniformData[a];
					s[a] = {
						location: e.getUniformLocation(o, a),
						value: _i(h.type, h.size)
					}
				}
				var u = new sn(o, s);
				return r.glPrograms[this.renderer.CONTEXT_UID] = u, u
			}, e.prototype.reset = function () {
				this.program = null, this.shader = null
			}, e.prototype.destroy = function () {
				this.destroyed = !0
			}, e
		}(Fr);
	var ln = 0,
		cn = 1,
		dn = 2,
		pn = 3,
		fn = 4,
		vn = function (e) {
			function r(r) {
				e.call(this, r), this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = t.BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[ln] = this.setBlend, this.map[cn] = this.setOffset, this.map[dn] = this.setCullFace, this.map[pn] = this.setDepthTest, this.map[fn] = this.setFrontFace, this.checks = [], this.defaultState = new Gi, this.defaultState.blend = !0, this.defaultState.depth = !0
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.contextChange = function (e) {
				this.gl = e, this.blendModes = function (e, r) {
					return void 0 === r && (r = []), r[t.BLEND_MODES.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.ADD] = [e.ONE, e.ONE], r[t.BLEND_MODES.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.NONE] = [0, 0], r[t.BLEND_MODES.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE], r[t.BLEND_MODES.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SRC_IN] = [e.DST_ALPHA, e.ZERO], r[t.BLEND_MODES.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO], r[t.BLEND_MODES.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE], r[t.BLEND_MODES.DST_IN] = [e.ZERO, e.SRC_ALPHA], r[t.BLEND_MODES.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA], r[t.BLEND_MODES.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD], r
				}(e), this.set(this.defaultState), this.reset()
			}, r.prototype.set = function (t) {
				if (t = t || this.defaultState, this.stateId !== t.data) {
					for (var e = this.stateId ^ t.data, r = 0; e;) 1 & e && this.map[r].call(this, !!(t.data & 1 << r)), e >>= 1, r++;
					this.stateId = t.data
				}
				for (var i = 0; i < this.checks.length; i++) this.checks[i](this, t)
			}, r.prototype.forceState = function (t) {
				t = t || this.defaultState;
				for (var e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
				for (var r = 0; r < this.checks.length; r++) this.checks[r](this, t);
				this.stateId = t.data
			}, r.prototype.setBlend = function (t) {
				this.updateCheck(r.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND)
			}, r.prototype.setOffset = function (t) {
				this.updateCheck(r.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
			}, r.prototype.setDepthTest = function (t) {
				this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
			}, r.prototype.setCullFace = function (t) {
				this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
			}, r.prototype.setFrontFace = function (t) {
				this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
			}, r.prototype.setBlendMode = function (t) {
				if (t !== this.blendMode) {
					this.blendMode = t;
					var e = this.blendModes[t],
						r = this.gl;
					2 === e.length ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), 6 === e.length ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
				}
			}, r.prototype.setPolygonOffset = function (t, e) {
				this.gl.polygonOffset(t, e)
			}, r.prototype.reset = function () {
				this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(0), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
			}, r.prototype.updateCheck = function (t, e) {
				var r = this.checks.indexOf(t);
				e && -1 === r ? this.checks.push(t) : e || -1 === r || this.checks.splice(r, 1)
			}, r.checkBlendMode = function (t, e) {
				t.setBlendMode(e.blendMode)
			}, r.checkPolygonOffset = function (t, e) {
				t.setPolygonOffset(e.polygonOffset, 0)
			}, r
		}(Fr),
		mn = function (e) {
			function r(t) {
				e.call(this, t), this.count = 0, this.checkCount = 0, this.maxIdle = M.GC_MAX_IDLE, this.checkCountMax = M.GC_MAX_CHECK_COUNT, this.mode = M.GC_MODE
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.postrender = function () {
				this.renderer.renderingToScreen && (this.count++, this.mode !== t.GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
			}, r.prototype.run = function () {
				for (var t = this.renderer.texture, e = t.managedTextures, r = !1, i = 0; i < e.length; i++) {
					var n = e[i];
					!n.framebuffer && this.count - n.touched > this.maxIdle && (t.destroyTexture(n, !0), e[i] = null, r = !0)
				}
				if (r) {
					for (var o = 0, s = 0; s < e.length; s++) null !== e[s] && (e[o++] = e[s]);
					e.length = o
				}
			}, r.prototype.unload = function (t) {
				var e = this.renderer.textureSystem;
				t._texture && t._texture._glRenderTargets && e.destroyTexture(t._texture);
				for (var r = t.children.length - 1; r >= 0; r--) this.unload(t.children[r])
			}, r
		}(Fr),
		gn = function (t) {
			this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = 6408, this.internalFormat = 5121
		},
		yn = function (e) {
			function r(t) {
				e.call(this, t), this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Ar
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.contextChange = function () {
				var t = this.gl = this.renderer.gl;
				this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion;
				var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
				this.boundTextures.length = e;
				for (var r = 0; r < e; r++) this.boundTextures[r] = null;
				this.emptyTextures = {};
				var i = new gn(t.createTexture());
				t.bindTexture(t.TEXTURE_2D, i.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = i, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new gn(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
				for (var n = 0; n < 6; n++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
				t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
				for (var o = 0; o < this.boundTextures.length; o++) this.bind(null, o)
			}, r.prototype.bind = function (t, e) {
				void 0 === e && (e = 0);
				var r = this.gl;
				if (t) {
					if ((t = t.baseTexture || t).valid) {
						t.touched = this.renderer.textureGC.count;
						var i = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
						this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, i.texture)), i.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t
					}
				} else this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null
			}, r.prototype.reset = function () {
				this._unknownBoundTextures = !0, this.currentLocation = -1;
				for (var t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
			}, r.prototype.unbind = function (t) {
				var e = this.gl,
					r = this.boundTextures;
				if (this._unknownBoundTextures) {
					this._unknownBoundTextures = !1;
					for (var i = 0; i < r.length; i++) r[i] === this.unknownTexture && this.bind(null, i)
				}
				for (var n = 0; n < r.length; n++) r[n] === t && (this.currentLocation !== n && (e.activeTexture(e.TEXTURE0 + n), this.currentLocation = n), e.bindTexture(e.TEXTURE_2D, this.emptyTextures[t.target].texture), r[n] = null)
			}, r.prototype.initTexture = function (t) {
				var e = new gn(this.gl.createTexture());
				return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e
			}, r.prototype.initTextureType = function (e, r) {
				if (r.internalFormat = e.format, r.type = e.type, 2 === this.webGLVersion) {
					var i = this.renderer.gl;
					e.type === i.FLOAT && e.format === i.RGBA && (r.internalFormat = i.RGBA32F), e.type === t.TYPES.HALF_FLOAT && (r.type = i.HALF_FLOAT), r.type === i.HALF_FLOAT && e.format === i.RGBA && (r.internalFormat = i.RGBA16F)
				}
			}, r.prototype.updateTexture = function (t) {
				var e = t._glTextures[this.CONTEXT_UID];
				if (e) {
					var r = this.renderer;
					if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e));
					else {
						var i = t.realWidth,
							n = t.realHeight,
							o = r.gl;
						(e.width !== i || e.height !== n || e.dirtyId < 0) && (e.width = i, e.height = n, o.texImage2D(t.target, 0, e.internalFormat, i, n, 0, t.format, e.type, null))
					}
					t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId
				}
			}, r.prototype.destroyTexture = function (t, e) {
				var r = this.gl;
				if ((t = t.baseTexture || t)._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
					var i = this.managedTextures.indexOf(t); - 1 !== i && fe(this.managedTextures, i, 1)
				}
			}, r.prototype.updateTextureStyle = function (e) {
				var r = e._glTextures[this.CONTEXT_UID];
				r && (e.mipmap !== t.MIPMAP_MODES.POW2 && 2 === this.webGLVersion || e.isPowerOfTwo ? r.mipmap = e.mipmap >= 1 : r.mipmap = 0, 2 === this.webGLVersion || e.isPowerOfTwo ? r.wrapMode = e.wrapMode : r.wrapMode = t.WRAP_MODES.CLAMP, e.resource && e.resource.style(this.renderer, e, r) || this.setStyle(e, r), r.dirtyStyleId = e.dirtyStyleId)
			}, r.prototype.setStyle = function (e, r) {
				var i = this.gl;
				if (r.mipmap && i.generateMipmap(e.target), i.texParameteri(e.target, i.TEXTURE_WRAP_S, r.wrapMode), i.texParameteri(e.target, i.TEXTURE_WRAP_T, r.wrapMode), r.mipmap) {
					i.texParameteri(e.target, i.TEXTURE_MIN_FILTER, e.scaleMode === t.SCALE_MODES.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
					var n = this.renderer.context.extensions.anisotropicFiltering;
					if (n && e.anisotropicLevel > 0 && e.scaleMode === t.SCALE_MODES.LINEAR) {
						var o = Math.min(e.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
						i.texParameterf(e.target, n.TEXTURE_MAX_ANISOTROPY_EXT, o)
					}
				} else i.texParameteri(e.target, i.TEXTURE_MIN_FILTER, e.scaleMode === t.SCALE_MODES.LINEAR ? i.LINEAR : i.NEAREST);
				i.texParameteri(e.target, i.TEXTURE_MAG_FILTER, e.scaleMode === t.SCALE_MODES.LINEAR ? i.LINEAR : i.NEAREST)
			}, r
		}(Fr),
		_n = {
			FilterSystem: ai,
			BatchSystem: ui,
			ContextSystem: ci,
			FramebufferSystem: di,
			GeometrySystem: vi,
			MaskSystem: Qi,
			ScissorSystem: tn,
			StencilSystem: en,
			ProjectionSystem: rn,
			RenderTextureSystem: on,
			ShaderSystem: un,
			StateSystem: vn,
			TextureGCSystem: mn,
			TextureSystem: yn
		},
		xn = new Fe,
		bn = function (e) {
			function r(r, i) {
				e.call(this), (i = Object.assign({}, M.RENDER_OPTIONS, i)).roundPixels && (M.ROUND_PIXELS = i.roundPixels, _e("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2)), this.options = i, this.type = t.RENDERER_TYPE.UNKNOWN, this.screen = new ze(0, 0, i.width, i.height), this.view = i.view || document.createElement("canvas"), this.resolution = i.resolution || M.RESOLUTION, this.transparent = i.transparent, this.autoDensity = i.autoDensity || i.autoResize || !1, this.preserveDrawingBuffer = i.preserveDrawingBuffer, this.clearBeforeRender = i.clearBeforeRender, this._backgroundColor = 0, this._backgroundColorRgba = [0, 0, 0, 0], this._backgroundColorString = "#000000", this.backgroundColor = i.backgroundColor || this._backgroundColor, this._tempDisplayObjectParent = new tr, this._lastObjectRendered = this._tempDisplayObjectParent, this.plugins = {}
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				},
				backgroundColor: {
					configurable: !0
				}
			};
			return r.prototype.initPlugins = function (t) {
				for (var e in t) this.plugins[e] = new t[e](this)
			}, i.width.get = function () {
				return this.view.width
			}, i.height.get = function () {
				return this.view.height
			}, r.prototype.resize = function (t, e) {
				this.screen.width = t, this.screen.height = e, this.view.width = t * this.resolution, this.view.height = e * this.resolution, this.autoDensity && (this.view.style.width = t + "px", this.view.style.height = e + "px")
			}, r.prototype.generateTexture = function (t, e, r, i) {
				0 === (i = i || t.getLocalBounds()).width && (i.width = 1), 0 === i.height && (i.height = 1);
				var n = Vr.create({
					width: 0 | i.width,
					height: 0 | i.height,
					scaleMode: e,
					resolution: r
				});
				return xn.tx = -i.x, xn.ty = -i.y, this.render(t, n, !1, xn, !!t.parent), n
			}, r.prototype.destroy = function (e) {
				for (var r in this.plugins) this.plugins[r].destroy(), this.plugins[r] = null;
				e && this.view.parentNode && this.view.parentNode.removeChild(this.view), this.plugins = null, this.type = t.RENDERER_TYPE.UNKNOWN, this.view = null, this.screen = null, this.resolution = 0, this.transparent = !1, this.autoDensity = !1, this.blendModes = null, this.options = null, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !1, this._backgroundColor = 0, this._backgroundColorRgba = null, this._backgroundColorString = null, this._tempDisplayObjectParent = null, this._lastObjectRendered = null
			}, i.backgroundColor.get = function () {
				return this._backgroundColor
			}, i.backgroundColor.set = function (t) {
				this._backgroundColor = t, this._backgroundColorString = ee(t), te(t, this._backgroundColorRgba)
			}, Object.defineProperties(r.prototype, i), r
		}(R),
		En = function (e) {
			function r(i) {
				void 0 === i && (i = {}), e.call(this, "WebGL", i), i = this.options, this.type = t.RENDERER_TYPE.WEBGL, this.gl = null, this.CONTEXT_UID = 0, this.runners = {
					destroy: new _r("destroy"),
					contextChange: new _r("contextChange", 1),
					reset: new _r("reset"),
					update: new _r("update"),
					postrender: new _r("postrender"),
					prerender: new _r("prerender"),
					resize: new _r("resize", 2)
				}, this.globalUniforms = new oi({
					projectionMatrix: new Fe
				}, !0), this.addSystem(Qi, "mask").addSystem(ci, "context").addSystem(vn, "state").addSystem(un, "shader").addSystem(yn, "texture").addSystem(vi, "geometry").addSystem(di, "framebuffer").addSystem(tn, "scissor").addSystem(en, "stencil").addSystem(rn, "projection").addSystem(mn, "textureGC").addSystem(ai, "filter").addSystem(on, "renderTexture").addSystem(ui, "batch"), this.initPlugins(r.__plugins), i.context ? this.context.initFromContext(i.context) : this.context.initFromOptions({
					alpha: this.transparent,
					antialias: i.antialias,
					premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
					stencil: !0,
					preserveDrawingBuffer: i.preserveDrawingBuffer,
					powerPreference: this.options.powerPreference
				}), this.renderingToScreen = !0, Qt(2 === this.context.webGLVersion ? "WebGL 2" : "WebGL 1"), this.resize(this.options.width, this.options.height)
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.create = function (t) {
				if ($t()) return new r(t);
				throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')
			}, r.prototype.addSystem = function (t, e) {
				e || (e = t.name);
				var r = new t(this);
				if (this[e]) throw new Error('Whoops! The name "' + e + '" is already in use');
				for (var i in this[e] = r, this.runners) this.runners[i].add(r);
				return this
			}, r.prototype.render = function (t, e, r, i, n) {
				if (this.renderingToScreen = !e, this.runners.prerender.run(), this.emit("prerender"), this.projection.transform = i, !this.context.isLost) {
					if (e || (this._lastObjectRendered = t), !n) {
						var o = t.parent;
						t.parent = this._tempDisplayObjectParent, t.updateTransform(), t.parent = o
					}
					this.renderTexture.bind(e), this.batch.currentRenderer.start(), (void 0 !== r ? r : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), e && e.baseTexture.update(), this.runners.postrender.run(), this.projection.transform = null, this.emit("postrender")
				}
			}, r.prototype.resize = function (t, r) {
				e.prototype.resize.call(this, t, r), this.runners.resize.run(t, r)
			}, r.prototype.reset = function () {
				return this.runners.reset.run(), this
			}, r.prototype.clear = function () {
				this.framebuffer.bind(), this.framebuffer.clear()
			}, r.prototype.destroy = function (t) {
				for (var r in this.runners.destroy.run(), this.runners) this.runners[r].destroy();
				e.prototype.destroy.call(this, t), this.gl = null
			}, r.registerPlugin = function (t, e) {
				r.__plugins = r.__plugins || {}, r.__plugins[t] = e
			}, r
		}(bn);

	function Tn(t) {
		return En.create(t)
	}
	var wn = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",
		Sn = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
		In = function (t) {
			function e() {
				t.apply(this, arguments)
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.from = function (t, r) {
				return new e(new Cr(t, r))
			}, e
		}(Ar),
		Pn = function () {
			this.texArray = null, this.blend = 0, this.type = t.DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null
		},
		An = function () {
			this.elements = [], this.ids = [], this.count = 0
		};
	An.prototype.clear = function () {
		for (var t = 0; t < this.count; t++) this.elements[t] = null;
		this.count = 0
	};
	var On = function (t) {
			this.rawBinaryData = new ArrayBuffer(t), this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
		},
		Dn = {
			int8View: {
				configurable: !0
			},
			uint8View: {
				configurable: !0
			},
			int16View: {
				configurable: !0
			},
			uint16View: {
				configurable: !0
			},
			int32View: {
				configurable: !0
			}
		};
	Dn.int8View.get = function () {
		return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
	}, Dn.uint8View.get = function () {
		return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
	}, Dn.int16View.get = function () {
		return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
	}, Dn.uint16View.get = function () {
		return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
	}, Dn.int32View.get = function () {
		return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
	}, On.prototype.view = function (t) {
		return this[t + "View"]
	}, On.prototype.destroy = function () {
		this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
	}, On.sizeOf = function (t) {
		switch (t) {
			case "int8":
			case "uint8":
				return 1;
			case "int16":
			case "uint16":
				return 2;
			case "int32":
			case "uint32":
			case "float32":
				return 4;
			default:
				throw new Error(t + " isn't a valid view type")
		}
	}, Object.defineProperties(On.prototype, Dn);
	var Cn = function (e) {
		function r(t) {
			e.call(this, t), this.shaderGenerator = null, this.geometryClass = null, this.vertexSize = null, this.state = Gi.for2d(), this.size = 4 * M.SPRITE_BATCH_SIZE, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.MAX_TEXTURES = 1, this.renderer.on("prerender", this.onPrerender, this), t.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = []
		}
		return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.contextChange = function () {
			var e = this.renderer.gl;
			M.PREFER_ENV === t.ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), M.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = Ni(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
			for (var r = 0; r < this._packedGeometryPoolSize; r++) this._packedGeometries[r] = new this.geometryClass;
			this.initFlushBuffers()
		}, r.prototype.initFlushBuffers = function () {
			for (var t = r._drawCallPool, e = r._textureArrayPool, i = this.size / 4, n = Math.floor(i / this.MAX_TEXTURES) + 1; t.length < i;) t.push(new Pn);
			for (; e.length < n;) e.push(new An);
			for (var o = 0; o < this.MAX_TEXTURES; o++) this._tempBoundTextures[o] = null
		}, r.prototype.onPrerender = function () {
			this._flushId = 0
		}, r.prototype.render = function (t) {
			t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
		}, r.prototype.buildTexturesAndDrawCalls = function () {
			var t = this._bufferedTextures,
				e = this.MAX_TEXTURES,
				i = r._textureArrayPool,
				n = this.renderer.batch,
				o = this._tempBoundTextures,
				s = this.renderer.textureGC.count,
				a = ++Ar._globalBatch,
				h = 0,
				u = i[0],
				l = 0;
			n.copyBoundTextures(o, e);
			for (var c = 0; c < this._bufferSize; ++c) {
				var d = t[c];
				t[c] = null, d._batchEnabled !== a && (u.count >= e && (n.boundArray(u, o, a, e), this.buildDrawCalls(u, l, c), l = c, u = i[++h], ++a), d._batchEnabled = a, d.touched = s, u.elements[u.count++] = d)
			}
			u.count > 0 && (n.boundArray(u, o, a, e), this.buildDrawCalls(u, l, this._bufferSize), ++h, ++a);
			for (var p = 0; p < o.length; p++) o[p] = null;
			Ar._globalBatch = a
		}, r.prototype.buildDrawCalls = function (t, e, i) {
			var n = this._bufferedElements,
				o = this._attributeBuffer,
				s = this._indexBuffer,
				a = this.vertexSize,
				h = r._drawCallPool,
				u = this._dcIndex,
				l = this._aIndex,
				c = this._iIndex,
				d = h[u];
			d.start = this._iIndex, d.texArray = t;
			for (var p = e; p < i; ++p) {
				var f = n[p],
					v = f._texture.baseTexture,
					m = ie[v.alphaMode ? 1 : 0][f.blendMode];
				n[p] = null, e < p && d.blend !== m && (d.size = c - d.start, e = p, (d = h[++u]).texArray = t, d.start = c), this.packInterleavedGeometry(f, o, s, l, c), l += f.vertexData.length / 2 * a, c += f.indices.length, d.blend = m
			}
			e < i && (d.size = c - d.start, ++u), this._dcIndex = u, this._aIndex = l, this._iIndex = c
		}, r.prototype.bindAndClearTexArray = function (t) {
			for (var e = this.renderer.texture, r = 0; r < t.count; r++) e.bind(t.elements[r], t.ids[r]), t.elements[r] = null;
			t.count = 0
		}, r.prototype.updateGeometry = function () {
			var t = this._packedGeometries,
				e = this._attributeBuffer,
				r = this._indexBuffer;
			M.CAN_UPLOAD_SAME_BUFFER ? (t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(r), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t[this._flushId] = new this.geometryClass), t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(r), this.renderer.geometry.bind(t[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
		}, r.prototype.drawBatches = function () {
			for (var t = this._dcIndex, e = this.renderer, i = e.gl, n = e.state, o = r._drawCallPool, s = null, a = 0; a < t; a++) {
				var h = o[a],
					u = h.texArray,
					l = h.type,
					c = h.size,
					d = h.start,
					p = h.blend;
				s !== u && (s = u, this.bindAndClearTexArray(u)), this.state.blendMode = p, n.set(this.state), i.drawElements(l, c, i.UNSIGNED_SHORT, 2 * d)
			}
		}, r.prototype.flush = function () {
			0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
		}, r.prototype.start = function () {
			this.renderer.state.set(this.state), this.renderer.shader.bind(this._shader), M.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
		}, r.prototype.stop = function () {
			this.flush()
		}, r.prototype.destroy = function () {
			for (var t = 0; t < this._packedGeometryPoolSize; t++) this._packedGeometries[t] && this._packedGeometries[t].destroy();
			this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), e.prototype.destroy.call(this)
		}, r.prototype.getAttributeBuffer = function (t) {
			var e = ce(Math.ceil(t / 8)),
				r = pe(e),
				i = 8 * e;
			this._aBuffers.length <= r && (this._iBuffers.length = r + 1);
			var n = this._aBuffers[i];
			return n || (this._aBuffers[i] = n = new On(i * this.vertexSize * 4)), n
		}, r.prototype.getIndexBuffer = function (t) {
			var e = ce(Math.ceil(t / 12)),
				r = pe(e),
				i = 12 * e;
			this._iBuffers.length <= r && (this._iBuffers.length = r + 1);
			var n = this._iBuffers[r];
			return n || (this._iBuffers[r] = n = new Uint16Array(i)), n
		}, r.prototype.packInterleavedGeometry = function (t, e, r, i, n) {
			for (var o = e.uint32View, s = e.float32View, a = i / this.vertexSize, h = t.uvs, u = t.indices, l = t.vertexData, c = t._texture.baseTexture._batchLocation, d = Math.min(t.worldAlpha, 1), p = d < 1 && t._texture.baseTexture.alphaMode ? se(t._tintRGB, d) : t._tintRGB + (255 * d << 24), f = 0; f < l.length; f += 2) s[i++] = l[f], s[i++] = l[f + 1], s[i++] = h[f], s[i++] = h[f + 1], o[i++] = p, s[i++] = c;
			for (var v = 0; v < u.length; v++) r[n++] = a + u[v]
		}, r
	}(hi);
	Cn._drawCallPool = [], Cn._textureArrayPool = [];
	var Mn = function (t, e) {
		if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".');
		if (e.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".')
	};
	Mn.prototype.generateShader = function (t) {
		if (!this.programCache[t]) {
			for (var e = new Int32Array(t), r = 0; r < t; r++) e[r] = r;
			this.defaultGroupCache[t] = oi.from({
				uSamplers: e
			}, !0);
			var i = this.fragTemplate;
			i = (i = i.replace(/%count%/gi, "" + t)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new ki(this.vertexSrc, i)
		}
		var n = {
			tint: new Float32Array([1, 1, 1, 1]),
			translationMatrix: new Fe,
			default: this.defaultGroupCache[t]
		};
		return new ji(this.programCache[t], n)
	}, Mn.prototype.generateSampleSrc = function (t) {
		var e = "";
		e += "\n", e += "\n";
		for (var r = 0; r < t; r++) r > 0 && (e += "\nelse "), r < t - 1 && (e += "if(vTextureId < " + r + ".5)"), e += "\n{", e += "\n\tcolor = texture2D(uSamplers[" + r + "], vTextureCoord);", e += "\n}";
		return e += "\n", e += "\n"
	};
	var Rn = function (e) {
			function r(r) {
				void 0 === r && (r = !1), e.call(this), this._buffer = new Kr(null, r, !1), this._indexBuffer = new Kr(null, r, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, t.TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, t.TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, !0, t.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, t.TYPES.FLOAT).addIndex(this._indexBuffer)
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r
		}(ei),
		Ln = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",
		Nn = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n",
		Fn = function () {},
		Bn = {
			defaultVertexSrc: {
				configurable: !0
			},
			defaultFragmentTemplate: {
				configurable: !0
			}
		};
	Fn.create = function (t) {
		var e = Object.assign({
				vertex: Ln,
				fragment: Nn,
				geometryClass: Rn,
				vertexSize: 6
			}, t),
			r = e.vertex,
			i = e.fragment,
			n = e.vertexSize,
			o = e.geometryClass;
		return function (t) {
			function e(e) {
				t.call(this, e), this.shaderGenerator = new Mn(r, i), this.geometryClass = o, this.vertexSize = n
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
		}(Cn)
	}, Bn.defaultVertexSrc.get = function () {
		return Ln
	}, Bn.defaultFragmentTemplate.get = function () {
		return Nn
	}, Object.defineProperties(Fn, Bn);
	var Un = Fn.create(),
		kn = function t(e) {
			var r = this;
			e = Object.assign({
				forceCanvas: !1
			}, e), this.renderer = Tn(e), this.stage = new tr, t._plugins.forEach(function (t) {
				t.init.call(r, e)
			})
		},
		Xn = {
			view: {
				configurable: !0
			},
			screen: {
				configurable: !0
			}
		};
	kn.registerPlugin = function (t) {
		kn._plugins.push(t)
	}, kn.prototype.render = function () {
		this.renderer.render(this.stage)
	}, Xn.view.get = function () {
		return this.renderer.view
	}, Xn.screen.get = function () {
		return this.renderer.screen
	}, kn.prototype.destroy = function (t, e) {
		var r = this,
			i = kn._plugins.slice(0);
		i.reverse(), i.forEach(function (t) {
			t.destroy.call(r)
		}), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null, this._options = null
	}, Object.defineProperties(kn.prototype, Xn), kn._plugins = [];
	var jn = function () {};
	jn.init = function (t) {
		var e = this;
		Object.defineProperty(this, "resizeTo", {
			set: function (t) {
				window.removeEventListener("resize", this.resize), this._resizeTo = t, t && (window.addEventListener("resize", this.resize), this.resize())
			},
			get: function () {
				return this._resizeTo
			}
		}), this.resize = function () {
			e._resizeTo && (e._resizeTo === window ? e.renderer.resize(window.innerWidth, window.innerHeight) : e.renderer.resize(e._resizeTo.clientWidth, e._resizeTo.clientHeight))
		}, this._resizeTo = null, this.resizeTo = t.resizeTo || null
	}, jn.destroy = function () {
		this.resizeTo = null, this.resize = null
	}, kn.registerPlugin(jn);
	var Hn = new ze,
		Gn = function (t) {
			this.renderer = t, t.extract = this
		};
	Gn.prototype.image = function (t, e, r) {
		var i = new Image;
		return i.src = this.base64(t, e, r), i
	}, Gn.prototype.base64 = function (t, e, r) {
		return this.canvas(t).toDataURL(e, r)
	}, Gn.prototype.canvas = function (t) {
		var e, r, i, n = this.renderer,
			o = !1,
			s = !1;
		t && (t instanceof Vr ? i = t : (i = this.renderer.generateTexture(t), s = !0)), i ? (e = i.baseTexture.resolution, r = i.frame, o = !1, n.renderTexture.bind(i)) : (e = this.renderer.resolution, o = !0, (r = Hn).width = this.renderer.width, r.height = this.renderer.height, n.renderTexture.bind(null));
		var a = Math.floor(r.width * e + 1e-4),
			h = Math.floor(r.height * e + 1e-4),
			u = new Te(a, h, 1),
			l = new Uint8Array(4 * a * h),
			c = n.gl;
		c.readPixels(r.x * e, r.y * e, a, h, c.RGBA, c.UNSIGNED_BYTE, l);
		var d = u.context.getImageData(0, 0, a, h);
		if (Gn.arrayPostDivide(l, d.data), u.context.putImageData(d, 0, 0), o) {
			var p = new Te(u.width, u.height, 1);
			p.context.scale(1, -1), p.context.drawImage(u.canvas, 0, -h), u.destroy(), u = p
		}
		return s && i.destroy(!0), u.canvas
	}, Gn.prototype.pixels = function (t) {
		var e, r, i, n = this.renderer,
			o = !1;
		t && (t instanceof Vr ? i = t : (i = this.renderer.generateTexture(t), o = !0)), i ? (e = i.baseTexture.resolution, r = i.frame, n.renderTexture.bind(i)) : (e = n.resolution, (r = Hn).width = n.width, r.height = n.height, n.renderTexture.bind(null));
		var s = r.width * e,
			a = r.height * e,
			h = new Uint8Array(4 * s * a),
			u = n.gl;
		return u.readPixels(r.x * e, r.y * e, s, a, u.RGBA, u.UNSIGNED_BYTE, h), o && i.destroy(!0), Gn.arrayPostDivide(h, h), h
	}, Gn.prototype.destroy = function () {
		this.renderer.extract = null, this.renderer = null
	}, Gn.arrayPostDivide = function (t, e) {
		for (var r = 0; r < t.length; r += 4) {
			var i = e[r + 3] = t[r + 3];
			0 !== i ? (e[r] = Math.round(Math.min(255 * t[r] / i, 255)), e[r + 1] = Math.round(Math.min(255 * t[r + 1] / i, 255)), e[r + 2] = Math.round(Math.min(255 * t[r + 2] / i, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2])
		}
	};
	var Yn = function (t, e) {
			e = e || {};
			for (var r = {
					key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
					q: {
						name: "queryKey",
						parser: /(?:^|&)([^&=]*)=?([^&]*)/g
					},
					parser: {
						strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
						loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
					}
				}, i = r.parser[e.strictMode ? "strict" : "loose"].exec(t), n = {}, o = 14; o--;) n[r.key[o]] = i[o] || "";
			return n[r.q.name] = {}, n[r.key[12]].replace(r.q.parser, function (t, e, i) {
				e && (n[r.q.name][e] = i)
			}), n
		},
		Vn = function (t) {
			return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
		}(r(function (t, e) {
			Object.defineProperty(e, "__esModule", {
				value: !0
			});
			var r = function () {
				function t(t, e) {
					for (var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
					}
				}
				return function (e, r, i) {
					return r && t(e.prototype, r), i && t(e, i), e
				}
			}();

			function i(t, e) {
				if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
			}
			var n = function () {
				function t(e, r, n) {
					void 0 === r && (r = !1), i(this, t), this._fn = e, this._once = r, this._thisArg = n, this._next = this._prev = this._owner = null
				}
				return r(t, [{
					key: "detach",
					value: function () {
						return null !== this._owner && (this._owner.detach(this), !0)
					}
				}]), t
			}();

			function o(t, e) {
				return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
			}
			var s = function () {
				function t() {
					i(this, t), this._head = this._tail = void 0
				}
				return r(t, [{
					key: "handlers",
					value: function () {
						var t = !(arguments.length <= 0 || void 0 === arguments[0]) && arguments[0],
							e = this._head;
						if (t) return !!e;
						for (var r = []; e;) r.push(e), e = e._next;
						return r
					}
				}, {
					key: "has",
					value: function (t) {
						if (!(t instanceof n)) throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
						return t._owner === this
					}
				}, {
					key: "dispatch",
					value: function () {
						var t = arguments,
							e = this._head;
						if (!e) return !1;
						for (; e;) e._once && this.detach(e), e._fn.apply(e._thisArg, t), e = e._next;
						return !0
					}
				}, {
					key: "add",
					value: function (t) {
						var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
						if ("function" != typeof t) throw new Error("MiniSignal#add(): First arg must be a Function.");
						return o(this, new n(t, !1, e))
					}
				}, {
					key: "once",
					value: function (t) {
						var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
						if ("function" != typeof t) throw new Error("MiniSignal#once(): First arg must be a Function.");
						return o(this, new n(t, !0, e))
					}
				}, {
					key: "detach",
					value: function (t) {
						if (!(t instanceof n)) throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
						return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this)
					}
				}, {
					key: "detachAll",
					value: function () {
						var t = this._head;
						if (!t) return this;
						for (this._head = this._tail = null; t;) t._owner = null, t = t._next;
						return this
					}
				}]), t
			}();
			s.MiniSignalBinding = n, e.default = s, t.exports = e.default
		}));

	function zn() {}

	function Wn(t, e, r, i) {
		var n = 0,
			o = t.length;
		! function s(a) {
			a || n === o ? r && r(a) : i ? setTimeout(function () {
				e(t[n++], s)
			}, 1) : e(t[n++], s)
		}()
	}

	function qn(t) {
		return function () {
			if (null === t) throw new Error("Callback was already called.");
			var e = t;
			t = null, e.apply(this, arguments)
		}
	}

	function Kn(t, e) {
		if (null == e) e = 1;
		else if (0 === e) throw new Error("Concurrency must not be zero");
		var r = 0,
			i = {
				_tasks: [],
				concurrency: e,
				saturated: zn,
				unsaturated: zn,
				buffer: e / 4,
				empty: zn,
				drain: zn,
				error: zn,
				started: !1,
				paused: !1,
				push: function (t, e) {
					n(t, !1, e)
				},
				kill: function () {
					r = 0, i.drain = zn, i.started = !1, i._tasks = []
				},
				unshift: function (t, e) {
					n(t, !0, e)
				},
				process: function () {
					for (; !i.paused && r < i.concurrency && i._tasks.length;) {
						var e = i._tasks.shift();
						0 === i._tasks.length && i.empty(), (r += 1) === i.concurrency && i.saturated(), t(e.data, qn(o(e)))
					}
				},
				length: function () {
					return i._tasks.length
				},
				running: function () {
					return r
				},
				idle: function () {
					return i._tasks.length + r === 0
				},
				pause: function () {
					!0 !== i.paused && (i.paused = !0)
				},
				resume: function () {
					if (!1 !== i.paused) {
						i.paused = !1;
						for (var t = 1; t <= i.concurrency; t++) i.process()
					}
				}
			};

		function n(t, e, r) {
			if (null != r && "function" != typeof r) throw new Error("task callback must be a function");
			if (i.started = !0, null == t && i.idle()) setTimeout(function () {
				return i.drain()
			}, 1);
			else {
				var n = {
					data: t,
					callback: "function" == typeof r ? r : zn
				};
				e ? i._tasks.unshift(n) : i._tasks.push(n), setTimeout(function () {
					return i.process()
				}, 1)
			}
		}

		function o(t) {
			return function () {
				r -= 1, t.callback.apply(t, arguments), null != arguments[0] && i.error(arguments[0], t.data), r <= i.concurrency - i.buffer && i.unsaturated(), i.idle() && i.drain(), i.process()
			}
		}
		return i
	}
	var Zn = {};

	function Jn(t, e) {
		for (var r = 0; r < e.length; r++) {
			var i = e[r];
			i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
		}
	}

	function Qn(t, e, r) {
		return e && Jn(t.prototype, e), r && Jn(t, r), t
	}
	var $n = !(!window.XDomainRequest || "withCredentials" in new XMLHttpRequest),
		to = null;

	function eo() {}
	var ro = function () {
		function t(e, r, i) {
			if ("string" != typeof e || "string" != typeof r) throw new Error("Both name and url are required for constructing a resource.");
			i = i || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === r.indexOf("data:")), this.name = e, this.url = r, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === i.crossOrigin ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = eo, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Vn, this.onProgress = new Vn, this.onComplete = new Vn, this.onAfterMiddleware = new Vn
		}
		t.setExtensionLoadType = function (e, r) {
			io(t._loadTypeMap, e, r)
		}, t.setExtensionXhrType = function (e, r) {
			io(t._xhrTypeMap, e, r)
		};
		var e = t.prototype;
		return e.complete = function () {
			this._clearEvents(), this._finish()
		}, e.abort = function (e) {
			if (!this.error) {
				if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort();
				else if (this.xdr) this.xdr.abort();
				else if (this.data)
					if (this.data.src) this.data.src = t.EMPTY_GIF;
					else
						for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild);
				this._finish()
			}
		}, e.load = function (e) {
			var r = this;
			if (!this.isLoading)
				if (this.isComplete) e && setTimeout(function () {
					return e(r)
				}, 1);
				else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
					case t.LOAD_TYPE.IMAGE:
						this.type = t.TYPE.IMAGE, this._loadElement("image");
						break;
					case t.LOAD_TYPE.AUDIO:
						this.type = t.TYPE.AUDIO, this._loadSourceElement("audio");
						break;
					case t.LOAD_TYPE.VIDEO:
						this.type = t.TYPE.VIDEO, this._loadSourceElement("video");
						break;
					case t.LOAD_TYPE.XHR:
					default:
						$n && this.crossOrigin ? this._loadXdr() : this._loadXhr()
				}
		}, e._hasFlag = function (t) {
			return 0 != (this._flags & t)
		}, e._setFlag = function (t, e) {
			this._flags = e ? this._flags | t : this._flags & ~t
		}, e._clearEvents = function () {
			clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null))
		}, e._finish = function () {
			if (this.isComplete) throw new Error("Complete called again for an already completed resource.");
			this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this)
		}, e._loadElement = function (t) {
			this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && void 0 !== window.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
		}, e._loadSourceElement = function (t) {
			if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && void 0 !== window.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) {
				if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
					if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
					else if (Array.isArray(this.url))
					for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r) this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));
				else {
					var i = this.metadata.mimeType;
					this.data.appendChild(this._createSource(t, this.url, Array.isArray(i) ? i[0] : i))
				}
				this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
			} else this.abort("Unsupported element: " + t)
		}, e._loadXhr = function () {
			"string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
			var e = this.xhr = new XMLHttpRequest;
			e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send()
		}, e._loadXdr = function () {
			"string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
			var t = this.xhr = new XDomainRequest;
			t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function () {
				return t.send()
			}, 1)
		}, e._createSource = function (t, e, r) {
			r || (r = t + "/" + this._getExtension(e));
			var i = document.createElement("source");
			return i.src = e, i.type = r, i
		}, e._onError = function (t) {
			this.abort("Failed to load element using: " + t.target.nodeName)
		}, e._onProgress = function (t) {
			t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total)
		}, e._onTimeout = function () {
			this.abort("Load timed out.")
		}, e._xhrOnError = function () {
			var t = this.xhr;
			this.abort(no(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
		}, e._xhrOnTimeout = function () {
			var t = this.xhr;
			this.abort(no(t) + " Request timed out.")
		}, e._xhrOnAbort = function () {
			var t = this.xhr;
			this.abort(no(t) + " Request was aborted by the user.")
		}, e._xhrOnLoad = function () {
			var e = this.xhr,
				r = "",
				i = void 0 === e.status ? 200 : e.status;
			if ("" !== e.responseType && "text" !== e.responseType && void 0 !== e.responseType || (r = e.responseText), 0 === i && (r.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? i = 200 : 1223 === i && (i = 204), 2 === (i / 100 | 0)) {
				if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = r, this.type = t.TYPE.TEXT;
				else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try {
					this.data = JSON.parse(r), this.type = t.TYPE.JSON
				} catch (t) {
					return void this.abort("Error trying to parse loaded json: " + t)
				} else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try {
					if (window.DOMParser) {
						var n = new DOMParser;
						this.data = n.parseFromString(r, "text/xml")
					} else {
						var o = document.createElement("div");
						o.innerHTML = r, this.data = o
					}
					this.type = t.TYPE.XML
				} catch (t) {
					return void this.abort("Error trying to parse loaded xml: " + t)
				} else this.data = e.response || r;
				this.complete()
			} else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL)
		}, e._determineCrossOrigin = function (t, e) {
			if (0 === t.indexOf("data:")) return "";
			if (window.origin !== window.location.origin) return "anonymous";
			e = e || window.location, to || (to = document.createElement("a")), to.href = t;
			var r = !(t = Yn(to.href, {
					strictMode: !0
				})).port && "" === e.port || t.port === e.port,
				i = t.protocol ? t.protocol + ":" : "";
			return t.host === e.hostname && r && i === e.protocol ? "" : "anonymous"
		}, e._determineXhrType = function () {
			return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT
		}, e._determineLoadType = function () {
			return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR
		}, e._getExtension = function () {
			var t = this.url,
				e = "";
			if (this.isDataUrl) {
				var r = t.indexOf("/");
				e = t.substring(r + 1, t.indexOf(";", r))
			} else {
				var i = t.indexOf("?"),
					n = t.indexOf("#"),
					o = Math.min(i > -1 ? i : t.length, n > -1 ? n : t.length);
				e = (t = t.substring(0, o)).substring(t.lastIndexOf(".") + 1)
			}
			return e.toLowerCase()
		}, e._getMimeFromXhrType = function (e) {
			switch (e) {
				case t.XHR_RESPONSE_TYPE.BUFFER:
					return "application/octet-binary";
				case t.XHR_RESPONSE_TYPE.BLOB:
					return "application/blob";
				case t.XHR_RESPONSE_TYPE.DOCUMENT:
					return "application/xml";
				case t.XHR_RESPONSE_TYPE.JSON:
					return "application/json";
				case t.XHR_RESPONSE_TYPE.DEFAULT:
				case t.XHR_RESPONSE_TYPE.TEXT:
				default:
					return "text/plain"
			}
		}, Qn(t, [{
			key: "isDataUrl",
			get: function () {
				return this._hasFlag(t.STATUS_FLAGS.DATA_URL)
			}
		}, {
			key: "isComplete",
			get: function () {
				return this._hasFlag(t.STATUS_FLAGS.COMPLETE)
			}
		}, {
			key: "isLoading",
			get: function () {
				return this._hasFlag(t.STATUS_FLAGS.LOADING)
			}
		}]), t
	}();

	function io(t, e, r) {
		e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = r)
	}

	function no(t) {
		return t.toString().replace("object ", "")
	}
	ro.STATUS_FLAGS = {
		NONE: 0,
		DATA_URL: 1,
		COMPLETE: 2,
		LOADING: 4
	}, ro.TYPE = {
		UNKNOWN: 0,
		JSON: 1,
		XML: 2,
		IMAGE: 3,
		AUDIO: 4,
		VIDEO: 5,
		TEXT: 6
	}, ro.LOAD_TYPE = {
		XHR: 1,
		IMAGE: 2,
		AUDIO: 3,
		VIDEO: 4
	}, ro.XHR_RESPONSE_TYPE = {
		DEFAULT: "text",
		BUFFER: "arraybuffer",
		BLOB: "blob",
		DOCUMENT: "document",
		JSON: "json",
		TEXT: "text"
	}, ro._loadTypeMap = {
		gif: ro.LOAD_TYPE.IMAGE,
		png: ro.LOAD_TYPE.IMAGE,
		bmp: ro.LOAD_TYPE.IMAGE,
		jpg: ro.LOAD_TYPE.IMAGE,
		jpeg: ro.LOAD_TYPE.IMAGE,
		tif: ro.LOAD_TYPE.IMAGE,
		tiff: ro.LOAD_TYPE.IMAGE,
		webp: ro.LOAD_TYPE.IMAGE,
		tga: ro.LOAD_TYPE.IMAGE,
		svg: ro.LOAD_TYPE.IMAGE,
		"svg+xml": ro.LOAD_TYPE.IMAGE,
		mp3: ro.LOAD_TYPE.AUDIO,
		ogg: ro.LOAD_TYPE.AUDIO,
		wav: ro.LOAD_TYPE.AUDIO,
		mp4: ro.LOAD_TYPE.VIDEO,
		webm: ro.LOAD_TYPE.VIDEO
	}, ro._xhrTypeMap = {
		xhtml: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		html: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		htm: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		xml: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		tmx: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		svg: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		tsx: ro.XHR_RESPONSE_TYPE.DOCUMENT,
		gif: ro.XHR_RESPONSE_TYPE.BLOB,
		png: ro.XHR_RESPONSE_TYPE.BLOB,
		bmp: ro.XHR_RESPONSE_TYPE.BLOB,
		jpg: ro.XHR_RESPONSE_TYPE.BLOB,
		jpeg: ro.XHR_RESPONSE_TYPE.BLOB,
		tif: ro.XHR_RESPONSE_TYPE.BLOB,
		tiff: ro.XHR_RESPONSE_TYPE.BLOB,
		webp: ro.XHR_RESPONSE_TYPE.BLOB,
		tga: ro.XHR_RESPONSE_TYPE.BLOB,
		json: ro.XHR_RESPONSE_TYPE.JSON,
		text: ro.XHR_RESPONSE_TYPE.TEXT,
		txt: ro.XHR_RESPONSE_TYPE.TEXT,
		ttf: ro.XHR_RESPONSE_TYPE.BUFFER,
		otf: ro.XHR_RESPONSE_TYPE.BUFFER
	}, ro.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
	var oo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var so = window.URL || window.webkitURL;
	var ao = {
			caching: function (t, e) {
				var r = this;
				Zn[t.url] ? (t.data = Zn[t.url], t.complete()) : t.onComplete.once(function () {
					return Zn[r.url] = r.data
				}), e()
			},
			parsing: function (t, e) {
				if (t.data) {
					if (t.xhr && t.xhrType === ro.XHR_RESPONSE_TYPE.BLOB)
						if (window.Blob && "string" != typeof t.data) {
							if (0 === t.data.type.indexOf("image")) {
								var r = so.createObjectURL(t.data);
								return t.blob = t.data, t.data = new Image, t.data.src = r, t.type = ro.TYPE.IMAGE, void(t.data.onload = function () {
									so.revokeObjectURL(r), t.data.onload = null, e()
								})
							}
						} else {
							var i = t.xhr.getResponseHeader("content-type");
							if (i && 0 === i.indexOf("image")) return t.data = new Image, t.data.src = "data:" + i + ";base64," + function (t) {
								for (var e = "", r = 0; r < t.length;) {
									for (var i = [0, 0, 0], n = [0, 0, 0, 0], o = 0; o < i.length; ++o) r < t.length ? i[o] = 255 & t.charCodeAt(r++) : i[o] = 0;
									switch (n[0] = i[0] >> 2, n[1] = (3 & i[0]) << 4 | i[1] >> 4, n[2] = (15 & i[1]) << 2 | i[2] >> 6, n[3] = 63 & i[2], r - (t.length - 1)) {
										case 2:
											n[3] = 64, n[2] = 64;
											break;
										case 1:
											n[3] = 64
									}
									for (var s = 0; s < n.length; ++s) e += oo.charAt(n[s])
								}
								return e
							}(t.xhr.responseText), t.type = ro.TYPE.IMAGE, void(t.data.onload = function () {
								t.data.onload = null, e()
							})
						} e()
				} else e()
			}
		},
		ho = /(#[\w-]+)?$/,
		uo = function () {
			function t(e, r) {
				var i = this;
				void 0 === e && (e = ""), void 0 === r && (r = 10), this.baseUrl = e, this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) {
					return i._loadResource(t, e)
				}, this._queue = Kn(this._boundLoadResource, r), this._queue.pause(), this.resources = {}, this.onProgress = new Vn, this.onError = new Vn, this.onLoad = new Vn, this.onStart = new Vn, this.onComplete = new Vn;
				for (var n = 0; n < t._defaultBeforeMiddleware.length; ++n) this.pre(t._defaultBeforeMiddleware[n]);
				for (var o = 0; o < t._defaultAfterMiddleware.length; ++o) this.use(t._defaultAfterMiddleware[o])
			}
			var e = t.prototype;
			return e.add = function (t, e, r, i) {
				if (Array.isArray(t)) {
					for (var n = 0; n < t.length; ++n) this.add(t[n]);
					return this
				}
				if ("object" == typeof t && (i = e || t.callback || t.onComplete, r = t, e = t.url, t = t.name || t.key || t.url), "string" != typeof e && (i = r, r = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader.");
				if ("function" == typeof r && (i = r, r = null), this.loading && (!r || !r.parentResource)) throw new Error("Cannot add resources while the loader is running.");
				if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.');
				if (e = this._prepareUrl(e), this.resources[t] = new ro(t, e, r), "function" == typeof i && this.resources[t].onAfterMiddleware.once(i), this.loading) {
					for (var o = r.parentResource, s = [], a = 0; a < o.children.length; ++a) o.children[a].isComplete || s.push(o.children[a]);
					var h = o.progressChunk * (s.length + 1) / (s.length + 2);
					o.children.push(this.resources[t]), o.progressChunk = h;
					for (var u = 0; u < s.length; ++u) s[u].progressChunk = h;
					this.resources[t].progressChunk = h
				}
				return this._queue.push(this.resources[t]), this
			}, e.pre = function (t) {
				return this._beforeMiddleware.push(t), this
			}, e.use = function (t) {
				return this._afterMiddleware.push(t), this
			}, e.reset = function () {
				for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) {
					var e = this.resources[t];
					e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort()
				}
				return this.resources = {}, this
			}, e.load = function (t) {
				if ("function" == typeof t && this.onComplete.once(t), this.loading) return this;
				if (this._queue.idle()) this._onStart(), this._onComplete();
				else {
					for (var e = 100 / this._queue._tasks.length, r = 0; r < this._queue._tasks.length; ++r) this._queue._tasks[r].data.progressChunk = e;
					this._onStart(), this._queue.resume()
				}
				return this
			}, e._prepareUrl = function (t) {
				var e, r = Yn(t, {
					strictMode: !0
				});
				if (e = r.protocol || !r.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) {
					var i = ho.exec(e)[0]; - 1 !== (e = e.substr(0, e.length - i.length)).indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += i
				}
				return e
			}, e._loadResource = function (t, e) {
				var r = this;
				t._dequeue = e, Wn(this._beforeMiddleware, function (e, i) {
					e.call(r, t, function () {
						i(t.isComplete ? {} : null)
					})
				}, function () {
					t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load())
				}, !0)
			}, e._onStart = function () {
				this.progress = 0, this.loading = !0, this.onStart.dispatch(this)
			}, e._onComplete = function () {
				this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources)
			}, e._onLoad = function (t) {
				var e = this;
				t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), Wn(this._afterMiddleware, function (r, i) {
					r.call(e, t, i)
				}, function () {
					t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete()
				}, !0)
			}, Qn(t, [{
				key: "concurrency",
				get: function () {
					return this._queue.concurrency
				},
				set: function (t) {
					this._queue.concurrency = t
				}
			}]), t
		}();
	uo._defaultBeforeMiddleware = [], uo._defaultAfterMiddleware = [], uo.pre = function (t) {
		return uo._defaultBeforeMiddleware.push(t), uo
	}, uo.use = function (t) {
		return uo._defaultAfterMiddleware.push(t), uo
	};
	var lo = function () {};
	lo.use = function (t, e) {
		t.data && t.type === ro.TYPE.IMAGE && (t.texture = Gr.fromLoader(t.data, t.url, t.name)), e()
	};
	var co = function (t) {
		function e(r, i) {
			var n = this;
			t.call(this, r, i), R.call(this);
			for (var o = 0; o < e._plugins.length; ++o) {
				var s = e._plugins[o],
					a = s.pre,
					h = s.use;
				a && this.pre(a), h && this.use(h)
			}
			this.onStart.add(function (t) {
				return n.emit("start", t)
			}), this.onProgress.add(function (t, e) {
				return n.emit("progress", t, e)
			}), this.onError.add(function (t, e, r) {
				return n.emit("error", t, e, r)
			}), this.onLoad.add(function (t, e) {
				return n.emit("load", t, e)
			}), this.onComplete.add(function (t, e) {
				return n.emit("complete", t, e)
			}), this._protected = !1
		}
		t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
		var r = {
			shared: {
				configurable: !0
			}
		};
		return e.prototype.destroy = function () {
			this._protected || (this.removeAllListeners(), this.reset())
		}, r.shared.get = function () {
			var t = e._shared;
			return t || ((t = new e)._protected = !0, e._shared = t), t
		}, Object.defineProperties(e, r), e
	}(uo);
	Object.assign(co.prototype, R.prototype), co._plugins = [], co.registerPlugin = function (t) {
		return co._plugins.push(t), t.add && t.add(), co
	}, co.registerPlugin({
		use: ao.parsing
	}), co.registerPlugin(lo);
	var po = function () {};
	po.init = function (t) {
		t = Object.assign({
			sharedLoader: !1
		}, t), this.loader = t.sharedLoader ? co.shared : new co
	}, po.destroy = function () {
		this.loader && (this.loader.destroy(), this.loader = null)
	};
	var fo = ro,
		vo = function (e) {
			function r(r, i, n, o) {
				void 0 === r && (r = 1500), void 0 === n && (n = 16384), void 0 === o && (o = !1), e.call(this);
				n > 16384 && (n = 16384), this._properties = [!1, !0, !1, !1, !1], this._maxSize = r, this._batchSize = n, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = t.BLEND_MODES.NORMAL, this.autoResize = o, this.roundPixels = !0, this.baseTexture = null, this.setProperties(i), this._tint = 0, this.tintRgb = new Float32Array(4), this.tint = 16777215
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				tint: {
					configurable: !0
				}
			};
			return r.prototype.setProperties = function (t) {
				t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
			}, r.prototype.updateTransform = function () {
				this.displayObjectUpdateTransform()
			}, i.tint.get = function () {
				return this._tint
			}, i.tint.set = function (t) {
				this._tint = t, te(t, this.tintRgb)
			}, r.prototype.render = function (t) {
				var e = this;
				this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function () {
					return e.onChildrenChange(0)
				})), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
			}, r.prototype.onChildrenChange = function (t) {
				for (var e = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < e;) this._bufferUpdateIDs.push(0);
				this._bufferUpdateIDs[e] = ++this._updateID
			}, r.prototype.dispose = function () {
				if (this._buffers) {
					for (var t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
					this._buffers = null
				}
			}, r.prototype.destroy = function (t) {
				e.prototype.destroy.call(this, t), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
			}, Object.defineProperties(r.prototype, i), r
		}(tr),
		mo = function (e, r, i) {
			this.geometry = new ei, this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
			for (var n = 0; n < e.length; ++n) {
				var o = e[n];
				o = {
					attributeName: o.attributeName,
					size: o.size,
					uploadFunction: o.uploadFunction,
					type: o.type || t.TYPES.FLOAT,
					offset: o.offset
				}, r[n] ? this.dynamicProperties.push(o) : this.staticProperties.push(o)
			}
			this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
		};
	mo.prototype.initBuffers = function () {
		var e = this.geometry,
			r = 0;
		this.indexBuffer = new Kr(he(this.size), !0, !0), e.addIndex(this.indexBuffer), this.dynamicStride = 0;
		for (var i = 0; i < this.dynamicProperties.length; ++i) {
			var n = this.dynamicProperties[i];
			n.offset = r, r += n.size, this.dynamicStride += n.size
		}
		var o = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
		this.dynamicData = new Float32Array(o), this.dynamicDataUint32 = new Uint32Array(o), this.dynamicBuffer = new Kr(this.dynamicData, !1, !1);
		var s = 0;
		this.staticStride = 0;
		for (var a = 0; a < this.staticProperties.length; ++a) {
			var h = this.staticProperties[a];
			h.offset = s, s += h.size, this.staticStride += h.size
		}
		var u = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
		this.staticData = new Float32Array(u), this.staticDataUint32 = new Uint32Array(u), this.staticBuffer = new Kr(this.staticData, !0, !1);
		for (var l = 0; l < this.dynamicProperties.length; ++l) {
			var c = this.dynamicProperties[l];
			e.addAttribute(c.attributeName, this.dynamicBuffer, 0, c.type === t.TYPES.UNSIGNED_BYTE, c.type, 4 * this.dynamicStride, 4 * c.offset)
		}
		for (var d = 0; d < this.staticProperties.length; ++d) {
			var p = this.staticProperties[d];
			e.addAttribute(p.attributeName, this.staticBuffer, 0, p.type === t.TYPES.UNSIGNED_BYTE, p.type, 4 * this.staticStride, 4 * p.offset)
		}
	}, mo.prototype.uploadDynamic = function (e, r, i) {
		for (var n = 0; n < this.dynamicProperties.length; n++) {
			var o = this.dynamicProperties[n];
			o.uploadFunction(e, r, i, o.type === t.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, o.offset)
		}
		this.dynamicBuffer._updateID++
	}, mo.prototype.uploadStatic = function (e, r, i) {
		for (var n = 0; n < this.staticProperties.length; n++) {
			var o = this.staticProperties[n];
			o.uploadFunction(e, r, i, o.type === t.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, o.offset)
		}
		this.staticBuffer._updateID++
	}, mo.prototype.destroy = function () {
		this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
	};
	var go = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n",
		yo = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}",
		_o = function (e) {
			function r(r) {
				e.call(this, r), this.shader = null, this.properties = null, this.tempMatrix = new Fe, this.properties = [{
					attributeName: "aVertexPosition",
					size: 2,
					uploadFunction: this.uploadVertices,
					offset: 0
				}, {
					attributeName: "aPositionCoord",
					size: 2,
					uploadFunction: this.uploadPosition,
					offset: 0
				}, {
					attributeName: "aRotation",
					size: 1,
					uploadFunction: this.uploadRotation,
					offset: 0
				}, {
					attributeName: "aTextureCoord",
					size: 2,
					uploadFunction: this.uploadUvs,
					offset: 0
				}, {
					attributeName: "aColor",
					size: 1,
					type: t.TYPES.UNSIGNED_BYTE,
					uploadFunction: this.uploadTint,
					offset: 0
				}], this.shader = ji.from(go, yo, {}), this.state = Gi.for2d()
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.render = function (t) {
				var e = t.children,
					r = t._maxSize,
					i = t._batchSize,
					n = this.renderer,
					o = e.length;
				if (0 !== o) {
					o > r && !t.autoResize && (o = r);
					var s = t._buffers;
					s || (s = t._buffers = this.generateBuffers(t));
					var a = e[0]._texture.baseTexture;
					this.state.blendMode = ne(t.blendMode, a.alphaMode), n.state.set(this.state);
					var h = n.gl,
						u = t.worldTransform.copyTo(this.tempMatrix);
					u.prepend(n.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = u.toArray(!0), this.shader.uniforms.uColor = oe(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, a.alphaMode), this.shader.uniforms.uSampler = a, this.renderer.shader.bind(this.shader);
					for (var l = !1, c = 0, d = 0; c < o; c += i, d += 1) {
						var p = o - c;
						p > i && (p = i), d >= s.length && s.push(this._generateOneMoreBuffer(t));
						var f = s[d];
						f.uploadDynamic(e, c, p);
						var v = t._bufferUpdateIDs[d] || 0;
						(l = l || f._updateID < v) && (f._updateID = t._updateID, f.uploadStatic(e, c, p)), n.geometry.bind(f.geometry), h.drawElements(h.TRIANGLES, 6 * p, h.UNSIGNED_SHORT, 0)
					}
				}
			}, r.prototype.generateBuffers = function (t) {
				for (var e = [], r = t._maxSize, i = t._batchSize, n = t._properties, o = 0; o < r; o += i) e.push(new mo(this.properties, n, i));
				return e
			}, r.prototype._generateOneMoreBuffer = function (t) {
				var e = t._batchSize,
					r = t._properties;
				return new mo(this.properties, r, e)
			}, r.prototype.uploadVertices = function (t, e, r, i, n, o) {
				for (var s = 0, a = 0, h = 0, u = 0, l = 0; l < r; ++l) {
					var c = t[e + l],
						d = c._texture,
						p = c.scale.x,
						f = c.scale.y,
						v = d.trim,
						m = d.orig;
					v ? (s = (a = v.x - c.anchor.x * m.width) + v.width, h = (u = v.y - c.anchor.y * m.height) + v.height) : (s = m.width * (1 - c.anchor.x), a = m.width * -c.anchor.x, h = m.height * (1 - c.anchor.y), u = m.height * -c.anchor.y), i[o] = a * p, i[o + 1] = u * f, i[o + n] = s * p, i[o + n + 1] = u * f, i[o + 2 * n] = s * p, i[o + 2 * n + 1] = h * f, i[o + 3 * n] = a * p, i[o + 3 * n + 1] = h * f, o += 4 * n
				}
			}, r.prototype.uploadPosition = function (t, e, r, i, n, o) {
				for (var s = 0; s < r; s++) {
					var a = t[e + s].position;
					i[o] = a.x, i[o + 1] = a.y, i[o + n] = a.x, i[o + n + 1] = a.y, i[o + 2 * n] = a.x, i[o + 2 * n + 1] = a.y, i[o + 3 * n] = a.x, i[o + 3 * n + 1] = a.y, o += 4 * n
				}
			}, r.prototype.uploadRotation = function (t, e, r, i, n, o) {
				for (var s = 0; s < r; s++) {
					var a = t[e + s].rotation;
					i[o] = a, i[o + n] = a, i[o + 2 * n] = a, i[o + 3 * n] = a, o += 4 * n
				}
			}, r.prototype.uploadUvs = function (t, e, r, i, n, o) {
				for (var s = 0; s < r; ++s) {
					var a = t[e + s]._texture._uvs;
					a ? (i[o] = a.x0, i[o + 1] = a.y0, i[o + n] = a.x1, i[o + n + 1] = a.y1, i[o + 2 * n] = a.x2, i[o + 2 * n + 1] = a.y2, i[o + 3 * n] = a.x3, i[o + 3 * n + 1] = a.y3, o += 4 * n) : (i[o] = 0, i[o + 1] = 0, i[o + n] = 0, i[o + n + 1] = 0, i[o + 2 * n] = 0, i[o + 2 * n + 1] = 0, i[o + 3 * n] = 0, i[o + 3 * n + 1] = 0, o += 4 * n)
				}
			}, r.prototype.uploadTint = function (t, e, r, i, n, o) {
				for (var s = 0; s < r; ++s) {
					var a = t[e + s],
						h = a._texture.baseTexture.alphaMode > 0,
						u = a.alpha,
						l = u < 1 && h ? se(a._tintRGB, u) : a._tintRGB + (255 * u << 24);
					i[o] = l, i[o + n] = l, i[o + 2 * n] = l, i[o + 3 * n] = l, o += 4 * n
				}
			}, r.prototype.destroy = function () {
				e.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
			}, r
		}(hi),
		xo = {
			adaptive: !0,
			maxLength: 10,
			minSegments: 8,
			maxSegments: 2048,
			_segmentsCount: function (t, e) {
				if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e;
				var r = Math.ceil(t / this.maxLength);
				return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments), r
			}
		},
		bo = function () {
			this.reset()
		};
	bo.prototype.clone = function () {
		var t = new bo;
		return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t
	}, bo.prototype.reset = function () {
		this.color = 16777215, this.alpha = 1, this.texture = Gr.WHITE, this.matrix = null, this.visible = !1
	}, bo.prototype.destroy = function () {
		this.texture = null, this.matrix = null
	};
	var Eo = {
			build: function (t) {
				t.points = t.shape.points.slice()
			},
			triangulate: function (t, e) {
				var r = t.points,
					i = t.holes,
					n = e.points,
					o = e.indices;
				if (r.length >= 6) {
					for (var s = [], a = 0; a < i.length; a++) {
						var h = i[a];
						s.push(r.length / 2), r = r.concat(h.points)
					}
					var u = L(r, s, 2);
					if (!u) return;
					for (var l = n.length / 2, c = 0; c < u.length; c += 3) o.push(u[c] + l), o.push(u[c + 1] + l), o.push(u[c + 2] + l);
					for (var d = 0; d < r.length; d++) n.push(r[d])
				}
			}
		},
		To = {
			build: function (e) {
				var r, i, n = e.shape,
					o = e.points,
					s = n.x,
					a = n.y;
				if (o.length = 0, e.type === t.SHAPES.CIRC ? (r = n.radius, i = n.radius) : (r = n.width, i = n.height), 0 !== r && 0 !== i) {
					var h = Math.floor(30 * Math.sqrt(n.radius)) || Math.floor(15 * Math.sqrt(n.width + n.height));
					h /= 2.3;
					for (var u = 2 * Math.PI / h, l = 0; l < h - .5; l++) o.push(s + Math.sin(-u * l) * r, a + Math.cos(-u * l) * i);
					o.push(o[0], o[1])
				}
			},
			triangulate: function (t, e) {
				var r = t.points,
					i = e.points,
					n = e.indices,
					o = i.length / 2,
					s = o,
					a = t.shape,
					h = t.matrix,
					u = a.x,
					l = a.y;
				i.push(t.matrix ? h.a * u + h.c * l + h.tx : u, t.matrix ? h.b * u + h.d * l + h.ty : l);
				for (var c = 0; c < r.length; c += 2) i.push(r[c], r[c + 1]), n.push(o++, s, o)
			}
		},
		wo = {
			build: function (t) {
				var e = t.shape,
					r = e.x,
					i = e.y,
					n = e.width,
					o = e.height,
					s = t.points;
				s.length = 0, s.push(r, i, r + n, i, r + n, i + o, r, i + o)
			},
			triangulate: function (t, e) {
				var r = t.points,
					i = e.points,
					n = i.length / 2;
				i.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]), e.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3)
			}
		},
		So = {
			build: function (t) {
				var e = t.shape,
					r = t.points,
					i = e.x,
					n = e.y,
					o = e.width,
					s = e.height,
					a = Math.max(0, Math.min(e.radius, Math.min(o, s) / 2));
				r.length = 0, a ? (Po(i, n + a, i, n, i + a, n, r), Po(i + o - a, n, i + o, n, i + o, n + a, r), Po(i + o, n + s - a, i + o, n + s, i + o - a, n + s, r), Po(i + a, n + s, i, n + s, i, n + s - a, r)) : r.push(i, n, i + o, n, i + o, n + s, i, n + s)
			},
			triangulate: function (t, e) {
				for (var r = t.points, i = e.points, n = e.indices, o = i.length / 2, s = L(r, null, 2), a = 0, h = s.length; a < h; a += 3) n.push(s[a] + o), n.push(s[a + 1] + o), n.push(s[a + 2] + o);
				for (var u = 0, l = r.length; u < l; u++) i.push(r[u], r[++u])
			}
		};

	function Io(t, e, r) {
		return t + (e - t) * r
	}

	function Po(t, e, r, i, n, o, s) {
		void 0 === s && (s = []);
		for (var a = s, h = 0, u = 0, l = 0, c = 0, d = 0, p = 0, f = 0, v = 0; f <= 20; ++f) h = Io(t, r, v = f / 20), u = Io(e, i, v), l = Io(r, n, v), c = Io(i, o, v), d = Io(h, l, v), p = Io(u, c, v), a.push(d, p);
		return a
	}

	function Ao(e, r) {
		e.lineStyle.native ? function (e, r) {
			var i = 0,
				n = e.shape,
				o = e.points || n.points,
				s = n.type !== t.SHAPES.POLY || n.closeStroke;
			if (0 === o.length) return;
			var a = r.points,
				h = r.indices,
				u = o.length / 2,
				l = a.length / 2,
				c = l;
			for (a.push(o[0], o[1]), i = 1; i < u; i++) a.push(o[2 * i], o[2 * i + 1]), h.push(c, c + 1), c++;
			s && h.push(c, l)
		}(e, r) : function (e, r) {
			var i = e.shape,
				n = e.points || i.points.slice(),
				o = r.closePointEps;
			if (0 === n.length) return;
			var s = e.lineStyle,
				a = new Ce(n[0], n[1]),
				h = new Ce(n[n.length - 2], n[n.length - 1]),
				u = i.type !== t.SHAPES.POLY || i.closeStroke,
				l = Math.abs(a.x - h.x) < o && Math.abs(a.y - h.y) < o;
			if (u) {
				n = n.slice(), l && (n.pop(), n.pop(), h.set(n[n.length - 2], n[n.length - 1]));
				var c = h.x + .5 * (a.x - h.x),
					d = h.y + .5 * (a.y - h.y);
				n.unshift(c, d), n.push(c, d)
			}
			var p = r.points,
				f = n.length / 2,
				v = n.length,
				m = p.length / 2,
				g = s.width / 2,
				y = n[0],
				_ = n[1],
				x = n[2],
				b = n[3],
				E = 0,
				T = 0,
				w = -(_ - b),
				S = y - x,
				I = 0,
				P = 0,
				A = 0,
				O = 0,
				D = Math.sqrt(w * w + S * S);
			w /= D, S /= D, w *= g, S *= g;
			var C = s.alignment,
				M = 2 * (1 - C),
				R = 2 * C;
			p.push(y - w * M, _ - S * M), p.push(y + w * R, _ + S * R);
			for (var L = 1; L < f - 1; ++L) {
				y = n[2 * (L - 1)], _ = n[2 * (L - 1) + 1], x = n[2 * L], b = n[2 * L + 1], E = n[2 * (L + 1)], T = n[2 * (L + 1) + 1], w = -(_ - b), S = y - x, D = Math.sqrt(w * w + S * S), w /= D, S /= D, w *= g, S *= g, I = -(b - T), P = x - E, D = Math.sqrt(I * I + P * P), I /= D, P /= D;
				var N = -S + _ - (-S + b),
					F = -w + x - (-w + y),
					B = (-w + y) * (-S + b) - (-w + x) * (-S + _),
					U = -(P *= g) + T - (-P + b),
					k = -(I *= g) + x - (-I + E),
					X = (-I + E) * (-P + b) - (-I + x) * (-P + T),
					j = N * k - U * F;
				if (Math.abs(j) < .1) j += 10.1, p.push(x - w * M, b - S * M), p.push(x + w * R, b + S * R);
				else {
					var H = (F * X - k * B) / j,
						G = (U * B - N * X) / j,
						Y = (H - x) * (H - x) + (G - b) * (G - b);
					Y > 196 * g * g ? (A = w - I, O = S - P, D = Math.sqrt(A * A + O * O), A /= D, O /= D, A *= g, O *= g, p.push(x - A * M, b - O * M), p.push(x + A * R, b + O * R), p.push(x - A * R * M, b - O * M), v++) : (p.push(x + (H - x) * M, b + (G - b) * M), p.push(x - (H - x) * R, b - (G - b) * R))
				}
			}
			y = n[2 * (f - 2)], _ = n[2 * (f - 2) + 1], x = n[2 * (f - 1)], b = n[2 * (f - 1) + 1], w = -(_ - b), S = y - x, D = Math.sqrt(w * w + S * S), w /= D, S /= D, w *= g, S *= g, p.push(x - w * M, b - S * M), p.push(x + w * R, b + S * R);
			for (var V = r.indices, z = 0; z < v - 2; ++z) V.push(m, m + 1, m + 2), m++
		}(e, r)
	}
	var Oo = function (t) {
			function e(e, r, i, n, o, s) {
				o = o || n / 2;
				for (var a = -1 * Math.PI / 2 + s, h = 2 * i, u = Re / h, l = [], c = 0; c < h; c++) {
					var d = c % 2 ? o : n,
						p = c * u + a;
					l.push(e + d * Math.cos(p), r + d * Math.sin(p))
				}
				t.call(this, l)
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
		}(Ke),
		Do = function () {};
	Do.curveTo = function (t, e, r, i, n, o) {
		var s = o[o.length - 2],
			a = o[o.length - 1] - e,
			h = s - t,
			u = i - e,
			l = r - t,
			c = Math.abs(a * l - h * u);
		if (c < 1e-8 || 0 === n) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null;
		var d = a * a + h * h,
			p = u * u + l * l,
			f = a * u + h * l,
			v = n * Math.sqrt(d) / c,
			m = n * Math.sqrt(p) / c,
			g = v * f / d,
			y = m * f / p,
			_ = v * l + m * h,
			x = v * u + m * a,
			b = h * (m + g),
			E = a * (m + g),
			T = l * (v + y),
			w = u * (v + y);
		return {
			cx: _ + t,
			cy: x + e,
			radius: n,
			startAngle: Math.atan2(E - x, b - _),
			endAngle: Math.atan2(w - x, T - _),
			anticlockwise: h * u > l * a
		}
	}, Do.arc = function (t, e, r, i, n, o, s, a, h) {
		for (var u = s - o, l = xo._segmentsCount(Math.abs(u) * n, 40 * Math.ceil(Math.abs(u) / Re)), c = u / (2 * l), d = 2 * c, p = Math.cos(c), f = Math.sin(c), v = l - 1, m = v % 1 / v, g = 0; g <= v; ++g) {
			var y = c + o + d * (g + m * g),
				_ = Math.cos(y),
				x = -Math.sin(y);
			h.push((p * _ + f * x) * n + r, (p * -x + f * _) * n + i)
		}
	};
	var Co = function () {};
	Co.curveLength = function (t, e, r, i, n, o, s, a) {
		for (var h = 0, u = 0, l = 0, c = 0, d = 0, p = 0, f = 0, v = 0, m = 0, g = 0, y = 0, _ = t, x = e, b = 1; b <= 10; ++b) g = _ - (v = (f = (p = (d = 1 - (u = b / 10)) * d) * d) * t + 3 * p * u * r + 3 * d * (l = u * u) * n + (c = l * u) * s), y = x - (m = f * e + 3 * p * u * i + 3 * d * l * o + c * a), _ = v, x = m, h += Math.sqrt(g * g + y * y);
		return h
	}, Co.curveTo = function (t, e, r, i, n, o, s) {
		var a = s[s.length - 2],
			h = s[s.length - 1];
		s.length -= 2;
		var u = xo._segmentsCount(Co.curveLength(a, h, t, e, r, i, n, o)),
			l = 0,
			c = 0,
			d = 0,
			p = 0,
			f = 0;
		s.push(a, h);
		for (var v = 1, m = 0; v <= u; ++v) d = (c = (l = 1 - (m = v / u)) * l) * l, f = (p = m * m) * m, s.push(d * a + 3 * c * m * t + 3 * l * p * r + f * n, d * h + 3 * c * m * e + 3 * l * p * i + f * o)
	};
	var Mo = function () {};
	Mo.curveLength = function (t, e, r, i, n, o) {
		var s = t - 2 * r + n,
			a = e - 2 * i + o,
			h = 2 * r - 2 * t,
			u = 2 * i - 2 * e,
			l = 4 * (s * s + a * a),
			c = 4 * (s * h + a * u),
			d = h * h + u * u,
			p = 2 * Math.sqrt(l + c + d),
			f = Math.sqrt(l),
			v = 2 * l * f,
			m = 2 * Math.sqrt(d),
			g = c / f;
		return (v * p + f * c * (p - m) + (4 * d * l - c * c) * Math.log((2 * f + g + p) / (g + m))) / (4 * v)
	}, Mo.curveTo = function (t, e, r, i, n) {
		for (var o = n[n.length - 2], s = n[n.length - 1], a = xo._segmentsCount(Mo.curveLength(o, s, t, e, r, i)), h = 0, u = 0, l = 1; l <= a; ++l) {
			var c = l / a;
			h = o + (t - o) * c, u = s + (e - s) * c, n.push(h + (t + (r - t) * c - h) * c, u + (e + (i - e) * c - u) * c)
		}
	};
	var Ro = function () {
		this.reset()
	};
	Ro.prototype.begin = function (t, e, r) {
		this.reset(), this.style = t, this.start = e, this.attribStart = r
	}, Ro.prototype.end = function (t, e) {
		this.attribSize = e - this.attribStart, this.size = t - this.start
	}, Ro.prototype.reset = function () {
		this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
	};
	var Lo = {};
	Lo[t.SHAPES.POLY] = Eo, Lo[t.SHAPES.CIRC] = To, Lo[t.SHAPES.ELIP] = To, Lo[t.SHAPES.RECT] = wo, Lo[t.SHAPES.RREC] = So;
	var No = [],
		Fo = [],
		Bo = {
			buildPoly: Eo,
			buildCircle: To,
			buildRectangle: wo,
			buildRoundedRectangle: So,
			FILL_COMMANDS: Lo,
			BATCH_POOL: No,
			DRAW_CALL_POOL: Fo,
			buildLine: Ao,
			buildComplexPoly: function (t, e) {
				var r = t.points.slice();
				if (!(r.length < 6)) {
					var i = e.indices;
					e.points = r, e.alpha = t.fillAlpha, e.color = te(t.fillColor);
					for (var n = 1 / 0, o = -1 / 0, s = 1 / 0, a = -1 / 0, h = 0, u = 0, l = 0; l < r.length; l += 2) n = (h = r[l]) < n ? h : n, o = h > o ? h : o, s = (u = r[l + 1]) < s ? u : s, a = u > a ? u : a;
					r.push(n, s, o, s, o, a, n, a);
					for (var c = r.length / 2, d = 0; d < c; d++) i.push(d)
				}
			},
			bezierCurveTo: function (t, e, r, i, n, o, s, a, h, u) {
				void 0 === u && (u = []);
				var l = 0,
					c = 0,
					d = 0,
					p = 0,
					f = 0;
				u.push(t, e);
				for (var v = 1, m = 0; v <= h; ++v) d = (c = (l = 1 - (m = v / h)) * l) * l, f = (p = m * m) * m, u.push(d * t + 3 * c * m * r + 3 * l * p * n + f * s, d * e + 3 * c * m * i + 3 * l * p * o + f * a);
				return u
			},
			Star: Oo,
			ArcUtils: Do,
			BezierUtils: Co,
			QuadraticUtils: Mo,
			BatchPart: Ro
		},
		Uo = function (t, e, r, i) {
			void 0 === e && (e = null), void 0 === r && (r = null), void 0 === i && (i = null), this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = i, this.type = t.type, this.points = [], this.holes = []
		};
	Uo.prototype.clone = function () {
		return new Uo(this.shape, this.fillStyle, this.lineStyle, this.matrix)
	}, Uo.prototype.destroy = function () {
		this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
	};
	var ko = new Ce,
		Xo = new Je,
		jo = function (e) {
			function r() {
				e.call(this), this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.dirty = 0, this.batchDirty = -1, this.cacheDirty = -1, this.clearDirty = 0, this.drawCalls = [], this.batches = [], this.shapeIndex = 0, this._bounds = new Je, this.boundsDirty = -1, this.boundsPadding = 0, this.batchable = !1, this.indicesUint16 = null, this.uvsFloat32 = null, this.closePointEps = 1e-4
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				bounds: {
					configurable: !0
				}
			};
			return i.bounds.get = function () {
				return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
			}, r.prototype.invalidate = function () {
				this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
				for (var t = 0; t < this.drawCalls.length; t++) this.drawCalls[t].textures.length = 0, Fo.push(this.drawCalls[t]);
				this.drawCalls.length = 0;
				for (var e = 0; e < this.batches.length; e++) {
					var r = this.batches[e];
					r.reset(), No.push(r)
				}
				this.batches.length = 0
			}, r.prototype.clear = function () {
				return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
			}, r.prototype.drawShape = function (t, e, r, i) {
				var n = new Uo(t, e, r, i);
				return this.graphicsData.push(n), this.dirty++, this
			}, r.prototype.drawHole = function (t, e) {
				if (!this.graphicsData.length) return null;
				var r = new Uo(t, null, null, e),
					i = this.graphicsData[this.graphicsData.length - 1];
				return r.lineStyle = i.lineStyle, i.holes.push(r), this.dirty++, this
			}, r.prototype.destroy = function (t) {
				e.prototype.destroy.call(this, t);
				for (var r = 0; r < this.graphicsData.length; ++r) this.graphicsData[r].destroy();
				this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
			}, r.prototype.containsPoint = function (t) {
				for (var e = this.graphicsData, r = 0; r < e.length; ++r) {
					var i = e[r];
					if (i.fillStyle.visible && (i.shape && (i.matrix ? i.matrix.applyInverse(t, ko) : ko.copyFrom(t), i.shape.contains(ko.x, ko.y)))) {
						var n = !1;
						if (i.holes)
							for (var o = 0; o < i.holes.length; o++) {
								if (i.holes[o].shape.contains(ko.x, ko.y)) {
									n = !0;
									break
								}
							}
						if (!n) return !0
					}
				}
				return !1
			}, r.prototype.updateBatches = function () {
				if (this.graphicsData.length) {
					if (this.validateBatching()) {
						this.cacheDirty = this.dirty;
						var e = this.uvs,
							r = this.graphicsData,
							i = null,
							n = null;
						this.batches.length > 0 && (n = (i = this.batches[this.batches.length - 1]).style);
						for (var o = this.shapeIndex; o < r.length; o++) {
							this.shapeIndex++;
							var s = r[o],
								a = s.fillStyle,
								h = s.lineStyle;
							Lo[s.type].build(s), s.matrix && this.transformPoints(s.points, s.matrix);
							for (var u = 0; u < 2; u++) {
								var l = 0 === u ? a : h;
								if (l.visible) {
									var c = l.texture.baseTexture,
										d = this.indices.length,
										p = this.points.length / 2;
									c.wrapMode = t.WRAP_MODES.REPEAT, 0 === u ? this.processFill(s) : this.processLine(s);
									var f = this.points.length / 2 - p;
									0 !== f && (i && !this._compareStyles(n, l) && (i.end(d, p), i = null), i || ((i = No.pop() || new Ro).begin(l, d, p), this.batches.push(i), n = l), this.addUvs(this.points, e, l.texture, p, f, l.matrix))
								}
							}
						}
						if (i) {
							var v = this.indices.length,
								m = this.points.length / 2;
							i.end(v, m)
						}
						0 !== this.batches.length ? (this.indicesUint16 = new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()) : this.batchable = !0
					}
				} else this.batchable = !0
			}, r.prototype._compareStyles = function (t, e) {
				return !(!t || !e) && (t.texture.baseTexture === e.texture.baseTexture && (t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native))
			}, r.prototype.validateBatching = function () {
				if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
				for (var t = 0, e = this.graphicsData.length; t < e; t++) {
					var r = this.graphicsData[t],
						i = r.fillStyle,
						n = r.lineStyle;
					if (i && !i.texture.baseTexture.valid) return !1;
					if (n && !n.texture.baseTexture.valid) return !1
				}
				return !0
			}, r.prototype.packBatches = function () {
				this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
				for (var t = this.batches, e = 0, r = t.length; e < r; e++)
					for (var i = t[e], n = 0; n < i.size; n++) {
						var o = i.start + n;
						this.indicesUint16[o] = this.indicesUint16[o] - i.attribStart
					}
			}, r.prototype.isBatchable = function () {
				for (var t = this.batches, e = 0; e < t.length; e++)
					if (t[e].style.native) return !1;
				return this.points.length < 2 * r.BATCHABLE_SIZE
			}, r.prototype.buildDrawCalls = function () {
				for (var e = ++Ar._globalBatch, r = 0; r < this.drawCalls.length; r++) this.drawCalls[r].textures.length = 0, Fo.push(this.drawCalls[r]);
				this.drawCalls.length = 0;
				var i = this.colors,
					n = this.textureIds,
					o = Fo.pop();
				o || ((o = new Pn).textures = new An), o.textures.count = 0, o.start = 0, o.size = 0, o.type = t.DRAW_MODES.TRIANGLES;
				var s = 0,
					a = null,
					h = 0,
					u = !1,
					l = t.DRAW_MODES.TRIANGLES,
					c = 0;
				this.drawCalls.push(o);
				for (var d = 0; d < this.batches.length; d++) {
					var p = this.batches[d],
						f = p.style,
						v = f.texture.baseTexture;
					u !== !!f.native && (l = (u = !!f.native) ? t.DRAW_MODES.LINES : t.DRAW_MODES.TRIANGLES, a = null, s = 8, e++), a !== v && (a = v, v._batchEnabled !== e && (8 === s && (e++, s = 0, o.size > 0 && ((o = Fo.pop()) || ((o = new Pn).textures = new An), this.drawCalls.push(o)), o.start = c, o.size = 0, o.textures.count = 0, o.type = l), v.touched = 1, v._batchEnabled = e, v._batchLocation = s, v.wrapMode = 10497, o.textures.elements[o.textures.count++] = v, s++)), o.size += p.size, c += p.size, h = v._batchLocation, this.addColors(i, f.color, f.alpha, p.attribSize), this.addTextureIds(n, h, p.attribSize)
				}
				Ar._globalBatch = e, this.packAttributes()
			}, r.prototype.packAttributes = function () {
				for (var t = this.points, e = this.uvs, r = this.colors, i = this.textureIds, n = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(n), s = new Uint32Array(n), a = 0, h = 0; h < t.length / 2; h++) o[a++] = t[2 * h], o[a++] = t[2 * h + 1], o[a++] = e[2 * h], o[a++] = e[2 * h + 1], s[a++] = r[h], o[a++] = i[h];
				this._buffer.update(n), this._indexBuffer.update(this.indicesUint16)
			}, r.prototype.processFill = function (t) {
				t.holes.length ? (this.processHoles(t.holes), Eo.triangulate(t, this)) : Lo[t.type].triangulate(t, this)
			}, r.prototype.processLine = function (t) {
				Ao(t, this);
				for (var e = 0; e < t.holes.length; e++) Ao(t.holes[e], this)
			}, r.prototype.processHoles = function (t) {
				for (var e = 0; e < t.length; e++) {
					var r = t[e];
					Lo[r.type].build(r), r.matrix && this.transformPoints(r.points, r.matrix)
				}
			}, r.prototype.calculateBounds = function () {
				var e = this._bounds,
					r = Xo,
					i = Fe.IDENTITY;
				this._bounds.clear(), r.clear();
				for (var n = 0; n < this.graphicsData.length; n++) {
					var o = this.graphicsData[n],
						s = o.shape,
						a = o.type,
						h = o.lineStyle,
						u = o.matrix || Fe.IDENTITY,
						l = 0;
					if (h && h.visible) {
						var c = h.alignment;
						l = h.width, a === t.SHAPES.POLY ? l *= .5 + Math.abs(.5 - c) : l *= Math.max(0, c)
					}
					i !== u && (r.isEmpty() || (e.addBoundsMatrix(r, i), r.clear()), i = u), a === t.SHAPES.RECT || a === t.SHAPES.RREC ? r.addFramePad(s.x, s.y, s.x + s.width, s.y + s.height, l, l) : a === t.SHAPES.CIRC ? r.addFramePad(s.x, s.y, s.x, s.y, s.radius + l, s.radius + l) : a === t.SHAPES.ELIP ? r.addFramePad(s.x, s.y, s.x, s.y, s.width + l, s.height + l) : e.addVerticesMatrix(i, s.points, 0, s.points.length, l, l)
				}
				r.isEmpty() || e.addBoundsMatrix(r, i), e.pad(this.boundsPadding, this.boundsPadding)
			}, r.prototype.transformPoints = function (t, e) {
				for (var r = 0; r < t.length / 2; r++) {
					var i = t[2 * r],
						n = t[2 * r + 1];
					t[2 * r] = e.a * i + e.c * n + e.tx, t[2 * r + 1] = e.b * i + e.d * n + e.ty
				}
			}, r.prototype.addColors = function (t, e, r, i) {
				for (var n = se((e >> 16) + (65280 & e) + ((255 & e) << 16), r); i-- > 0;) t.push(n)
			}, r.prototype.addTextureIds = function (t, e, r) {
				for (; r-- > 0;) t.push(e)
			}, r.prototype.addUvs = function (t, e, r, i, n, o) {
				for (var s = 0, a = e.length, h = r.frame; s < n;) {
					var u = t[2 * (i + s)],
						l = t[2 * (i + s) + 1];
					if (o) {
						var c = o.a * u + o.c * l + o.tx;
						l = o.b * u + o.d * l + o.ty, u = c
					}
					s++, e.push(u / h.width, l / h.height)
				}
				var d = r.baseTexture;
				(h.width < d.width || h.height < d.height) && this.adjustUvs(e, r, a, n)
			}, r.prototype.adjustUvs = function (t, e, r, i) {
				for (var n = e.baseTexture, o = r + 2 * i, s = e.frame, a = s.width / n.width, h = s.height / n.height, u = s.x / s.width, l = s.y / s.height, c = Math.floor(t[r] + 1e-6), d = Math.floor(t[r + 1] + 1e-6), p = r + 2; p < o; p += 2) c = Math.min(c, Math.floor(t[p] + 1e-6)), d = Math.min(d, Math.floor(t[p + 1] + 1e-6));
				u -= c, l -= d;
				for (var f = r; f < o; f += 2) t[f] = (t[f] + u) * a, t[f + 1] = (t[f + 1] + l) * h
			}, Object.defineProperties(r.prototype, i), r
		}(Rn);
	jo.BATCHABLE_SIZE = 100;
	var Ho = function (t) {
			function e() {
				t.apply(this, arguments)
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () {
				var t = new e;
				return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t
			}, e.prototype.reset = function () {
				t.prototype.reset.call(this), this.color = 0, this.width = 0, this.alignment = .5, this.native = !1
			}, e
		}(bo),
		Go = new Float32Array(3),
		Yo = {},
		Vo = function (e) {
			function r(r) {
				void 0 === r && (r = null), e.call(this), this.geometry = r || new jo, this.geometry.refCount++, this.shader = null, this.state = Gi.for2d(), this._fillStyle = new bo, this._lineStyle = new Ho, this._matrix = null, this._holeMode = !1, this.currentPath = null, this.batches = [], this.batchTint = -1, this.vertexData = null, this._transformID = -1, this.batchDirty = -1, this.pluginName = "batch", this.tint = 16777215, this.blendMode = t.BLEND_MODES.NORMAL
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				blendMode: {
					configurable: !0
				},
				tint: {
					configurable: !0
				},
				fill: {
					configurable: !0
				},
				line: {
					configurable: !0
				}
			};
			return r.prototype.clone = function () {
				return this.finishPoly(), new r(this.geometry)
			}, i.blendMode.set = function (t) {
				this.state.blendMode = t
			}, i.blendMode.get = function () {
				return this.state.blendMode
			}, i.tint.get = function () {
				return this._tint
			}, i.tint.set = function (t) {
				this._tint = t
			}, i.fill.get = function () {
				return this._fillStyle
			}, i.line.get = function () {
				return this._lineStyle
			}, r.prototype.lineStyle = function (t) {
				if ("number" == typeof t) {
					var e = arguments;
					t = {
						width: e[0] || 0,
						color: e[1] || 0,
						alpha: void 0 !== e[2] ? e[2] : 1,
						alignment: void 0 !== e[3] ? e[3] : .5,
						native: !!e[4]
					}
				}
				return this.lineTextureStyle(t)
			}, r.prototype.lineTextureStyle = function (t) {
				if ("number" == typeof t) {
					_e("v5.2.0", "Please use object-based options for Graphics#lineTextureStyle");
					var e = arguments[0],
						r = arguments[1],
						i = arguments[2],
						n = arguments[3],
						o = arguments[4],
						s = arguments[5],
						a = arguments[6];
					t = {
						width: e,
						texture: r,
						color: i,
						alpha: n,
						matrix: o,
						alignment: s,
						native: a
					}, Object.keys(t).forEach(function (e) {
						return void 0 === t[e] && delete t[e]
					})
				}
				t = Object.assign({
					width: 0,
					texture: Gr.WHITE,
					color: t && t.texture ? 16777215 : 0,
					alpha: 1,
					matrix: null,
					alignment: .5,
					native: !1
				}, t), this.currentPath && this.startPoly();
				var h = t.width > 0 && t.alpha > 0;
				return h ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, {
					visible: h
				}, t)) : this._lineStyle.reset(), this
			}, r.prototype.startPoly = function () {
				if (this.currentPath) {
					var t = this.currentPath.points,
						e = this.currentPath.points.length;
					e > 2 && (this.drawShape(this.currentPath), this.currentPath = new Ke, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1]))
				} else this.currentPath = new Ke, this.currentPath.closeStroke = !1
			}, r.prototype.finishPoly = function () {
				this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
			}, r.prototype.moveTo = function (t, e) {
				return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this
			}, r.prototype.lineTo = function (t, e) {
				this.currentPath || this.moveTo(0, 0);
				var r = this.currentPath.points,
					i = r[r.length - 2],
					n = r[r.length - 1];
				return i === t && n === e || r.push(t, e), this
			}, r.prototype._initCurve = function (t, e) {
				void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
			}, r.prototype.quadraticCurveTo = function (t, e, r, i) {
				this._initCurve();
				var n = this.currentPath.points;
				return 0 === n.length && this.moveTo(0, 0), Mo.curveTo(t, e, r, i, n), this
			}, r.prototype.bezierCurveTo = function (t, e, r, i, n, o) {
				return this._initCurve(), Co.curveTo(t, e, r, i, n, o, this.currentPath.points), this
			}, r.prototype.arcTo = function (t, e, r, i, n) {
				this._initCurve(t, e);
				var o = this.currentPath.points,
					s = Do.curveTo(t, e, r, i, n, o);
				if (s) {
					var a = s.cx,
						h = s.cy,
						u = s.radius,
						l = s.startAngle,
						c = s.endAngle,
						d = s.anticlockwise;
					this.arc(a, h, u, l, c, d)
				}
				return this
			}, r.prototype.arc = function (t, e, r, i, n, o) {
				if (void 0 === o && (o = !1), i === n) return this;
				if (!o && n <= i ? n += Re : o && i <= n && (i += Re), 0 === n - i) return this;
				var s = t + Math.cos(i) * r,
					a = e + Math.sin(i) * r,
					h = this.geometry.closePointEps,
					u = this.currentPath ? this.currentPath.points : null;
				if (u) {
					var l = Math.abs(u[u.length - 2] - s),
						c = Math.abs(u[u.length - 1] - a);
					l < h && c < h || u.push(s, a)
				} else this.moveTo(s, a), u = this.currentPath.points;
				return Do.arc(s, a, t, e, r, i, n, o, u), this
			}, r.prototype.beginFill = function (t, e) {
				return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({
					texture: Gr.WHITE,
					color: t,
					alpha: e
				})
			}, r.prototype.beginTextureFill = function (t) {
				if (t instanceof Gr) {
					_e("v5.2.0", "Please use object-based options for Graphics#beginTextureFill");
					var e = arguments[0],
						r = arguments[1],
						i = arguments[2],
						n = arguments[3];
					t = {
						texture: e,
						color: r,
						alpha: i,
						matrix: n
					}, Object.keys(t).forEach(function (e) {
						return void 0 === t[e] && delete t[e]
					})
				}
				t = Object.assign({
					texture: Gr.WHITE,
					color: 16777215,
					alpha: 1,
					matrix: null
				}, t), this.currentPath && this.startPoly();
				var o = t.alpha > 0;
				return o ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, {
					visible: o
				}, t)) : this._fillStyle.reset(), this
			}, r.prototype.endFill = function () {
				return this.finishPoly(), this._fillStyle.reset(), this
			}, r.prototype.drawRect = function (t, e, r, i) {
				return this.drawShape(new ze(t, e, r, i))
			}, r.prototype.drawRoundedRect = function (t, e, r, i, n) {
				return this.drawShape(new Ze(t, e, r, i, n))
			}, r.prototype.drawCircle = function (t, e, r) {
				return this.drawShape(new We(t, e, r))
			}, r.prototype.drawEllipse = function (t, e, r, i) {
				return this.drawShape(new qe(t, e, r, i))
			}, r.prototype.drawPolygon = function (t) {
				var e = arguments,
					r = t,
					i = !0;
				if (r.points && (i = r.closeStroke, r = r.points), !Array.isArray(r)) {
					r = new Array(arguments.length);
					for (var n = 0; n < r.length; ++n) r[n] = e[n]
				}
				var o = new Ke(r);
				return o.closeStroke = i, this.drawShape(o), this
			}, r.prototype.drawShape = function (t) {
				return this._holeMode ? this.geometry.drawHole(t, this._matrix) : this.geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
			}, r.prototype.drawStar = function (t, e, r, i, n, o) {
				return void 0 === o && (o = 0), this.drawPolygon(new Oo(t, e, r, i, n, o))
			}, r.prototype.clear = function () {
				return this.geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._matrix = null, this._holeMode = !1, this.currentPath = null, this
			}, r.prototype.isFastRect = function () {
				return 1 === this.geometry.graphicsData.length && this.geometry.graphicsData[0].shape.type === t.SHAPES.RECT && !this.geometry.graphicsData[0].lineWidth
			}, r.prototype._render = function (t) {
				this.finishPoly();
				var e = this.geometry;
				e.updateBatches(), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t))
			}, r.prototype._populateBatches = function () {
				var t = this.geometry,
					e = this.blendMode;
				this.batches = [], this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.vertexData = new Float32Array(t.points);
				for (var r = 0, i = t.batches.length; r < i; r++) {
					var n = t.batches[r],
						o = n.style.color,
						s = new Float32Array(this.vertexData.buffer, 4 * n.attribStart * 2, 2 * n.attribSize),
						a = new Float32Array(t.uvsFloat32.buffer, 4 * n.attribStart * 2, 2 * n.attribSize),
						h = {
							vertexData: s,
							blendMode: e,
							indices: new Uint16Array(t.indicesUint16.buffer, 2 * n.start, n.size),
							uvs: a,
							_batchRGB: te(o),
							_tintRGB: o,
							_texture: n.style.texture,
							alpha: n.style.alpha,
							worldAlpha: 1
						};
					this.batches[r] = h
				}
			}, r.prototype._renderBatched = function (t) {
				if (this.batches.length) {
					t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
					for (var e = 0, r = this.batches.length; e < r; e++) {
						var i = this.batches[e];
						i.worldAlpha = this.worldAlpha * i.alpha, t.plugins[this.pluginName].render(i)
					}
				}
			}, r.prototype._renderDirect = function (t) {
				var e = this._resolveDirectShader(t),
					r = this.geometry,
					i = this.tint,
					n = this.worldAlpha,
					o = e.uniforms,
					s = r.drawCalls;
				o.translationMatrix = this.transform.worldTransform, o.tint[0] = (i >> 16 & 255) / 255 * n, o.tint[1] = (i >> 8 & 255) / 255 * n, o.tint[2] = (255 & i) / 255 * n, o.tint[3] = n, t.shader.bind(e), t.geometry.bind(r, e), t.state.set(this.state);
				for (var a = 0, h = s.length; a < h; a++) this._renderDrawCallDirect(t, r.drawCalls[a])
			}, r.prototype._renderDrawCallDirect = function (t, e) {
				for (var r = e.textures, i = e.type, n = e.size, o = e.start, s = r.count, a = 0; a < s; a++) t.texture.bind(r.elements[a], a);
				t.geometry.draw(i, n, o)
			}, r.prototype._resolveDirectShader = function (t) {
				var e = this.shader,
					r = this.pluginName;
				if (!e) {
					if (!Yo[r]) {
						for (var i = new Int32Array(16), n = 0; n < 16; n++) i[n] = n;
						var o = {
								tint: new Float32Array([1, 1, 1, 1]),
								translationMatrix: new Fe,
								default: oi.from({
									uSamplers: i
								}, !0)
							},
							s = t.plugins[r]._shader.program;
						Yo[r] = new ji(s, o)
					}
					e = Yo[r]
				}
				return e
			}, r.prototype._calculateBounds = function () {
				this.finishPoly();
				var t = this.geometry;
				if (t.graphicsData.length) {
					var e = t.bounds,
						r = e.minX,
						i = e.minY,
						n = e.maxX,
						o = e.maxY;
					this._bounds.addFrame(this.transform, r, i, n, o)
				}
			}, r.prototype.containsPoint = function (t) {
				return this.worldTransform.applyInverse(t, r._TEMP_POINT), this.geometry.containsPoint(r._TEMP_POINT)
			}, r.prototype.calculateTints = function () {
				if (this.batchTint !== this.tint) {
					this.batchTint = this.tint;
					for (var t = te(this.tint, Go), e = 0; e < this.batches.length; e++) {
						var r = this.batches[e],
							i = r._batchRGB,
							n = (t[0] * i[0] * 255 << 16) + (t[1] * i[1] * 255 << 8) + (0 | t[2] * i[2] * 255);
						r._tintRGB = (n >> 16) + (65280 & n) + ((255 & n) << 16)
					}
				}
			}, r.prototype.calculateVertices = function () {
				if (this._transformID !== this.transform._worldID) {
					this._transformID = this.transform._worldID;
					for (var t = this.transform.worldTransform, e = t.a, r = t.b, i = t.c, n = t.d, o = t.tx, s = t.ty, a = this.geometry.points, h = this.vertexData, u = 0, l = 0; l < a.length; l += 2) {
						var c = a[l],
							d = a[l + 1];
						h[u++] = e * c + i * d + o, h[u++] = n * d + r * c + s
					}
				}
			}, r.prototype.closePath = function () {
				var t = this.currentPath;
				return t && (t.closeStroke = !0), this
			}, r.prototype.setMatrix = function (t) {
				return this._matrix = t, this
			}, r.prototype.beginHole = function () {
				return this.finishPoly(), this._holeMode = !0, this
			}, r.prototype.endHole = function () {
				return this.finishPoly(), this._holeMode = !1, this
			}, r.prototype.destroy = function (t) {
				e.prototype.destroy.call(this, t), this.geometry.refCount--, 0 === this.geometry.refCount && this.geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this.geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, e.prototype.destroy.call(this, t)
			}, Object.defineProperties(r.prototype, i), r
		}(tr);
	Vo._TEMP_POINT = new Ce;
	var zo = new Ce,
		Wo = new Uint16Array([0, 1, 2, 0, 2, 3]),
		qo = function (e) {
			function r(r) {
				e.call(this), this._anchor = new Me(this._onAnchorUpdate, this, r ? r.defaultAnchor.x : 0, r ? r.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tint = null, this._tintRGB = null, this.tint = 16777215, this.blendMode = t.BLEND_MODES.NORMAL, this.shader = null, this._cachedTint = 16777215, this.uvs = null, this.texture = r || Gr.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = Wo, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = M.ROUND_PIXELS
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				roundPixels: {
					configurable: !0
				},
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				},
				anchor: {
					configurable: !0
				},
				tint: {
					configurable: !0
				},
				texture: {
					configurable: !0
				}
			};
			return r.prototype._onTextureUpdate = function () {
				this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = ve(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = ve(this.scale.y) * this._height / this._texture.orig.height)
			}, r.prototype._onAnchorUpdate = function () {
				this._transformID = -1, this._transformTrimmedID = -1
			}, r.prototype.calculateVertices = function () {
				var t = this._texture;
				if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) {
					this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
					var e = this.transform.worldTransform,
						r = e.a,
						i = e.b,
						n = e.c,
						o = e.d,
						s = e.tx,
						a = e.ty,
						h = this.vertexData,
						u = t.trim,
						l = t.orig,
						c = this._anchor,
						d = 0,
						p = 0,
						f = 0,
						v = 0;
					if (u ? (d = (p = u.x - c._x * l.width) + u.width, f = (v = u.y - c._y * l.height) + u.height) : (d = (p = -c._x * l.width) + l.width, f = (v = -c._y * l.height) + l.height), h[0] = r * p + n * v + s, h[1] = o * v + i * p + a, h[2] = r * d + n * v + s, h[3] = o * v + i * d + a, h[4] = r * d + n * f + s, h[5] = o * f + i * d + a, h[6] = r * p + n * f + s, h[7] = o * f + i * p + a, this._roundPixels)
						for (var m = M.RESOLUTION, g = 0; g < h.length; ++g) h[g] = Math.round((h[g] * m | 0) / m)
				}
			}, r.prototype.calculateTrimmedVertices = function () {
				if (this.vertexTrimmedData) {
					if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
				} else this.vertexTrimmedData = new Float32Array(8);
				this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
				var t = this._texture,
					e = this.vertexTrimmedData,
					r = t.orig,
					i = this._anchor,
					n = this.transform.worldTransform,
					o = n.a,
					s = n.b,
					a = n.c,
					h = n.d,
					u = n.tx,
					l = n.ty,
					c = -i._x * r.width,
					d = c + r.width,
					p = -i._y * r.height,
					f = p + r.height;
				e[0] = o * c + a * p + u, e[1] = h * p + s * c + l, e[2] = o * d + a * p + u, e[3] = h * p + s * d + l, e[4] = o * d + a * f + u, e[5] = h * f + s * d + l, e[6] = o * c + a * f + u, e[7] = h * f + s * c + l
			}, r.prototype._render = function (t) {
				this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
			}, r.prototype._calculateBounds = function () {
				var t = this._texture.trim,
					e = this._texture.orig;
				!t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
			}, r.prototype.getLocalBounds = function (t) {
				return 0 === this.children.length ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new ze), t = this._localBoundsRect), this._bounds.getRectangle(t)) : e.prototype.getLocalBounds.call(this, t)
			}, r.prototype.containsPoint = function (t) {
				this.worldTransform.applyInverse(t, zo);
				var e = this._texture.orig.width,
					r = this._texture.orig.height,
					i = -e * this.anchor.x,
					n = 0;
				return zo.x >= i && zo.x < i + e && (n = -r * this.anchor.y, zo.y >= n && zo.y < n + r)
			}, r.prototype.destroy = function (t) {
				if (e.prototype.destroy.call(this, t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof t ? t : t && t.texture) {
					var r = "boolean" == typeof t ? t : t && t.baseTexture;
					this._texture.destroy(!!r)
				}
				this._texture = null, this.shader = null
			}, r.from = function (t, e) {
				return new r(t instanceof Gr ? t : Gr.from(t, e))
			}, i.roundPixels.set = function (t) {
				this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
			}, i.roundPixels.get = function () {
				return this._roundPixels
			}, i.width.get = function () {
				return Math.abs(this.scale.x) * this._texture.orig.width
			}, i.width.set = function (t) {
				var e = ve(this.scale.x) || 1;
				this.scale.x = e * t / this._texture.orig.width, this._width = t
			}, i.height.get = function () {
				return Math.abs(this.scale.y) * this._texture.orig.height
			}, i.height.set = function (t) {
				var e = ve(this.scale.y) || 1;
				this.scale.y = e * t / this._texture.orig.height, this._height = t
			}, i.anchor.get = function () {
				return this._anchor
			}, i.anchor.set = function (t) {
				this._anchor.copyFrom(t)
			}, i.tint.get = function () {
				return this._tint
			}, i.tint.set = function (t) {
				this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)
			}, i.texture.get = function () {
				return this._texture
			}, i.texture.set = function (t) {
				this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || Gr.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
			}, Object.defineProperties(r.prototype, i), r
		}(tr),
		Ko = {
			LINEAR_VERTICAL: 0,
			LINEAR_HORIZONTAL: 1
		},
		Zo = {
			align: "left",
			breakWords: !1,
			dropShadow: !1,
			dropShadowAlpha: 1,
			dropShadowAngle: Math.PI / 6,
			dropShadowBlur: 0,
			dropShadowColor: "black",
			dropShadowDistance: 5,
			fill: "black",
			fillGradientType: Ko.LINEAR_VERTICAL,
			fillGradientStops: [],
			fontFamily: "Arial",
			fontSize: 26,
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal",
			letterSpacing: 0,
			lineHeight: 0,
			lineJoin: "miter",
			miterLimit: 10,
			padding: 0,
			stroke: "black",
			strokeThickness: 0,
			textBaseline: "alphabetic",
			trim: !1,
			whiteSpace: "pre",
			wordWrap: !1,
			wordWrapWidth: 100,
			leading: 0
		},
		Jo = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
		Qo = function (t) {
			this.styleID = 0, this.reset(), rs(this, t, t)
		},
		$o = {
			align: {
				configurable: !0
			},
			breakWords: {
				configurable: !0
			},
			dropShadow: {
				configurable: !0
			},
			dropShadowAlpha: {
				configurable: !0
			},
			dropShadowAngle: {
				configurable: !0
			},
			dropShadowBlur: {
				configurable: !0
			},
			dropShadowColor: {
				configurable: !0
			},
			dropShadowDistance: {
				configurable: !0
			},
			fill: {
				configurable: !0
			},
			fillGradientType: {
				configurable: !0
			},
			fillGradientStops: {
				configurable: !0
			},
			fontFamily: {
				configurable: !0
			},
			fontSize: {
				configurable: !0
			},
			fontStyle: {
				configurable: !0
			},
			fontVariant: {
				configurable: !0
			},
			fontWeight: {
				configurable: !0
			},
			letterSpacing: {
				configurable: !0
			},
			lineHeight: {
				configurable: !0
			},
			leading: {
				configurable: !0
			},
			lineJoin: {
				configurable: !0
			},
			miterLimit: {
				configurable: !0
			},
			padding: {
				configurable: !0
			},
			stroke: {
				configurable: !0
			},
			strokeThickness: {
				configurable: !0
			},
			textBaseline: {
				configurable: !0
			},
			trim: {
				configurable: !0
			},
			whiteSpace: {
				configurable: !0
			},
			wordWrap: {
				configurable: !0
			},
			wordWrapWidth: {
				configurable: !0
			}
		};

	function ts(t) {
		return "number" == typeof t ? ee(t) : ("string" == typeof t && 0 === t.indexOf("0x") && (t = t.replace("0x", "#")), t)
	}

	function es(t) {
		if (Array.isArray(t)) {
			for (var e = 0; e < t.length; ++e) t[e] = ts(t[e]);
			return t
		}
		return ts(t)
	}

	function rs(t, e, r) {
		for (var i in r) Array.isArray(e[i]) ? t[i] = e[i].slice() : t[i] = e[i]
	}
	Qo.prototype.clone = function () {
		var t = {};
		return rs(t, this, Zo), new Qo(t)
	}, Qo.prototype.reset = function () {
		rs(this, Zo, Zo)
	}, $o.align.get = function () {
		return this._align
	}, $o.align.set = function (t) {
		this._align !== t && (this._align = t, this.styleID++)
	}, $o.breakWords.get = function () {
		return this._breakWords
	}, $o.breakWords.set = function (t) {
		this._breakWords !== t && (this._breakWords = t, this.styleID++)
	}, $o.dropShadow.get = function () {
		return this._dropShadow
	}, $o.dropShadow.set = function (t) {
		this._dropShadow !== t && (this._dropShadow = t, this.styleID++)
	}, $o.dropShadowAlpha.get = function () {
		return this._dropShadowAlpha
	}, $o.dropShadowAlpha.set = function (t) {
		this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++)
	}, $o.dropShadowAngle.get = function () {
		return this._dropShadowAngle
	}, $o.dropShadowAngle.set = function (t) {
		this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++)
	}, $o.dropShadowBlur.get = function () {
		return this._dropShadowBlur
	}, $o.dropShadowBlur.set = function (t) {
		this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++)
	}, $o.dropShadowColor.get = function () {
		return this._dropShadowColor
	}, $o.dropShadowColor.set = function (t) {
		var e = es(t);
		this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++)
	}, $o.dropShadowDistance.get = function () {
		return this._dropShadowDistance
	}, $o.dropShadowDistance.set = function (t) {
		this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++)
	}, $o.fill.get = function () {
		return this._fill
	}, $o.fill.set = function (t) {
		var e = es(t);
		this._fill !== e && (this._fill = e, this.styleID++)
	}, $o.fillGradientType.get = function () {
		return this._fillGradientType
	}, $o.fillGradientType.set = function (t) {
		this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++)
	}, $o.fillGradientStops.get = function () {
		return this._fillGradientStops
	}, $o.fillGradientStops.set = function (t) {
		(function (t, e) {
			if (!Array.isArray(t) || !Array.isArray(e)) return !1;
			if (t.length !== e.length) return !1;
			for (var r = 0; r < t.length; ++r)
				if (t[r] !== e[r]) return !1;
			return !0
		})(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++)
	}, $o.fontFamily.get = function () {
		return this._fontFamily
	}, $o.fontFamily.set = function (t) {
		this.fontFamily !== t && (this._fontFamily = t, this.styleID++)
	}, $o.fontSize.get = function () {
		return this._fontSize
	}, $o.fontSize.set = function (t) {
		this._fontSize !== t && (this._fontSize = t, this.styleID++)
	}, $o.fontStyle.get = function () {
		return this._fontStyle
	}, $o.fontStyle.set = function (t) {
		this._fontStyle !== t && (this._fontStyle = t, this.styleID++)
	}, $o.fontVariant.get = function () {
		return this._fontVariant
	}, $o.fontVariant.set = function (t) {
		this._fontVariant !== t && (this._fontVariant = t, this.styleID++)
	}, $o.fontWeight.get = function () {
		return this._fontWeight
	}, $o.fontWeight.set = function (t) {
		this._fontWeight !== t && (this._fontWeight = t, this.styleID++)
	}, $o.letterSpacing.get = function () {
		return this._letterSpacing
	}, $o.letterSpacing.set = function (t) {
		this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++)
	}, $o.lineHeight.get = function () {
		return this._lineHeight
	}, $o.lineHeight.set = function (t) {
		this._lineHeight !== t && (this._lineHeight = t, this.styleID++)
	}, $o.leading.get = function () {
		return this._leading
	}, $o.leading.set = function (t) {
		this._leading !== t && (this._leading = t, this.styleID++)
	}, $o.lineJoin.get = function () {
		return this._lineJoin
	}, $o.lineJoin.set = function (t) {
		this._lineJoin !== t && (this._lineJoin = t, this.styleID++)
	}, $o.miterLimit.get = function () {
		return this._miterLimit
	}, $o.miterLimit.set = function (t) {
		this._miterLimit !== t && (this._miterLimit = t, this.styleID++)
	}, $o.padding.get = function () {
		return this._padding
	}, $o.padding.set = function (t) {
		this._padding !== t && (this._padding = t, this.styleID++)
	}, $o.stroke.get = function () {
		return this._stroke
	}, $o.stroke.set = function (t) {
		var e = es(t);
		this._stroke !== e && (this._stroke = e, this.styleID++)
	}, $o.strokeThickness.get = function () {
		return this._strokeThickness
	}, $o.strokeThickness.set = function (t) {
		this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++)
	}, $o.textBaseline.get = function () {
		return this._textBaseline
	}, $o.textBaseline.set = function (t) {
		this._textBaseline !== t && (this._textBaseline = t, this.styleID++)
	}, $o.trim.get = function () {
		return this._trim
	}, $o.trim.set = function (t) {
		this._trim !== t && (this._trim = t, this.styleID++)
	}, $o.whiteSpace.get = function () {
		return this._whiteSpace
	}, $o.whiteSpace.set = function (t) {
		this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++)
	}, $o.wordWrap.get = function () {
		return this._wordWrap
	}, $o.wordWrap.set = function (t) {
		this._wordWrap !== t && (this._wordWrap = t, this.styleID++)
	}, $o.wordWrapWidth.get = function () {
		return this._wordWrapWidth
	}, $o.wordWrapWidth.set = function (t) {
		this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++)
	}, Qo.prototype.toFontString = function () {
		var t = "number" == typeof this.fontSize ? this.fontSize + "px" : this.fontSize,
			e = this.fontFamily;
		Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
		for (var r = e.length - 1; r >= 0; r--) {
			var i = e[r].trim();
			!/([\"\'])[^\'\"]+\1/.test(i) && Jo.indexOf(i) < 0 && (i = '"' + i + '"'), e[r] = i
		}
		return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",")
	}, Object.defineProperties(Qo.prototype, $o);
	var is = function (t, e, r, i, n, o, s, a, h) {
		this.text = t, this.style = e, this.width = r, this.height = i, this.lines = n, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = a, this.fontProperties = h
	};
	is.measureText = function (t, e, r, i) {
		void 0 === i && (i = is._canvas), r = null == r ? e.wordWrap : r;
		var n = e.toFontString(),
			o = is.measureFont(n);
		0 === o.fontSize && (o.fontSize = e.fontSize, o.ascent = e.fontSize);
		var s = i.getContext("2d");
		s.font = n;
		for (var a = (r ? is.wordWrap(t, e, i) : t).split(/(?:\r\n|\r|\n)/), h = new Array(a.length), u = 0, l = 0; l < a.length; l++) {
			var c = s.measureText(a[l]).width + (a[l].length - 1) * e.letterSpacing;
			h[l] = c, u = Math.max(u, c)
		}
		var d = u + e.strokeThickness;
		e.dropShadow && (d += e.dropShadowDistance);
		var p = e.lineHeight || o.fontSize + e.strokeThickness,
			f = Math.max(p, o.fontSize + e.strokeThickness) + (a.length - 1) * (p + e.leading);
		return e.dropShadow && (f += e.dropShadowDistance), new is(t, e, d, f, a, h, p + e.leading, u, o)
	}, is.wordWrap = function (t, e, r) {
		void 0 === r && (r = is._canvas);
		for (var i = r.getContext("2d"), n = 0, o = "", s = "", a = {}, h = e.letterSpacing, u = e.whiteSpace, l = is.collapseSpaces(u), c = is.collapseNewlines(u), d = !l, p = e.wordWrapWidth + h, f = is.tokenize(t), v = 0; v < f.length; v++) {
			var m = f[v];
			if (is.isNewline(m)) {
				if (!c) {
					s += is.addLine(o), d = !l, o = "", n = 0;
					continue
				}
				m = " "
			}
			if (l) {
				var g = is.isBreakingSpace(m),
					y = is.isBreakingSpace(o[o.length - 1]);
				if (g && y) continue
			}
			var _ = is.getFromCache(m, h, a, i);
			if (_ > p)
				if ("" !== o && (s += is.addLine(o), o = "", n = 0), is.canBreakWords(m, e.breakWords))
					for (var x = is.wordWrapSplit(m), b = 0; b < x.length; b++) {
						for (var E = x[b], T = 1; x[b + T];) {
							var w = x[b + T],
								S = E[E.length - 1];
							if (is.canBreakChars(S, w, m, b, e.breakWords)) break;
							E += w, T++
						}
						b += E.length - 1;
						var I = is.getFromCache(E, h, a, i);
						I + n > p && (s += is.addLine(o), d = !1, o = "", n = 0), o += E, n += I
					} else {
						o.length > 0 && (s += is.addLine(o), o = "", n = 0);
						var P = v === f.length - 1;
						s += is.addLine(m, !P), d = !1, o = "", n = 0
					} else _ + n > p && (d = !1, s += is.addLine(o), o = "", n = 0), (o.length > 0 || !is.isBreakingSpace(m) || d) && (o += m, n += _)
		}
		return s += is.addLine(o, !1)
	}, is.addLine = function (t, e) {
		return void 0 === e && (e = !0), t = is.trimRight(t), t = e ? t + "\n" : t
	}, is.getFromCache = function (t, e, r, i) {
		var n = r[t];
		if (void 0 === n) {
			var o = t.length * e;
			n = i.measureText(t).width + o, r[t] = n
		}
		return n
	}, is.collapseSpaces = function (t) {
		return "normal" === t || "pre-line" === t
	}, is.collapseNewlines = function (t) {
		return "normal" === t
	}, is.trimRight = function (t) {
		if ("string" != typeof t) return "";
		for (var e = t.length - 1; e >= 0; e--) {
			var r = t[e];
			if (!is.isBreakingSpace(r)) break;
			t = t.slice(0, -1)
		}
		return t
	}, is.isNewline = function (t) {
		return "string" == typeof t && is._newlines.indexOf(t.charCodeAt(0)) >= 0
	}, is.isBreakingSpace = function (t) {
		return "string" == typeof t && is._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0
	}, is.tokenize = function (t) {
		var e = [],
			r = "";
		if ("string" != typeof t) return e;
		for (var i = 0; i < t.length; i++) {
			var n = t[i];
			is.isBreakingSpace(n) || is.isNewline(n) ? ("" !== r && (e.push(r), r = ""), e.push(n)) : r += n
		}
		return "" !== r && e.push(r), e
	}, is.canBreakWords = function (t, e) {
		return e
	}, is.canBreakChars = function (t, e, r, i, n) {
		return !0
	}, is.wordWrapSplit = function (t) {
		return t.split("")
	}, is.measureFont = function (t) {
		if (is._fonts[t]) return is._fonts[t];
		var e = {},
			r = is._canvas,
			i = is._context;
		i.font = t;
		var n = is.METRICS_STRING + is.BASELINE_SYMBOL,
			o = Math.ceil(i.measureText(n).width),
			s = Math.ceil(i.measureText(is.BASELINE_SYMBOL).width),
			a = 2 * s;
		s = s * is.BASELINE_MULTIPLIER | 0, r.width = o, r.height = a, i.fillStyle = "#f00", i.fillRect(0, 0, o, a), i.font = t, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(n, 0, s);
		var h = i.getImageData(0, 0, o, a).data,
			u = h.length,
			l = 4 * o,
			c = 0,
			d = 0,
			p = !1;
		for (c = 0; c < s; ++c) {
			for (var f = 0; f < l; f += 4)
				if (255 !== h[d + f]) {
					p = !0;
					break
				} if (p) break;
			d += l
		}
		for (e.ascent = s - c, d = u - l, p = !1, c = a; c > s; --c) {
			for (var v = 0; v < l; v += 4)
				if (255 !== h[d + v]) {
					p = !0;
					break
				} if (p) break;
			d -= l
		}
		return e.descent = c - s, e.fontSize = e.ascent + e.descent, is._fonts[t] = e, e
	}, is.clearMetrics = function (t) {
		void 0 === t && (t = ""), t ? delete is._fonts[t] : is._fonts = {}
	};
	var ns = function () {
		try {
			var t = new OffscreenCanvas(0, 0),
				e = t.getContext("2d");
			return e && e.measureText ? t : document.createElement("canvas")
		} catch (t) {
			return document.createElement("canvas")
		}
	}();
	ns.width = ns.height = 10, is._canvas = ns, is._context = ns.getContext("2d"), is._fonts = {}, is.METRICS_STRING = "|ÉqÅ", is.BASELINE_SYMBOL = "M", is.BASELINE_MULTIPLIER = 1.4, is._newlines = [10, 13], is._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
	var os = {
			texture: !0,
			children: !1,
			baseTexture: !0
		},
		ss = function (t) {
			function e(e, r, i) {
				var n = !1;
				i || (i = document.createElement("canvas"), n = !0), i.width = 3, i.height = 3;
				var o = Gr.from(i);
				o.orig = new ze, o.trim = new ze, t.call(this, o), this._ownCanvas = n, this.canvas = i, this.context = this.canvas.getContext("2d"), this._resolution = M.RESOLUTION, this._autoResolution = !0, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = e, this.style = r, this.localStyleID = -1
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				},
				style: {
					configurable: !0
				},
				text: {
					configurable: !0
				},
				resolution: {
					configurable: !0
				}
			};
			return e.prototype.updateText = function (t) {
				var e = this._style;
				if (this.localStyleID !== e.styleID && (this.dirty = !0, this.localStyleID = e.styleID), this.dirty || !t) {
					this._font = this._style.toFontString();
					var r, i, n = this.context,
						o = is.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
						s = o.width,
						a = o.height,
						h = o.lines,
						u = o.lineHeight,
						l = o.lineWidths,
						c = o.maxLineWidth,
						d = o.fontProperties;
					this.canvas.width = Math.ceil((Math.max(1, s) + 2 * e.padding) * this._resolution), this.canvas.height = Math.ceil((Math.max(1, a) + 2 * e.padding) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = e.strokeThickness, n.textBaseline = e.textBaseline, n.lineJoin = e.lineJoin, n.miterLimit = e.miterLimit;
					for (var p = e.dropShadow ? 2 : 1, f = 0; f < p; ++f) {
						var v = e.dropShadow && 0 === f,
							m = v ? 2 * a : 0,
							g = m * this.resolution;
						if (v) {
							n.fillStyle = "black", n.strokeStyle = "black";
							var y = e.dropShadowColor,
								_ = te("number" == typeof y ? y : re(y));
							n.shadowColor = "rgba(" + 255 * _[0] + "," + 255 * _[1] + "," + 255 * _[2] + "," + e.dropShadowAlpha + ")", n.shadowBlur = e.dropShadowBlur, n.shadowOffsetX = Math.cos(e.dropShadowAngle) * e.dropShadowDistance, n.shadowOffsetY = Math.sin(e.dropShadowAngle) * e.dropShadowDistance + g
						} else n.fillStyle = this._generateFillStyle(e, h, o), n.strokeStyle = e.stroke, n.shadowColor = 0, n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;
						for (var x = 0; x < h.length; x++) r = e.strokeThickness / 2, i = e.strokeThickness / 2 + x * u + d.ascent, "right" === e.align ? r += c - l[x] : "center" === e.align && (r += (c - l[x]) / 2), e.stroke && e.strokeThickness && this.drawLetterSpacing(h[x], r + e.padding, i + e.padding - m, !0), e.fill && this.drawLetterSpacing(h[x], r + e.padding, i + e.padding - m)
					}
					this.updateTexture()
				}
			}, e.prototype.drawLetterSpacing = function (t, e, r, i) {
				void 0 === i && (i = !1);
				var n = this._style.letterSpacing;
				if (0 !== n)
					for (var o = e, s = Array.from ? Array.from(t) : t.split(""), a = this.context.measureText(t).width, h = 0, u = 0; u < s.length; ++u) {
						var l = s[u];
						i ? this.context.strokeText(l, o, r) : this.context.fillText(l, o, r), o += a - (h = this.context.measureText(t.substring(u + 1)).width) + n, a = h
					} else i ? this.context.strokeText(t, e, r) : this.context.fillText(t, e, r)
			}, e.prototype.updateTexture = function () {
				var t = this.canvas;
				if (this._style.trim) {
					var e = we(t);
					e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0))
				}
				var r = this._texture,
					i = this._style,
					n = i.trim ? 0 : i.padding,
					o = r.baseTexture;
				r.trim.width = r._frame.width = Math.ceil(t.width / this._resolution), r.trim.height = r._frame.height = Math.ceil(t.height / this._resolution), r.trim.x = -n, r.trim.y = -n, r.orig.width = r._frame.width - 2 * n, r.orig.height = r._frame.height - 2 * n, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), this.dirty = !1
			}, e.prototype._render = function (e) {
				this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), t.prototype._render.call(this, e)
			}, e.prototype.getLocalBounds = function (e) {
				return this.updateText(!0), t.prototype.getLocalBounds.call(this, e)
			}, e.prototype._calculateBounds = function () {
				this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
			}, e.prototype._onStyleChange = function () {
				this.dirty = !0
			}, e.prototype._generateFillStyle = function (t, e, r) {
				if (!Array.isArray(t.fill)) return t.fill;
				if (1 === t.fill.length) return t.fill[0];
				var i, n = t.dropShadow ? t.dropShadowDistance : 0,
					o = t.padding || 0,
					s = Math.ceil(this.canvas.width / this._resolution) - n - 2 * o,
					a = Math.ceil(this.canvas.height / this._resolution) - n - 2 * o,
					h = t.fill.slice(),
					u = t.fillGradientStops.slice();
				if (!u.length)
					for (var l = h.length + 1, c = 1; c < l; ++c) u.push(c / l);
				if (h.unshift(t.fill[0]), u.unshift(0), h.push(t.fill[t.fill.length - 1]), u.push(1), t.fillGradientType === Ko.LINEAR_VERTICAL) {
					i = this.context.createLinearGradient(s / 2, o, s / 2, a + o);
					for (var d = 0, p = (r.fontProperties.fontSize + t.strokeThickness) / a, f = 0; f < e.length; f++)
						for (var v = r.lineHeight * f, m = 0; m < h.length; m++) {
							var g = v / a + ("number" == typeof u[m] ? u[m] : m / h.length) * p,
								y = Math.max(d, g);
							y = Math.min(y, 1), i.addColorStop(y, h[m]), d = y
						}
				} else {
					i = this.context.createLinearGradient(o, a / 2, s + o, a / 2);
					for (var _ = h.length + 1, x = 1, b = 0; b < h.length; b++) {
						var E = void 0;
						E = "number" == typeof u[b] ? u[b] : x / _, i.addColorStop(E, h[b]), x++
					}
				}
				return i
			}, e.prototype.destroy = function (e) {
				"boolean" == typeof e && (e = {
					children: e
				}), e = Object.assign({}, os, e), t.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
			}, r.width.get = function () {
				return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
			}, r.width.set = function (t) {
				this.updateText(!0);
				var e = ve(this.scale.x) || 1;
				this.scale.x = e * t / this._texture.orig.width, this._width = t
			}, r.height.get = function () {
				return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
			}, r.height.set = function (t) {
				this.updateText(!0);
				var e = ve(this.scale.y) || 1;
				this.scale.y = e * t / this._texture.orig.height, this._height = t
			}, r.style.get = function () {
				return this._style
			}, r.style.set = function (t) {
				t = t || {}, this._style = t instanceof Qo ? t : new Qo(t), this.localStyleID = -1, this.dirty = !0
			}, r.text.get = function () {
				return this._text
			}, r.text.set = function (t) {
				t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
			}, r.resolution.get = function () {
				return this._resolution
			}, r.resolution.set = function (t) {
				this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
			}, Object.defineProperties(e.prototype, r), e
		}(qo);
	M.UPLOADS_PER_FRAME = 4;
	var as = function (t) {
		this.maxItemsPerFrame = t, this.itemsLeft = 0
	};
	as.prototype.beginFrame = function () {
		this.itemsLeft = this.maxItemsPerFrame
	}, as.prototype.allowedToUpload = function () {
		return this.itemsLeft-- > 0
	};
	var hs = function (t) {
		var e = this;
		this.limiter = new as(M.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function () {
			e.queue && e.prepareItems()
		}, this.registerFindHook(fs), this.registerFindHook(vs), this.registerFindHook(us), this.registerFindHook(ls), this.registerFindHook(cs), this.registerUploadHook(ds), this.registerUploadHook(ps)
	};

	function us(t, e) {
		var r = !1;
		if (t && t._textures && t._textures.length)
			for (var i = 0; i < t._textures.length; i++)
				if (t._textures[i] instanceof Gr) {
					var n = t._textures[i].baseTexture; - 1 === e.indexOf(n) && (e.push(n), r = !0)
				} return r
	}

	function ls(t, e) {
		if (t.baseTexture instanceof Ar) {
			var r = t.baseTexture;
			return -1 === e.indexOf(r) && e.push(r), !0
		}
		return !1
	}

	function cs(t, e) {
		if (t._texture && t._texture instanceof Gr) {
			var r = t._texture.baseTexture;
			return -1 === e.indexOf(r) && e.push(r), !0
		}
		return !1
	}

	function ds(t, e) {
		return e instanceof ss && (e.updateText(!0), !0)
	}

	function ps(t, e) {
		if (e instanceof Qo) {
			var r = e.toFontString();
			return is.measureFont(r), !0
		}
		return !1
	}

	function fs(t, e) {
		if (t instanceof ss) {
			-1 === e.indexOf(t.style) && e.push(t.style), -1 === e.indexOf(t) && e.push(t);
			var r = t._texture.baseTexture;
			return -1 === e.indexOf(r) && e.push(r), !0
		}
		return !1
	}

	function vs(t, e) {
		return t instanceof Qo && (-1 === e.indexOf(t) && e.push(t), !0)
	}
	hs.prototype.upload = function (e, r) {
		"function" == typeof e && (r = e, e = null), e && this.add(e), this.queue.length ? (r && this.completes.push(r), this.ticking || (this.ticking = !0, sr.system.addOnce(this.tick, this, t.UPDATE_PRIORITY.UTILITY))) : r && r()
	}, hs.prototype.tick = function () {
		setTimeout(this.delayedTick, 0)
	}, hs.prototype.prepareItems = function () {
		for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
			var e = this.queue[0],
				r = !1;
			if (e && !e._destroyed)
				for (var i = 0, n = this.uploadHooks.length; i < n; i++)
					if (this.uploadHooks[i](this.uploadHookHelper, e)) {
						this.queue.shift(), r = !0;
						break
					} r || this.queue.shift()
		}
		if (this.queue.length) sr.system.addOnce(this.tick, this, t.UPDATE_PRIORITY.UTILITY);
		else {
			this.ticking = !1;
			var o = this.completes.slice(0);
			this.completes.length = 0;
			for (var s = 0, a = o.length; s < a; s++) o[s]()
		}
	}, hs.prototype.registerFindHook = function (t) {
		return t && this.addHooks.push(t), this
	}, hs.prototype.registerUploadHook = function (t) {
		return t && this.uploadHooks.push(t), this
	}, hs.prototype.add = function (t) {
		for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++);
		if (t instanceof tr)
			for (var i = t.children.length - 1; i >= 0; i--) this.add(t.children[i]);
		return this
	}, hs.prototype.destroy = function () {
		this.ticking && sr.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
	};
	var ms = function (t) {
		function e(e) {
			t.call(this, e), this.uploadHookHelper = this.renderer, this.registerFindHook(_s), this.registerUploadHook(gs), this.registerUploadHook(ys)
		}
		return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
	}(hs);

	function gs(t, e) {
		return e instanceof Ar && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0)
	}

	function ys(t, e) {
		if (!(e instanceof Vo)) return !1;
		var r = e.geometry;
		e.finishPoly(), r.updateBatches();
		for (var i = r.batches, n = 0; n < i.length; n++) {
			var o = i[n].style.texture;
			o && gs(t, o.baseTexture)
		}
		return r.batchable || t.geometry.bind(r, e._resolveDirectShader(t)), !0
	}

	function _s(t, e) {
		return t instanceof Vo && (e.push(t), !0)
	}
	var xs = function (t) {
		this.maxMilliseconds = t, this.frameStart = 0
	};
	xs.prototype.beginFrame = function () {
		this.frameStart = Date.now()
	}, xs.prototype.allowedToUpload = function () {
		return Date.now() - this.frameStart < this.maxMilliseconds
	};
	var bs = function (t, e, r) {
			void 0 === r && (r = null), this.baseTexture = t, this.textures = {}, this.animations = {}, this.data = e, this.resolution = this._updateResolution(r || (this.baseTexture.resource ? this.baseTexture.resource.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
		},
		Es = {
			BATCH_SIZE: {
				configurable: !0
			}
		};
	Es.BATCH_SIZE.get = function () {
		return 1e3
	}, bs.prototype._updateResolution = function (t) {
		var e = this.data.meta.scale,
			r = Ae(t, null);
		return null === r && (r = void 0 !== e ? parseFloat(e) : 1), 1 !== r && this.baseTexture.setResolution(r), r
	}, bs.prototype.parse = function (t) {
		this._batchIndex = 0, this._callback = t, this._frameKeys.length <= bs.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
	}, bs.prototype._processFrames = function (t) {
		for (var e = t, r = bs.BATCH_SIZE; e - t < r && e < this._frameKeys.length;) {
			var i = this._frameKeys[e],
				n = this._frames[i],
				o = n.frame;
			if (o) {
				var s = null,
					a = null,
					h = !1 !== n.trimmed && n.sourceSize ? n.sourceSize : n.frame,
					u = new ze(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution);
				s = n.rotated ? new ze(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : new ze(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), !1 !== n.trimmed && n.spriteSourceSize && (a = new ze(Math.floor(n.spriteSourceSize.x) / this.resolution, Math.floor(n.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[i] = new Gr(this.baseTexture, s, u, a, n.rotated ? 2 : 0, n.anchor), Gr.addToCache(this.textures[i], i)
			}
			e++
		}
	}, bs.prototype._processAnimations = function () {
		var t = this.data.animations || {};
		for (var e in t) {
			this.animations[e] = [];
			for (var r = 0; r < t[e].length; r++) {
				var i = t[e][r];
				this.animations[e].push(this.textures[i])
			}
		}
	}, bs.prototype._parseComplete = function () {
		var t = this._callback;
		this._callback = null, this._batchIndex = 0, t.call(this, this.textures)
	}, bs.prototype._nextBatch = function () {
		var t = this;
		this._processFrames(this._batchIndex * bs.BATCH_SIZE), this._batchIndex++, setTimeout(function () {
			t._batchIndex * bs.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete())
		}, 0)
	}, bs.prototype.destroy = function (t) {
		for (var e in void 0 === t && (t = !1), this.textures) this.textures[e].destroy();
		this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && this.baseTexture.destroy(), this.baseTexture = null
	}, Object.defineProperties(bs, Es);
	var Ts = function () {};
	Ts.use = function (t, e) {
		var r = t.name + "_image";
		if (t.data && t.type === fo.TYPE.JSON && t.data.frames && !this.resources[r]) {
			var i = {
					crossOrigin: t.crossOrigin,
					metadata: t.metadata.imageMetadata,
					parentResource: t
				},
				n = Ts.getResourcePath(t, this.baseUrl);
			this.add(r, n, i, function (r) {
				if (r.error) e(r.error);
				else {
					var i = r.texture.baseTexture;
					r.texture.destroy();
					var n = new bs(i, t.data, t.url);
					n.parse(function () {
						t.spritesheet = n, t.textures = n.textures, e()
					})
				}
			})
		} else e()
	}, Ts.getResourcePath = function (t, e) {
		return t.isDataUrl ? t.data.meta.image : qt.resolve(t.url.replace(e, ""), t.data.meta.image)
	};
	var ws = new Ce,
		Ss = function (t) {
			function e(e, r, i) {
				void 0 === r && (r = 100), void 0 === i && (i = 100), t.call(this, e), this.tileTransform = new Ve, this._width = r, this._height = i, this._canvasPattern = null, this.uvMatrix = e.uvMatrix || new Ki(e), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				clampMargin: {
					configurable: !0
				},
				tileScale: {
					configurable: !0
				},
				tilePosition: {
					configurable: !0
				},
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				}
			};
			return r.clampMargin.get = function () {
				return this.uvMatrix.clampMargin
			}, r.clampMargin.set = function (t) {
				this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
			}, r.tileScale.get = function () {
				return this.tileTransform.scale
			}, r.tileScale.set = function (t) {
				this.tileTransform.scale.copyFrom(t)
			}, r.tilePosition.get = function () {
				return this.tileTransform.position
			}, r.tilePosition.set = function (t) {
				this.tileTransform.position.copyFrom(t)
			}, e.prototype._onTextureUpdate = function () {
				this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
			}, e.prototype._render = function (t) {
				var e = this._texture;
				e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
			}, e.prototype._calculateBounds = function () {
				var t = this._width * -this._anchor._x,
					e = this._height * -this._anchor._y,
					r = this._width * (1 - this._anchor._x),
					i = this._height * (1 - this._anchor._y);
				this._bounds.addFrame(this.transform, t, e, r, i)
			}, e.prototype.getLocalBounds = function (e) {
				return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new ze), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
			}, e.prototype.containsPoint = function (t) {
				this.worldTransform.applyInverse(t, ws);
				var e = this._width,
					r = this._height,
					i = -e * this.anchor._x;
				if (ws.x >= i && ws.x < i + e) {
					var n = -r * this.anchor._y;
					if (ws.y >= n && ws.y < n + r) return !0
				}
				return !1
			}, e.prototype.destroy = function (e) {
				t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null
			}, e.from = function (t, r, i) {
				return new e(Gr.from(t), r, i)
			}, e.fromFrame = function (t, r, i) {
				var n = be[t];
				if (!n) throw new Error('The frameId "' + t + '" does not exist in the texture cache ' + this);
				return new e(n, r, i)
			}, e.fromImage = function (t, r, i, n) {
				return n && "object" != typeof n && (n = {
					scaleMode: arguments[4],
					resourceOptions: {
						crossorigin: arguments[3]
					}
				}), new e(Gr.from(t, n), r, i)
			}, r.width.get = function () {
				return this._width
			}, r.width.set = function (t) {
				this._width = t
			}, r.height.get = function () {
				return this._height
			}, r.height.set = function (t) {
				this._height = t
			}, Object.defineProperties(e.prototype, r), e
		}(qo),
		Is = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
		Ps = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord - floor(vTextureCoord - uClampOffset);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n",
		As = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n",
		Os = new Fe,
		Ds = function (e) {
			function r(t) {
				e.call(this, t);
				var r = {
					globals: this.renderer.globalUniforms
				};
				this.shader = ji.from(Is, Ps, r), this.simpleShader = ji.from(Is, As, r), this.quad = new ii, this.state = Gi.for2d()
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype.render = function (e) {
				var r = this.renderer,
					i = this.quad,
					n = i.vertices;
				n[0] = n[6] = e._width * -e.anchor.x, n[1] = n[3] = e._height * -e.anchor.y, n[2] = n[4] = e._width * (1 - e.anchor.x), n[5] = n[7] = e._height * (1 - e.anchor.y), e.uvRespectAnchor && ((n = i.uvs)[0] = n[6] = -e.anchor.x, n[1] = n[3] = -e.anchor.y, n[2] = n[4] = 1 - e.anchor.x, n[5] = n[7] = 1 - e.anchor.y), i.invalidate();
				var o = e._texture,
					s = o.baseTexture,
					a = e.tileTransform.localTransform,
					h = e.uvMatrix,
					u = s.isPowerOfTwo && o.frame.width === s.width && o.frame.height === s.height;
				u && (s._glTextures[r.CONTEXT_UID] ? u = s.wrapMode !== t.WRAP_MODES.CLAMP : s.wrapMode === t.WRAP_MODES.CLAMP && (s.wrapMode = t.WRAP_MODES.REPEAT));
				var l = u ? this.simpleShader : this.shader,
					c = o.width,
					d = o.height,
					p = e._width,
					f = e._height;
				Os.set(a.a * c / p, a.b * c / f, a.c * d / p, a.d * d / f, a.tx / p, a.ty / f), Os.invert(), u ? Os.prepend(h.mapCoord) : (l.uniforms.uMapCoord = h.mapCoord.toArray(!0), l.uniforms.uClampFrame = h.uClampFrame, l.uniforms.uClampOffset = h.uClampOffset), l.uniforms.uTransform = Os.toArray(!0), l.uniforms.uColor = ae(e.tint, e.worldAlpha, l.uniforms.uColor, s.alphaMode), l.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), l.uniforms.uSampler = o, r.shader.bind(l), r.geometry.bind(i), this.state.blendMode = ne(e.blendMode, s.alphaMode), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
			}, r
		}(hi),
		Cs = function (t) {
			function e(e, r) {
				var i = this;
				void 0 === r && (r = {}), t.call(this), this._textWidth = 0, this._textHeight = 0, this._glyphs = [], this._font = {
					tint: void 0 !== r.tint ? r.tint : 16777215,
					align: r.align || "left",
					name: null,
					size: 0
				}, this.font = r.font, this._text = e, this._maxWidth = 0, this._maxLineHeight = 0, this._letterSpacing = 0, this._anchor = new Me(function () {
					i.dirty = !0
				}, this, 0, 0), this.dirty = !1, this.roundPixels = M.ROUND_PIXELS, this.updateText()
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				tint: {
					configurable: !0
				},
				align: {
					configurable: !0
				},
				anchor: {
					configurable: !0
				},
				font: {
					configurable: !0
				},
				text: {
					configurable: !0
				},
				maxWidth: {
					configurable: !0
				},
				maxLineHeight: {
					configurable: !0
				},
				textWidth: {
					configurable: !0
				},
				letterSpacing: {
					configurable: !0
				},
				textHeight: {
					configurable: !0
				}
			};
			return e.prototype.updateText = function () {
				for (var t = e.fonts[this._font.name], r = this._font.size / t.size, i = new Ce, n = [], o = [], s = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ", a = s.length, h = this._maxWidth * t.size / this._font.size, u = null, l = 0, c = 0, d = 0, p = -1, f = 0, v = 0, m = 0, g = 0; g < a; g++) {
					var y = s.charCodeAt(g),
						_ = s.charAt(g);
					if (/(?:\s)/.test(_) && (p = g, f = l), "\r" !== _ && "\n" !== _) {
						var x = t.chars[y];
						x && (u && x.kerning[u] && (i.x += x.kerning[u]), n.push({
							texture: x.texture,
							line: d,
							charCode: y,
							position: new Ce(i.x + x.xOffset + this._letterSpacing / 2, i.y + x.yOffset)
						}), i.x += x.xAdvance + this._letterSpacing, l = i.x, m = Math.max(m, x.yOffset + x.texture.height), u = y, -1 !== p && h > 0 && i.x > h && (fe(n, 1 + p - ++v, 1 + g - p), g = p, p = -1, o.push(f), c = Math.max(c, f), d++, i.x = 0, i.y += t.lineHeight, u = null))
					} else o.push(l), c = Math.max(c, l), ++d, ++v, i.x = 0, i.y += t.lineHeight, u = null
				}
				var b = s.charAt(s.length - 1);
				"\r" !== b && "\n" !== b && (/(?:\s)/.test(b) && (l = f), o.push(l), c = Math.max(c, l));
				for (var E = [], T = 0; T <= d; T++) {
					var w = 0;
					"right" === this._font.align ? w = c - o[T] : "center" === this._font.align && (w = (c - o[T]) / 2), E.push(w)
				}
				for (var S = n.length, I = this.tint, P = 0; P < S; P++) {
					var A = this._glyphs[P];
					A ? A.texture = n[P].texture : ((A = new qo(n[P].texture)).roundPixels = this.roundPixels, this._glyphs.push(A)), A.position.x = (n[P].position.x + E[n[P].line]) * r, A.position.y = n[P].position.y * r, A.scale.x = A.scale.y = r, A.tint = I, A.parent || this.addChild(A)
				}
				for (var O = S; O < this._glyphs.length; ++O) this.removeChild(this._glyphs[O]);
				if (this._textWidth = c * r, this._textHeight = (i.y + t.lineHeight) * r, 0 !== this.anchor.x || 0 !== this.anchor.y)
					for (var D = 0; D < S; D++) this._glyphs[D].x -= this._textWidth * this.anchor.x, this._glyphs[D].y -= this._textHeight * this.anchor.y;
				this._maxLineHeight = m * r
			}, e.prototype.updateTransform = function () {
				this.validate(), this.containerUpdateTransform()
			}, e.prototype.getLocalBounds = function () {
				return this.validate(), t.prototype.getLocalBounds.call(this)
			}, e.prototype.validate = function () {
				this.dirty && (this.updateText(), this.dirty = !1)
			}, r.tint.get = function () {
				return this._font.tint
			}, r.tint.set = function (t) {
				this._font.tint = "number" == typeof t && t >= 0 ? t : 16777215, this.dirty = !0
			}, r.align.get = function () {
				return this._font.align
			}, r.align.set = function (t) {
				this._font.align = t || "left", this.dirty = !0
			}, r.anchor.get = function () {
				return this._anchor
			}, r.anchor.set = function (t) {
				"number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
			}, r.font.get = function () {
				return this._font
			}, r.font.set = function (t) {
				t && ("string" == typeof t ? (t = t.split(" "), this._font.name = 1 === t.length ? t[0] : t.slice(1).join(" "), this._font.size = t.length >= 2 ? parseInt(t[0], 10) : e.fonts[this._font.name].size) : (this._font.name = t.name, this._font.size = "number" == typeof t.size ? t.size : parseInt(t.size, 10)), this.dirty = !0)
			}, r.text.get = function () {
				return this._text
			}, r.text.set = function (t) {
				t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
			}, r.maxWidth.get = function () {
				return this._maxWidth
			}, r.maxWidth.set = function (t) {
				this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0)
			}, r.maxLineHeight.get = function () {
				return this.validate(), this._maxLineHeight
			}, r.textWidth.get = function () {
				return this.validate(), this._textWidth
			}, r.letterSpacing.get = function () {
				return this._letterSpacing
			}, r.letterSpacing.set = function (t) {
				this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0)
			}, r.textHeight.get = function () {
				return this.validate(), this._textHeight
			}, e.registerFont = function (t, r) {
				var i = {},
					n = t.getElementsByTagName("info")[0],
					o = t.getElementsByTagName("common")[0],
					s = t.getElementsByTagName("page"),
					a = Ae(s[0].getAttribute("file")),
					h = {};
				i.font = n.getAttribute("face"), i.size = parseInt(n.getAttribute("size"), 10), i.lineHeight = parseInt(o.getAttribute("lineHeight"), 10) / a, i.chars = {}, r instanceof Gr && (r = [r]);
				for (var u = 0; u < s.length; u++) {
					var l = s[u].getAttribute("id"),
						c = s[u].getAttribute("file");
					h[l] = r instanceof Array ? r[u] : r[c]
				}
				for (var d = t.getElementsByTagName("char"), p = 0; p < d.length; p++) {
					var f = d[p],
						v = parseInt(f.getAttribute("id"), 10),
						m = f.getAttribute("page") || 0,
						g = new ze(parseInt(f.getAttribute("x"), 10) / a + h[m].frame.x / a, parseInt(f.getAttribute("y"), 10) / a + h[m].frame.y / a, parseInt(f.getAttribute("width"), 10) / a, parseInt(f.getAttribute("height"), 10) / a);
					i.chars[v] = {
						xOffset: parseInt(f.getAttribute("xoffset"), 10) / a,
						yOffset: parseInt(f.getAttribute("yoffset"), 10) / a,
						xAdvance: parseInt(f.getAttribute("xadvance"), 10) / a,
						kerning: {},
						texture: new Gr(h[m].baseTexture, g),
						page: m
					}
				}
				for (var y = t.getElementsByTagName("kerning"), _ = 0; _ < y.length; _++) {
					var x = y[_],
						b = parseInt(x.getAttribute("first"), 10) / a,
						E = parseInt(x.getAttribute("second"), 10) / a,
						T = parseInt(x.getAttribute("amount"), 10) / a;
					i.chars[E] && (i.chars[E].kerning[b] = T)
				}
				return e.fonts[i.font] = i, i
			}, Object.defineProperties(e.prototype, r), e
		}(tr);
	Cs.fonts = {};
	var Ms = function () {};
	Ms.parse = function (t, e) {
		t.bitmapFont = Cs.registerFont(t.data, e)
	}, Ms.add = function () {
		fo.setExtensionXhrType("fnt", fo.XHR_RESPONSE_TYPE.DOCUMENT)
	}, Ms.dirname = function (t) {
		var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
		return e === t ? "." : "" === e ? "/" : e
	}, Ms.use = function (t, e) {
		if (t.data && t.type === fo.TYPE.XML)
			if (0 !== t.data.getElementsByTagName("page").length && 0 !== t.data.getElementsByTagName("info").length && null !== t.data.getElementsByTagName("info")[0].getAttribute("face")) {
				var r = t.isDataUrl ? "" : Ms.dirname(t.url);
				t.isDataUrl && ("." === r && (r = ""), this.baseUrl && r && "/" === this.baseUrl.charAt(this.baseUrl.length - 1) && (r += "/")), (r = r.replace(this.baseUrl, "")) && "/" !== r.charAt(r.length - 1) && (r += "/");
				for (var i = t.data.getElementsByTagName("page"), n = {}, o = function (r) {
						n[r.metadata.pageFile] = r.texture, Object.keys(n).length === i.length && (Ms.parse(t, n), e())
					}, s = 0; s < i.length; ++s) {
					var a = i[s].getAttribute("file"),
						h = r + a,
						u = !1;
					for (var l in this.resources) {
						var c = this.resources[l];
						if (c.url === h) {
							c.metadata.pageFile = a, c.texture ? o(c) : c.onAfterMiddleware.add(o), u = !0;
							break
						}
					}
					if (!u) {
						var d = {
							crossOrigin: t.crossOrigin,
							loadType: fo.LOAD_TYPE.IMAGE,
							metadata: Object.assign({
								pageFile: a
							}, t.metadata.imageMetadata),
							parentResource: t
						};
						this.add(h, d, o)
					}
				}
			} else e();
		else e()
	};
	var Rs = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n",
		Ls = function (t) {
			function e(e) {
				void 0 === e && (e = 1), t.call(this, wn, Rs, {
					uAlpha: 1
				}), this.alpha = e
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				alpha: {
					configurable: !0
				}
			};
			return r.alpha.get = function () {
				return this.uniforms.uAlpha
			}, r.alpha.set = function (t) {
				this.uniforms.uAlpha = t
			}, Object.defineProperties(e.prototype, r), e
		}(Vi),
		Ns = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
	var Fs = {
			5: [.153388, .221461, .250301],
			7: [.071303, .131514, .189879, .214607],
			9: [.028532, .067234, .124009, .179044, .20236],
			11: [.0093, .028002, .065984, .121703, .175713, .198596],
			13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
			15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
		},
		Bs = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
	var Us = function (t) {
			function e(e, r, i, n, o) {
				var s = function (t, e) {
						var r, i = Math.ceil(t / 2),
							n = Ns,
							o = "";
						r = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
						for (var s = 0; s < t; s++) {
							var a = r.replace("%index%", s);
							o += a = a.replace("%sampleIndex%", s - (i - 1) + ".0"), o += "\n"
						}
						return n = (n = n.replace("%blur%", o)).replace("%size%", t)
					}(o = o || 5, e),
					a = function (t) {
						for (var e, r = Fs[t], i = r.length, n = Bs, o = "", s = 0; s < t; s++) {
							var a = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s);
							e = s, s >= i && (e = t - s - 1), o += a = a.replace("%value%", r[e]), o += "\n"
						}
						return n = (n = n.replace("%blur%", o)).replace("%size%", t)
					}(o);
				t.call(this, s, a), this.horizontal = e, this.resolution = n || M.RESOLUTION, this._quality = 0, this.quality = i || 4, this.blur = r || 8
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				blur: {
					configurable: !0
				},
				quality: {
					configurable: !0
				}
			};
			return e.prototype.apply = function (t, e, r, i) {
				if (r ? this.horizontal ? this.uniforms.strength = 1 / r.width * (r.width / e.width) : this.uniforms.strength = 1 / r.height * (r.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t.applyFilter(this, e, r, i);
				else {
					var n = t.getFilterTexture(),
						o = t.renderer,
						s = e,
						a = n;
					this.state.blend = !1, t.applyFilter(this, s, a, !0);
					for (var h = 1; h < this.passes - 1; h++) {
						o.renderTexture.bind(s, s.filterFrame), this.uniforms.uSampler = a;
						var u = a;
						a = s, s = u, o.shader.bind(this), o.geometry.draw(5)
					}
					this.state.blend = !0, t.applyFilter(this, a, r, i), t.returnFilterTexture(n)
				}
			}, r.blur.get = function () {
				return this.strength
			}, r.blur.set = function (t) {
				this.padding = 1 + 2 * Math.abs(t), this.strength = t
			}, r.quality.get = function () {
				return this._quality
			}, r.quality.set = function (t) {
				this._quality = t, this.passes = t
			}, Object.defineProperties(e.prototype, r), e
		}(Vi),
		ks = function (t) {
			function e(e, r, i, n) {
				t.call(this), this.blurXFilter = new Us(!0, e, r, i, n), this.blurYFilter = new Us(!1, e, r, i, n), this.resolution = i || M.RESOLUTION, this.quality = r || 4, this.blur = e || 8, this.repeatEdgePixels = !1
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				blur: {
					configurable: !0
				},
				quality: {
					configurable: !0
				},
				blurX: {
					configurable: !0
				},
				blurY: {
					configurable: !0
				},
				blendMode: {
					configurable: !0
				},
				repeatEdgePixels: {
					configurable: !0
				}
			};
			return e.prototype.apply = function (t, e, r, i) {
				var n = Math.abs(this.blurXFilter.strength),
					o = Math.abs(this.blurYFilter.strength);
				if (n && o) {
					var s = t.getFilterTexture();
					this.blurXFilter.apply(t, e, s, !0), this.blurYFilter.apply(t, s, r, i), t.returnFilterTexture(s)
				} else o ? this.blurYFilter.apply(t, e, r, i) : this.blurXFilter.apply(t, e, r, i)
			}, e.prototype.updatePadding = function () {
				this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
			}, r.blur.get = function () {
				return this.blurXFilter.blur
			}, r.blur.set = function (t) {
				this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
			}, r.quality.get = function () {
				return this.blurXFilter.quality
			}, r.quality.set = function (t) {
				this.blurXFilter.quality = this.blurYFilter.quality = t
			}, r.blurX.get = function () {
				return this.blurXFilter.blur
			}, r.blurX.set = function (t) {
				this.blurXFilter.blur = t, this.updatePadding()
			}, r.blurY.get = function () {
				return this.blurYFilter.blur
			}, r.blurY.set = function (t) {
				this.blurYFilter.blur = t, this.updatePadding()
			}, r.blendMode.get = function () {
				return this.blurYFilter.blendMode
			}, r.blendMode.set = function (t) {
				this.blurYFilter.blendMode = t
			}, r.repeatEdgePixels.get = function () {
				return this._repeatEdgePixels
			}, r.repeatEdgePixels.set = function (t) {
				this._repeatEdgePixels = t, this.updatePadding()
			}, Object.defineProperties(e.prototype, r), e
		}(Vi),
		Xs = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n",
		js = function (t) {
			function e() {
				var e = {
					m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
					uAlpha: 1
				};
				t.call(this, Sn, Xs, e), this.alpha = 1
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				matrix: {
					configurable: !0
				},
				alpha: {
					configurable: !0
				}
			};
			return e.prototype._loadMatrix = function (t, e) {
				void 0 === e && (e = !1);
				var r = t;
				e && (this._multiply(r, this.uniforms.m, t), r = this._colorMatrix(r)), this.uniforms.m = r
			}, e.prototype._multiply = function (t, e, r) {
				return t[0] = e[0] * r[0] + e[1] * r[5] + e[2] * r[10] + e[3] * r[15], t[1] = e[0] * r[1] + e[1] * r[6] + e[2] * r[11] + e[3] * r[16], t[2] = e[0] * r[2] + e[1] * r[7] + e[2] * r[12] + e[3] * r[17], t[3] = e[0] * r[3] + e[1] * r[8] + e[2] * r[13] + e[3] * r[18], t[4] = e[0] * r[4] + e[1] * r[9] + e[2] * r[14] + e[3] * r[19] + e[4], t[5] = e[5] * r[0] + e[6] * r[5] + e[7] * r[10] + e[8] * r[15], t[6] = e[5] * r[1] + e[6] * r[6] + e[7] * r[11] + e[8] * r[16], t[7] = e[5] * r[2] + e[6] * r[7] + e[7] * r[12] + e[8] * r[17], t[8] = e[5] * r[3] + e[6] * r[8] + e[7] * r[13] + e[8] * r[18], t[9] = e[5] * r[4] + e[6] * r[9] + e[7] * r[14] + e[8] * r[19] + e[9], t[10] = e[10] * r[0] + e[11] * r[5] + e[12] * r[10] + e[13] * r[15], t[11] = e[10] * r[1] + e[11] * r[6] + e[12] * r[11] + e[13] * r[16], t[12] = e[10] * r[2] + e[11] * r[7] + e[12] * r[12] + e[13] * r[17], t[13] = e[10] * r[3] + e[11] * r[8] + e[12] * r[13] + e[13] * r[18], t[14] = e[10] * r[4] + e[11] * r[9] + e[12] * r[14] + e[13] * r[19] + e[14], t[15] = e[15] * r[0] + e[16] * r[5] + e[17] * r[10] + e[18] * r[15], t[16] = e[15] * r[1] + e[16] * r[6] + e[17] * r[11] + e[18] * r[16], t[17] = e[15] * r[2] + e[16] * r[7] + e[17] * r[12] + e[18] * r[17], t[18] = e[15] * r[3] + e[16] * r[8] + e[17] * r[13] + e[18] * r[18], t[19] = e[15] * r[4] + e[16] * r[9] + e[17] * r[14] + e[18] * r[19] + e[19], t
			}, e.prototype._colorMatrix = function (t) {
				var e = new Float32Array(t);
				return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e
			}, e.prototype.brightness = function (t, e) {
				var r = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
				this._loadMatrix(r, e)
			}, e.prototype.greyscale = function (t, e) {
				var r = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
				this._loadMatrix(r, e)
			}, e.prototype.blackAndWhite = function (t) {
				this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t)
			}, e.prototype.hue = function (t, e) {
				t = (t || 0) / 180 * Math.PI;
				var r = Math.cos(t),
					i = Math.sin(t),
					n = 1 / 3,
					o = (0, Math.sqrt)(n),
					s = [r + (1 - r) * n, n * (1 - r) - o * i, n * (1 - r) + o * i, 0, 0, n * (1 - r) + o * i, r + n * (1 - r), n * (1 - r) - o * i, 0, 0, n * (1 - r) - o * i, n * (1 - r) + o * i, r + n * (1 - r), 0, 0, 0, 0, 0, 1, 0];
				this._loadMatrix(s, e)
			}, e.prototype.contrast = function (t, e) {
				var r = (t || 0) + 1,
					i = -.5 * (r - 1),
					n = [r, 0, 0, 0, i, 0, r, 0, 0, i, 0, 0, r, 0, i, 0, 0, 0, 1, 0];
				this._loadMatrix(n, e)
			}, e.prototype.saturate = function (t, e) {
				void 0 === t && (t = 0);
				var r = 2 * t / 3 + 1,
					i = -.5 * (r - 1),
					n = [r, i, i, 0, 0, i, r, i, 0, 0, i, i, r, 0, 0, 0, 0, 0, 1, 0];
				this._loadMatrix(n, e)
			}, e.prototype.desaturate = function () {
				this.saturate(-1)
			}, e.prototype.negative = function (t) {
				this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
			}, e.prototype.sepia = function (t) {
				this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t)
			}, e.prototype.technicolor = function (t) {
				this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
			}, e.prototype.polaroid = function (t) {
				this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
			}, e.prototype.toBGR = function (t) {
				this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
			}, e.prototype.kodachrome = function (t) {
				this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
			}, e.prototype.browni = function (t) {
				this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
			}, e.prototype.vintage = function (t) {
				this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
			}, e.prototype.colorTone = function (t, e, r, i, n) {
				var o = ((r = r || 16770432) >> 16 & 255) / 255,
					s = (r >> 8 & 255) / 255,
					a = (255 & r) / 255,
					h = ((i = i || 3375104) >> 16 & 255) / 255,
					u = (i >> 8 & 255) / 255,
					l = (255 & i) / 255,
					c = [.3, .59, .11, 0, 0, o, s, a, t = t || .2, 0, h, u, l, e = e || .15, 0, o - h, s - u, a - l, 0, 0];
				this._loadMatrix(c, n)
			}, e.prototype.night = function (t, e) {
				var r = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0];
				this._loadMatrix(r, e)
			}, e.prototype.predator = function (t, e) {
				var r = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
				this._loadMatrix(r, e)
			}, e.prototype.lsd = function (t) {
				this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
			}, e.prototype.reset = function () {
				this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
			}, r.matrix.get = function () {
				return this.uniforms.m
			}, r.matrix.set = function (t) {
				this.uniforms.m = t
			}, r.alpha.get = function () {
				return this.uniforms.uAlpha
			}, r.alpha.set = function (t) {
				this.uniforms.uAlpha = t
			}, Object.defineProperties(e.prototype, r), e
		}(Vi);
	js.prototype.grayscale = js.prototype.greyscale;
	var Hs = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n",
		Gs = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n",
		Ys = function (t) {
			function e(e, r) {
				var i = new Fe;
				e.renderable = !1, t.call(this, Hs, Gs, {
					mapSampler: e._texture,
					filterMatrix: i,
					scale: {
						x: 1,
						y: 1
					},
					rotation: new Float32Array([1, 0, 0, 1])
				}), this.maskSprite = e, this.maskMatrix = i, null == r && (r = 20), this.scale = new Ce(r, r)
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				map: {
					configurable: !0
				}
			};
			return e.prototype.apply = function (t, e, r, i) {
				this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
				var n = this.maskSprite.transform.worldTransform,
					o = Math.sqrt(n.a * n.a + n.b * n.b),
					s = Math.sqrt(n.c * n.c + n.d * n.d);
				0 !== o && 0 !== s && (this.uniforms.rotation[0] = n.a / o, this.uniforms.rotation[1] = n.b / o, this.uniforms.rotation[2] = n.c / s, this.uniforms.rotation[3] = n.d / s), t.applyFilter(this, e, r, i)
			}, r.map.get = function () {
				return this.uniforms.mapSampler
			}, r.map.set = function (t) {
				this.uniforms.mapSampler = t
			}, Object.defineProperties(e.prototype, r), e
		}(Vi),
		Vs = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
		zs = 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputPixel;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n',
		Ws = function (t) {
			function e() {
				t.call(this, Vs, zs)
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
		}(Vi),
		qs = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n",
		Ks = function (t) {
			function e(e, r) {
				void 0 === e && (e = .5), void 0 === r && (r = Math.random()), t.call(this, Sn, qs, {
					uNoise: 0,
					uSeed: 0
				}), this.noise = e, this.seed = r
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				noise: {
					configurable: !0
				},
				seed: {
					configurable: !0
				}
			};
			return r.noise.get = function () {
				return this.uniforms.uNoise
			}, r.noise.set = function (t) {
				this.uniforms.uNoise = t
			}, r.seed.get = function () {
				return this.uniforms.uSeed
			}, r.seed.set = function (t) {
				this.uniforms.uSeed = t
			}, Object.defineProperties(e.prototype, r), e
		}(Vi),
		Zs = new Fe;
	Qe.prototype._cacheAsBitmap = !1, Qe.prototype._cacheData = !1;
	var Js = function () {
		this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalHitTest = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.sprite = null
	};
	Object.defineProperties(Qe.prototype, {
		cacheAsBitmap: {
			get: function () {
				return this._cacheAsBitmap
			},
			set: function (t) {
				var e;
				this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new Js), (e = this._cacheData).originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea))
			}
		}
	}), Qe.prototype._renderCached = function (t) {
		!this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
	}, Qe.prototype._initCachedDisplayObject = function (t) {
		if (!this._cacheData || !this._cacheData.sprite) {
			var e = this.alpha;
			this.alpha = 1, t.batch.flush();
			var r = this.getLocalBounds().clone();
			if (this.filters) {
				var i = this.filters[0].padding;
				r.pad(i)
			}
			r.ceil(M.RESOLUTION);
			var n = t.renderTexture.current,
				o = t.renderTexture.sourceFrame.clone(),
				s = t.projection.transform,
				a = Vr.create(r.width, r.height),
				h = "cacheAsBitmap_" + ge();
			this._cacheData.textureCacheId = h, Ar.addToCache(a.baseTexture, h), Gr.addToCache(a, h);
			var u = Zs;
			u.tx = -r.x, u.ty = -r.y, this.transform.worldTransform.identity(), this.render = this._cacheData.originalRender, t.render(this, a, !0, u, !0), t.projection.transform = s, t.renderTexture.bind(n, o), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null;
			var l = new qo(a);
			l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -r.x / r.width, l.anchor.y = -r.y / r.height, l.alpha = e, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l)
		}
	}, Qe.prototype._renderCachedCanvas = function (t) {
		!this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
	}, Qe.prototype._initCachedDisplayObjectCanvas = function (t) {
		if (!this._cacheData || !this._cacheData.sprite) {
			var e = this.getLocalBounds(),
				r = this.alpha;
			this.alpha = 1;
			var i = t.context,
				n = t._projTransform;
			e.ceil(M.RESOLUTION);
			var o = Vr.create(e.width, e.height),
				s = "cacheAsBitmap_" + ge();
			this._cacheData.textureCacheId = s, Ar.addToCache(o.baseTexture, s), Gr.addToCache(o, s);
			var a = Zs;
			this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, o, !0, a, !1), t.context = i, t._projTransform = n, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null;
			var h = new qo(o);
			h.transform.worldTransform = this.transform.worldTransform, h.anchor.x = -e.x / e.width, h.anchor.y = -e.y / e.height, h.alpha = r, h._bounds = this._bounds, this._cacheData.sprite = h, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = h.containsPoint.bind(h)
		}
	}, Qe.prototype._calculateCachedBounds = function () {
		this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._lastBoundsID = this._boundsID
	}, Qe.prototype._getCachedLocalBounds = function () {
		return this._cacheData.sprite.getLocalBounds()
	}, Qe.prototype._destroyCachedDisplayObject = function () {
		this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Ar.removeFromCache(this._cacheData.textureCacheId), Gr.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
	}, Qe.prototype._cacheAsBitmapDestroy = function (t) {
		this.cacheAsBitmap = !1, this.destroy(t)
	}, Qe.prototype.name = null, tr.prototype.getChildByName = function (t) {
		for (var e = 0; e < this.children.length; e++)
			if (this.children[e].name === t) return this.children[e];
		return null
	}, Qe.prototype.getGlobalPosition = function (t, e) {
		return void 0 === t && (t = new Ce), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t
	};
	var Qs = "5.0.0";
	var $s = function (t, e) {
		this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
	};
	$s.prototype.update = function (t) {
		if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
			this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
			var e = this.uvBuffer.data;
			this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++
		}
	};
	var ta = new Ce,
		ea = new Ke,
		ra = function (e) {
			function r(r, i, n, o) {
				void 0 === o && (o = t.DRAW_MODES.TRIANGLES), e.call(this), this.geometry = r, r.refCount++, this.shader = i, this.state = n || Gi.for2d(), this.drawMode = o, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = 0, this._transformID = -1, this.tint = 16777215, this.blendMode = t.BLEND_MODES.NORMAL, this._roundPixels = M.ROUND_PIXELS, this.batchUvs = null
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				uvBuffer: {
					configurable: !0
				},
				verticesBuffer: {
					configurable: !0
				},
				material: {
					configurable: !0
				},
				blendMode: {
					configurable: !0
				},
				roundPixels: {
					configurable: !0
				},
				tint: {
					configurable: !0
				},
				texture: {
					configurable: !0
				}
			};
			return i.uvBuffer.get = function () {
				return this.geometry.buffers[1]
			}, i.verticesBuffer.get = function () {
				return this.geometry.buffers[0]
			}, i.material.set = function (t) {
				this.shader = t
			}, i.material.get = function () {
				return this.shader
			}, i.blendMode.set = function (t) {
				this.state.blendMode = t
			}, i.blendMode.get = function () {
				return this.state.blendMode
			}, i.roundPixels.set = function (t) {
				this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
			}, i.roundPixels.get = function () {
				return this._roundPixels
			}, i.tint.get = function () {
				return this.shader.tint
			}, i.tint.set = function (t) {
				this.shader.tint = t
			}, i.texture.get = function () {
				return this.shader.texture
			}, i.texture.set = function (t) {
				this.shader.texture = t
			}, r.prototype._render = function (e) {
				var i = this.geometry.buffers[0].data;
				this.shader.batchable && this.drawMode === t.DRAW_MODES.TRIANGLES && i.length < 2 * r.BATCHABLE_SIZE ? this._renderToBatch(e) : this._renderDefault(e)
			}, r.prototype._renderDefault = function (t) {
				var e = this.shader;
				e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.program.uniformData.translationMatrix && (e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0)), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
			}, r.prototype._renderToBatch = function (t) {
				var e = this.geometry;
				this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = this.shader._tintRGB, this._texture = this.shader.texture;
				var r = this.material.pluginName;
				t.batch.setObjectRenderer(t.plugins[r]), t.plugins[r].render(this)
			}, r.prototype.calculateVertices = function () {
				var t = this.geometry,
					e = t.buffers[0].data;
				if (t.vertexDirtyId !== this.vertexDirty || this._transformID !== this.transform._worldID) {
					this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
					for (var r = this.transform.worldTransform, i = r.a, n = r.b, o = r.c, s = r.d, a = r.tx, h = r.ty, u = this.vertexData, l = 0; l < u.length / 2; l++) {
						var c = e[2 * l],
							d = e[2 * l + 1];
						u[2 * l] = i * c + o * d + a, u[2 * l + 1] = n * c + s * d + h
					}
					if (this._roundPixels)
						for (var p = M.RESOLUTION, f = 0; f < u.length; ++f) u[f] = Math.round((u[f] * p | 0) / p);
					this.vertexDirty = t.vertexDirtyId
				}
			}, r.prototype.calculateUvs = function () {
				var t = this.geometry.buffers[1];
				this.shader.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new $s(t, this.shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
			}, r.prototype._calculateBounds = function () {
				this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
			}, r.prototype.containsPoint = function (t) {
				if (!this.getBounds().contains(t.x, t.y)) return !1;
				this.worldTransform.applyInverse(t, ta);
				for (var e = this.geometry.getBuffer("aVertexPosition").data, r = ea.points, i = this.geometry.getIndex().data, n = i.length, o = 4 === this.drawMode ? 3 : 1, s = 0; s + 2 < n; s += o) {
					var a = 2 * i[s],
						h = 2 * i[s + 1],
						u = 2 * i[s + 2];
					if (r[0] = e[a], r[1] = e[a + 1], r[2] = e[h], r[3] = e[h + 1], r[4] = e[u], r[5] = e[u + 1], ea.contains(ta.x, ta.y)) return !0
				}
				return !1
			}, r.prototype.destroy = function (t) {
				e.prototype.destroy.call(this, t), this.geometry.refCount--, 0 === this.geometry.refCount && this.geometry.dispose(), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
			}, Object.defineProperties(r.prototype, i), r
		}(tr);
	ra.BATCHABLE_SIZE = 100;
	var ia = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n",
		na = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n",
		oa = function (t) {
			function e(e, r) {
				var i = {
					uSampler: e,
					alpha: 1,
					uTextureMatrix: Fe.IDENTITY,
					uColor: new Float32Array([1, 1, 1, 1])
				};
				(r = Object.assign({
					tint: 16777215,
					alpha: 1,
					pluginName: "batch"
				}, r)).uniforms && Object.assign(i, r.uniforms), t.call(this, r.program || ki.from(ia, na), i), this._colorDirty = !1, this.uvMatrix = new Ki(e), this.batchable = void 0 === r.program, this.pluginName = r.pluginName, this.tint = r.tint, this.alpha = r.alpha
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				texture: {
					configurable: !0
				},
				alpha: {
					configurable: !0
				},
				tint: {
					configurable: !0
				}
			};
			return r.texture.get = function () {
				return this.uniforms.uSampler
			}, r.texture.set = function (t) {
				this.uniforms.uSampler !== t && (this.uniforms.uSampler = t, this.uvMatrix.texture = t)
			}, r.alpha.set = function (t) {
				t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
			}, r.alpha.get = function () {
				return this._alpha
			}, r.tint.set = function (t) {
				t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0)
			}, r.tint.get = function () {
				return this._tint
			}, e.prototype.update = function () {
				if (this._colorDirty) {
					this._colorDirty = !1;
					var t = this.texture.baseTexture;
					ae(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
				}
				this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
			}, Object.defineProperties(e.prototype, r), e
		}(ji),
		sa = function (e) {
			function r(r, i, n) {
				e.call(this);
				var o = new Kr(r),
					s = new Kr(i, !0),
					a = new Kr(n, !0, !0);
				this.addAttribute("aVertexPosition", o, 2, !1, t.TYPES.FLOAT).addAttribute("aTextureCoord", s, 2, !1, t.TYPES.FLOAT).addIndex(a), this._updateId = -1
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				vertexDirtyId: {
					configurable: !0
				}
			};
			return i.vertexDirtyId.get = function () {
				return this.buffers[0]._updateID
			}, Object.defineProperties(r.prototype, i), r
		}(ei),
		aa = function (t) {
			function e(e, r, i, n) {
				void 0 === e && (e = 100), void 0 === r && (r = 100), void 0 === i && (i = 10), void 0 === n && (n = 10), t.call(this), this.segWidth = i, this.segHeight = n, this.width = e, this.height = r, this.build()
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.build = function () {
				for (var t = this.segWidth * this.segHeight, e = [], r = [], i = [], n = this.segWidth - 1, o = this.segHeight - 1, s = this.width / n, a = this.height / o, h = 0; h < t; h++) {
					var u = h % this.segWidth,
						l = h / this.segWidth | 0;
					e.push(u * s, l * a), r.push(u / n, l / o)
				}
				for (var c = n * o, d = 0; d < c; d++) {
					var p = d % n,
						f = d / n | 0,
						v = f * this.segWidth + p,
						m = f * this.segWidth + p + 1,
						g = (f + 1) * this.segWidth + p,
						y = (f + 1) * this.segWidth + p + 1;
					i.push(v, m, g, m, y, g)
				}
				this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(r), this.indexBuffer.data = new Uint16Array(i), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
			}, e
		}(sa),
		ha = function (t) {
			function e(e, r, i) {
				void 0 === e && (e = 200), void 0 === i && (i = 0), t.call(this, new Float32Array(4 * r.length), new Float32Array(4 * r.length), new Uint16Array(6 * (r.length - 1))), this.points = r, this.width = e, this.textureScale = i, this.build()
			}
			return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.build = function () {
				var t = this.points;
				if (t) {
					var e = this.getBuffer("aVertexPosition"),
						r = this.getBuffer("aTextureCoord"),
						i = this.getIndex();
					if (!(t.length < 1)) {
						e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), r.data = new Float32Array(4 * t.length), i.data = new Uint16Array(6 * (t.length - 1)));
						var n = r.data,
							o = i.data;
						n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1;
						for (var s = 0, a = t[0], h = this.width * this.textureScale, u = t.length, l = 0; l < u; l++) {
							var c = 4 * l;
							if (this.textureScale > 0) {
								var d = a.x - t[l].x,
									p = a.y - t[l].y,
									f = Math.sqrt(d * d + p * p);
								a = t[l], s += f / h
							} else s = l / (u - 1);
							n[c] = s, n[c + 1] = 0, n[c + 2] = s, n[c + 3] = 1
						}
						for (var v = 0, m = 0; m < u - 1; m++) {
							var g = 2 * m;
							o[v++] = g, o[v++] = g + 1, o[v++] = g + 2, o[v++] = g + 2, o[v++] = g + 1, o[v++] = g + 3
						}
						r.update(), i.update(), this.updateVertices()
					}
				}
			}, e.prototype.updateVertices = function () {
				var t = this.points;
				if (!(t.length < 1)) {
					for (var e, r = t[0], i = 0, n = 0, o = this.buffers[0].data, s = t.length, a = 0; a < s; a++) {
						var h = t[a],
							u = 4 * a;
						n = -((e = a < t.length - 1 ? t[a + 1] : h).x - r.x), i = e.y - r.y;
						var l = Math.sqrt(i * i + n * n),
							c = this.textureScale > 0 ? this.textureScale * this.width / 2 : this.width / 2;
						i /= l, n /= l, i *= c, n *= c, o[u] = h.x + i, o[u + 1] = h.y + n, o[u + 2] = h.x - i, o[u + 3] = h.y - n, r = h
					}
					this.buffers[0].update()
				}
			}, e.prototype.update = function () {
				this.textureScale > 0 ? this.build() : this.updateVertices()
			}, e
		}(sa),
		ua = function (e) {
			function r(r, i, n) {
				void 0 === n && (n = 0);
				var o = new ha(r.height, i, n),
					s = new oa(r);
				n > 0 && (r.baseTexture.wrapMode = t.WRAP_MODES.REPEAT), e.call(this, o, s), this.autoUpdate = !0
			}
			return e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r, r.prototype._render = function (t) {
				(this.autoUpdate || this.geometry.width !== this.shader.texture.height) && (this.geometry.width = this.shader.texture.height, this.geometry.update()), e.prototype._render.call(this, t)
			}, r
		}(ra),
		la = function (t) {
			function e(e, r, i) {
				var n = new aa(e.width, e.height, r, i),
					o = new oa(Gr.WHITE);
				t.call(this, n, o), this.texture = e
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				texture: {
					configurable: !0
				}
			};
			return e.prototype.textureUpdated = function () {
				this._textureID = this.shader.texture._updateID, this.geometry.width = this.shader.texture.width, this.geometry.height = this.shader.texture.height, this.geometry.build()
			}, r.texture.set = function (t) {
				this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
			}, r.texture.get = function () {
				return this.shader.texture
			}, e.prototype._render = function (e) {
				this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e)
			}, Object.defineProperties(e.prototype, r), e
		}(ra),
		ca = function (t) {
			function e(e, r, i, n, o) {
				void 0 === e && (e = Gr.EMPTY);
				var s = new sa(r, i, n);
				s.getBuffer("aVertexPosition").static = !1;
				var a = new oa(e);
				t.call(this, s, a, null, o), this.autoUpdate = !0
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				vertices: {
					configurable: !0
				}
			};
			return r.vertices.get = function () {
				return this.geometry.getBuffer("aVertexPosition").data
			}, r.vertices.set = function (t) {
				this.geometry.getBuffer("aVertexPosition").data = t
			}, e.prototype._render = function (e) {
				this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t.prototype._render.call(this, e)
			}, Object.defineProperties(e.prototype, r), e
		}(ra),
		da = 10,
		pa = function (t) {
			function e(e, r, i, n, o) {
				t.call(this, Gr.WHITE, 4, 4), this._origWidth = e.orig.width, this._origHeight = e.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = void 0 !== r ? r : da, this._rightWidth = void 0 !== n ? n : da, this._topHeight = void 0 !== i ? i : da, this._bottomHeight = void 0 !== o ? o : da, this.texture = e
			}
			t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
			var r = {
				vertices: {
					configurable: !0
				},
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				},
				leftWidth: {
					configurable: !0
				},
				rightWidth: {
					configurable: !0
				},
				topHeight: {
					configurable: !0
				},
				bottomHeight: {
					configurable: !0
				}
			};
			return e.prototype.textureUpdated = function () {
				this._textureID = this.shader.texture._updateID, this._refresh()
			}, r.vertices.get = function () {
				return this.geometry.getBuffer("aVertexPosition").data
			}, r.vertices.set = function (t) {
				this.geometry.getBuffer("aVertexPosition").data = t
			}, e.prototype.updateHorizontalVertices = function () {
				var t = this.vertices,
					e = this._getMinScale();
				t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height
			}, e.prototype.updateVerticalVertices = function () {
				var t = this.vertices,
					e = this._getMinScale();
				t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width
			}, e.prototype._getMinScale = function () {
				var t = this._leftWidth + this._rightWidth,
					e = this._width > t ? 1 : this._width / t,
					r = this._topHeight + this._bottomHeight,
					i = this._height > r ? 1 : this._height / r;
				return Math.min(e, i)
			}, r.width.get = function () {
				return this._width
			}, r.width.set = function (t) {
				this._width = t, this._refresh()
			}, r.height.get = function () {
				return this._height
			}, r.height.set = function (t) {
				this._height = t, this._refresh()
			}, r.leftWidth.get = function () {
				return this._leftWidth
			}, r.leftWidth.set = function (t) {
				this._leftWidth = t, this._refresh()
			}, r.rightWidth.get = function () {
				return this._rightWidth
			}, r.rightWidth.set = function (t) {
				this._rightWidth = t, this._refresh()
			}, r.topHeight.get = function () {
				return this._topHeight
			}, r.topHeight.set = function (t) {
				this._topHeight = t, this._refresh()
			}, r.bottomHeight.get = function () {
				return this._bottomHeight
			}, r.bottomHeight.set = function (t) {
				this._bottomHeight = t, this._refresh()
			}, e.prototype._refresh = function () {
				var t = this.texture,
					e = this.geometry.buffers[1].data;
				this._origWidth = t.orig.width, this._origHeight = t.orig.height;
				var r = 1 / this._origWidth,
					i = 1 / this._origHeight;
				e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = r * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - r * this._rightWidth, e[9] = e[11] = e[13] = e[15] = i * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - i * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
			}, Object.defineProperties(e.prototype, r), e
		}(la),
		fa = function (e) {
			function r(t, r) {
				e.call(this, t[0] instanceof Gr ? t[0] : t[0].texture), this._textures = null, this._durations = null, this._autoUpdate = !1 !== r, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = t
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var i = {
				totalFrames: {
					configurable: !0
				},
				textures: {
					configurable: !0
				},
				currentFrame: {
					configurable: !0
				},
				playing: {
					configurable: !0
				},
				autoUpdate: {
					configurable: !0
				}
			};
			return r.prototype.stop = function () {
				this.playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (sr.shared.remove(this.update, this), this._isConnectedToTicker = !1))
			}, r.prototype.play = function () {
				this.playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (sr.shared.add(this.update, this, t.UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0))
			}, r.prototype.gotoAndStop = function (t) {
				this.stop();
				var e = this.currentFrame;
				this._currentTime = t, e !== this.currentFrame && this.updateTexture()
			}, r.prototype.gotoAndPlay = function (t) {
				var e = this.currentFrame;
				this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play()
			}, r.prototype.update = function (t) {
				var e = this.animationSpeed * t,
					r = this.currentFrame;
				if (null !== this._durations) {
					var i = this._currentTime % 1 * this._durations[this.currentFrame];
					for (i += e / 60 * 1e3; i < 0;) this._currentTime--, i += this._durations[this.currentFrame];
					var n = Math.sign(this.animationSpeed * t);
					for (this._currentTime = Math.floor(this._currentTime); i >= this._durations[this.currentFrame];) i -= this._durations[this.currentFrame] * n, this._currentTime += n;
					this._currentTime += i / this._durations[this.currentFrame]
				} else this._currentTime += e;
				this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : r !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < r ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > r && this.onLoop()), this.updateTexture())
			}, r.prototype.updateTexture = function () {
				var t = this.currentFrame;
				this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
			}, r.prototype.destroy = function (t) {
				this.stop(), e.prototype.destroy.call(this, t), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
			}, r.fromFrames = function (t) {
				for (var e = [], i = 0; i < t.length; ++i) e.push(Gr.from(t[i]));
				return new r(e)
			}, r.fromImages = function (t) {
				for (var e = [], i = 0; i < t.length; ++i) e.push(Gr.from(t[i]));
				return new r(e)
			}, i.totalFrames.get = function () {
				return this._textures.length
			}, i.textures.get = function () {
				return this._textures
			}, i.textures.set = function (t) {
				if (t[0] instanceof Gr) this._textures = t, this._durations = null;
				else {
					this._textures = [], this._durations = [];
					for (var e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time)
				}
				this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
			}, i.currentFrame.get = function () {
				var t = Math.floor(this._currentTime) % this._textures.length;
				return t < 0 && (t += this._textures.length), t
			}, i.playing.get = function () {
				return this._playing
			}, i.autoUpdate.get = function () {
				return this._autoUpdate
			}, i.autoUpdate.set = function (t) {
				t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (sr.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (sr.shared.add(this.update, this), this._isConnectedToTicker = !0))
			}, Object.defineProperties(r.prototype, i), r
		}(qo);
	En.registerPlugin("accessibility", rr), En.registerPlugin("extract", Gn), En.registerPlugin("interaction", gr), En.registerPlugin("particle", _o), En.registerPlugin("prepare", ms), En.registerPlugin("batch", Un), En.registerPlugin("tilingSprite", Ds), co.registerPlugin(Ms), co.registerPlugin(Ts), kn.registerPlugin(ar), kn.registerPlugin(po);
	var va = {
		AlphaFilter: Ls,
		BlurFilter: ks,
		BlurFilterPass: Us,
		ColorMatrixFilter: js,
		DisplacementFilter: Ys,
		FXAAFilter: Ws,
		NoiseFilter: Ks
	};
	return t.AbstractBatchRenderer = Cn, t.AbstractRenderer = bn, t.AnimatedSprite = fa, t.AppLoaderPlugin = po, t.Application = kn, t.Attribute = Wr, t.BasePrepare = hs, t.BaseRenderTexture = Xr, t.BaseTexture = Ar, t.BatchDrawCall = Pn, t.BatchGeometry = Rn, t.BatchPluginFactory = Fn, t.BatchRenderer = Un, t.BatchShaderGenerator = Mn, t.BatchTextureArray = An, t.BitmapFontLoader = Ms, t.BitmapText = Cs, t.Bounds = Je, t.Buffer = Kr, t.Circle = We, t.Container = tr, t.CountLimiter = as, t.CubeTexture = In, t.DEG_TO_RAD = Ne, t.DisplayObject = Qe, t.Ellipse = qe, t.Extract = Gn, t.FillStyle = bo, t.Filter = Vi, t.Framebuffer = Ur, t.GLProgram = sn, t.GLTexture = gn, t.GRAPHICS_CURVES = xo, t.Geometry = ei, t.Graphics = Vo, t.GraphicsData = Uo, t.GraphicsGeometry = jo, t.LineStyle = Ho, t.Loader = co, t.LoaderResource = fo, t.MaskData = mi, t.Matrix = Fe, t.Mesh = ra, t.MeshBatchUvs = $s, t.MeshGeometry = sa, t.MeshMaterial = oa, t.NineSlicePlane = pa, t.ObjectRenderer = hi, t.ObservablePoint = Me, t.PI_2 = Re, t.ParticleContainer = vo, t.ParticleRenderer = _o, t.PlaneGeometry = aa, t.Point = Ce, t.Polygon = Ke, t.Prepare = ms, t.Program = ki, t.Quad = ri, t.QuadUv = ii, t.RAD_TO_DEG = Le, t.Rectangle = ze, t.RenderTexture = Vr, t.RenderTexturePool = zr, t.Renderer = En, t.RopeGeometry = ha, t.RoundedRectangle = Ze, t.Runner = _r, t.Shader = ji, t.SimpleMesh = ca, t.SimplePlane = la, t.SimpleRope = ua, t.Sprite = qo, t.SpriteMaskFilter = Ji, t.Spritesheet = bs, t.SpritesheetLoader = Ts, t.State = Gi, t.System = Fr, t.TEXT_GRADIENT = Ko, t.Text = ss, t.TextMetrics = is, t.TextStyle = Qo, t.Texture = Gr, t.TextureLoader = lo, t.TextureMatrix = Ki, t.TextureUvs = jr, t.Ticker = sr, t.TickerPlugin = ar, t.TilingSprite = Ss, t.TilingSpriteRenderer = Ds, t.TimeLimiter = xs, t.Transform = Ve, t.UniformGroup = oi, t.VERSION = "5.2.2", t.ViewableBuffer = On, t.accessibility = nr, t.autoDetectRenderer = Tn, t.checkMaxIfStatementsInShader = Ni, t.defaultFilterVertex = Sn, t.defaultVertex = wn, t.filters = va, t.graphicsUtils = Bo, t.groupD8 = Ye, t.interaction = yr, t.isMobile = C, t.resources = Nr, t.settings = M, t.systems = _n, t.useDeprecated = function () {
		var t = this;
		Object.defineProperties(t, {
			SVG_SIZE: {
				get: function () {
					return _e(Qs, "PIXI.utils.SVG_SIZE property has moved to PIXI.resources.SVGResource.SVG_SIZE"), t.SVGResource.SVG_SIZE
				}
			},
			TransformStatic: {
				get: function () {
					return _e(Qs, "PIXI.TransformStatic class has been removed, use PIXI.Transform"), t.Transform
				}
			},
			TransformBase: {
				get: function () {
					return _e(Qs, "PIXI.TransformBase class has been removed, use PIXI.Transform"), t.Transform
				}
			},
			TRANSFORM_MODE: {
				get: function () {
					return _e(Qs, "PIXI.TRANSFORM_MODE property has been removed"), {
						STATIC: 0,
						DYNAMIC: 1
					}
				}
			},
			WebGLRenderer: {
				get: function () {
					return _e(Qs, "PIXI.WebGLRenderer class has moved to PIXI.Renderer"), t.Renderer
				}
			},
			CanvasRenderTarget: {
				get: function () {
					return _e(Qs, "PIXI.CanvasRenderTarget class has moved to PIXI.utils.CanvasRenderTarget"), t.utils.CanvasRenderTarget
				}
			},
			loader: {
				get: function () {
					return _e(Qs, "PIXI.loader instance has moved to PIXI.Loader.shared"), t.Loader.shared
				}
			},
			FilterManager: {
				get: function () {
					return _e(Qs, "PIXI.FilterManager class has moved to PIXI.systems.FilterSystem"), t.systems.FilterSystem
				}
			},
			CanvasTinter: {
				get: function () {
					return _e("5.2.0", "PIXI.CanvasTinter namespace has moved to PIXI.canvasUtils"), t.canvasUtils
				}
			},
			GroupD8: {
				get: function () {
					return _e("5.2.0", "PIXI.GroupD8 namespace has moved to PIXI.groupD8"), t.groupD8
				}
			}
		}), t.prepare = {}, Object.defineProperties(t.prepare, {
			BasePrepare: {
				get: function () {
					return _e("5.2.1", "PIXI.prepare.BasePrepare moved to PIXI.BasePrepare"), t.BasePrepare
				}
			},
			Prepare: {
				get: function () {
					return _e("5.2.1", "PIXI.prepare.Prepare moved to PIXI.Prepare"), t.Prepare
				}
			},
			CanvasPrepare: {
				get: function () {
					return _e("5.2.1", "PIXI.prepare.CanvasPrepare moved to PIXI.CanvasPrepare"), t.CanvasPrepare
				}
			}
		}), t.extract = {}, Object.defineProperties(t.extract, {
			Extract: {
				get: function () {
					return _e("5.2.1", "PIXI.extract.Extract moved to PIXI.Extract"), t.Extract
				}
			},
			CanvasExtract: {
				get: function () {
					return _e("5.2.1", "PIXI.extract.CanvasExtract moved to PIXI.CanvasExtract"), t.CanvasExtract
				}
			}
		}), t.extras = {}, Object.defineProperties(t.extras, {
			TilingSprite: {
				get: function () {
					return _e(Qs, "PIXI.extras.TilingSprite class has moved to PIXI.TilingSprite"), t.TilingSprite
				}
			},
			TilingSpriteRenderer: {
				get: function () {
					return _e(Qs, "PIXI.extras.TilingSpriteRenderer class has moved to PIXI.TilingSpriteRenderer"), t.TilingSpriteRenderer
				}
			},
			AnimatedSprite: {
				get: function () {
					return _e(Qs, "PIXI.extras.AnimatedSprite class has moved to PIXI.AnimatedSprite"), t.AnimatedSprite
				}
			},
			BitmapText: {
				get: function () {
					return _e(Qs, "PIXI.extras.BitmapText class has moved to PIXI.BitmapText"), t.BitmapText
				}
			}
		}), Object.defineProperties(t.utils, {
			getSvgSize: {
				get: function () {
					return _e(Qs, "PIXI.utils.getSvgSize function has moved to PIXI.resources.SVGResource.getSize"), t.SVGResource.getSize
				}
			}
		}), t.mesh = {}, Object.defineProperties(t.mesh, {
			Mesh: {
				get: function () {
					return _e(Qs, "PIXI.mesh.Mesh class has moved to PIXI.SimpleMesh"), t.SimpleMesh
				}
			},
			NineSlicePlane: {
				get: function () {
					return _e(Qs, "PIXI.mesh.NineSlicePlane class has moved to PIXI.NineSlicePlane"), t.NineSlicePlane
				}
			},
			Plane: {
				get: function () {
					return _e(Qs, "PIXI.mesh.Plane class has moved to PIXI.SimplePlane"), t.SimplePlane
				}
			},
			Rope: {
				get: function () {
					return _e(Qs, "PIXI.mesh.Rope class has moved to PIXI.SimpleRope"), t.SimpleRope
				}
			},
			RawMesh: {
				get: function () {
					return _e(Qs, "PIXI.mesh.RawMesh class has moved to PIXI.Mesh"), t.Mesh
				}
			},
			CanvasMeshRenderer: {
				get: function () {
					return _e(Qs, "PIXI.mesh.CanvasMeshRenderer class has moved to PIXI.CanvasMeshRenderer"), t.CanvasMeshRenderer
				}
			},
			MeshRenderer: {
				get: function () {
					return _e(Qs, "PIXI.mesh.MeshRenderer class has moved to PIXI.MeshRenderer"), t.MeshRenderer
				}
			}
		}), t.particles = {}, Object.defineProperties(t.particles, {
			ParticleContainer: {
				get: function () {
					return _e(Qs, "PIXI.particles.ParticleContainer class has moved to PIXI.ParticleContainer"), t.ParticleContainer
				}
			},
			ParticleRenderer: {
				get: function () {
					return _e(Qs, "PIXI.particles.ParticleRenderer class has moved to PIXI.ParticleRenderer"), t.ParticleRenderer
				}
			}
		}), t.ticker = {}, Object.defineProperties(t.ticker, {
			Ticker: {
				get: function () {
					return _e(Qs, "PIXI.ticker.Ticker class has moved to PIXI.Ticker"), t.Ticker
				}
			},
			shared: {
				get: function () {
					return _e(Qs, "PIXI.ticker.shared instance has moved to PIXI.Ticker.shared"), t.Ticker.shared
				}
			}
		}), t.loaders = {}, Object.defineProperties(t.loaders, {
			Loader: {
				get: function () {
					return _e(Qs, "PIXI.loaders.Loader class has moved to PIXI.Loader"), t.Loader
				}
			},
			Resource: {
				get: function () {
					return _e(Qs, "PIXI.loaders.Resource class has moved to PIXI.LoaderResource"), t.LoaderResource
				}
			},
			bitmapFontParser: {
				get: function () {
					return _e(Qs, "PIXI.loaders.bitmapFontParser function has moved to PIXI.BitmapFontLoader.use"), t.BitmapFontLoader.use
				}
			},
			parseBitmapFontData: {
				get: function () {
					return _e(Qs, "PIXI.loaders.parseBitmapFontData function has moved to PIXI.BitmapFontLoader.parse"), t.BitmapFontLoader.parse
				}
			},
			spritesheetParser: {
				get: function () {
					return _e(Qs, "PIXI.loaders.spritesheetParser function has moved to PIXI.SpritesheetLoader.use"), t.SpritesheetLoader.use
				}
			},
			getResourcePath: {
				get: function () {
					return _e(Qs, "PIXI.loaders.getResourcePath property has moved to PIXI.SpritesheetLoader.getResourcePath"), t.SpritesheetLoader.getResourcePath
				}
			}
		}), t.Loader.addPixiMiddleware = function (e) {
			return _e(Qs, "PIXI.loaders.Loader.addPixiMiddleware function is deprecated, use PIXI.loaders.Loader.registerPlugin"), t.loaders.Loader.registerPlugin({
				use: e()
			})
		}, Object.defineProperty(t.extract, "WebGLExtract", {
			get: function () {
				return _e(Qs, "PIXI.extract.WebGLExtract method has moved to PIXI.Extract"), t.Extract
			}
		}), Object.defineProperty(t.prepare, "WebGLPrepare", {
			get: function () {
				return _e(Qs, "PIXI.prepare.WebGLPrepare class has moved to PIXI.Prepare"), t.Prepare
			}
		}), t.Container.prototype._renderWebGL = function (t) {
			_e(Qs, "PIXI.Container._renderWebGL method has moved to PIXI.Container._render"), this._render(t)
		}, t.Container.prototype.renderWebGL = function (t) {
			_e(Qs, "PIXI.Container.renderWebGL method has moved to PIXI.Container.render"), this.render(t)
		}, t.DisplayObject.prototype.renderWebGL = function (t) {
			_e(Qs, "PIXI.DisplayObject.renderWebGL method has moved to PIXI.DisplayObject.render"), this.render(t)
		}, t.Container.prototype.renderAdvancedWebGL = function (t) {
			_e(Qs, "PIXI.Container.renderAdvancedWebGL method has moved to PIXI.Container.renderAdvanced"), this.renderAdvanced(t)
		}, Object.defineProperties(t.settings, {
			TRANSFORM_MODE: {
				get: function () {
					return _e(Qs, "PIXI.settings.TRANSFORM_MODE property has been removed"), 0
				},
				set: function () {
					_e(Qs, "PIXI.settings.TRANSFORM_MODE property has been removed")
				}
			}
		});
		var e = t.BaseTexture;
		e.prototype.loadSource = function (e) {
			_e(Qs, "PIXI.BaseTexture.loadSource method has been deprecated");
			var r = t.resources.autoDetectResource(e);
			r.internal = !0, this.setResource(r), this.update()
		};
		var r = !1;
		Object.defineProperties(e.prototype, {
			hasLoaded: {
				get: function () {
					return _e(Qs, "PIXI.BaseTexture.hasLoaded property has been removed, use PIXI.BaseTexture.valid"), this.valid
				}
			},
			imageUrl: {
				get: function () {
					return _e(Qs, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), this.resource && this.resource.url
				},
				set: function (t) {
					_e(Qs, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), this.resource && (this.resource.url = t)
				}
			},
			source: {
				get: function () {
					return _e(Qs, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source`"), this.resource && this.resource.source
				},
				set: function (t) {
					_e(Qs, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source` if you want to set HTMLCanvasElement. Otherwise, create new BaseTexture."), this.resource && (this.resource.source = t)
				}
			},
			premultiplyAlpha: {
				get: function () {
					return _e("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode
				},
				set: function (t) {
					_e("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t)
				}
			},
			_id: {
				get: function () {
					return r || (_e("5.2.0", "PIXI.BaseTexture._id batch local field has been changed to `_batchLocation`"), r = !0), this._batchLocation
				},
				set: function (t) {
					this._batchLocation = t
				}
			}
		}), e.fromImage = function (t, r, i, n) {
			_e(Qs, "PIXI.BaseTexture.fromImage method has been replaced with PIXI.BaseTexture.from");
			var o = {
				scale: n,
				crossorigin: r
			};
			return e.from(t, {
				scaleMode: i,
				resourceOptions: o
			})
		}, e.fromCanvas = function (t, r) {
			return _e(Qs, "PIXI.BaseTexture.fromCanvas method has been replaced with PIXI.BaseTexture.from"), e.from(t, {
				scaleMode: r
			})
		}, e.fromSVG = function (t, r, i, n) {
			_e(Qs, "PIXI.BaseTexture.fromSVG method has been replaced with PIXI.BaseTexture.from");
			var o = {
				scale: n,
				crossorigin: r
			};
			return e.from(t, {
				scaleMode: i,
				resourceOptions: o
			})
		}, Object.defineProperties(t.resources.ImageResource.prototype, {
			premultiplyAlpha: {
				get: function () {
					return _e("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode
				},
				set: function (t) {
					_e("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t)
				}
			}
		}), t.Point.prototype.copy = function (t) {
			return _e(Qs, "PIXI.Point.copy method has been replaced with PIXI.Point.copyFrom"), this.copyFrom(t)
		}, t.ObservablePoint.prototype.copy = function (t) {
			return _e(Qs, "PIXI.ObservablePoint.copy method has been replaced with PIXI.ObservablePoint.copyFrom"), this.copyFrom(t)
		}, t.Rectangle.prototype.copy = function (t) {
			return _e(Qs, "PIXI.Rectangle.copy method has been replaced with PIXI.Rectangle.copyFrom"), this.copyFrom(t)
		}, t.Matrix.prototype.copy = function (t) {
			return _e(Qs, "PIXI.Matrix.copy method has been replaced with PIXI.Matrix.copyTo"), this.copyTo(t)
		}, t.systems.StateSystem.prototype.setState = function (t) {
			return _e("v5.1.0", "StateSystem.setState has been renamed to StateSystem.set"), this.set(t)
		}, Object.assign(t.systems.FilterSystem.prototype, {
			getRenderTarget: function (t, e) {
				return _e(Qs, "PIXI.FilterManager.getRenderTarget method has been replaced with PIXI.systems.FilterSystem#getFilterTexture"), this.getFilterTexture(e)
			},
			returnRenderTarget: function (t) {
				_e(Qs, "PIXI.FilterManager.returnRenderTarget method has been replaced with PIXI.systems.FilterSystem.returnFilterTexture"), this.returnFilterTexture(t)
			},
			calculateScreenSpaceMatrix: function (t) {
				_e(Qs, "PIXI.systems.FilterSystem.calculateScreenSpaceMatrix method is removed, use `(vTextureCoord * inputSize.xy) + outputFrame.xy` instead");
				var e = t.identity(),
					r = this.activeState,
					i = r.sourceFrame,
					n = r.destinationFrame;
				return e.translate(i.x / n.width, i.y / n.height), e.scale(n.width, n.height), e
			},
			calculateNormalizedScreenSpaceMatrix: function (t) {
				_e(Qs, "PIXI.systems.FilterManager.calculateNormalizedScreenSpaceMatrix method is removed, use `((vTextureCoord * inputSize.xy) + outputFrame.xy) / outputFrame.zw` instead.");
				var e = this.activeState,
					r = e.sourceFrame,
					i = e.destinationFrame,
					n = t.identity();
				n.translate(r.x / i.width, r.y / i.height);
				var o = i.width / r.width,
					s = i.height / r.height;
				return n.scale(o, s), n
			}
		}), Object.defineProperties(t.RenderTexture.prototype, {
			sourceFrame: {
				get: function () {
					return _e(Qs, "PIXI.RenderTexture.sourceFrame property has been removed"), this.filterFrame
				}
			},
			size: {
				get: function () {
					return _e(Qs, "PIXI.RenderTexture.size property has been removed"), this._frame
				}
			}
		});
		var i = function (t) {
				function e(e, r, i, n) {
					_e(Qs, "PIXI.filters.BlurXFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !0, e, r, i, n)
				}
				return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
			}(t.filters.BlurFilterPass),
			n = function (t) {
				function e(e, r, i, n) {
					_e(Qs, "PIXI.filters.BlurYFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !1, e, r, i, n)
				}
				return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
			}(t.filters.BlurFilterPass);
		Object.assign(t.filters, {
			BlurXFilter: i,
			BlurYFilter: n
		});
		var o = t.Sprite,
			s = t.Texture,
			a = t.Graphics;

		function h(t, e, r, i) {
			return _e(Qs, "PIXI.Sprite." + t + " method is deprecated, use PIXI.Sprite.from"), o.from(e, {
				resourceOptions: {
					scale: i,
					crossorigin: r
				}
			})
		}

		function u(t, e, r, i) {
			return _e(Qs, "PIXI.Texture." + t + " method is deprecated, use PIXI.Texture.from"), s.from(e, {
				resourceOptions: {
					scale: i,
					crossorigin: r
				}
			})
		}
		a.prototype.generateCanvasTexture || (a.prototype.generateCanvasTexture = function () {
			_e(Qs, 'PIXI.Graphics.generateCanvasTexture method is only available in "pixi.js-legacy"')
		}), Object.defineProperty(t.Graphics.prototype, "graphicsData", {
			get: function () {
				return _e(Qs, "PIXI.Graphics.graphicsData property is deprecated, use PIXI.Graphics.geometry.graphicsData"), this.geometry.graphicsData
			}
		}), Object.defineProperty(t.SimpleRope.prototype, "points", {
			get: function () {
				return _e(Qs, "PIXI.SimpleRope.points property is deprecated, use PIXI.SimpleRope.geometry.points"), this.geometry.points
			},
			set: function (t) {
				_e(Qs, "PIXI.SimpleRope.points property is deprecated, use PIXI.SimpleRope.geometry.points"), this.geometry.points = t
			}
		}), o.fromImage = h.bind(null, "fromImage"), o.fromSVG = h.bind(null, "fromSVG"), o.fromCanvas = h.bind(null, "fromCanvas"), o.fromVideo = h.bind(null, "fromVideo"), o.fromFrame = h.bind(null, "fromFrame"), s.fromImage = u.bind(null, "fromImage"), s.fromSVG = u.bind(null, "fromSVG"), s.fromCanvas = u.bind(null, "fromCanvas"), s.fromVideo = u.bind(null, "fromVideo"), s.fromFrame = u.bind(null, "fromFrame"), Object.defineProperty(t.AbstractRenderer.prototype, "autoResize", {
			get: function () {
				return _e(Qs, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity
			},
			set: function (t) {
				_e(Qs, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity = t
			}
		}), Object.defineProperty(t.Renderer.prototype, "textureManager", {
			get: function () {
				return _e(Qs, "PIXI.Renderer.textureManager property is deprecated, use PIXI.Renderer.texture"), this.texture
			}
		}), t.utils.mixins = {
			mixin: function () {
				_e(Qs, "PIXI.utils.mixins.mixin function is no longer available")
			},
			delayMixin: function () {
				_e(Qs, "PIXI.utils.mixins.delayMixin function is no longer available")
			},
			performMixins: function () {
				_e(Qs, "PIXI.utils.mixins.performMixins function is no longer available")
			}
		}
	}, t.utils = De, t
}({});
PIXI.useDeprecated();
//# sourceMappingURL=pixi.min.js.map


/*!
 * pixi-filters - v3.1.0
 * Compiled Wed, 11 Mar 2020 20:38:18 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters = function (e, t, n, r, o, i, l, s) {
	"use strict";
	var a = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",
		u = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n",
		c = function (e) {
			function t(t) {
				e.call(this, a, u), Object.assign(this, {
					gamma: 1,
					saturation: 1,
					contrast: 1,
					brightness: 1,
					red: 1,
					green: 1,
					blue: 1,
					alpha: 1
				}, t)
			}
			return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.apply = function (e, t, n, r) {
				this.uniforms.gamma = Math.max(this.gamma, 1e-4), this.uniforms.saturation = this.saturation, this.uniforms.contrast = this.contrast, this.uniforms.brightness = this.brightness, this.uniforms.red = this.red, this.uniforms.green = this.green, this.uniforms.blue = this.blue, this.uniforms.alpha = this.alpha, e.applyFilter(this, t, n, r)
			}, t
		}(t.Filter),
		f = a,
		h = "\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}",
		p = "\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n",
		d = function (e) {
			function t(t, r, o) {
				void 0 === t && (t = 4), void 0 === r && (r = 3), void 0 === o && (o = !1), e.call(this, f, o ? p : h), this.uniforms.uOffset = new Float32Array(2), this._pixelSize = new n.Point, this.pixelSize = 1, this._clamp = o, this._kernels = null, Array.isArray(t) ? this.kernels = t : (this._blur = t, this.quality = r)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var r = {
				kernels: {
					configurable: !0
				},
				clamp: {
					configurable: !0
				},
				pixelSize: {
					configurable: !0
				},
				quality: {
					configurable: !0
				},
				blur: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				var o, i = this.pixelSize.x / t._frame.width,
					l = this.pixelSize.y / t._frame.height;
				if (1 === this._quality || 0 === this._blur) o = this._kernels[0] + .5, this.uniforms.uOffset[0] = o * i, this.uniforms.uOffset[1] = o * l, e.applyFilter(this, t, n, r);
				else {
					for (var s, a = e.getFilterTexture(), u = t, c = a, f = this._quality - 1, h = 0; h < f; h++) o = this._kernels[h] + .5, this.uniforms.uOffset[0] = o * i, this.uniforms.uOffset[1] = o * l, e.applyFilter(this, u, c, 1), s = u, u = c, c = s;
					o = this._kernels[f] + .5, this.uniforms.uOffset[0] = o * i, this.uniforms.uOffset[1] = o * l, e.applyFilter(this, u, n, r), e.returnFilterTexture(a)
				}
			}, t.prototype._generateKernels = function () {
				var e = this._blur,
					t = this._quality,
					n = [e];
				if (e > 0)
					for (var r = e, o = e / t, i = 1; i < t; i++) r -= o, n.push(r);
				this._kernels = n
			}, r.kernels.get = function () {
				return this._kernels
			}, r.kernels.set = function (e) {
				Array.isArray(e) && e.length > 0 ? (this._kernels = e, this._quality = e.length, this._blur = Math.max.apply(Math, e)) : (this._kernels = [0], this._quality = 1)
			}, r.clamp.get = function () {
				return this._clamp
			}, r.pixelSize.set = function (e) {
				"number" == typeof e ? (this._pixelSize.x = e, this._pixelSize.y = e) : Array.isArray(e) ? (this._pixelSize.x = e[0], this._pixelSize.y = e[1]) : e instanceof n.Point ? (this._pixelSize.x = e.x, this._pixelSize.y = e.y) : (this._pixelSize.x = 1, this._pixelSize.y = 1)
			}, r.pixelSize.get = function () {
				return this._pixelSize
			}, r.quality.get = function () {
				return this._quality
			}, r.quality.set = function (e) {
				this._quality = Math.max(1, Math.round(e)), this._generateKernels()
			}, r.blur.get = function () {
				return this._blur
			}, r.blur.set = function (e) {
				this._blur = e, this._generateKernels()
			}, Object.defineProperties(t.prototype, r), t
		}(t.Filter),
		m = a,
		g = "\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n",
		v = function (e) {
			function t(t) {
				void 0 === t && (t = .5), e.call(this, m, g), this.threshold = t
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				threshold: {
					configurable: !0
				}
			};
			return n.threshold.get = function () {
				return this.uniforms.threshold
			}, n.threshold.set = function (e) {
				this.uniforms.threshold = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		x = "uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n",
		y = function (e) {
			function t(t) {
				e.call(this, m, x), "number" == typeof t && (t = {
					threshold: t
				}), t = Object.assign({
					threshold: .5,
					bloomScale: 1,
					brightness: 1,
					kernels: null,
					blur: 8,
					quality: 4,
					pixelSize: 1,
					resolution: r.settings.RESOLUTION
				}, t), this.bloomScale = t.bloomScale, this.brightness = t.brightness;
				var n = t.kernels,
					o = t.blur,
					i = t.quality,
					l = t.pixelSize,
					s = t.resolution;
				this._extractFilter = new v(t.threshold), this._extractFilter.resolution = s, this._blurFilter = n ? new d(n) : new d(o, i), this.pixelSize = l, this.resolution = s
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				resolution: {
					configurable: !0
				},
				threshold: {
					configurable: !0
				},
				kernels: {
					configurable: !0
				},
				blur: {
					configurable: !0
				},
				quality: {
					configurable: !0
				},
				pixelSize: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r, o) {
				var i = e.getFilterTexture();
				this._extractFilter.apply(e, t, i, 1, o);
				var l = e.getFilterTexture();
				this._blurFilter.apply(e, i, l, 1, o), this.uniforms.bloomScale = this.bloomScale, this.uniforms.brightness = this.brightness, this.uniforms.bloomTexture = l, e.applyFilter(this, t, n, r), e.returnFilterTexture(l), e.returnFilterTexture(i)
			}, n.resolution.get = function () {
				return this._resolution
			}, n.resolution.set = function (e) {
				this._resolution = e, this._extractFilter && (this._extractFilter.resolution = e), this._blurFilter && (this._blurFilter.resolution = e)
			}, n.threshold.get = function () {
				return this._extractFilter.threshold
			}, n.threshold.set = function (e) {
				this._extractFilter.threshold = e
			}, n.kernels.get = function () {
				return this._blurFilter.kernels
			}, n.kernels.set = function (e) {
				this._blurFilter.kernels = e
			}, n.blur.get = function () {
				return this._blurFilter.blur
			}, n.blur.set = function (e) {
				this._blurFilter.blur = e
			}, n.quality.get = function () {
				return this._blurFilter.quality
			}, n.quality.set = function (e) {
				this._blurFilter.quality = e
			}, n.pixelSize.get = function () {
				return this._blurFilter.pixelSize
			}, n.pixelSize.set = function (e) {
				this._blurFilter.pixelSize = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		_ = a,
		b = "varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n",
		C = function (e) {
			function t(t) {
				void 0 === t && (t = 8), e.call(this, _, b), this.size = t
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				size: {
					configurable: !0
				}
			};
			return n.size.get = function () {
				return this.uniforms.pixelSize
			}, n.size.set = function (e) {
				this.uniforms.pixelSize = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		S = a,
		F = "precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n",
		z = function (e) {
			function t(t) {
				void 0 === t && (t = {}), e.call(this, S, F), this.uniforms.lightColor = new Float32Array(3), this.uniforms.shadowColor = new Float32Array(3), t = Object.assign({
					rotation: 45,
					thickness: 2,
					lightColor: 16777215,
					lightAlpha: .7,
					shadowColor: 0,
					shadowAlpha: .7
				}, t), this.rotation = t.rotation, this.thickness = t.thickness, this.lightColor = t.lightColor, this.lightAlpha = t.lightAlpha, this.shadowColor = t.shadowColor, this.shadowAlpha = t.shadowAlpha
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var r = {
				rotation: {
					configurable: !0
				},
				thickness: {
					configurable: !0
				},
				lightColor: {
					configurable: !0
				},
				lightAlpha: {
					configurable: !0
				},
				shadowColor: {
					configurable: !0
				},
				shadowAlpha: {
					configurable: !0
				}
			};
			return t.prototype._updateTransform = function () {
				this.uniforms.transformX = this._thickness * Math.cos(this._angle), this.uniforms.transformY = this._thickness * Math.sin(this._angle)
			}, r.rotation.get = function () {
				return this._angle / n.DEG_TO_RAD
			}, r.rotation.set = function (e) {
				this._angle = e * n.DEG_TO_RAD, this._updateTransform()
			}, r.thickness.get = function () {
				return this._thickness
			}, r.thickness.set = function (e) {
				this._thickness = e, this._updateTransform()
			}, r.lightColor.get = function () {
				return o.rgb2hex(this.uniforms.lightColor)
			}, r.lightColor.set = function (e) {
				o.hex2rgb(e, this.uniforms.lightColor)
			}, r.lightAlpha.get = function () {
				return this.uniforms.lightAlpha
			}, r.lightAlpha.set = function (e) {
				this.uniforms.lightAlpha = e
			}, r.shadowColor.get = function () {
				return o.rgb2hex(this.uniforms.shadowColor)
			}, r.shadowColor.set = function (e) {
				o.hex2rgb(e, this.uniforms.shadowColor)
			}, r.shadowAlpha.get = function () {
				return this.uniforms.shadowAlpha
			}, r.shadowAlpha.set = function (e) {
				this.uniforms.shadowAlpha = e
			}, Object.defineProperties(t.prototype, r), t
		}(t.Filter),
		A = function (e) {
			function t(t, o, a, u) {
				var c, f;
				void 0 === t && (t = 2), void 0 === o && (o = 4), void 0 === a && (a = r.settings.RESOLUTION), void 0 === u && (u = 5), e.call(this), "number" == typeof t ? (c = t, f = t) : t instanceof n.Point ? (c = t.x, f = t.y) : Array.isArray(t) && (c = t[0], f = t[1]), this.blurXFilter = new s.BlurFilterPass(!0, c, o, a, u), this.blurYFilter = new s.BlurFilterPass(!1, f, o, a, u), this.blurYFilter.blendMode = i.BLEND_MODES.SCREEN, this.defaultFilter = new l.AlphaFilter
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var o = {
				blur: {
					configurable: !0
				},
				blurX: {
					configurable: !0
				},
				blurY: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n) {
				var r = e.getFilterTexture(!0);
				this.defaultFilter.apply(e, t, n), this.blurXFilter.apply(e, t, r), this.blurYFilter.apply(e, r, n), e.returnFilterTexture(r)
			}, o.blur.get = function () {
				return this.blurXFilter.blur
			}, o.blur.set = function (e) {
				this.blurXFilter.blur = this.blurYFilter.blur = e
			}, o.blurX.get = function () {
				return this.blurXFilter.blur
			}, o.blurX.set = function (e) {
				this.blurXFilter.blur = e
			}, o.blurY.get = function () {
				return this.blurYFilter.blur
			}, o.blurY.set = function (e) {
				this.blurYFilter.blur = e
			}, Object.defineProperties(t.prototype, o), t
		}(t.Filter),
		w = a,
		T = "uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n",
		O = function (e) {
			function t(t) {
				if (e.call(this, w, T), "object" != typeof t) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					t = {}, void 0 !== n && (t.center = n), void 0 !== r && (t.radius = r), void 0 !== o && (t.strength = o)
				}
				this.uniforms.dimensions = new Float32Array(2), Object.assign(this, {
					center: [.5, .5],
					radius: 100,
					strength: 1
				}, t)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				radius: {
					configurable: !0
				},
				strength: {
					configurable: !0
				},
				center: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.dimensions[0] = t.filterFrame.width, this.uniforms.dimensions[1] = t.filterFrame.height, e.applyFilter(this, t, n, r)
			}, n.radius.get = function () {
				return this.uniforms.radius
			}, n.radius.set = function (e) {
				this.uniforms.radius = e
			}, n.strength.get = function () {
				return this.uniforms.strength
			}, n.strength.set = function (e) {
				this.uniforms.strength = e
			}, n.center.get = function () {
				return this.uniforms.center
			}, n.center.set = function (e) {
				this.uniforms.center = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		D = a,
		P = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}",
		M = function (e) {
			function n(t, n, r) {
				void 0 === n && (n = !1), void 0 === r && (r = 1), e.call(this, D, P), this._size = 0, this._sliceSize = 0, this._slicePixelSize = 0, this._sliceInnerSize = 0, this._scaleMode = null, this._nearest = !1, this.nearest = n, this.mix = r, this.colorMap = t
			}
			e && (n.__proto__ = e), n.prototype = Object.create(e && e.prototype), n.prototype.constructor = n;
			var r = {
				colorSize: {
					configurable: !0
				},
				colorMap: {
					configurable: !0
				},
				nearest: {
					configurable: !0
				}
			};
			return n.prototype.apply = function (e, t, n, r) {
				this.uniforms._mix = this.mix, e.applyFilter(this, t, n, r)
			}, r.colorSize.get = function () {
				return this._size
			}, r.colorMap.get = function () {
				return this._colorMap
			}, r.colorMap.set = function (e) {
				e instanceof t.Texture || (e = t.Texture.from(e)), e && e.baseTexture && (e.baseTexture.scaleMode = this._scaleMode, e.baseTexture.mipmap = !1, this._size = e.height, this._sliceSize = 1 / this._size, this._slicePixelSize = this._sliceSize / this._size, this._sliceInnerSize = this._slicePixelSize * (this._size - 1), this.uniforms._size = this._size, this.uniforms._sliceSize = this._sliceSize, this.uniforms._slicePixelSize = this._slicePixelSize, this.uniforms._sliceInnerSize = this._sliceInnerSize, this.uniforms.colorMap = e), this._colorMap = e
			}, r.nearest.get = function () {
				return this._nearest
			}, r.nearest.set = function (e) {
				this._nearest = e, this._scaleMode = e ? i.SCALE_MODES.NEAREST : i.SCALE_MODES.LINEAR;
				var t = this._colorMap;
				t && t.baseTexture && (t.baseTexture._glTextures = {}, t.baseTexture.scaleMode = this._scaleMode, t.baseTexture.mipmap = !1, t._updateID++, t.baseTexture.emit("update", t.baseTexture))
			}, n.prototype.updateColorMap = function () {
				var e = this._colorMap;
				e && e.baseTexture && (e._updateID++, e.baseTexture.emit("update", e.baseTexture), this.colorMap = e)
			}, n.prototype.destroy = function (t) {
				this._colorMap && this._colorMap.destroy(t), e.prototype.destroy.call(this)
			}, Object.defineProperties(n.prototype, r), n
		}(t.Filter),
		R = a,
		k = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorOverlay = color * currentColor.a;\n    gl_FragColor = vec4(colorOverlay.r, colorOverlay.g, colorOverlay.b, currentColor.a);\n}\n",
		j = function (e) {
			function t(t) {
				void 0 === t && (t = 0), e.call(this, R, k), this.uniforms.color = new Float32Array(3), this.color = t
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				color: {
					configurable: !0
				}
			};
			return n.color.set = function (e) {
				var t = this.uniforms.color;
				"number" == typeof e ? (o.hex2rgb(e, t), this._color = e) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], this._color = o.rgb2hex(t))
			}, n.color.get = function () {
				return this._color
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		E = a,
		L = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n",
		I = function (e) {
			function t(t, n, r) {
				void 0 === t && (t = 16711680), void 0 === n && (n = 0), void 0 === r && (r = .4), e.call(this, E, L), this.uniforms.originalColor = new Float32Array(3), this.uniforms.newColor = new Float32Array(3), this.originalColor = t, this.newColor = n, this.epsilon = r
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				originalColor: {
					configurable: !0
				},
				newColor: {
					configurable: !0
				},
				epsilon: {
					configurable: !0
				}
			};
			return n.originalColor.set = function (e) {
				var t = this.uniforms.originalColor;
				"number" == typeof e ? (o.hex2rgb(e, t), this._originalColor = e) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], this._originalColor = o.rgb2hex(t))
			}, n.originalColor.get = function () {
				return this._originalColor
			}, n.newColor.set = function (e) {
				var t = this.uniforms.newColor;
				"number" == typeof e ? (o.hex2rgb(e, t), this._newColor = e) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], this._newColor = o.rgb2hex(t))
			}, n.newColor.get = function () {
				return this._newColor
			}, n.epsilon.set = function (e) {
				this.uniforms.epsilon = e
			}, n.epsilon.get = function () {
				return this.uniforms.epsilon
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		X = a,
		B = "precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n",
		N = function (e) {
			function t(t, n, r) {
				void 0 === n && (n = 200), void 0 === r && (r = 200), e.call(this, X, B), this.uniforms.texelSize = new Float32Array(2), this.uniforms.matrix = new Float32Array(9), void 0 !== t && (this.matrix = t), this.width = n, this.height = r
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				matrix: {
					configurable: !0
				},
				width: {
					configurable: !0
				},
				height: {
					configurable: !0
				}
			};
			return n.matrix.get = function () {
				return this.uniforms.matrix
			}, n.matrix.set = function (e) {
				var t = this;
				e.forEach(function (e, n) {
					return t.uniforms.matrix[n] = e
				})
			}, n.width.get = function () {
				return 1 / this.uniforms.texelSize[0]
			}, n.width.set = function (e) {
				this.uniforms.texelSize[0] = 1 / e
			}, n.height.get = function () {
				return 1 / this.uniforms.texelSize[1]
			}, n.height.set = function (e) {
				this.uniforms.texelSize[1] = 1 / e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		G = a,
		q = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n",
		W = function (e) {
			function t() {
				e.call(this, G, q)
			}
			return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t
		}(t.Filter),
		K = a,
		Y = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    vec2 dir = vec2(coord - vec2(0.5, 0.5));\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0) {\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n",
		Z = function (e) {
			function t(t) {
				e.call(this, K, Y), this.uniforms.dimensions = new Float32Array(2), this.time = 0, this.seed = 0, Object.assign(this, {
					curvature: 1,
					lineWidth: 1,
					lineContrast: .25,
					verticalLine: !1,
					noise: 0,
					noiseSize: 1,
					seed: 0,
					vignetting: .3,
					vignettingAlpha: 1,
					vignettingBlur: .3,
					time: 0
				}, t)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				curvature: {
					configurable: !0
				},
				lineWidth: {
					configurable: !0
				},
				lineContrast: {
					configurable: !0
				},
				verticalLine: {
					configurable: !0
				},
				noise: {
					configurable: !0
				},
				noiseSize: {
					configurable: !0
				},
				vignetting: {
					configurable: !0
				},
				vignettingAlpha: {
					configurable: !0
				},
				vignettingBlur: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.dimensions[0] = t.filterFrame.width, this.uniforms.dimensions[1] = t.filterFrame.height, this.uniforms.seed = this.seed, this.uniforms.time = this.time, e.applyFilter(this, t, n, r)
			}, n.curvature.set = function (e) {
				this.uniforms.curvature = e
			}, n.curvature.get = function () {
				return this.uniforms.curvature
			}, n.lineWidth.set = function (e) {
				this.uniforms.lineWidth = e
			}, n.lineWidth.get = function () {
				return this.uniforms.lineWidth
			}, n.lineContrast.set = function (e) {
				this.uniforms.lineContrast = e
			}, n.lineContrast.get = function () {
				return this.uniforms.lineContrast
			}, n.verticalLine.set = function (e) {
				this.uniforms.verticalLine = e
			}, n.verticalLine.get = function () {
				return this.uniforms.verticalLine
			}, n.noise.set = function (e) {
				this.uniforms.noise = e
			}, n.noise.get = function () {
				return this.uniforms.noise
			}, n.noiseSize.set = function (e) {
				this.uniforms.noiseSize = e
			}, n.noiseSize.get = function () {
				return this.uniforms.noiseSize
			}, n.vignetting.set = function (e) {
				this.uniforms.vignetting = e
			}, n.vignetting.get = function () {
				return this.uniforms.vignetting
			}, n.vignettingAlpha.set = function (e) {
				this.uniforms.vignettingAlpha = e
			}, n.vignettingAlpha.get = function () {
				return this.uniforms.vignettingAlpha
			}, n.vignettingBlur.set = function (e) {
				this.uniforms.vignettingBlur = e
			}, n.vignettingBlur.get = function () {
				return this.uniforms.vignettingBlur
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Q = a,
		U = "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n",
		V = function (e) {
			function t(t, n) {
				void 0 === t && (t = 1), void 0 === n && (n = 5), e.call(this, Q, U), this.scale = t, this.angle = n
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				scale: {
					configurable: !0
				},
				angle: {
					configurable: !0
				}
			};
			return n.scale.get = function () {
				return this.uniforms.scale
			}, n.scale.set = function (e) {
				this.uniforms.scale = e
			}, n.angle.get = function () {
				return this.uniforms.angle
			}, n.angle.set = function (e) {
				this.uniforms.angle = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		H = a,
		$ = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}",
		J = function (e) {
			function t(t) {
				t && t.constructor !== Object && (console.warn("DropShadowFilter now uses options instead of (rotation, distance, blur, color, alpha)"), t = {
					rotation: t
				}, void 0 !== arguments[1] && (t.distance = arguments[1]), void 0 !== arguments[2] && (t.blur = arguments[2]), void 0 !== arguments[3] && (t.color = arguments[3]), void 0 !== arguments[4] && (t.alpha = arguments[4])), t = Object.assign({
					rotation: 45,
					distance: 5,
					color: 0,
					alpha: .5,
					shadowOnly: !1,
					kernels: null,
					blur: 2,
					quality: 3,
					pixelSize: 1,
					resolution: r.settings.RESOLUTION
				}, t), e.call(this);
				var o = t.kernels,
					i = t.blur,
					l = t.quality,
					s = t.pixelSize,
					a = t.resolution;
				this._tintFilter = new e(H, $), this._tintFilter.uniforms.color = new Float32Array(4), this._tintFilter.uniforms.shift = new n.Point, this._tintFilter.resolution = a, this._blurFilter = o ? new d(o) : new d(i, l), this.pixelSize = s, this.resolution = a;
				var u = t.shadowOnly,
					c = t.rotation,
					f = t.distance,
					h = t.alpha,
					p = t.color;
				this.shadowOnly = u, this.rotation = c, this.distance = f, this.alpha = h, this.color = p, this._updatePadding()
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var i = {
				resolution: {
					configurable: !0
				},
				distance: {
					configurable: !0
				},
				rotation: {
					configurable: !0
				},
				alpha: {
					configurable: !0
				},
				color: {
					configurable: !0
				},
				kernels: {
					configurable: !0
				},
				blur: {
					configurable: !0
				},
				quality: {
					configurable: !0
				},
				pixelSize: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				var o = e.getFilterTexture();
				this._tintFilter.apply(e, t, o, 1), this._blurFilter.apply(e, o, n, r), !0 !== this.shadowOnly && e.applyFilter(this, t, n, 0), e.returnFilterTexture(o)
			}, t.prototype._updatePadding = function () {
				this.padding = this.distance + 2 * this.blur
			}, t.prototype._updateShift = function () {
				this._tintFilter.uniforms.shift.set(this.distance * Math.cos(this.angle), this.distance * Math.sin(this.angle))
			}, i.resolution.get = function () {
				return this._resolution
			}, i.resolution.set = function (e) {
				this._resolution = e, this._tintFilter && (this._tintFilter.resolution = e), this._blurFilter && (this._blurFilter.resolution = e)
			}, i.distance.get = function () {
				return this._distance
			}, i.distance.set = function (e) {
				this._distance = e, this._updatePadding(), this._updateShift()
			}, i.rotation.get = function () {
				return this.angle / n.DEG_TO_RAD
			}, i.rotation.set = function (e) {
				this.angle = e * n.DEG_TO_RAD, this._updateShift()
			}, i.alpha.get = function () {
				return this._tintFilter.uniforms.alpha
			}, i.alpha.set = function (e) {
				this._tintFilter.uniforms.alpha = e
			}, i.color.get = function () {
				return o.rgb2hex(this._tintFilter.uniforms.color)
			}, i.color.set = function (e) {
				o.hex2rgb(e, this._tintFilter.uniforms.color)
			}, i.kernels.get = function () {
				return this._blurFilter.kernels
			}, i.kernels.set = function (e) {
				this._blurFilter.kernels = e
			}, i.blur.get = function () {
				return this._blurFilter.blur
			}, i.blur.set = function (e) {
				this._blurFilter.blur = e, this._updatePadding()
			}, i.quality.get = function () {
				return this._blurFilter.quality
			}, i.quality.set = function (e) {
				this._blurFilter.quality = e
			}, i.pixelSize.get = function () {
				return this._blurFilter.pixelSize
			}, i.pixelSize.set = function (e) {
				this._blurFilter.pixelSize = e
			}, Object.defineProperties(t.prototype, i), t
		}(t.Filter),
		ee = a,
		te = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n",
		ne = function (e) {
			function t(t) {
				void 0 === t && (t = 5), e.call(this, ee, te), this.strength = t
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				strength: {
					configurable: !0
				}
			};
			return n.strength.get = function () {
				return this.uniforms.strength
			}, n.strength.set = function (e) {
				this.uniforms.strength = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		re = a,
		oe = "// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n",
		ie = function (e) {
			function r(n) {
				void 0 === n && (n = {}), e.call(this, re, oe), this.uniforms.dimensions = new Float32Array(2), n = Object.assign({
					slices: 5,
					offset: 100,
					direction: 0,
					fillMode: 0,
					average: !1,
					seed: 0,
					red: [0, 0],
					green: [0, 0],
					blue: [0, 0],
					minSize: 8,
					sampleSize: 512
				}, n), this.direction = n.direction, this.red = n.red, this.green = n.green, this.blue = n.blue, this.offset = n.offset, this.fillMode = n.fillMode, this.average = n.average, this.seed = n.seed, this.minSize = n.minSize, this.sampleSize = n.sampleSize, this._canvas = document.createElement("canvas"), this._canvas.width = 4, this._canvas.height = this.sampleSize, this.texture = t.Texture.from(this._canvas, {
					scaleMode: i.SCALE_MODES.NEAREST
				}), this._slices = 0, this.slices = n.slices
			}
			e && (r.__proto__ = e), r.prototype = Object.create(e && e.prototype), r.prototype.constructor = r;
			var o = {
				sizes: {
					configurable: !0
				},
				offsets: {
					configurable: !0
				},
				slices: {
					configurable: !0
				},
				direction: {
					configurable: !0
				},
				red: {
					configurable: !0
				},
				green: {
					configurable: !0
				},
				blue: {
					configurable: !0
				}
			};
			return r.prototype.apply = function (e, t, n, r) {
				var o = t.filterFrame.width,
					i = t.filterFrame.height;
				this.uniforms.dimensions[0] = o, this.uniforms.dimensions[1] = i, this.uniforms.aspect = i / o, this.uniforms.seed = this.seed, this.uniforms.offset = this.offset, this.uniforms.fillMode = this.fillMode, e.applyFilter(this, t, n, r)
			}, r.prototype._randomizeSizes = function () {
				var e = this._sizes,
					t = this._slices - 1,
					n = this.sampleSize,
					r = Math.min(this.minSize / n, .9 / this._slices);
				if (this.average) {
					for (var o = this._slices, i = 1, l = 0; l < t; l++) {
						var s = i / (o - l),
							a = Math.max(s * (1 - .6 * Math.random()), r);
						e[l] = a, i -= a
					}
					e[t] = i
				} else {
					for (var u = 1, c = Math.sqrt(1 / this._slices), f = 0; f < t; f++) {
						var h = Math.max(c * u * Math.random(), r);
						e[f] = h, u -= h
					}
					e[t] = u
				}
				this.shuffle()
			}, r.prototype.shuffle = function () {
				for (var e = this._sizes, t = this._slices - 1; t > 0; t--) {
					var n = Math.random() * t >> 0,
						r = e[t];
					e[t] = e[n], e[n] = r
				}
			}, r.prototype._randomizeOffsets = function () {
				for (var e = 0; e < this._slices; e++) this._offsets[e] = Math.random() * (Math.random() < .5 ? -1 : 1)
			}, r.prototype.refresh = function () {
				this._randomizeSizes(), this._randomizeOffsets(), this.redraw()
			}, r.prototype.redraw = function () {
				var e, t = this.sampleSize,
					n = this.texture,
					r = this._canvas.getContext("2d");
				r.clearRect(0, 0, 8, t);
				for (var o = 0, i = 0; i < this._slices; i++) {
					e = Math.floor(256 * this._offsets[i]);
					var l = this._sizes[i] * t,
						s = e > 0 ? e : 0,
						a = e < 0 ? -e : 0;
					r.fillStyle = "rgba(" + s + ", " + a + ", 0, 1)", r.fillRect(0, o >> 0, t, l + 1 >> 0), o += l
				}
				n.baseTexture.update(), this.uniforms.displacementMap = n
			}, o.sizes.set = function (e) {
				for (var t = Math.min(this._slices, e.length), n = 0; n < t; n++) this._sizes[n] = e[n]
			}, o.sizes.get = function () {
				return this._sizes
			}, o.offsets.set = function (e) {
				for (var t = Math.min(this._slices, e.length), n = 0; n < t; n++) this._offsets[n] = e[n]
			}, o.offsets.get = function () {
				return this._offsets
			}, o.slices.get = function () {
				return this._slices
			}, o.slices.set = function (e) {
				this._slices !== e && (this._slices = e, this.uniforms.slices = e, this._sizes = this.uniforms.slicesWidth = new Float32Array(e), this._offsets = this.uniforms.slicesOffset = new Float32Array(e), this.refresh())
			}, o.direction.get = function () {
				return this._direction
			}, o.direction.set = function (e) {
				if (this._direction !== e) {
					this._direction = e;
					var t = e * n.DEG_TO_RAD;
					this.uniforms.sinDir = Math.sin(t), this.uniforms.cosDir = Math.cos(t)
				}
			}, o.red.get = function () {
				return this.uniforms.red
			}, o.red.set = function (e) {
				this.uniforms.red = e
			}, o.green.get = function () {
				return this.uniforms.green
			}, o.green.set = function (e) {
				this.uniforms.green = e
			}, o.blue.get = function () {
				return this.uniforms.blue
			}, o.blue.set = function (e) {
				this.uniforms.blue = e
			}, r.prototype.destroy = function () {
				this.texture.destroy(!0), this.texture = null, this._canvas = null, this.red = null, this.green = null, this.blue = null, this._sizes = null, this._offsets = null
			}, Object.defineProperties(r.prototype, o), r
		}(t.Filter);
	ie.TRANSPARENT = 0, ie.ORIGINAL = 1, ie.LOOP = 2, ie.CLAMP = 3, ie.MIRROR = 4;
	var le = a,
		se = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n    \n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n",
		ae = function (e) {
			function t(n) {
				var r = Object.assign({}, t.defaults, n),
					o = r.distance,
					i = r.outerStrength,
					l = r.innerStrength,
					s = r.color,
					a = r.knockout,
					u = r.quality;
				o = Math.round(o), e.call(this, le, se.replace(/__ANGLE_STEP_SIZE__/gi, "" + (1 / u / o).toFixed(7)).replace(/__DIST__/gi, o.toFixed(0) + ".0")), this.uniforms.glowColor = new Float32Array([0, 0, 0, 1]), Object.assign(this, {
					color: s,
					outerStrength: i,
					innerStrength: l,
					padding: o,
					knockout: a
				})
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				color: {
					configurable: !0
				},
				outerStrength: {
					configurable: !0
				},
				innerStrength: {
					configurable: !0
				},
				knockout: {
					configurable: !0
				}
			};
			return n.color.get = function () {
				return o.rgb2hex(this.uniforms.glowColor)
			}, n.color.set = function (e) {
				o.hex2rgb(e, this.uniforms.glowColor)
			}, n.outerStrength.get = function () {
				return this.uniforms.outerStrength
			}, n.outerStrength.set = function (e) {
				this.uniforms.outerStrength = e
			}, n.innerStrength.get = function () {
				return this.uniforms.innerStrength
			}, n.innerStrength.set = function (e) {
				this.uniforms.innerStrength = e
			}, n.knockout.get = function () {
				return this.uniforms.knockout
			}, n.knockout.set = function (e) {
				this.uniforms.knockout = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter);
	ae.defaults = {
		distance: 10,
		outerStrength: 4,
		innerStrength: 0,
		color: 16777215,
		quality: .1,
		knockout: !1
	};
	var ue = a,
		ce = "vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n",
		fe = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n}\n",
		he = function (e) {
			function t(t) {
				e.call(this, ue, fe.replace("${perlin}", ce)), this.uniforms.dimensions = new Float32Array(2), "number" == typeof t && (console.warn("GodrayFilter now uses options instead of (angle, gain, lacunarity, time)"), t = {
					angle: t
				}, void 0 !== arguments[1] && (t.gain = arguments[1]), void 0 !== arguments[2] && (t.lacunarity = arguments[2]), void 0 !== arguments[3] && (t.time = arguments[3])), t = Object.assign({
					angle: 30,
					gain: .5,
					lacunarity: 2.5,
					time: 0,
					parallel: !0,
					center: [0, 0]
				}, t), this._angleLight = new n.Point, this.angle = t.angle, this.gain = t.gain, this.lacunarity = t.lacunarity, this.parallel = t.parallel, this.center = t.center, this.time = t.time
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var r = {
				angle: {
					configurable: !0
				},
				gain: {
					configurable: !0
				},
				lacunarity: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				var o = t.filterFrame,
					i = o.width,
					l = o.height;
				this.uniforms.light = this.parallel ? this._angleLight : this.center, this.uniforms.parallel = this.parallel, this.uniforms.dimensions[0] = i, this.uniforms.dimensions[1] = l, this.uniforms.aspect = l / i, this.uniforms.time = this.time, e.applyFilter(this, t, n, r)
			}, r.angle.get = function () {
				return this._angle
			}, r.angle.set = function (e) {
				this._angle = e;
				var t = e * n.DEG_TO_RAD;
				this._angleLight.x = Math.cos(t), this._angleLight.y = Math.sin(t)
			}, r.gain.get = function () {
				return this.uniforms.gain
			}, r.gain.set = function (e) {
				this.uniforms.gain = e
			}, r.lacunarity.get = function () {
				return this.uniforms.lacunarity
			}, r.lacunarity.set = function (e) {
				this.uniforms.lacunarity = e
			}, Object.defineProperties(t.prototype, r), t
		}(t.Filter),
		pe = a,
		de = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n",
		me = function (e) {
			function t(t, r, o) {
				void 0 === t && (t = [0, 0]), void 0 === r && (r = 5), void 0 === o && (o = 0), e.call(this, pe, de), this.uniforms.uVelocity = new Float32Array(2), this._velocity = new n.ObservablePoint(this.velocityChanged, this), this.velocity = t, this.kernelSize = r, this.offset = o
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var r = {
				velocity: {
					configurable: !0
				},
				offset: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				var o = this.velocity,
					i = o.x,
					l = o.y;
				this.uniforms.uKernelSize = 0 !== i || 0 !== l ? this.kernelSize : 0, e.applyFilter(this, t, n, r)
			}, r.velocity.set = function (e) {
				Array.isArray(e) ? this._velocity.set(e[0], e[1]) : (e instanceof n.Point || e instanceof n.ObservablePoint) && this._velocity.copyFrom(e)
			}, r.velocity.get = function () {
				return this._velocity
			}, t.prototype.velocityChanged = function () {
				this.uniforms.uVelocity[0] = this._velocity.x, this.uniforms.uVelocity[1] = this._velocity.y
			}, r.offset.set = function (e) {
				this.uniforms.uOffset = e
			}, r.offset.get = function () {
				return this.uniforms.uOffset
			}, Object.defineProperties(t.prototype, r), t
		}(t.Filter),
		ge = a,
		ve = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n",
		xe = function (e) {
			function t(t, n, r) {
				void 0 === n && (n = .05), void 0 === r && (r = null), r = r || t.length, e.call(this, ge, ve.replace(/%maxColors%/g, r)), this.epsilon = n, this._maxColors = r, this._replacements = null, this.uniforms.originalColors = new Float32Array(3 * r), this.uniforms.targetColors = new Float32Array(3 * r), this.replacements = t
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				replacements: {
					configurable: !0
				},
				maxColors: {
					configurable: !0
				},
				epsilon: {
					configurable: !0
				}
			};
			return n.replacements.set = function (e) {
				var t = this.uniforms.originalColors,
					n = this.uniforms.targetColors,
					r = e.length;
				if (r > this._maxColors) throw "Length of replacements (" + r + ") exceeds the maximum colors length (" + this._maxColors + ")";
				t[3 * r] = -1;
				for (var i = 0; i < r; i++) {
					var l = e[i],
						s = l[0];
					"number" == typeof s ? s = o.hex2rgb(s) : l[0] = o.rgb2hex(s), t[3 * i] = s[0], t[3 * i + 1] = s[1], t[3 * i + 2] = s[2];
					var a = l[1];
					"number" == typeof a ? a = o.hex2rgb(a) : l[1] = o.rgb2hex(a), n[3 * i] = a[0], n[3 * i + 1] = a[1], n[3 * i + 2] = a[2]
				}
				this._replacements = e
			}, n.replacements.get = function () {
				return this._replacements
			}, t.prototype.refresh = function () {
				this.replacements = this._replacements
			}, n.maxColors.get = function () {
				return this._maxColors
			}, n.epsilon.set = function (e) {
				this.uniforms.epsilon = e
			}, n.epsilon.get = function () {
				return this.uniforms.epsilon
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		ye = a,
		_e = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n",
		be = function (e) {
			function t(t, n) {
				void 0 === n && (n = 0), e.call(this, ye, _e), this.uniforms.dimensions = new Float32Array(2), "number" == typeof t ? (this.seed = t, t = null) : this.seed = n, Object.assign(this, {
					sepia: .3,
					noise: .3,
					noiseSize: 1,
					scratch: .5,
					scratchDensity: .3,
					scratchWidth: 1,
					vignetting: .3,
					vignettingAlpha: 1,
					vignettingBlur: .3
				}, t)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				sepia: {
					configurable: !0
				},
				noise: {
					configurable: !0
				},
				noiseSize: {
					configurable: !0
				},
				scratch: {
					configurable: !0
				},
				scratchDensity: {
					configurable: !0
				},
				scratchWidth: {
					configurable: !0
				},
				vignetting: {
					configurable: !0
				},
				vignettingAlpha: {
					configurable: !0
				},
				vignettingBlur: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.dimensions[0] = t.filterFrame.width, this.uniforms.dimensions[1] = t.filterFrame.height, this.uniforms.seed = this.seed, e.applyFilter(this, t, n, r)
			}, n.sepia.set = function (e) {
				this.uniforms.sepia = e
			}, n.sepia.get = function () {
				return this.uniforms.sepia
			}, n.noise.set = function (e) {
				this.uniforms.noise = e
			}, n.noise.get = function () {
				return this.uniforms.noise
			}, n.noiseSize.set = function (e) {
				this.uniforms.noiseSize = e
			}, n.noiseSize.get = function () {
				return this.uniforms.noiseSize
			}, n.scratch.set = function (e) {
				this.uniforms.scratch = e
			}, n.scratch.get = function () {
				return this.uniforms.scratch
			}, n.scratchDensity.set = function (e) {
				this.uniforms.scratchDensity = e
			}, n.scratchDensity.get = function () {
				return this.uniforms.scratchDensity
			}, n.scratchWidth.set = function (e) {
				this.uniforms.scratchWidth = e
			}, n.scratchWidth.get = function () {
				return this.uniforms.scratchWidth
			}, n.vignetting.set = function (e) {
				this.uniforms.vignetting = e
			}, n.vignetting.get = function () {
				return this.uniforms.vignetting
			}, n.vignettingAlpha.set = function (e) {
				this.uniforms.vignettingAlpha = e
			}, n.vignettingAlpha.get = function () {
				return this.uniforms.vignettingAlpha
			}, n.vignettingBlur.set = function (e) {
				this.uniforms.vignettingBlur = e
			}, n.vignettingBlur.get = function () {
				return this.uniforms.vignettingBlur
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Ce = a,
		Se = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n",
		Fe = function (e) {
			function t(n, r, o) {
				void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === o && (o = .1);
				var i = Math.max(o * t.MAX_SAMPLES, t.MIN_SAMPLES),
					l = (2 * Math.PI / i).toFixed(7);
				e.call(this, Ce, Se.replace(/\$\{angleStep\}/, l)), this.uniforms.thickness = new Float32Array([0, 0]), this.thickness = n, this.uniforms.outlineColor = new Float32Array([0, 0, 0, 1]), this.color = r, this.quality = o
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				color: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.thickness[0] = this.thickness / t._frame.width, this.uniforms.thickness[1] = this.thickness / t._frame.height, e.applyFilter(this, t, n, r)
			}, n.color.get = function () {
				return o.rgb2hex(this.uniforms.outlineColor)
			}, n.color.set = function (e) {
				o.hex2rgb(e, this.uniforms.outlineColor)
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter);
	Fe.MIN_SAMPLES = 1, Fe.MAX_SAMPLES = 100;
	var ze = a,
		Ae = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n",
		we = function (e) {
			function t(t) {
				void 0 === t && (t = 10), e.call(this, ze, Ae), this.size = t
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				size: {
					configurable: !0
				}
			};
			return n.size.get = function () {
				return this.uniforms.size
			}, n.size.set = function (e) {
				"number" == typeof e && (e = [e, e]), this.uniforms.size = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Te = a,
		Oe = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n",
		De = function (e) {
			function t(t, n, r, o) {
				void 0 === t && (t = 0), void 0 === n && (n = [0, 0]), void 0 === r && (r = 5), void 0 === o && (o = -1), e.call(this, Te, Oe), this._angle = 0, this.angle = t, this.center = n, this.kernelSize = r, this.radius = o
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				angle: {
					configurable: !0
				},
				center: {
					configurable: !0
				},
				radius: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.uKernelSize = 0 !== this._angle ? this.kernelSize : 0, e.applyFilter(this, t, n, r)
			}, n.angle.set = function (e) {
				this._angle = e, this.uniforms.uRadian = e * Math.PI / 180
			}, n.angle.get = function () {
				return this._angle
			}, n.center.get = function () {
				return this.uniforms.uCenter
			}, n.center.set = function (e) {
				this.uniforms.uCenter = e
			}, n.radius.get = function () {
				return this.uniforms.uRadius
			}, n.radius.set = function (e) {
				(e < 0 || e === 1 / 0) && (e = -1), this.uniforms.uRadius = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Pe = a,
		Me = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n",
		Re = function (e) {
			function t(t) {
				e.call(this, Pe, Me), this.uniforms.amplitude = new Float32Array(2), this.uniforms.waveLength = new Float32Array(2), this.uniforms.alpha = new Float32Array(2), this.uniforms.dimensions = new Float32Array(2), Object.assign(this, {
					mirror: !0,
					boundary: .5,
					amplitude: [0, 20],
					waveLength: [30, 100],
					alpha: [1, 1],
					time: 0
				}, t)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				mirror: {
					configurable: !0
				},
				boundary: {
					configurable: !0
				},
				amplitude: {
					configurable: !0
				},
				waveLength: {
					configurable: !0
				},
				alpha: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.dimensions[0] = t.filterFrame.width, this.uniforms.dimensions[1] = t.filterFrame.height, this.uniforms.time = this.time, e.applyFilter(this, t, n, r)
			}, n.mirror.set = function (e) {
				this.uniforms.mirror = e
			}, n.mirror.get = function () {
				return this.uniforms.mirror
			}, n.boundary.set = function (e) {
				this.uniforms.boundary = e
			}, n.boundary.get = function () {
				return this.uniforms.boundary
			}, n.amplitude.set = function (e) {
				this.uniforms.amplitude[0] = e[0], this.uniforms.amplitude[1] = e[1]
			}, n.amplitude.get = function () {
				return this.uniforms.amplitude
			}, n.waveLength.set = function (e) {
				this.uniforms.waveLength[0] = e[0], this.uniforms.waveLength[1] = e[1]
			}, n.waveLength.get = function () {
				return this.uniforms.waveLength
			}, n.alpha.set = function (e) {
				this.uniforms.alpha[0] = e[0], this.uniforms.alpha[1] = e[1]
			}, n.alpha.get = function () {
				return this.uniforms.alpha
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		ke = a,
		je = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n",
		Ee = function (e) {
			function t(t, n, r) {
				void 0 === t && (t = [-10, 0]), void 0 === n && (n = [0, 10]), void 0 === r && (r = [0, 0]), e.call(this, ke, je), this.red = t, this.green = n, this.blue = r
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				red: {
					configurable: !0
				},
				green: {
					configurable: !0
				},
				blue: {
					configurable: !0
				}
			};
			return n.red.get = function () {
				return this.uniforms.red
			}, n.red.set = function (e) {
				this.uniforms.red = e
			}, n.green.get = function () {
				return this.uniforms.green
			}, n.green.set = function (e) {
				this.uniforms.green = e
			}, n.blue.get = function () {
				return this.uniforms.blue
			}, n.blue.set = function (e) {
				this.uniforms.blue = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Le = a,
		Ie = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n",
		Xe = function (e) {
			function t(t, n, r) {
				void 0 === t && (t = [0, 0]), void 0 === n && (n = {}), void 0 === r && (r = 0), e.call(this, Le, Ie), this.center = t, Array.isArray(n) && (console.warn("Deprecated Warning: ShockwaveFilter params Array has been changed to options Object."), n = {}), n = Object.assign({
					amplitude: 30,
					wavelength: 160,
					brightness: 1,
					speed: 500,
					radius: -1
				}, n), this.amplitude = n.amplitude, this.wavelength = n.wavelength, this.brightness = n.brightness, this.speed = n.speed, this.radius = n.radius, this.time = r
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				center: {
					configurable: !0
				},
				amplitude: {
					configurable: !0
				},
				wavelength: {
					configurable: !0
				},
				brightness: {
					configurable: !0
				},
				speed: {
					configurable: !0
				},
				radius: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.time = this.time, e.applyFilter(this, t, n, r)
			}, n.center.get = function () {
				return this.uniforms.center
			}, n.center.set = function (e) {
				this.uniforms.center = e
			}, n.amplitude.get = function () {
				return this.uniforms.amplitude
			}, n.amplitude.set = function (e) {
				this.uniforms.amplitude = e
			}, n.wavelength.get = function () {
				return this.uniforms.wavelength
			}, n.wavelength.set = function (e) {
				this.uniforms.wavelength = e
			}, n.brightness.get = function () {
				return this.uniforms.brightness
			}, n.brightness.set = function (e) {
				this.uniforms.brightness = e
			}, n.speed.get = function () {
				return this.uniforms.speed
			}, n.speed.set = function (e) {
				this.uniforms.speed = e
			}, n.radius.get = function () {
				return this.uniforms.radius
			}, n.radius.set = function (e) {
				this.uniforms.radius = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Be = a,
		Ne = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n",
		Ge = function (e) {
			function t(t, n, r) {
				void 0 === n && (n = 0), void 0 === r && (r = 1), e.call(this, Be, Ne), this.uniforms.dimensions = new Float32Array(2), this.uniforms.ambientColor = new Float32Array([0, 0, 0, r]), this.texture = t, this.color = n
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				texture: {
					configurable: !0
				},
				color: {
					configurable: !0
				},
				alpha: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n, r) {
				this.uniforms.dimensions[0] = t.filterFrame.width, this.uniforms.dimensions[1] = t.filterFrame.height, e.applyFilter(this, t, n, r)
			}, n.texture.get = function () {
				return this.uniforms.uLightmap
			}, n.texture.set = function (e) {
				this.uniforms.uLightmap = e
			}, n.color.set = function (e) {
				var t = this.uniforms.ambientColor;
				"number" == typeof e ? (o.hex2rgb(e, t), this._color = e) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], this._color = o.rgb2hex(t))
			}, n.color.get = function () {
				return this._color
			}, n.alpha.get = function () {
				return this.uniforms.ambientColor[3]
			}, n.alpha.set = function (e) {
				this.uniforms.ambientColor[3] = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		qe = a,
		We = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n",
		Ke = function (e) {
			function t(t, r, o, i) {
				void 0 === t && (t = 100), void 0 === r && (r = 600), void 0 === o && (o = null), void 0 === i && (i = null), e.call(this, qe, We), this.uniforms.blur = t, this.uniforms.gradientBlur = r, this.uniforms.start = o || new n.Point(0, window.innerHeight / 2), this.uniforms.end = i || new n.Point(600, window.innerHeight / 2), this.uniforms.delta = new n.Point(30, 30), this.uniforms.texSize = new n.Point(window.innerWidth, window.innerHeight), this.updateDelta()
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var r = {
				blur: {
					configurable: !0
				},
				gradientBlur: {
					configurable: !0
				},
				start: {
					configurable: !0
				},
				end: {
					configurable: !0
				}
			};
			return t.prototype.updateDelta = function () {
				this.uniforms.delta.x = 0, this.uniforms.delta.y = 0
			}, r.blur.get = function () {
				return this.uniforms.blur
			}, r.blur.set = function (e) {
				this.uniforms.blur = e
			}, r.gradientBlur.get = function () {
				return this.uniforms.gradientBlur
			}, r.gradientBlur.set = function (e) {
				this.uniforms.gradientBlur = e
			}, r.start.get = function () {
				return this.uniforms.start
			}, r.start.set = function (e) {
				this.uniforms.start = e, this.updateDelta()
			}, r.end.get = function () {
				return this.uniforms.end
			}, r.end.set = function (e) {
				this.uniforms.end = e, this.updateDelta()
			}, Object.defineProperties(t.prototype, r), t
		}(t.Filter),
		Ye = function (e) {
			function t() {
				e.apply(this, arguments)
			}
			return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.updateDelta = function () {
				var e = this.uniforms.end.x - this.uniforms.start.x,
					t = this.uniforms.end.y - this.uniforms.start.y,
					n = Math.sqrt(e * e + t * t);
				this.uniforms.delta.x = e / n, this.uniforms.delta.y = t / n
			}, t
		}(Ke),
		Ze = function (e) {
			function t() {
				e.apply(this, arguments)
			}
			return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.updateDelta = function () {
				var e = this.uniforms.end.x - this.uniforms.start.x,
					t = this.uniforms.end.y - this.uniforms.start.y,
					n = Math.sqrt(e * e + t * t);
				this.uniforms.delta.x = -t / n, this.uniforms.delta.y = e / n
			}, t
		}(Ke),
		Qe = function (e) {
			function t(t, n, r, o) {
				void 0 === t && (t = 100), void 0 === n && (n = 600), void 0 === r && (r = null), void 0 === o && (o = null), e.call(this), this.tiltShiftXFilter = new Ye(t, n, r, o), this.tiltShiftYFilter = new Ze(t, n, r, o)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				blur: {
					configurable: !0
				},
				gradientBlur: {
					configurable: !0
				},
				start: {
					configurable: !0
				},
				end: {
					configurable: !0
				}
			};
			return t.prototype.apply = function (e, t, n) {
				var r = e.getFilterTexture();
				this.tiltShiftXFilter.apply(e, t, r), this.tiltShiftYFilter.apply(e, r, n), e.returnFilterTexture(r)
			}, n.blur.get = function () {
				return this.tiltShiftXFilter.blur
			}, n.blur.set = function (e) {
				this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = e
			}, n.gradientBlur.get = function () {
				return this.tiltShiftXFilter.gradientBlur
			}, n.gradientBlur.set = function (e) {
				this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = e
			}, n.start.get = function () {
				return this.tiltShiftXFilter.start
			}, n.start.set = function (e) {
				this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = e
			}, n.end.get = function () {
				return this.tiltShiftXFilter.end
			}, n.end.set = function (e) {
				this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		Ue = a,
		Ve = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n",
		He = function (e) {
			function t(t, n, r) {
				void 0 === t && (t = 200), void 0 === n && (n = 4), void 0 === r && (r = 20), e.call(this, Ue, Ve), this.radius = t, this.angle = n, this.padding = r
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				offset: {
					configurable: !0
				},
				radius: {
					configurable: !0
				},
				angle: {
					configurable: !0
				}
			};
			return n.offset.get = function () {
				return this.uniforms.offset
			}, n.offset.set = function (e) {
				this.uniforms.offset = e
			}, n.radius.get = function () {
				return this.uniforms.radius
			}, n.radius.set = function (e) {
				this.uniforms.radius = e
			}, n.angle.get = function () {
				return this.uniforms.angle
			}, n.angle.set = function (e) {
				this.uniforms.angle = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter),
		$e = a,
		Je = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = 32.0;\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n",
		et = function (e) {
			function t(t) {
				if (e.call(this, $e, Je), "object" != typeof t) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2],
						i = arguments[3];
					t = {}, void 0 !== n && (t.strength = n), void 0 !== r && (t.center = r), void 0 !== o && (t.innerRadius = o), void 0 !== i && (t.radius = i)
				}
				Object.assign(this, {
					strength: .1,
					center: [0, 0],
					innerRadius: 0,
					radius: -1
				}, t)
			}
			e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
			var n = {
				center: {
					configurable: !0
				},
				strength: {
					configurable: !0
				},
				innerRadius: {
					configurable: !0
				},
				radius: {
					configurable: !0
				}
			};
			return n.center.get = function () {
				return this.uniforms.uCenter
			}, n.center.set = function (e) {
				this.uniforms.uCenter = e
			}, n.strength.get = function () {
				return this.uniforms.uStrength
			}, n.strength.set = function (e) {
				this.uniforms.uStrength = e
			}, n.innerRadius.get = function () {
				return this.uniforms.uInnerRadius
			}, n.innerRadius.set = function (e) {
				this.uniforms.uInnerRadius = e
			}, n.radius.get = function () {
				return this.uniforms.uRadius
			}, n.radius.set = function (e) {
				(e < 0 || e === 1 / 0) && (e = -1), this.uniforms.uRadius = e
			}, Object.defineProperties(t.prototype, n), t
		}(t.Filter);
	return e.AdjustmentFilter = c, e.AdvancedBloomFilter = y, e.AsciiFilter = C, e.BevelFilter = z, e.BloomFilter = A, e.BulgePinchFilter = O, e.CRTFilter = Z, e.ColorMapFilter = M, e.ColorOverlayFilter = j, e.ColorReplaceFilter = I, e.ConvolutionFilter = N, e.CrossHatchFilter = W, e.DotFilter = V, e.DropShadowFilter = J, e.EmbossFilter = ne, e.GlitchFilter = ie, e.GlowFilter = ae, e.GodrayFilter = he, e.KawaseBlurFilter = d, e.MotionBlurFilter = me, e.MultiColorReplaceFilter = xe, e.OldFilmFilter = be, e.OutlineFilter = Fe, e.PixelateFilter = we, e.RGBSplitFilter = Ee, e.RadialBlurFilter = De, e.ReflectionFilter = Re, e.ShockwaveFilter = Xe, e.SimpleLightmapFilter = Ge, e.TiltShiftAxisFilter = Ke, e.TiltShiftFilter = Qe, e.TiltShiftXFilter = Ye, e.TiltShiftYFilter = Ze, e.TwistFilter = He, e.ZoomBlurFilter = et, e
}({}, PIXI, PIXI, PIXI, PIXI.utils, PIXI, PIXI.filters, PIXI.filters);
Object.assign(PIXI.filters, __filters);
//# sourceMappingURL=pixi-filters.js.map


/*!
 * pixi-particles - v4.2.0
 * Compiled Sat, 26 Oct 2019 14:41:00 UTC
 *
 * pixi-particles is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI = this.PIXI || {};
(function (exports, pixi) {
	'use strict';

	/**
	 * A single node in a PropertyList.
	 */
	var PropertyNode = /** @class */ (function () {
		/**
		 * @param value The value for this node
		 * @param time The time for this node, between 0-1
		 * @param [ease] Custom ease for this list. Only relevant for the first node.
		 */
		function PropertyNode(value, time, ease) {
			this.value = value;
			this.time = time;
			this.next = null;
			this.isStepped = false;
			if (ease) {
				this.ease = typeof ease == "function" ? ease : exports.ParticleUtils.generateEase(ease);
			} else {
				this.ease = null;
			}
		}
		/**
		 * Creates a list of property values from a data object {list, isStepped} with a list of objects in
		 * the form {value, time}. Alternatively, the data object can be in the deprecated form of
		 * {start, end}.
		 * @param data The data for the list.
		 * @param data.list The array of value and time objects.
		 * @param data.isStepped If the list is stepped rather than interpolated.
		 * @param data.ease Custom ease for this list.
		 * @return The first node in the list
		 */
		PropertyNode.createList = function (data) {
			if ("list" in data) {
				var array = data.list;
				var node = void 0,
					first = void 0;
				var _a = array[0],
					value = _a.value,
					time = _a.time;
				first = node = new PropertyNode(typeof value === 'string' ? exports.ParticleUtils.hexToRGB(value) : value, time, data.ease);
				//only set up subsequent nodes if there are a bunch or the 2nd one is different from the first
				if (array.length > 2 || (array.length === 2 && array[1].value !== value)) {
					for (var i = 1; i < array.length; ++i) {
						var _b = array[i],
							value_1 = _b.value,
							time_1 = _b.time;
						node.next = new PropertyNode(typeof value_1 === 'string' ? exports.ParticleUtils.hexToRGB(value_1) : value_1, time_1);
						node = node.next;
					}
				}
				first.isStepped = !!data.isStepped;
				return first;
			} else {
				//Handle deprecated version here
				var start = new PropertyNode(typeof data.start === 'string' ? exports.ParticleUtils.hexToRGB(data.start) : data.start, 0);
				//only set up a next value if it is different from the starting value
				if (data.end !== data.start)
					start.next = new PropertyNode(typeof data.end === 'string' ? exports.ParticleUtils.hexToRGB(data.end) : data.end, 1);
				return start;
			}
		};
		return PropertyNode;
	}());

	// get Texture.from()/Texture.fromImage(), in V4 and V5 friendly methods
	/**
	 * @hidden
	 */
	var TextureFromString;
	// to avoid Rollup transforming our import, save pixi namespace in a variable
	var pixiNS = pixi;
	if (parseInt(/^(\d+)\./.exec(pixi.VERSION)[1]) < 5) {
		TextureFromString = pixiNS.Texture.fromImage;
	} else {
		TextureFromString = pixiNS.Texture.from;
	}

	function GetTextureFromString(s) {
		return TextureFromString(s);
	}
	(function (ParticleUtils) {
		/**
		 * If errors and warnings should be logged within the library.
		 */
		ParticleUtils.verbose = false;
		ParticleUtils.DEG_TO_RADS = Math.PI / 180;
		/**
		 * Rotates a point by a given angle.
		 * @param angle The angle to rotate by in degrees
		 * @param p The point to rotate around 0,0.
		 */
		function rotatePoint(angle, p) {
			if (!angle)
				return;
			angle *= ParticleUtils.DEG_TO_RADS;
			var s = Math.sin(angle);
			var c = Math.cos(angle);
			var xnew = p.x * c - p.y * s;
			var ynew = p.x * s + p.y * c;
			p.x = xnew;
			p.y = ynew;
		}
		ParticleUtils.rotatePoint = rotatePoint;
		/**
		 * Combines separate color components (0-255) into a single uint color.
		 * @param r The red value of the color
		 * @param g The green value of the color
		 * @param b The blue value of the color
		 * @return The color in the form of 0xRRGGBB
		 */
		function combineRGBComponents(r, g, b /*, a*/ ) {
			return /*a << 24 |*/ r << 16 | g << 8 | b;
		}
		ParticleUtils.combineRGBComponents = combineRGBComponents;
		/**
		 * Reduces the point to a length of 1.
		 * @param point The point to normalize
		 */
		function normalize(point) {
			var oneOverLen = 1 / ParticleUtils.length(point);
			point.x *= oneOverLen;
			point.y *= oneOverLen;
		}
		ParticleUtils.normalize = normalize;
		/**
		 * Multiplies the x and y values of this point by a value.
		 * @param point The point to scaleBy
		 * @param value The value to scale by.
		 */
		function scaleBy(point, value) {
			point.x *= value;
			point.y *= value;
		}
		ParticleUtils.scaleBy = scaleBy;
		/**
		 * Returns the length (or magnitude) of this point.
		 * @param point The point to measure length
		 * @return The length of this point.
		 */
		function length(point) {
			return Math.sqrt(point.x * point.x + point.y * point.y);
		}
		ParticleUtils.length = length;
		/**
		 * Converts a hex string from "#AARRGGBB", "#RRGGBB", "0xAARRGGBB", "0xRRGGBB",
		 * "AARRGGBB", or "RRGGBB" to an object of ints of 0-255, as
		 * {r, g, b, (a)}.
		 * @param color The input color string.
		 * @param output An object to put the output in. If omitted, a new object is created.
		 * @return The object with r, g, and b properties, possibly with an a property.
		 */
		function hexToRGB(color, output) {
			if (!output)
				output = {};
			if (color.charAt(0) == "#")
				color = color.substr(1);
			else if (color.indexOf("0x") === 0)
				color = color.substr(2);
			var alpha;
			if (color.length == 8) {
				alpha = color.substr(0, 2);
				color = color.substr(2);
			}
			output.r = parseInt(color.substr(0, 2), 16); //Red
			output.g = parseInt(color.substr(2, 2), 16); //Green
			output.b = parseInt(color.substr(4, 2), 16); //Blue
			if (alpha)
				output.a = parseInt(alpha, 16);
			return output;
		}
		ParticleUtils.hexToRGB = hexToRGB;
		/**
		 * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated
		 * by the related tool at http://www.greensock.com/customease/.
		 * @param segments An array of segments, as created by
		 * http://www.greensock.com/customease/.
		 * @return A function that calculates the percentage of change at
		 *                    a given point in time (0-1 inclusive).
		 */
		function generateEase(segments) {
			var qty = segments.length;
			var oneOverQty = 1 / qty;
			/*
			 * Calculates the percentage of change at a given point in time (0-1 inclusive).
			 * @param {Number} time The time of the ease, 0-1 inclusive.
			 * @return {Number} The percentage of the change, 0-1 inclusive (unless your
			 *                  ease goes outside those bounds).
			 */
			return function (time) {
				var t, s;
				var i = (qty * time) | 0; //do a quick floor operation
				t = (time - (i * oneOverQty)) * qty;
				s = segments[i] || segments[qty - 1];
				return (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));
			};
		}
		ParticleUtils.generateEase = generateEase;
		/**
		 * Gets a blend mode, ensuring that it is valid.
		 * @param name The name of the blend mode to get.
		 * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.
		 */
		function getBlendMode(name) {
			if (!name)
				return pixi.BLEND_MODES.NORMAL;
			name = name.toUpperCase();
			while (name.indexOf(" ") >= 0)
				name = name.replace(" ", "_");
			return pixi.BLEND_MODES[name] || pixi.BLEND_MODES.NORMAL;
		}
		ParticleUtils.getBlendMode = getBlendMode;
		/**
		 * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly
		 * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of
		 * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.
		 * @param list The list of data to convert.
		 * @param [numSteps=10] The number of steps to use.
		 * @return The blend mode as specified in the PIXI.blendModes enumeration.
		 */
		function createSteppedGradient(list, numSteps) {
			if (numSteps === void 0) {
				numSteps = 10;
			}
			if (typeof numSteps !== 'number' || numSteps <= 0)
				numSteps = 10;
			var first = new PropertyNode(ParticleUtils.hexToRGB(list[0].value), list[0].time);
			first.isStepped = true;
			var currentNode = first;
			var current = list[0];
			var nextIndex = 1;
			var next = list[nextIndex];
			for (var i = 1; i < numSteps; ++i) {
				var lerp = i / numSteps;
				//ensure we are on the right segment, if multiple
				while (lerp > next.time) {
					current = next;
					next = list[++nextIndex];
				}
				//convert the lerp value to the segment range
				lerp = (lerp - current.time) / (next.time - current.time);
				var curVal = ParticleUtils.hexToRGB(current.value);
				var nextVal = ParticleUtils.hexToRGB(next.value);
				var output = {
					r: (nextVal.r - curVal.r) * lerp + curVal.r,
					g: (nextVal.g - curVal.g) * lerp + curVal.g,
					b: (nextVal.b - curVal.b) * lerp + curVal.b,
				};
				currentNode.next = new PropertyNode(output, i / numSteps);
				currentNode = currentNode.next;
			}
			//we don't need to have a PropertyNode for time of 1, because in a stepped version at that point
			//the particle has died of old age
			return first;
		}
		ParticleUtils.createSteppedGradient = createSteppedGradient;
	})(exports.ParticleUtils || (exports.ParticleUtils = {}));

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function (d, b) {
		extendStatics = Object.setPrototypeOf ||
			({
					__proto__: []
				}
				instanceof Array && function (d, b) {
					d.__proto__ = b;
				}) ||
			function (d, b) {
				for (var p in b)
					if (b.hasOwnProperty(p)) d[p] = b[p];
			};
		return extendStatics(d, b);
	};

	function __extends(d, b) {
		extendStatics(d, b);

		function __() {
			this.constructor = d;
		}
		d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function () {
		__assign = Object.assign || function __assign(t) {
			for (var s, i = 1, n = arguments.length; i < n; i++) {
				s = arguments[i];
				for (var p in s)
					if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
			}
			return t;
		};
		return __assign.apply(this, arguments);
	};

	function __rest(s, e) {
		var t = {};
		for (var p in s)
			if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
				t[p] = s[p];
		if (s != null && typeof Object.getOwnPropertySymbols === "function")
			for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
				if (e.indexOf(p[i]) < 0)
					t[p[i]] = s[p[i]];
		return t;
	}

	function __decorate(decorators, target, key, desc) {
		var c = arguments.length,
			r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
			d;
		if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		else
			for (var i = decorators.length - 1; i >= 0; i--)
				if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __param(paramIndex, decorator) {
		return function (target, key) {
			decorator(target, key, paramIndex);
		}
	}

	function __metadata(metadataKey, metadataValue) {
		if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	}

	function __awaiter(thisArg, _arguments, P, generator) {
		return new(P || (P = Promise))(function (resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}

			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}

			function step(result) {
				result.done ? resolve(result.value) : new P(function (resolve) {
					resolve(result.value);
				}).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	}

	function __generator(thisArg, body) {
		var _ = {
				label: 0,
				sent: function () {
					if (t[0] & 1) throw t[1];
					return t[1];
				},
				trys: [],
				ops: []
			},
			f, y, t, g;
		return g = {
			next: verb(0),
			"throw": verb(1),
			"return": verb(2)
		}, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
			return this;
		}), g;

		function verb(n) {
			return function (v) {
				return step([n, v]);
			};
		}

		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return {
							value: op[1], done: false
						};
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
			if (op[0] & 5) throw op[1];
			return {
				value: op[0] ? op[1] : void 0,
				done: true
			};
		}
	}

	function __exportStar(m, exports) {
		for (var p in m)
			if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}

	function __values(o) {
		var m = typeof Symbol === "function" && o[Symbol.iterator],
			i = 0;
		if (m) return m.call(o);
		return {
			next: function () {
				if (o && i >= o.length) o = void 0;
				return {
					value: o && o[i++],
					done: !o
				};
			}
		};
	}

	function __read(o, n) {
		var m = typeof Symbol === "function" && o[Symbol.iterator];
		if (!m) return o;
		var i = m.call(o),
			r, ar = [],
			e;
		try {
			while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		} catch (error) {
			e = {
				error: error
			};
		} finally {
			try {
				if (r && !r.done && (m = i["return"])) m.call(i);
			} finally {
				if (e) throw e.error;
			}
		}
		return ar;
	}

	function __spread() {
		for (var ar = [], i = 0; i < arguments.length; i++)
			ar = ar.concat(__read(arguments[i]));
		return ar;
	}

	function __await(v) {
		return this instanceof __await ? (this.v = v, this) : new __await(v);
	}

	function __asyncGenerator(thisArg, _arguments, generator) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var g = generator.apply(thisArg, _arguments || []),
			i, q = [];
		return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
			return this;
		}, i;

		function verb(n) {
			if (g[n]) i[n] = function (v) {
				return new Promise(function (a, b) {
					q.push([n, v, a, b]) > 1 || resume(n, v);
				});
			};
		}

		function resume(n, v) {
			try {
				step(g[n](v));
			} catch (e) {
				settle(q[0][3], e);
			}
		}

		function step(r) {
			r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
		}

		function fulfill(value) {
			resume("next", value);
		}

		function reject(value) {
			resume("throw", value);
		}

		function settle(f, v) {
			if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
		}
	}

	function __asyncDelegator(o) {
		var i, p;
		return i = {}, verb("next"), verb("throw", function (e) {
			throw e;
		}), verb("return"), i[Symbol.iterator] = function () {
			return this;
		}, i;

		function verb(n, f) {
			i[n] = o[n] ? function (v) {
				return (p = !p) ? {
					value: __await(o[n](v)),
					done: n === "return"
				} : f ? f(v) : v;
			} : f;
		}
	}

	function __asyncValues(o) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var m = o[Symbol.asyncIterator],
			i;
		return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
			return this;
		}, i);

		function verb(n) {
			i[n] = o[n] && function (v) {
				return new Promise(function (resolve, reject) {
					v = o[n](v), settle(resolve, reject, v.done, v.value);
				});
			};
		}

		function settle(resolve, reject, d, v) {
			Promise.resolve(v).then(function (v) {
				resolve({
					value: v,
					done: d
				});
			}, reject);
		}
	}

	function __makeTemplateObject(cooked, raw) {
		if (Object.defineProperty) {
			Object.defineProperty(cooked, "raw", {
				value: raw
			});
		} else {
			cooked.raw = raw;
		}
		return cooked;
	};

	function __importStar(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null)
			for (var k in mod)
				if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
		result.default = mod;
		return result;
	}

	function __importDefault(mod) {
		return (mod && mod.__esModule) ? mod : {
			default: mod
		};
	}

	/**
	 * Singly linked list container for keeping track of interpolated properties for particles.
	 * Each Particle will have one of these for each interpolated property.
	 */
	var PropertyList = /** @class */ (function () {
		/**
		 * @param isColor If this list handles color values
		 */
		function PropertyList(isColor) {
			if (isColor === void 0) {
				isColor = false;
			}
			this.current = null;
			this.next = null;
			this.isColor = !!isColor;
			this.interpolate = null;
			this.ease = null;
		}
		/**
		 * Resets the list for use.
		 * @param first The first node in the list.
		 * @param first.isStepped If the values should be stepped instead of interpolated linearly.
		 */
		PropertyList.prototype.reset = function (first) {
			this.current = first;
			this.next = first.next;
			var isSimple = this.next && this.next.time >= 1;
			if (isSimple) {
				this.interpolate = this.isColor ? intColorSimple : intValueSimple;
			} else if (first.isStepped) {
				this.interpolate = this.isColor ? intColorStepped : intValueStepped;
			} else {
				this.interpolate = this.isColor ? intColorComplex : intValueComplex;
			}
			this.ease = this.current.ease;
		};
		return PropertyList;
	}());

	function intValueSimple(lerp) {
		if (this.ease)
			lerp = this.ease(lerp);
		return (this.next.value - this.current.value) * lerp + this.current.value;
	}

	function intColorSimple(lerp) {
		if (this.ease)
			lerp = this.ease(lerp);
		var curVal = this.current.value,
			nextVal = this.next.value;
		var r = (nextVal.r - curVal.r) * lerp + curVal.r;
		var g = (nextVal.g - curVal.g) * lerp + curVal.g;
		var b = (nextVal.b - curVal.b) * lerp + curVal.b;
		return exports.ParticleUtils.combineRGBComponents(r, g, b);
	}

	function intValueComplex(lerp) {
		if (this.ease)
			lerp = this.ease(lerp);
		//make sure we are on the right segment
		while (lerp > this.next.time) {
			this.current = this.next;
			this.next = this.next.next;
		}
		//convert the lerp value to the segment range
		lerp = (lerp - this.current.time) / (this.next.time - this.current.time);
		return (this.next.value - this.current.value) * lerp + this.current.value;
	}

	function intColorComplex(lerp) {
		if (this.ease)
			lerp = this.ease(lerp);
		//make sure we are on the right segment
		while (lerp > this.next.time) {
			this.current = this.next;
			this.next = this.next.next;
		}
		//convert the lerp value to the segment range
		lerp = (lerp - this.current.time) / (this.next.time - this.current.time);
		var curVal = this.current.value,
			nextVal = this.next.value;
		var r = (nextVal.r - curVal.r) * lerp + curVal.r;
		var g = (nextVal.g - curVal.g) * lerp + curVal.g;
		var b = (nextVal.b - curVal.b) * lerp + curVal.b;
		return exports.ParticleUtils.combineRGBComponents(r, g, b);
	}

	function intValueStepped(lerp) {
		if (this.ease)
			lerp = this.ease(lerp);
		//make sure we are on the right segment
		while (this.next && lerp > this.next.time) {
			this.current = this.next;
			this.next = this.next.next;
		}
		return this.current.value;
	}

	function intColorStepped(lerp) {
		if (this.ease)
			lerp = this.ease(lerp);
		//make sure we are on the right segment
		while (this.next && lerp > this.next.time) {
			this.current = this.next;
			this.next = this.next.next;
		}
		var curVal = this.current.value;
		return exports.ParticleUtils.combineRGBComponents(curVal.r, curVal.g, curVal.b);
	}

	/**
	 * An individual particle image. You shouldn't have to deal with these.
	 */
	var Particle = /** @class */ (function (_super) {
		__extends(Particle, _super);
		/**
		 * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.
		 */
		function Particle(emitter) {
			var _this =
				//start off the sprite with a blank texture, since we are going to replace it
				//later when the particle is initialized.
				_super.call(this) || this;
			_this.emitter = emitter;
			//particles should be centered
			_this.anchor.x = _this.anchor.y = 0.5;
			_this.velocity = new pixi.Point();
			_this.rotationSpeed = 0;
			_this.rotationAcceleration = 0;
			_this.maxLife = 0;
			_this.age = 0;
			_this.ease = null;
			_this.extraData = null;
			_this.alphaList = new PropertyList();
			_this.speedList = new PropertyList();
			_this.speedMultiplier = 1;
			_this.acceleration = new pixi.Point();
			_this.maxSpeed = NaN;
			_this.scaleList = new PropertyList();
			_this.scaleMultiplier = 1;
			_this.colorList = new PropertyList(true);
			_this._doAlpha = false;
			_this._doScale = false;
			_this._doSpeed = false;
			_this._doAcceleration = false;
			_this._doColor = false;
			_this._doNormalMovement = false;
			_this._oneOverLife = 0;
			_this.next = null;
			_this.prev = null;
			//save often used functions on the instance instead of the prototype for better speed
			_this.init = _this.init;
			_this.Particle_init = Particle.prototype.init;
			_this.update = _this.update;
			_this.Particle_update = Particle.prototype.update;
			_this.Sprite_destroy = _super.prototype.destroy;
			_this.Particle_destroy = Particle.prototype.destroy;
			_this.applyArt = _this.applyArt;
			_this.kill = _this.kill;
			return _this;
		}
		/**
		 * Initializes the particle for use, based on the properties that have to
		 * have been set already on the particle.
		 */
		Particle.prototype.init = function () {
			//reset the age
			this.age = 0;
			//set up the velocity based on the start speed and rotation
			this.velocity.x = this.speedList.current.value * this.speedMultiplier;
			this.velocity.y = 0;
			exports.ParticleUtils.rotatePoint(this.rotation, this.velocity);
			if (this.noRotation) {
				this.rotation = 0;
			} else {
				//convert rotation to Radians from Degrees
				this.rotation *= exports.ParticleUtils.DEG_TO_RADS;
			}
			//convert rotation speed to Radians from Degrees
			this.rotationSpeed *= exports.ParticleUtils.DEG_TO_RADS;
			this.rotationAcceleration *= exports.ParticleUtils.DEG_TO_RADS;
			//set alpha to inital alpha
			this.alpha = this.alphaList.current.value;
			//set scale to initial scale
			this.scale.x = this.scale.y = this.scaleList.current.value;
			//figure out what we need to interpolate
			this._doAlpha = !!this.alphaList.current.next;
			this._doSpeed = !!this.speedList.current.next;
			this._doScale = !!this.scaleList.current.next;
			this._doColor = !!this.colorList.current.next;
			this._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;
			//_doNormalMovement can be cancelled by subclasses
			this._doNormalMovement = this._doSpeed || this.speedList.current.value !== 0 || this._doAcceleration;
			//save our lerp helper
			this._oneOverLife = 1 / this.maxLife;
			//set the inital color
			var color = this.colorList.current.value;
			this.tint = exports.ParticleUtils.combineRGBComponents(color.r, color.g, color.b);
			//ensure visibility
			this.visible = true;
		};
		/**
		 * Sets the texture for the particle. This can be overridden to allow
		 * for an animated particle.
		 * @param art The texture to set.
		 */
		Particle.prototype.applyArt = function (art) {
			this.texture = art || pixi.Texture.EMPTY;
		};
		/**
		 * Updates the particle.
		 * @param delta Time elapsed since the previous frame, in __seconds__.
		 * @return The standard interpolation multiplier (0-1) used for all
		 *         relevant particle properties. A value of -1 means the particle
		 *         died of old age instead.
		 */
		Particle.prototype.update = function (delta) {
			//increase age
			this.age += delta;
			//recycle particle if it is too old
			if (this.age >= this.maxLife || this.age < 0) {
				this.kill();
				return -1;
			}
			//determine our interpolation value
			var lerp = this.age * this._oneOverLife; //lifetime / maxLife;
			if (this.ease) {
				if (this.ease.length == 4) {
					//the t, b, c, d parameters that some tween libraries use
					//(time, initial value, end value, duration)
					lerp = this.ease(lerp, 0, 1, 1);
				} else {
					//the simplified version that we like that takes
					//one parameter, time from 0-1. TweenJS eases provide this usage.
					lerp = this.ease(lerp);
				}
			}
			//interpolate alpha
			if (this._doAlpha)
				this.alpha = this.alphaList.interpolate(lerp);
			//interpolate scale
			if (this._doScale) {
				var scale = this.scaleList.interpolate(lerp) * this.scaleMultiplier;
				this.scale.x = this.scale.y = scale;
			}
			//handle movement
			if (this._doNormalMovement) {
				var deltaX = void 0;
				var deltaY = void 0;
				//interpolate speed
				if (this._doSpeed) {
					var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;
					exports.ParticleUtils.normalize(this.velocity);
					exports.ParticleUtils.scaleBy(this.velocity, speed);
					deltaX = this.velocity.x * delta;
					deltaY = this.velocity.y * delta;
				} else if (this._doAcceleration) {
					var oldVX = this.velocity.x;
					var oldVY = this.velocity.y;
					this.velocity.x += this.acceleration.x * delta;
					this.velocity.y += this.acceleration.y * delta;
					if (this.maxSpeed) {
						var currentSpeed = exports.ParticleUtils.length(this.velocity);
						//if we are going faster than we should, clamp at the max speed
						//DO NOT recalculate vector length
						if (currentSpeed > this.maxSpeed) {
							exports.ParticleUtils.scaleBy(this.velocity, this.maxSpeed / currentSpeed);
						}
					}
					// calculate position delta by the midpoint between our old velocity and our new velocity
					deltaX = (oldVX + this.velocity.x) / 2 * delta;
					deltaY = (oldVY + this.velocity.y) / 2 * delta;
				} else {
					deltaX = this.velocity.x * delta;
					deltaY = this.velocity.y * delta;
				}
				//adjust position based on velocity
				this.position.x += deltaX;
				this.position.y += deltaY;
			}
			//interpolate color
			if (this._doColor) {
				this.tint = this.colorList.interpolate(lerp);
			}
			//update rotation
			if (this.rotationAcceleration !== 0) {
				var newRotationSpeed = this.rotationSpeed + this.rotationAcceleration * delta;
				this.rotation += (this.rotationSpeed + newRotationSpeed) / 2 * delta;
				this.rotationSpeed = newRotationSpeed;
			} else if (this.rotationSpeed !== 0) {
				this.rotation += this.rotationSpeed * delta;
			} else if (this.acceleration && !this.noRotation) {
				this.rotation = Math.atan2(this.velocity.y, this.velocity.x); // + Math.PI / 2;
			}
			return lerp;
		};
		/**
		 * Kills the particle, removing it from the display list
		 * and telling the emitter to recycle it.
		 */
		Particle.prototype.kill = function () {
			this.emitter.recycle(this);
		};
		/**
		 * Destroys the particle, removing references and preventing future use.
		 */
		Particle.prototype.destroy = function () {
			if (this.parent)
				this.parent.removeChild(this);
			this.Sprite_destroy();
			this.emitter = this.velocity = this.colorList = this.scaleList = this.alphaList =
				this.speedList = this.ease = this.next = this.prev = null;
		};
		/**
		 * Checks over the art that was passed to the Emitter's init() function, to do any special
		 * modifications to prepare it ahead of time.
		 * @param art The array of art data. For Particle, it should be an array of
		 *            Textures. Any strings in the array will be converted to
		 *            Textures via Texture.from().
		 * @return The art, after any needed modifications.
		 */
		Particle.parseArt = function (art) {
			//convert any strings to Textures.
			var i;
			for (i = art.length; i >= 0; --i) {
				if (typeof art[i] == "string")
					art[i] = GetTextureFromString(art[i]);
			}
			//particles from different base textures will be slower in WebGL than if they
			//were from one spritesheet
			if (exports.ParticleUtils.verbose) {
				for (i = art.length - 1; i > 0; --i) {
					if (art[i].baseTexture != art[i - 1].baseTexture) {
						if (window.console)
							console.warn("PixiParticles: using particle textures from different images may hinder performance in WebGL");
						break;
					}
				}
			}
			return art;
		};
		/**
		 * Parses extra emitter data to ensure it is set up for this particle class.
		 * Particle does nothing to the extra data.
		 * @param extraData The extra data from the particle config.
		 * @return The parsed extra data.
		 */
		Particle.parseData = function (extraData) {
			return extraData;
		};
		return Particle;
	}(pixi.Sprite));

	/**
	 * Chain of line segments for generating spawn positions.
	 */
	var PolygonalChain = /** @class */ (function () {
		/**
		 * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.
		 */
		function PolygonalChain(data) {
			this.segments = [];
			this.countingLengths = [];
			this.totalLength = 0;
			this.init(data);
		}
		/**
		 * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.
		 */
		PolygonalChain.prototype.init = function (data) {
			// if data is not present, set up a segment of length 0
			if (!data || !data.length) {
				this.segments.push({
					p1: {
						x: 0,
						y: 0
					},
					p2: {
						x: 0,
						y: 0
					},
					l: 0
				});
			} else {
				if (Array.isArray(data[0])) {
					// list of segment chains, each defined as a list of points
					for (var i = 0; i < data.length; ++i) {
						// loop through the chain, connecting points
						var chain = data[i];
						var prevPoint = chain[0];
						for (var j = 1; j < chain.length; ++j) {
							var second = chain[j];
							this.segments.push({
								p1: prevPoint,
								p2: second,
								l: 0
							});
							prevPoint = second;
						}
					}
				} else {
					var prevPoint = data[0];
					// list of points
					for (var i = 1; i < data.length; ++i) {
						var second = data[i];
						this.segments.push({
							p1: prevPoint,
							p2: second,
							l: 0
						});
						prevPoint = second;
					}
				}
			}
			// now go through our segments to calculate the lengths so that we
			// can set up a nice weighted random distribution
			for (var i = 0; i < this.segments.length; ++i) {
				var _a = this.segments[i],
					p1 = _a.p1,
					p2 = _a.p2;
				var segLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
				// save length so we can turn a random number into a 0-1 interpolation value later
				this.segments[i].l = segLength;
				this.totalLength += segLength;
				// keep track of the length so far, counting up
				this.countingLengths.push(this.totalLength);
			}
		};
		/**
		 * Gets a random point in the chain.
		 * @param out The point to store the selected position in.
		 */
		PolygonalChain.prototype.getRandomPoint = function (out) {
			// select a random spot in the length of the chain
			var rand = Math.random() * this.totalLength;
			var chosenSeg;
			var lerp;
			// if only one segment, it wins
			if (this.segments.length === 1) {
				chosenSeg = this.segments[0];
				lerp = rand;
			} else {
				// otherwise, go through countingLengths until we have determined
				// which segment we chose
				for (var i = 0; i < this.countingLengths.length; ++i) {
					if (rand < this.countingLengths[i]) {
						chosenSeg = this.segments[i];
						// set lerp equal to the length into that segment (i.e. the remainder after subtracting all the segments before it)
						lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];
						break;
					}
				}
			}
			// divide lerp by the segment length, to result in a 0-1 number.
			lerp /= chosenSeg.l || 1;
			var p1 = chosenSeg.p1,
				p2 = chosenSeg.p2;
			// now calculate the position in the segment that the lerp value represents
			out.x = p1.x + lerp * (p2.x - p1.x);
			out.y = p1.y + lerp * (p2.y - p1.y);
		};
		return PolygonalChain;
	}());

	// get the shared ticker, in V4 and V5 friendly methods
	/**
	 * @hidden
	 */
	var ticker;
	// to avoid Rollup transforming our import, save pixi namespace in a variable
	var pixiNS$1 = pixi;
	if (parseInt(/^(\d+)\./.exec(pixi.VERSION)[1]) < 5) {
		ticker = pixiNS$1.ticker.shared;
	} else {
		ticker = pixiNS$1.Ticker.shared;
	}
	/**
	 * @hidden
	 */
	var helperPoint = new pixi.Point();
	/**
	 * A particle emitter.
	 */
	var Emitter = /** @class */ (function () {
		/**
		 * @param particleParent The container to add the particles to.
		 * @param particleImages A texture or array of textures to use
		 *                       for the particles. Strings will be turned
		 *                       into textures via Texture.fromImage().
		 * @param config A configuration object containing settings for the emitter.
		 * @param config.emit If config.emit is explicitly passed as false, the
		 *                    Emitter will start disabled.
		 * @param config.autoUpdate If config.autoUpdate is explicitly passed as
		 *                          true, the Emitter will automatically call
		 *                          update via the PIXI shared ticker.
		 */
		function Emitter(particleParent, particleImages, config) {
			/**
			 * A number keeping index of currently applied image. Used to emit arts in order.
			 */
			this._currentImageIndex = -1;
			this._particleConstructor = Particle;
			//properties for individual particles
			this.particleImages = null;
			this.startAlpha = null;
			this.startSpeed = null;
			this.minimumSpeedMultiplier = 1;
			this.acceleration = null;
			this.maxSpeed = NaN;
			this.startScale = null;
			this.minimumScaleMultiplier = 1;
			this.startColor = null;
			this.minLifetime = 0;
			this.maxLifetime = 0;
			this.minStartRotation = 0;
			this.maxStartRotation = 0;
			this.noRotation = false;
			this.minRotationSpeed = 0;
			this.maxRotationSpeed = 0;
			this.particleBlendMode = 0;
			this.customEase = null;
			this.extraData = null;
			//properties for spawning particles
			this._frequency = 1;
			this.spawnChance = 1;
			this.maxParticles = 1000;
			this.emitterLifetime = -1;
			this.spawnPos = null;
			this.spawnType = null;
			this._spawnFunc = null;
			this.spawnRect = null;
			this.spawnCircle = null;
			this.spawnPolygonalChain = null;
			this.particlesPerWave = 1;
			this.particleSpacing = 0;
			this.angleStart = 0;
			//emitter properties
			this.rotation = 0;
			this.ownerPos = null;
			this._prevEmitterPos = null;
			this._prevPosIsValid = false;
			this._posChanged = false;
			this._parent = null;
			this.addAtBack = false;
			this.particleCount = 0;
			this._emit = false;
			this._spawnTimer = 0;
			this._emitterLife = -1;
			this._activeParticlesFirst = null;
			this._activeParticlesLast = null;
			this._poolFirst = null;
			this._origConfig = null;
			this._origArt = null;
			this._autoUpdate = false;
			this._currentImageIndex = -1;
			this._destroyWhenComplete = false;
			this._completeCallback = null;
			//set the initial parent
			this.parent = particleParent;
			if (particleImages && config)
				this.init(particleImages, config);
			//save often used functions on the instance instead of the prototype for better speed
			this.recycle = this.recycle;
			this.update = this.update;
			this.rotate = this.rotate;
			this.updateSpawnPos = this.updateSpawnPos;
			this.updateOwnerPos = this.updateOwnerPos;
		}
		Object.defineProperty(Emitter.prototype, "orderedArt", {
			/**
			 * If the emitter is using particle art in order as provided in `particleImages`.
			 * Effective only when `particleImages` has multiple art options.
			 * This is particularly useful ensuring that each art shows up once, in case you need to emit a body in an order.
			 * For example: dragon - [Head, body1, body2, ..., tail]
			 */
			get: function () {
				return this._currentImageIndex !== -1;
			},
			set: function (value) {
				this._currentImageIndex = value ? 0 : -1;
			},
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(Emitter.prototype, "frequency", {
			/**
			 * Time between particle spawns in seconds. If this value is not a number greater than 0,
			 * it will be set to 1 (particle per second) to prevent infinite loops.
			 */
			get: function () {
				return this._frequency;
			},
			set: function (value) {
				//do some error checking to prevent infinite loops
				if (typeof value == "number" && value > 0)
					this._frequency = value;
				else
					this._frequency = 1;
			},
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(Emitter.prototype, "particleConstructor", {
			/**
			 * The constructor used to create new particles. The default is
			 * the built in Particle class. Setting this will dump any active or
			 * pooled particles, if the emitter has already been used.
			 */
			get: function () {
				return this._particleConstructor;
			},
			set: function (value) {
				if (value != this._particleConstructor) {
					this._particleConstructor = value;
					//clean up existing particles
					this.cleanup();
					//scrap all the particles
					for (var particle = this._poolFirst; particle; particle = particle.next) {
						particle.destroy();
					}
					this._poolFirst = null;
					//re-initialize the emitter so that the new constructor can do anything it needs to
					if (this._origConfig && this._origArt)
						this.init(this._origArt, this._origConfig);
				}
			},
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(Emitter.prototype, "parent", {
			/**
			 * The container to add particles to. Settings this will dump any active particles.
			 */
			get: function () {
				return this._parent;
			},
			set: function (value) {
				this.cleanup();
				this._parent = value;
			},
			enumerable: true,
			configurable: true
		});
		/**
		 * Sets up the emitter based on the config settings.
		 * @param art A texture or array of textures to use for the particles.
		 * @param config A configuration object containing settings for the emitter.
		 */
		Emitter.prototype.init = function (art, config) {
			if (!art || !config)
				return;
			//clean up any existing particles
			this.cleanup();
			//store the original config and particle images, in case we need to re-initialize
			//when the particle constructor is changed
			this._origConfig = config;
			this._origArt = art;
			//set up the array of data, also ensuring that it is an array
			art = Array.isArray(art) ? art.slice() : [art];
			//run the art through the particle class's parsing function
			var partClass = this._particleConstructor;
			this.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;
			///////////////////////////
			// Particle Properties   //
			///////////////////////////
			//set up the alpha
			if (config.alpha) {
				this.startAlpha = PropertyNode.createList(config.alpha);
			} else
				this.startAlpha = new PropertyNode(1, 0);
			//set up the speed
			if (config.speed) {
				this.startSpeed = PropertyNode.createList(config.speed);
				this.minimumSpeedMultiplier = ('minimumSpeedMultiplier' in config ? config.minimumSpeedMultiplier : config.speed.minimumSpeedMultiplier) || 1;
			} else {
				this.minimumSpeedMultiplier = 1;
				this.startSpeed = new PropertyNode(0, 0);
			}
			//set up acceleration
			var acceleration = config.acceleration;
			if (acceleration && (acceleration.x || acceleration.y)) {
				//make sure we disable speed interpolation
				this.startSpeed.next = null;
				this.acceleration = new pixi.Point(acceleration.x, acceleration.y);
				this.maxSpeed = config.maxSpeed || NaN;
			} else
				this.acceleration = new pixi.Point();
			//set up the scale
			if (config.scale) {
				this.startScale = PropertyNode.createList(config.scale);
				this.minimumScaleMultiplier = ('minimumScaleMultiplier' in config ? config.minimumScaleMultiplier : config.scale.minimumScaleMultiplier) || 1;
			} else {
				this.startScale = new PropertyNode(1, 0);
				this.minimumScaleMultiplier = 1;
			}
			//set up the color
			if (config.color) {
				this.startColor = PropertyNode.createList(config.color);
			} else {
				this.startColor = new PropertyNode({
					r: 0xFF,
					g: 0xFF,
					b: 0xFF
				}, 0);
			}
			//set up the start rotation
			if (config.startRotation) {
				this.minStartRotation = config.startRotation.min;
				this.maxStartRotation = config.startRotation.max;
			} else
				this.minStartRotation = this.maxStartRotation = 0;
			if (config.noRotation &&
				(this.minStartRotation || this.maxStartRotation)) {
				this.noRotation = !!config.noRotation;
			} else
				this.noRotation = false;
			//set up the rotation speed
			if (config.rotationSpeed) {
				this.minRotationSpeed = config.rotationSpeed.min;
				this.maxRotationSpeed = config.rotationSpeed.max;
			} else
				this.minRotationSpeed = this.maxRotationSpeed = 0;
			this.rotationAcceleration = config.rotationAcceleration || 0;
			//set up the lifetime
			this.minLifetime = config.lifetime.min;
			this.maxLifetime = config.lifetime.max;
			//get the blend mode
			this.particleBlendMode = exports.ParticleUtils.getBlendMode(config.blendMode);
			//use the custom ease if provided
			if (config.ease) {
				this.customEase = typeof config.ease == "function" ?
					config.ease : exports.ParticleUtils.generateEase(config.ease);
			} else
				this.customEase = null;
			//set up the extra data, running it through the particle class's parseData function.
			if (partClass.parseData)
				this.extraData = partClass.parseData(config.extraData);
			else
				this.extraData = config.extraData || null;
			//////////////////////////
			// Emitter Properties   //
			//////////////////////////
			//reset spawn type specific settings
			this.spawnRect = this.spawnCircle = null;
			this.particlesPerWave = 1;
			if (config.particlesPerWave && config.particlesPerWave > 1)
				this.particlesPerWave = config.particlesPerWave;
			this.particleSpacing = 0;
			this.angleStart = 0;
			//determine the spawn function to use
			this.parseSpawnType(config);
			//set the spawning frequency
			this.frequency = config.frequency;
			this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;
			//set the emitter lifetime
			this.emitterLifetime = config.emitterLifetime || -1;
			//set the max particles
			this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;
			//determine if we should add the particle at the back of the list or not
			this.addAtBack = !!config.addAtBack;
			//reset the emitter position and rotation variables
			this.rotation = 0;
			this.ownerPos = new pixi.Point();
			this.spawnPos = new pixi.Point(config.pos.x, config.pos.y);
			this.initAdditional(art, config);
			this._prevEmitterPos = this.spawnPos.clone();
			//previous emitter position is invalid and should not be used for interpolation
			this._prevPosIsValid = false;
			//start emitting
			this._spawnTimer = 0;
			this.emit = config.emit === undefined ? true : !!config.emit;
			this.autoUpdate = !!config.autoUpdate;
			this.orderedArt = !!config.orderedArt;
		};
		/**
		 * Sets up additional parameters to the emitter from config settings.
		 * Using for parsing additional parameters on classes that extend from Emitter
		 * @param art A texture or array of textures to use for the particles.
		 * @param config A configuration object containing settings for the emitter.
		 */
		Emitter.prototype.initAdditional = function (art, config) {};
		/**
		 * Parsing emitter spawn type from config settings.
		 * Place for override and add new kind of spawn type
		 * @param config A configuration object containing settings for the emitter.
		 */
		Emitter.prototype.parseSpawnType = function (config) {
			var spawnCircle;
			switch (config.spawnType) {
				case "rect":
					this.spawnType = "rect";
					this._spawnFunc = this._spawnRect;
					var spawnRect = config.spawnRect;
					this.spawnRect = new pixi.Rectangle(spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);
					break;
				case "circle":
					this.spawnType = "circle";
					this._spawnFunc = this._spawnCircle;
					spawnCircle = config.spawnCircle;
					this.spawnCircle = new pixi.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);
					break;
				case "ring":
					this.spawnType = "ring";
					this._spawnFunc = this._spawnRing;
					spawnCircle = config.spawnCircle;
					this.spawnCircle = new pixi.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);
					this.spawnCircle.minRadius = spawnCircle.minR;
					break;
				case "burst":
					this.spawnType = "burst";
					this._spawnFunc = this._spawnBurst;
					this.particleSpacing = config.particleSpacing;
					this.angleStart = config.angleStart ? config.angleStart : 0;
					break;
				case "point":
					this.spawnType = "point";
					this._spawnFunc = this._spawnPoint;
					break;
				case "polygonalChain":
					this.spawnType = "polygonalChain";
					this._spawnFunc = this._spawnPolygonalChain;
					this.spawnPolygonalChain = new PolygonalChain(config.spawnPolygon);
					break;
				default:
					this.spawnType = "point";
					this._spawnFunc = this._spawnPoint;
					break;
			}
		};
		/**
		 * Recycles an individual particle. For internal use only.
		 * @param particle The particle to recycle.
		 * @internal
		 */
		Emitter.prototype.recycle = function (particle) {
			if (particle.next)
				particle.next.prev = particle.prev;
			if (particle.prev)
				particle.prev.next = particle.next;
			if (particle == this._activeParticlesLast)
				this._activeParticlesLast = particle.prev;
			if (particle == this._activeParticlesFirst)
				this._activeParticlesFirst = particle.next;
			//add to pool
			particle.prev = null;
			particle.next = this._poolFirst;
			this._poolFirst = particle;
			//remove child from display, or make it invisible if it is in a ParticleContainer
			if (particle.parent)
				particle.parent.removeChild(particle);
			//decrease count
			--this.particleCount;
		};
		/**
		 * Sets the rotation of the emitter to a new value.
		 * @param newRot The new rotation, in degrees.
		 */
		Emitter.prototype.rotate = function (newRot) {
			if (this.rotation == newRot)
				return;
			//caclulate the difference in rotation for rotating spawnPos
			var diff = newRot - this.rotation;
			this.rotation = newRot;
			//rotate spawnPos
			exports.ParticleUtils.rotatePoint(diff, this.spawnPos);
			//mark the position as having changed
			this._posChanged = true;
		};
		/**
		 * Changes the spawn position of the emitter.
		 * @param x The new x value of the spawn position for the emitter.
		 * @param y The new y value of the spawn position for the emitter.
		 */
		Emitter.prototype.updateSpawnPos = function (x, y) {
			this._posChanged = true;
			this.spawnPos.x = x;
			this.spawnPos.y = y;
		};
		/**
		 * Changes the position of the emitter's owner. You should call this if you are adding
		 * particles to the world container that your emitter's owner is moving around in.
		 * @param x The new x value of the emitter's owner.
		 * @param y The new y value of the emitter's owner.
		 */
		Emitter.prototype.updateOwnerPos = function (x, y) {
			this._posChanged = true;
			this.ownerPos.x = x;
			this.ownerPos.y = y;
		};
		/**
		 * Prevents emitter position interpolation in the next update.
		 * This should be used if you made a major position change of your emitter's owner
		 * that was not normal movement.
		 */
		Emitter.prototype.resetPositionTracking = function () {
			this._prevPosIsValid = false;
		};
		Object.defineProperty(Emitter.prototype, "emit", {
			/**
			 * If particles should be emitted during update() calls. Setting this to false
			 * stops new particles from being created, but allows existing ones to die out.
			 */
			get: function () {
				return this._emit;
			},
			set: function (value) {
				this._emit = !!value;
				this._emitterLife = this.emitterLifetime;
			},
			enumerable: true,
			configurable: true
		});;
		Object.defineProperty(Emitter.prototype, "autoUpdate", {
			/**
			 * If the update function is called automatically from the shared ticker.
			 * Setting this to false requires calling the update function manually.
			 */
			get: function () {
				return this._autoUpdate;
			},
			set: function (value) {
				if (this._autoUpdate && !value) {
					ticker.remove(this.update, this);
				} else if (!this._autoUpdate && value) {
					ticker.add(this.update, this);
				}
				this._autoUpdate = !!value;
			},
			enumerable: true,
			configurable: true
		});
		/**
		 * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself
		 * when particle emission is complete.
		 * @param callback Callback for when emission is complete (all particles have died off)
		 */
		Emitter.prototype.playOnceAndDestroy = function (callback) {
			this.autoUpdate = true;
			this.emit = true;
			this._destroyWhenComplete = true;
			this._completeCallback = callback;
		};
		/**
		 * Starts emitting particles and optionally calls a callback when particle emission is complete.
		 * @param callback Callback for when emission is complete (all particles have died off)
		 */
		Emitter.prototype.playOnce = function (callback) {
			this.emit = true;
			this._completeCallback = callback;
		};
		/**
		 * Updates all particles spawned by this emitter and emits new ones.
		 * @param delta Time elapsed since the previous frame, in __seconds__.
		 */
		Emitter.prototype.update = function (delta) {
			if (this._autoUpdate) {
				delta = delta / pixi.settings.TARGET_FPMS / 1000;
			}
			//if we don't have a parent to add particles to, then don't do anything.
			//this also works as a isDestroyed check
			if (!this._parent)
				return;
			//update existing particles
			var i, particle, next;
			for (particle = this._activeParticlesFirst; particle; particle = next) {
				next = particle.next;
				particle.update(delta);
			}
			var prevX, prevY;
			//if the previous position is valid, store these for later interpolation
			if (this._prevPosIsValid) {
				prevX = this._prevEmitterPos.x;
				prevY = this._prevEmitterPos.y;
			}
			//store current position of the emitter as local variables
			var curX = this.ownerPos.x + this.spawnPos.x;
			var curY = this.ownerPos.y + this.spawnPos.y;
			//spawn new particles
			if (this._emit) {
				//decrease spawn timer
				this._spawnTimer -= delta < 0 ? 0 : delta;
				//while _spawnTimer < 0, we have particles to spawn
				while (this._spawnTimer <= 0) {
					//determine if the emitter should stop spawning
					if (this._emitterLife > 0) {
						this._emitterLife -= this._frequency;
						if (this._emitterLife <= 0) {
							this._spawnTimer = 0;
							this._emitterLife = 0;
							this.emit = false;
							break;
						}
					}
					//determine if we have hit the particle limit
					if (this.particleCount >= this.maxParticles) {
						this._spawnTimer += this._frequency;
						continue;
					}
					//determine the particle lifetime
					var lifetime = void 0;
					if (this.minLifetime == this.maxLifetime)
						lifetime = this.minLifetime;
					else
						lifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;
					//only make the particle if it wouldn't immediately destroy itself
					if (-this._spawnTimer < lifetime) {
						//If the position has changed and this isn't the first spawn,
						//interpolate the spawn position
						var emitPosX = void 0,
							emitPosY = void 0;
						if (this._prevPosIsValid && this._posChanged) {
							//1 - _spawnTimer / delta, but _spawnTimer is negative
							var lerp = 1 + this._spawnTimer / delta;
							emitPosX = (curX - prevX) * lerp + prevX;
							emitPosY = (curY - prevY) * lerp + prevY;
						} else //otherwise just set to the spawn position
						{
							emitPosX = curX;
							emitPosY = curY;
						}
						//create enough particles to fill the wave (non-burst types have a wave of 1)
						i = 0;
						for (var len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i) {
							//see if we actually spawn one
							if (this.spawnChance < 1 && Math.random() >= this.spawnChance)
								continue;
							//create particle
							var p = void 0;
							if (this._poolFirst) {
								p = this._poolFirst;
								this._poolFirst = this._poolFirst.next;
								p.next = null;
							} else {
								p = new this.particleConstructor(this);
							}
							//set a random texture if we have more than one
							if (this.particleImages.length > 1) {
								// if using ordered art
								if (this._currentImageIndex !== -1) {
									// get current art index, then increment for the next particle
									p.applyArt(this.particleImages[this._currentImageIndex++]);
									// loop around if needed
									if (this._currentImageIndex < 0 || this._currentImageIndex >= this.particleImages.length) {
										this._currentImageIndex = 0;
									}
								}
								// otherwise grab a random one
								else {
									p.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);
								}
							} else {
								//if they are actually the same texture, a standard particle
								//will quit early from the texture setting in setTexture().
								p.applyArt(this.particleImages[0]);
							}
							//set up the start and end values
							p.alphaList.reset(this.startAlpha);
							if (this.minimumSpeedMultiplier != 1) {
								p.speedMultiplier = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;
							}
							p.speedList.reset(this.startSpeed);
							p.acceleration.x = this.acceleration.x;
							p.acceleration.y = this.acceleration.y;
							p.maxSpeed = this.maxSpeed;
							if (this.minimumScaleMultiplier != 1) {
								p.scaleMultiplier = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;
							}
							p.scaleList.reset(this.startScale);
							p.colorList.reset(this.startColor);
							//randomize the rotation speed
							if (this.minRotationSpeed == this.maxRotationSpeed)
								p.rotationSpeed = this.minRotationSpeed;
							else
								p.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;
							p.rotationAcceleration = this.rotationAcceleration;
							p.noRotation = this.noRotation;
							//set up the lifetime
							p.maxLife = lifetime;
							//set the blend mode
							p.blendMode = this.particleBlendMode;
							//set the custom ease, if any
							p.ease = this.customEase;
							//set the extra data, if any
							p.extraData = this.extraData;
							//set additional properties to particle
							this.applyAdditionalProperties(p);
							//call the proper function to handle rotation and position of particle
							this._spawnFunc(p, emitPosX, emitPosY, i);
							//initialize particle
							p.init();
							//update the particle by the time passed, so the particles are spread out properly
							p.update(-this._spawnTimer); //we want a positive delta, because a negative delta messes things up
							//add the particle to the display list
							if (!p.parent) {
								if (this.addAtBack)
									this._parent.addChildAt(p, 0);
								else
									this._parent.addChild(p);
							} else {
								//kind of hacky, but performance friendly
								//shuffle children to correct place
								var children = this._parent.children;
								//avoid using splice if possible
								if (children[0] == p)
									children.shift();
								else if (children[children.length - 1] == p)
									children.pop();
								else {
									var index = children.indexOf(p);
									children.splice(index, 1);
								}
								if (this.addAtBack)
									children.unshift(p);
								else
									children.push(p);
							}
							//add particle to list of active particles
							if (this._activeParticlesLast) {
								this._activeParticlesLast.next = p;
								p.prev = this._activeParticlesLast;
								this._activeParticlesLast = p;
							} else {
								this._activeParticlesLast = this._activeParticlesFirst = p;
							}
							++this.particleCount;
						}
					}
					//increase timer and continue on to any other particles that need to be created
					this._spawnTimer += this._frequency;
				}
			}
			//if the position changed before this update, then keep track of that
			if (this._posChanged) {
				this._prevEmitterPos.x = curX;
				this._prevEmitterPos.y = curY;
				this._prevPosIsValid = true;
				this._posChanged = false;
			}
			//if we are all done and should destroy ourselves, take care of that
			if (!this._emit && !this._activeParticlesFirst) {
				if (this._completeCallback) {
					var cb = this._completeCallback;
					this._completeCallback = null;
					cb();
				}
				if (this._destroyWhenComplete) {
					this.destroy();
				}
			}
		};
		/**
		 * Set additional properties to new particle.
		 * Using on classes that extend from Emitter
		 * @param p The particle
		 */
		Emitter.prototype.applyAdditionalProperties = function (p) {};
		/**
		 * Positions a particle for a point type emitter.
		 * @param p The particle to position and rotate.
		 * @param emitPosX The emitter's x position
		 * @param emitPosY The emitter's y position
		 * @param i The particle number in the current wave. Not used for this function.
		 */
		Emitter.prototype._spawnPoint = function (p, emitPosX, emitPosY) {
			//set the initial rotation/direction of the particle based on
			//starting particle angle and rotation of emitter
			if (this.minStartRotation == this.maxStartRotation)
				p.rotation = this.minStartRotation + this.rotation;
			else
				p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;
			//drop the particle at the emitter's position
			p.position.x = emitPosX;
			p.position.y = emitPosY;
		};
		/**
		 * Positions a particle for a rectangle type emitter.
		 * @param p The particle to position and rotate.
		 * @param emitPosX The emitter's x position
		 * @param emitPosY The emitter's y position
		 * @param i The particle number in the current wave. Not used for this function.
		 */
		Emitter.prototype._spawnRect = function (p, emitPosX, emitPosY) {
			//set the initial rotation/direction of the particle based on starting
			//particle angle and rotation of emitter
			if (this.minStartRotation == this.maxStartRotation)
				p.rotation = this.minStartRotation + this.rotation;
			else
				p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;
			//place the particle at a random point in the rectangle
			helperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;
			helperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;
			if (this.rotation !== 0)
				exports.ParticleUtils.rotatePoint(this.rotation, helperPoint);
			p.position.x = emitPosX + helperPoint.x;
			p.position.y = emitPosY + helperPoint.y;
		};
		/**
		 * Positions a particle for a circle type emitter.
		 * @param p The particle to position and rotate.
		 * @param emitPosX The emitter's x position
		 * @param emitPosY The emitter's y position
		 * @param i The particle number in the current wave. Not used for this function.
		 */
		Emitter.prototype._spawnCircle = function (p, emitPosX, emitPosY) {
			//set the initial rotation/direction of the particle based on starting
			//particle angle and rotation of emitter
			if (this.minStartRotation == this.maxStartRotation)
				p.rotation = this.minStartRotation + this.rotation;
			else
				p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +
				this.minStartRotation + this.rotation;
			//place the particle at a random radius in the circle
			helperPoint.x = Math.random() * this.spawnCircle.radius;
			helperPoint.y = 0;
			//rotate the point to a random angle in the circle
			exports.ParticleUtils.rotatePoint(Math.random() * 360, helperPoint);
			//offset by the circle's center
			helperPoint.x += this.spawnCircle.x;
			helperPoint.y += this.spawnCircle.y;
			//rotate the point by the emitter's rotation
			if (this.rotation !== 0)
				exports.ParticleUtils.rotatePoint(this.rotation, helperPoint);
			//set the position, offset by the emitter's position
			p.position.x = emitPosX + helperPoint.x;
			p.position.y = emitPosY + helperPoint.y;
		};
		/**
		 * Positions a particle for a ring type emitter.
		 * @param p The particle to position and rotate.
		 * @param emitPosX The emitter's x position
		 * @param emitPosY The emitter's y position
		 * @param i The particle number in the current wave. Not used for this function.
		 */
		Emitter.prototype._spawnRing = function (p, emitPosX, emitPosY) {
			var spawnCircle = this.spawnCircle;
			//set the initial rotation/direction of the particle based on starting
			//particle angle and rotation of emitter
			if (this.minStartRotation == this.maxStartRotation)
				p.rotation = this.minStartRotation + this.rotation;
			else
				p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +
				this.minStartRotation + this.rotation;
			//place the particle at a random radius in the ring
			if (spawnCircle.minRadius !== spawnCircle.radius) {
				helperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +
					spawnCircle.minRadius;
			} else
				helperPoint.x = spawnCircle.radius;
			helperPoint.y = 0;
			//rotate the point to a random angle in the circle
			var angle = Math.random() * 360;
			p.rotation += angle;
			exports.ParticleUtils.rotatePoint(angle, helperPoint);
			//offset by the circle's center
			helperPoint.x += this.spawnCircle.x;
			helperPoint.y += this.spawnCircle.y;
			//rotate the point by the emitter's rotation
			if (this.rotation !== 0)
				exports.ParticleUtils.rotatePoint(this.rotation, helperPoint);
			//set the position, offset by the emitter's position
			p.position.x = emitPosX + helperPoint.x;
			p.position.y = emitPosY + helperPoint.y;
		};
		/**
		 * Positions a particle for polygonal chain.
		 * @param p The particle to position and rotate.
		 * @param emitPosX The emitter's x position
		 * @param emitPosY The emitter's y position
		 * @param i The particle number in the current wave. Not used for this function.
		 */
		Emitter.prototype._spawnPolygonalChain = function (p, emitPosX, emitPosY) {
			//set the initial rotation/direction of the particle based on starting
			//particle angle and rotation of emitter
			if (this.minStartRotation == this.maxStartRotation)
				p.rotation = this.minStartRotation + this.rotation;
			else
				p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +
				this.minStartRotation + this.rotation;
			// get random point on the polygon chain
			this.spawnPolygonalChain.getRandomPoint(helperPoint);
			//rotate the point by the emitter's rotation
			if (this.rotation !== 0)
				exports.ParticleUtils.rotatePoint(this.rotation, helperPoint);
			//set the position, offset by the emitter's position
			p.position.x = emitPosX + helperPoint.x;
			p.position.y = emitPosY + helperPoint.y;
		};
		/**
		 * Positions a particle for a burst type emitter.
		 * @param p The particle to position and rotate.
		 * @param emitPosX The emitter's x position
		 * @param emitPosY The emitter's y position
		 * @param i The particle number in the current wave.
		 */
		Emitter.prototype._spawnBurst = function (p, emitPosX, emitPosY, i) {
			//set the initial rotation/direction of the particle based on spawn
			//angle and rotation of emitter
			if (this.particleSpacing === 0)
				p.rotation = Math.random() * 360;
			else
				p.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;
			//drop the particle at the emitter's position
			p.position.x = emitPosX;
			p.position.y = emitPosY;
		};
		/**
		 * Kills all active particles immediately.
		 */
		Emitter.prototype.cleanup = function () {
			var particle, next;
			for (particle = this._activeParticlesFirst; particle; particle = next) {
				next = particle.next;
				this.recycle(particle);
				if (particle.parent)
					particle.parent.removeChild(particle);
			}
			this._activeParticlesFirst = this._activeParticlesLast = null;
			this.particleCount = 0;
		};
		/**
		 * Destroys the emitter and all of its particles.
		 */
		Emitter.prototype.destroy = function () {
			//make sure we aren't still listening to any tickers
			this.autoUpdate = false;
			//puts all active particles in the pool, and removes them from the particle parent
			this.cleanup();
			//wipe the pool clean
			var next;
			for (var particle = this._poolFirst; particle; particle = next) {
				//store next value so we don't lose it in our destroy call
				next = particle.next;
				particle.destroy();
			}
			this._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =
				this.startColor = this.startScale = this.startAlpha = this.startSpeed =
				this.customEase = this._completeCallback = null;
		};
		return Emitter;
	}());

	/**
	 * A helper point for math things.
	 * @hidden
	 */
	var helperPoint$1 = new pixi.Point();
	/**
	 * A hand picked list of Math functions (and a couple properties) that are
	 * allowable. They should be used without the preceding "Math."
	 * @hidden
	 */
	var MATH_FUNCS = [
		"pow",
		"sqrt",
		"abs",
		"floor",
		"round",
		"ceil",
		"E",
		"PI",
		"sin",
		"cos",
		"tan",
		"asin",
		"acos",
		"atan",
		"atan2",
		"log"
	];
	/**
	 * create an actual regular expression object from the string
	 * @hidden
	 */
	var WHITELISTER = new RegExp([
		//Allow the 4 basic operations, parentheses and all numbers/decimals, as well
		//as 'x', for the variable usage.
		"[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]",
	].concat(MATH_FUNCS).join("|"), "g");
	/**
	 * Parses a string into a function for path following.
	 * This involves whitelisting the string for safety, inserting "Math." to math function
	 * names, and using `new Function()` to generate a function.
	 * @hidden
	 * @param pathString The string to parse.
	 * @return The path function - takes x, outputs y.
	 */
	var parsePath = function (pathString) {
		var matches = pathString.match(WHITELISTER);
		for (var i = matches.length - 1; i >= 0; --i) {
			if (MATH_FUNCS.indexOf(matches[i]) >= 0)
				matches[i] = "Math." + matches[i];
		}
		pathString = matches.join("");
		return new Function("x", "return " + pathString + ";");
	};
	/**
	 * An particle that follows a path defined by an algebraic expression, e.g. "sin(x)" or
	 * "5x + 3".
	 * To use this class, the particle config must have a "path" string in the
	 * "extraData" parameter. This string should have "x" in it to represent movement (from the
	 * speed settings of the particle). It may have numbers, parentheses, the four basic
	 * operations, and the following Math functions or properties (without the preceding "Math."):
	 * "pow", "sqrt", "abs", "floor", "round", "ceil", "E", "PI", "sin", "cos", "tan", "asin",
	 * "acos", "atan", "atan2", "log".
	 * The overall movement of the particle and the expression value become x and y positions for
	 * the particle, respectively. The final position is rotated by the spawn rotation/angle of
	 * the particle.
	 *
	 * Some example paths:
	 *
	 * 	"sin(x/10) * 20" // A sine wave path.
	 * 	"cos(x/100) * 30" // Particles curve counterclockwise (for medium speed/low lifetime particles)
	 * 	"pow(x/10, 2) / 2" // Particles curve clockwise (remember, +y is down).
	 */
	var PathParticle = /** @class */ (function (_super) {
		__extends(PathParticle, _super);
		/**
		 * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.
		 */
		function PathParticle(emitter) {
			var _this = _super.call(this, emitter) || this;
			_this.path = null;
			_this.initialRotation = 0;
			_this.initialPosition = new pixi.Point();
			_this.movement = 0;
			return _this;
		}
		/**
		 * Initializes the particle for use, based on the properties that have to
		 * have been set already on the particle.
		 */
		PathParticle.prototype.init = function () {
			//get initial rotation before it is converted to radians
			this.initialRotation = this.rotation;
			//standard init
			this.Particle_init();
			//set the path for the particle
			this.path = this.extraData.path;
			//cancel the normal movement behavior
			this._doNormalMovement = !this.path;
			//reset movement
			this.movement = 0;
			//grab position
			this.initialPosition.x = this.position.x;
			this.initialPosition.y = this.position.y;
		};
		/**
		 * Updates the particle.
		 * @param delta Time elapsed since the previous frame, in __seconds__.
		 */
		PathParticle.prototype.update = function (delta) {
			var lerp = this.Particle_update(delta);
			//if the particle died during the update, then don't bother
			if (lerp >= 0 && this.path) {
				//increase linear movement based on speed
				var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;
				this.movement += speed * delta;
				//set up the helper point for rotation
				helperPoint$1.x = this.movement;
				helperPoint$1.y = this.path(this.movement);
				exports.ParticleUtils.rotatePoint(this.initialRotation, helperPoint$1);
				this.position.x = this.initialPosition.x + helperPoint$1.x;
				this.position.y = this.initialPosition.y + helperPoint$1.y;
			}
			return lerp;
		};
		/**
		 * Destroys the particle, removing references and preventing future use.
		 */
		PathParticle.prototype.destroy = function () {
			this.Particle_destroy();
			this.path = this.initialPosition = null;
		};
		/**
		 * Checks over the art that was passed to the Emitter's init() function, to do any special
		 * modifications to prepare it ahead of time. This just runs Particle.parseArt().
		 * @param art The array of art data. For Particle, it should be an array of
		 *            Textures. Any strings in the array will be converted to
		 *            Textures via Texture.fromImage().
		 * @return The art, after any needed modifications.
		 */
		PathParticle.parseArt = function (art) {
			return Particle.parseArt(art);
		};
		/**
		 * Parses extra emitter data to ensure it is set up for this particle class.
		 * PathParticle checks for the existence of path data, and parses the path data for use
		 * by particle instances.
		 * @param extraData The extra data from the particle config.
		 * @return The parsed extra data.
		 */
		PathParticle.parseData = function (extraData) {
			var output = {};
			if (extraData && extraData.path) {
				try {
					output.path = parsePath(extraData.path);
				} catch (e) {
					if (exports.ParticleUtils.verbose)
						console.error("PathParticle: error in parsing path expression");
					output.path = null;
				}
			} else {
				if (exports.ParticleUtils.verbose)
					console.error("PathParticle requires a path string in extraData!");
				output.path = null;
			}
			return output;
		};
		return PathParticle;
	}(Particle));

	/**
	 * An individual particle image with an animation. Art data passed to the emitter must be
	 * formatted in a particular way for AnimatedParticle to be able to handle it:
	 *
	 * ```typescript
	 * {
	 *     //framerate is required. It is the animation speed of the particle in frames per
	 *     //second.
	 *     //A value of "matchLife" causes the animation to match the lifetime of an individual
	 *     //particle, instead of at a constant framerate. This causes the animation to play
	 *     //through one time, completing when the particle expires.
	 *     framerate: 6,
	 *     //loop is optional, and defaults to false.
	 *     loop: true,
	 *     //textures is required, and can be an array of any (non-zero) length.
	 *     textures: [
	 *         //each entry represents a single texture that should be used for one or more
	 *         //frames. Any strings will be converted to Textures with Texture.from().
	 *         //Instances of PIXI.Texture will be used directly.
	 *         "animFrame1.png",
	 *         //entries can be an object with a 'count' property, telling AnimatedParticle to
	 *         //use that texture for 'count' frames sequentially.
	 *         {
	 *             texture: "animFrame2.png",
	 *             count: 3
	 *         },
	 *         "animFrame3.png"
	 *     ]
	 * }
	 * ```
	 */
	var AnimatedParticle = /** @class */ (function (_super) {
		__extends(AnimatedParticle, _super);
		/**
		 * @param emitter The emitter that controls this AnimatedParticle.
		 */
		function AnimatedParticle(emitter) {
			var _this = _super.call(this, emitter) || this;
			_this.textures = null;
			_this.duration = 0;
			_this.framerate = 0;
			_this.elapsed = 0;
			_this.loop = false;
			return _this;
		}
		/**
		 * Initializes the particle for use, based on the properties that have to
		 * have been set already on the particle.
		 */
		AnimatedParticle.prototype.init = function () {
			this.Particle_init();
			this.elapsed = 0;
			//if the animation needs to match the particle's life, then cacluate variables
			if (this.framerate < 0) {
				this.duration = this.maxLife;
				this.framerate = this.textures.length / this.duration;
			}
		};
		/**
		 * Sets the textures for the particle.
		 * @param art An array of PIXI.Texture objects for this animated particle.
		 */
		AnimatedParticle.prototype.applyArt = function (art) {
			this.textures = art.textures;
			this.framerate = art.framerate;
			this.duration = art.duration;
			this.loop = art.loop;
		};
		/**
		 * Updates the particle.
		 * @param delta Time elapsed since the previous frame, in __seconds__.
		 */
		AnimatedParticle.prototype.update = function (delta) {
			var lerp = this.Particle_update(delta);
			//only animate the particle if it is still alive
			if (lerp >= 0) {
				this.elapsed += delta;
				if (this.elapsed > this.duration) {
					//loop elapsed back around
					if (this.loop)
						this.elapsed = this.elapsed % this.duration;
					//subtract a small amount to prevent attempting to go past the end of the animation
					else
						this.elapsed = this.duration - 0.000001;
				}
				// add a very small number to the frame and then floor it to avoid
				// the frame being one short due to floating point errors.
				var frame = (this.elapsed * this.framerate + 0.0000001) | 0;
				this.texture = this.textures[frame] || pixi.Texture.EMPTY;
			}
			return lerp;
		};
		/**
		 * Destroys the particle, removing references and preventing future use.
		 */
		AnimatedParticle.prototype.destroy = function () {
			this.Particle_destroy();
			this.textures = null;
		};
		/**
		 * Checks over the art that was passed to the Emitter's init() function, to do any special
		 * modifications to prepare it ahead of time.
		 * @param art The array of art data, properly formatted for AnimatedParticle.
		 * @return The art, after any needed modifications.
		 */
		AnimatedParticle.parseArt = function (art) {
			var data, output, textures, tex, outTextures;
			var outArr = [];
			for (var i = 0; i < art.length; ++i) {
				data = art[i];
				outArr[i] = output = {};
				output.textures = outTextures = [];
				textures = data.textures;
				for (var j = 0; j < textures.length; ++j) {
					tex = textures[j];
					if (typeof tex == "string")
						outTextures.push(GetTextureFromString(tex));
					else if (tex instanceof pixi.Texture)
						outTextures.push(tex);
					//assume an object with extra data determining duplicate frame data
					else {
						var dupe = tex.count || 1;
						if (typeof tex.texture == "string")
							tex = GetTextureFromString(tex.texture);
						else // if(tex.texture instanceof Texture)
							tex = tex.texture;
						for (; dupe > 0; --dupe) {
							outTextures.push(tex);
						}
					}
				}
				//use these values to signify that the animation should match the particle life time.
				if (data.framerate == "matchLife") {
					//-1 means that it should be calculated
					output.framerate = -1;
					output.duration = 0;
					output.loop = false;
				} else {
					//determine if the animation should loop
					output.loop = !!data.loop;
					//get the framerate, default to 60
					output.framerate = data.framerate > 0 ? data.framerate : 60;
					//determine the duration
					output.duration = outTextures.length / output.framerate;
				}
			}
			return outArr;
		};
		return AnimatedParticle;
	}(Particle));

	exports.GetTextureFromString = GetTextureFromString;
	exports.Particle = Particle;
	exports.Emitter = Emitter;
	exports.PathParticle = PathParticle;
	exports.AnimatedParticle = AnimatedParticle;
	exports.PolygonalChain = PolygonalChain;
	exports.PropertyList = PropertyList;
	exports.PropertyNode = PropertyNode;

}(this.PIXI.particles = this.PIXI.particles || {}, PIXI));
//# sourceMappingURL=pixi-particles.js.map


/******/
(function (modules) { // webpackBootstrap
	/******/ // The module cache
	/******/
	var installedModules = {};
	/******/
	/******/ // The require function
	/******/
	function __webpack_require__(moduleId) {
		/******/
		/******/ // Check if module is in cache
		/******/
		if (installedModules[moduleId])
			/******/
			return installedModules[moduleId].exports;
		/******/
		/******/ // Create a new module (and put it into the cache)
		/******/
		var module = installedModules[moduleId] = {
			/******/
			exports: {},
			/******/
			id: moduleId,
			/******/
			loaded: false
			/******/
		};
		/******/
		/******/ // Execute the module function
		/******/
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ // Flag the module as loaded
		/******/
		module.loaded = true;
		/******/
		/******/ // Return the exports of the module
		/******/
		return module.exports;
		/******/
	}
	/******/
	/******/
	/******/ // expose the modules object (__webpack_modules__)
	/******/
	__webpack_require__.m = modules;
	/******/
	/******/ // expose the module cache
	/******/
	__webpack_require__.c = installedModules;
	/******/
	/******/ // __webpack_public_path__
	/******/
	__webpack_require__.p = "";
	/******/
	/******/ // Load entry module and return exports
	/******/
	return __webpack_require__(0);
	/******/
})
/************************************************************************/
/******/
([
	/* 0 */
	/***/
	(function (module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];
				for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}
			return target;
		};

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					if ("value" in descriptor) descriptor.writable = true;
					Object.defineProperty(target, descriptor.key, descriptor);
				}
			}
			return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);
				if (staticProps) defineProperties(Constructor, staticProps);
				return Constructor;
			};
		}();

		var _get = function get(object, property, receiver) {
			if (object === null) object = Function.prototype;
			var desc = Object.getOwnPropertyDescriptor(object, property);
			if (desc === undefined) {
				var parent = Object.getPrototypeOf(object);
				if (parent === null) {
					return undefined;
				} else {
					return get(parent, property, receiver);
				}
			} else if ("value" in desc) {
				return desc.value;
			} else {
				var getter = desc.get;
				if (getter === undefined) {
					return undefined;
				}
				return getter.call(receiver);
			}
		};

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}
			return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}
			subClass.prototype = Object.create(superClass && superClass.prototype, {
				constructor: {
					value: subClass,
					enumerable: false,
					writable: true,
					configurable: true
				}
			});
			if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		var loadFont = __webpack_require__(1);
		var isEqual = __webpack_require__(18);
		var createLayout = __webpack_require__(19);
		var createIndices = __webpack_require__(22);
		var vertices = __webpack_require__(26);

		(function () {
			/* Shaders */

			var vertexSrc = '\n\t    attribute vec2 aVertexPosition;\n\t\tattribute vec2 aTextureCoord;\n\n\t\tuniform mat3 translationMatrix;\n\t\tuniform mat3 projectionMatrix;\n\t\tuniform float u_fontInfoSize;\n\n\t\tvarying vec2 vTextureCoord;\n\n\t\tvoid main(void)\n\t\t{\n\t\t    vTextureCoord = aTextureCoord;\n\t\t    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition * u_fontInfoSize, 1.0)).xy, 0.0, 1.0);\n\t\t}';

			var fragmentSrc = '\n\t    varying vec2 vTextureCoord;\n\t\tuniform vec3 u_color;\n\t\tuniform sampler2D uSampler;\n\t\tuniform float u_alpha;\n\t\tuniform float u_realalpha;\n\t\tuniform float u_fontSize;\n\t\tuniform float u_weight;\n\n\t\tvoid main(void)\n\t\t{\n\t\t    float smoothing = 1. / u_fontSize * 6.;\n\t\t    float debug = 0.0;\n\n\t\t    vec2 textureCoord = vTextureCoord * 2.;\n\t\t    float dist = texture2D(uSampler, vTextureCoord).a;\n\n\t\t    if (debug > 0.0) {\n\t\t        gl_FragColor = vec4(dist, dist, dist, 1);\n\t\t    } else {\n\t\t        float alpha = smoothstep((u_weight - smoothing) / u_alpha, (u_weight + smoothing) / u_alpha, dist);\n\n\t\t        vec3 color = u_color * alpha;\n\n\t\t        gl_FragColor = vec4(color, alpha) * u_alpha * u_realalpha;\n\t\t    }\n\t\t}';

			var TT_SHADER = new PIXI.Program(vertexSrc, fragmentSrc, 'THEORYTYPE');

			/* PIXI.TheoryType */

			var TheoryType = function (_PIXI$Mesh) {
				_inherits(TheoryType, _PIXI$Mesh);

				function TheoryType(text) {
					var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

					_classCallCheck(this, TheoryType);

					var geometry = new PIXI.Geometry().addIndex([]).addAttribute('aVertexPosition', [], 2).addAttribute('aTextureCoord', [], 2);

					var _this = _possibleConstructorReturn(this, (TheoryType.__proto__ || Object.getPrototypeOf(TheoryType)).call(this, geometry, new PIXI.Shader(TT_SHADER, {})));

					_this.style = new TextStyle(style);
					_this._text = text;
					_this._alpha = 1;
					_this._realAlpha = 1;
					_this._lastWorldAlpha = 1;
					_this._copyDirty = true;

					_this.loadAssets();
					return _this;
				}

				_createClass(TheoryType, [{
					key: 'loadAssets',
					value: function loadAssets() {
						var _this2 = this;

						TTLoadFont(this.style.fontURL, this.style.imageURL, function (rd) {
							_this2._font = rd.font;
							_this2._texture = rd.texture;
							_this2.updateText();
						});
					}
				}, {
					key: 'updateText',
					value: function updateText() {
						// Update text copy
						if (this._copyDirty || this.style.copyDirty) {
							var opt = _extends({
								text: this._text,
								font: this._font
							}, this.style.getFlatCopy());

							if (!opt.font) {
								throw 'must specify a { font } in options';
							}

							var layout = createLayout(opt);

							// the desired BMFont data
							var font = opt.font;

							// determine texture size from font file
							var texWidth = font.common.scaleW;
							var texHeight = font.common.scaleH;

							// get visible glyphs
							var glyphs = layout.glyphs.filter(function (glyph) {
								var bitmap = glyph.data;
								return bitmap.width * bitmap.height > 0;
							});

							// get common vertex data
							var positions = vertices.positions(glyphs);
							var uvs = vertices.uvs(glyphs, texWidth, texHeight, false);

							var indices = createIndices({
								clockwise: true,
								type: 'uint16',
								count: glyphs.length
							});

							this.geometry.getIndex().update(indices);
							this.geometry.getBuffer('aVertexPosition').update(positions);
							this.geometry.getBuffer('aTextureCoord').update(uvs);

							this._copyDirty = false;
							this.style.copyDirty = false;
						}

						// Update text style
						if (this.styleID !== this.style.styleID) {
							this.shader.uniforms.uSampler = this._texture;
							this.shader.uniforms.u_alpha = this.worldAlpha;
							this.shader.uniforms.u_realalpha = this.realAlpha;
							this.shader.uniforms.u_color = this.style.fill;
							this.shader.uniforms.u_fontSize = this.style.fontSize;
							this.shader.uniforms.u_fontInfoSize = this.style.fontSize / this._font.info.size;
							this.shader.uniforms.u_weight = this.style.weight;

							this.styleID = this.style.styleID;
							this._lastWorldAlpha = this.worldAlpha;
						}
					}
				}, {
					key: '_renderDefault',
					value: function _renderDefault(renderer) {
						if (this.worldAlpha !== this._lastWorldAlpha) {
							this.style.styleID++;
						}

						this.updateText();

						_get(TheoryType.prototype.__proto__ || Object.getPrototypeOf(TheoryType.prototype), '_renderDefault', this).call(this, renderer);
					}
				}, {
					key: 'text',
					get: function get() {
						return this._text;
					},
					set: function set(value) {
						if (!this._text !== value) {
							this._text = value;
							this._copyDirty = true;
						}
					}
				}, {
					key: 'alpha',
					get: function get() {
						return this._alpha;
					},
					set: function set(value) {
						if (!this._alpha !== value) {
							this._alpha = value;
							if (this.style) {
								this.style.styleID++;
							}
						}
					}
				}, {
					key: 'realAlpha',
					get: function get() {
						return this._realAlpha;
					},
					set: function set(value) {
						if (!this._realAlpha !== value) {
							this._realAlpha = value;
							this.style.styleID++;
						}
					}
				}]);

				return TheoryType;
			}(PIXI.Mesh);

			PIXI.TheoryType = TheoryType;

			/* PIXI.TheoryType.LoadFont */

			var TTFontCache = {};

			function TTLoadFont(fontURL, imageURL, callback) {
				if (TTFontCache['' + fontURL + imageURL]) {
					callback(TTFontCache['' + fontURL + imageURL]);
					return;
				}

				loadFont(fontURL, function (err, font) {
					PIXI.Loader.shared.add(imageURL, imageURL).load(function (loader, resources) {
						var rd = {
							font: font,
							texture: resources[imageURL].texture
						};
						TTFontCache['' + fontURL + imageURL] = rd;

						callback(rd);
						return;
					});
				});
			}
			PIXI.TheoryType.LoadFont = TTLoadFont;

			/* private TextStyle */

			var defaultStyle = {
				align: 'left',
				/*breakWords: false,
	   dropShadow: false,
	   dropShadowAngle: Math.PI / 6,
	   dropShadowBlur: 0,
	   dropShadowColor: '#000000',
	   dropShadowDistance: 5,*/
				fill: 0xffffff,
				//fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
				fontSize: 26,
				fontWeight: 'normal',
				letterSpacing: 0,
				lineHeight: 0,
				//stroke: 'black',
				//strokeThickness: 0,
				wordWrap: false,
				wordWrapWidth: 100
			};

			var TextStyle = function () {
				function TextStyle(style) {
					_classCallCheck(this, TextStyle);

					this.styleID = 0;
					this._copyDirty = false;
					Object.assign(this, defaultStyle, style);
				}

				_createClass(TextStyle, [{
					key: 'getFlatCopy',
					value: function getFlatCopy() {
						return {
							align: this.align,
							fontSize: this.fontSize,
							fill: this.fill,
							fontWeight: this.fontWeight,
							width: this.wordWrapWidth,
							wordWrapWidth: this.wordWrapWidth,
							mode: this.wordWrap ? undefined : 'nowrap',
							lineHeight: this.lineHeight,
							letterSpacing: this.letterSpacing
						};
					}
				}, {
					key: 'copyDirty',
					get: function get() {
						return this._copyDirty;
					},
					set: function set(value) {
						this._copyDirty = value;
					}
				}, {
					key: 'align',
					get: function get() {
						return this._align;
					},
					set: function set(value) {
						if (!this._align !== value) {
							this._align = value;
							this.styleID++;
							this._copyDirty = true;
						}
					}
				}, {
					key: 'weight',
					get: function get() {
						return this._weight;
					}
				}, {
					key: 'fontWeight',
					get: function get() {
						return this._weight;
					},
					set: function set(value) {
						if (!this._weight !== value) {
							this._weight = value;
							this.styleID++;
						}
					}
				}, {
					key: 'fontSize',
					get: function get() {
						return this._fontSize;
					},
					set: function set(value) {
						if (!this._fontSize !== value) {
							this._fontSize = value;
							this.styleID++;
							this._copyDirty = true;
						}
					}
				}, {
					key: 'letterSpacing',
					get: function get() {
						return this._letterSpacing;
					},
					set: function set(value) {
						if (!this._letterSpacing !== value) {
							this._letterSpacing = value;
							this._copyDirty = true;
						}
					}
				}, {
					key: 'wordWrap',
					get: function get() {
						return this._wordWrap;
					},
					set: function set(value) {
						if (!this._wordWrap !== value) {
							this._wordWrap = value;
							this._copyDirty = true;
						}
					}
				}, {
					key: 'fill',
					get: function get() {
						return this._fill;
					},
					set: function set(value) {
						var outputColor = PIXI.utils.hex2rgb(value);
						if (!this._fill || !this._fill.every(function (v, i) {
								return v === outputColor[i];
							})) {
							this._fill = outputColor;
							this.styleID++;
						}
					}
				}]);

				return TextStyle;
			}();
		})();

		/***/
	}),
	/* 1 */
	/***/
	(function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (Buffer) {
			var xhr = __webpack_require__(6)
			var noop = function () {}
			var parseASCII = __webpack_require__(11)
			var parseXML = __webpack_require__(12)
			var readBinary = __webpack_require__(15)
			var isBinaryFormat = __webpack_require__(16)
			var xtend = __webpack_require__(10)

			var xml2 = (function hasXML2() {
				return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest
			})()

			module.exports = function (opt, cb) {
				cb = typeof cb === 'function' ? cb : noop

				if (typeof opt === 'string')
					opt = {
						uri: opt
					}
				else if (!opt)
					opt = {}

				var expectBinary = opt.binary
				if (expectBinary)
					opt = getBinaryOpts(opt)

				xhr(opt, function (err, res, body) {
					if (err)
						return cb(err)
					if (!/^2/.test(res.statusCode))
						return cb(new Error('http status code: ' + res.statusCode))
					if (!body)
						return cb(new Error('no body result'))

					var binary = false

					//if the response type is an array buffer,
					//we need to convert it into a regular Buffer object
					if (isArrayBuffer(body)) {
						var array = new Uint8Array(body)
						body = new Buffer(array, 'binary')
					}

					//now check the string/Buffer response
					//and see if it has a binary BMF header
					if (isBinaryFormat(body)) {
						binary = true
						//if we have a string, turn it into a Buffer
						if (typeof body === 'string')
							body = new Buffer(body, 'binary')
					}

					//we are not parsing a binary format, just ASCII/XML/etc
					if (!binary) {
						//might still be a buffer if responseType is 'arraybuffer'
						if (Buffer.isBuffer(body))
							body = body.toString(opt.encoding)
						body = body.trim()
					}

					var result
					try {
						var type = res.headers['content-type']
						if (binary)
							result = readBinary(body)
						else if (/json/.test(type) || body.charAt(0) === '{')
							result = JSON.parse(body)
						else if (/xml/.test(type) || body.charAt(0) === '<')
							result = parseXML(body)
						else
							result = parseASCII(body)
					} catch (e) {
						cb(new Error('error parsing font ' + e.message))
						cb = noop
					}
					cb(null, result)
				})
			}

			function isArrayBuffer(arr) {
				var str = Object.prototype.toString
				return str.call(arr) === '[object ArrayBuffer]'
			}

			function getBinaryOpts(opt) {
				//IE10+ and other modern browsers support array buffers
				if (xml2)
					return xtend(opt, {
						responseType: 'arraybuffer'
					})

				if (typeof self.XMLHttpRequest === 'undefined')
					throw new Error('your browser does not support XHR loading')

				//IE9 and XML1 browsers could still use an override
				var req = new self.XMLHttpRequest()
				req.overrideMimeType('text/plain; charset=x-user-defined')
				return xtend({
					xhr: req
				}, opt)
			}

			/* WEBPACK VAR INJECTION */
		}.call(exports, __webpack_require__(2).Buffer))

		/***/
	}),
	/* 2 */
	/***/
	(function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (global) {
			/*!
			 * The buffer module from node.js, for the browser.
			 *
			 * @author   Feross Aboukhadijeh <http://feross.org>
			 * @license  MIT
			 */
			/* eslint-disable no-proto */

			'use strict'

			var base64 = __webpack_require__(3)
			var ieee754 = __webpack_require__(4)
			var isArray = __webpack_require__(5)

			exports.Buffer = Buffer
			exports.SlowBuffer = SlowBuffer
			exports.INSPECT_MAX_BYTES = 50

			/**
			 * If `Buffer.TYPED_ARRAY_SUPPORT`:
			 *   === true    Use Uint8Array implementation (fastest)
			 *   === false   Use Object implementation (most compatible, even IE6)
			 *
			 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
			 * Opera 11.6+, iOS 4.2+.
			 *
			 * Due to various browser bugs, sometimes the Object implementation will be used even
			 * when the browser supports typed arrays.
			 *
			 * Note:
			 *
			 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
			 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
			 *
			 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
			 *
			 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
			 *     incorrect length in some situations.
			
			 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
			 * get the Object implementation, which is slower but behaves correctly.
			 */
			Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ?
				global.TYPED_ARRAY_SUPPORT :
				typedArraySupport()

			/*
			 * Export kMaxLength after typed array support is determined.
			 */
			exports.kMaxLength = kMaxLength()

			function typedArraySupport() {
				try {
					var arr = new Uint8Array(1)
					arr.__proto__ = {
						__proto__: Uint8Array.prototype,
						foo: function () {
							return 42
						}
					}
					return arr.foo() === 42 && // typed array instances can be augmented
						typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
						arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
				} catch (e) {
					return false
				}
			}

			function kMaxLength() {
				return Buffer.TYPED_ARRAY_SUPPORT ?
					0x7fffffff :
					0x3fffffff
			}

			function createBuffer(that, length) {
				if (kMaxLength() < length) {
					throw new RangeError('Invalid typed array length')
				}
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					// Return an augmented `Uint8Array` instance, for best performance
					that = new Uint8Array(length)
					that.__proto__ = Buffer.prototype
				} else {
					// Fallback: Return an object instance of the Buffer class
					if (that === null) {
						that = new Buffer(length)
					}
					that.length = length
				}

				return that
			}

			/**
			 * The Buffer constructor returns instances of `Uint8Array` that have their
			 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
			 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
			 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
			 * returns a single octet.
			 *
			 * The `Uint8Array` prototype remains unmodified.
			 */

			function Buffer(arg, encodingOrOffset, length) {
				if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
					return new Buffer(arg, encodingOrOffset, length)
				}

				// Common case.
				if (typeof arg === 'number') {
					if (typeof encodingOrOffset === 'string') {
						throw new Error(
							'If encoding is specified then the first argument must be a string'
						)
					}
					return allocUnsafe(this, arg)
				}
				return from(this, arg, encodingOrOffset, length)
			}

			Buffer.poolSize = 8192 // not used by this implementation

			// TODO: Legacy, not needed anymore. Remove in next major version.
			Buffer._augment = function (arr) {
				arr.__proto__ = Buffer.prototype
				return arr
			}

			function from(that, value, encodingOrOffset, length) {
				if (typeof value === 'number') {
					throw new TypeError('"value" argument must not be a number')
				}

				if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
					return fromArrayBuffer(that, value, encodingOrOffset, length)
				}

				if (typeof value === 'string') {
					return fromString(that, value, encodingOrOffset)
				}

				return fromObject(that, value)
			}

			/**
			 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
			 * if value is a number.
			 * Buffer.from(str[, encoding])
			 * Buffer.from(array)
			 * Buffer.from(buffer)
			 * Buffer.from(arrayBuffer[, byteOffset[, length]])
			 **/
			Buffer.from = function (value, encodingOrOffset, length) {
				return from(null, value, encodingOrOffset, length)
			}

			if (Buffer.TYPED_ARRAY_SUPPORT) {
				Buffer.prototype.__proto__ = Uint8Array.prototype
				Buffer.__proto__ = Uint8Array
				if (typeof Symbol !== 'undefined' && Symbol.species &&
					Buffer[Symbol.species] === Buffer) {
					// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
					Object.defineProperty(Buffer, Symbol.species, {
						value: null,
						configurable: true
					})
				}
			}

			function assertSize(size) {
				if (typeof size !== 'number') {
					throw new TypeError('"size" argument must be a number')
				} else if (size < 0) {
					throw new RangeError('"size" argument must not be negative')
				}
			}

			function alloc(that, size, fill, encoding) {
				assertSize(size)
				if (size <= 0) {
					return createBuffer(that, size)
				}
				if (fill !== undefined) {
					// Only pay attention to encoding if it's a string. This
					// prevents accidentally sending in a number that would
					// be interpretted as a start offset.
					return typeof encoding === 'string' ?
						createBuffer(that, size).fill(fill, encoding) :
						createBuffer(that, size).fill(fill)
				}
				return createBuffer(that, size)
			}

			/**
			 * Creates a new filled Buffer instance.
			 * alloc(size[, fill[, encoding]])
			 **/
			Buffer.alloc = function (size, fill, encoding) {
				return alloc(null, size, fill, encoding)
			}

			function allocUnsafe(that, size) {
				assertSize(size)
				that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
				if (!Buffer.TYPED_ARRAY_SUPPORT) {
					for (var i = 0; i < size; ++i) {
						that[i] = 0
					}
				}
				return that
			}

			/**
			 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
			 * */
			Buffer.allocUnsafe = function (size) {
				return allocUnsafe(null, size)
			}
			/**
			 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
			 */
			Buffer.allocUnsafeSlow = function (size) {
				return allocUnsafe(null, size)
			}

			function fromString(that, string, encoding) {
				if (typeof encoding !== 'string' || encoding === '') {
					encoding = 'utf8'
				}

				if (!Buffer.isEncoding(encoding)) {
					throw new TypeError('"encoding" must be a valid string encoding')
				}

				var length = byteLength(string, encoding) | 0
				that = createBuffer(that, length)

				var actual = that.write(string, encoding)

				if (actual !== length) {
					// Writing a hex string, for example, that contains invalid characters will
					// cause everything after the first invalid character to be ignored. (e.g.
					// 'abxxcd' will be treated as 'ab')
					that = that.slice(0, actual)
				}

				return that
			}

			function fromArrayLike(that, array) {
				var length = array.length < 0 ? 0 : checked(array.length) | 0
				that = createBuffer(that, length)
				for (var i = 0; i < length; i += 1) {
					that[i] = array[i] & 255
				}
				return that
			}

			function fromArrayBuffer(that, array, byteOffset, length) {
				array.byteLength // this throws if `array` is not a valid ArrayBuffer

				if (byteOffset < 0 || array.byteLength < byteOffset) {
					throw new RangeError('\'offset\' is out of bounds')
				}

				if (array.byteLength < byteOffset + (length || 0)) {
					throw new RangeError('\'length\' is out of bounds')
				}

				if (byteOffset === undefined && length === undefined) {
					array = new Uint8Array(array)
				} else if (length === undefined) {
					array = new Uint8Array(array, byteOffset)
				} else {
					array = new Uint8Array(array, byteOffset, length)
				}

				if (Buffer.TYPED_ARRAY_SUPPORT) {
					// Return an augmented `Uint8Array` instance, for best performance
					that = array
					that.__proto__ = Buffer.prototype
				} else {
					// Fallback: Return an object instance of the Buffer class
					that = fromArrayLike(that, array)
				}
				return that
			}

			function fromObject(that, obj) {
				if (Buffer.isBuffer(obj)) {
					var len = checked(obj.length) | 0
					that = createBuffer(that, len)

					if (that.length === 0) {
						return that
					}

					obj.copy(that, 0, 0, len)
					return that
				}

				if (obj) {
					if ((typeof ArrayBuffer !== 'undefined' &&
							obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
						if (typeof obj.length !== 'number' || isnan(obj.length)) {
							return createBuffer(that, 0)
						}
						return fromArrayLike(that, obj)
					}

					if (obj.type === 'Buffer' && isArray(obj.data)) {
						return fromArrayLike(that, obj.data)
					}
				}

				throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
			}

			function checked(length) {
				// Note: cannot use `length < kMaxLength()` here because that fails when
				// length is NaN (which is otherwise coerced to zero.)
				if (length >= kMaxLength()) {
					throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
						'size: 0x' + kMaxLength().toString(16) + ' bytes')
				}
				return length | 0
			}

			function SlowBuffer(length) {
				if (+length != length) { // eslint-disable-line eqeqeq
					length = 0
				}
				return Buffer.alloc(+length)
			}

			Buffer.isBuffer = function isBuffer(b) {
				return !!(b != null && b._isBuffer)
			}

			Buffer.compare = function compare(a, b) {
				if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
					throw new TypeError('Arguments must be Buffers')
				}

				if (a === b) return 0

				var x = a.length
				var y = b.length

				for (var i = 0, len = Math.min(x, y); i < len; ++i) {
					if (a[i] !== b[i]) {
						x = a[i]
						y = b[i]
						break
					}
				}

				if (x < y) return -1
				if (y < x) return 1
				return 0
			}

			Buffer.isEncoding = function isEncoding(encoding) {
				switch (String(encoding).toLowerCase()) {
					case 'hex':
					case 'utf8':
					case 'utf-8':
					case 'ascii':
					case 'latin1':
					case 'binary':
					case 'base64':
					case 'ucs2':
					case 'ucs-2':
					case 'utf16le':
					case 'utf-16le':
						return true
					default:
						return false
				}
			}

			Buffer.concat = function concat(list, length) {
				if (!isArray(list)) {
					throw new TypeError('"list" argument must be an Array of Buffers')
				}

				if (list.length === 0) {
					return Buffer.alloc(0)
				}

				var i
				if (length === undefined) {
					length = 0
					for (i = 0; i < list.length; ++i) {
						length += list[i].length
					}
				}

				var buffer = Buffer.allocUnsafe(length)
				var pos = 0
				for (i = 0; i < list.length; ++i) {
					var buf = list[i]
					if (!Buffer.isBuffer(buf)) {
						throw new TypeError('"list" argument must be an Array of Buffers')
					}
					buf.copy(buffer, pos)
					pos += buf.length
				}
				return buffer
			}

			function byteLength(string, encoding) {
				if (Buffer.isBuffer(string)) {
					return string.length
				}
				if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
					(ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
					return string.byteLength
				}
				if (typeof string !== 'string') {
					string = '' + string
				}

				var len = string.length
				if (len === 0) return 0

				// Use a for loop to avoid recursion
				var loweredCase = false
				for (;;) {
					switch (encoding) {
						case 'ascii':
						case 'latin1':
						case 'binary':
							return len
						case 'utf8':
						case 'utf-8':
						case undefined:
							return utf8ToBytes(string).length
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return len * 2
						case 'hex':
							return len >>> 1
						case 'base64':
							return base64ToBytes(string).length
						default:
							if (loweredCase) return utf8ToBytes(string).length // assume utf8
							encoding = ('' + encoding).toLowerCase()
							loweredCase = true
					}
				}
			}
			Buffer.byteLength = byteLength

			function slowToString(encoding, start, end) {
				var loweredCase = false

				// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
				// property of a typed array.

				// This behaves neither like String nor Uint8Array in that we set start/end
				// to their upper/lower bounds if the value passed is out of range.
				// undefined is handled specially as per ECMA-262 6th Edition,
				// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
				if (start === undefined || start < 0) {
					start = 0
				}
				// Return early if start > this.length. Done here to prevent potential uint32
				// coercion fail below.
				if (start > this.length) {
					return ''
				}

				if (end === undefined || end > this.length) {
					end = this.length
				}

				if (end <= 0) {
					return ''
				}

				// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
				end >>>= 0
				start >>>= 0

				if (end <= start) {
					return ''
				}

				if (!encoding) encoding = 'utf8'

				while (true) {
					switch (encoding) {
						case 'hex':
							return hexSlice(this, start, end)

						case 'utf8':
						case 'utf-8':
							return utf8Slice(this, start, end)

						case 'ascii':
							return asciiSlice(this, start, end)

						case 'latin1':
						case 'binary':
							return latin1Slice(this, start, end)

						case 'base64':
							return base64Slice(this, start, end)

						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return utf16leSlice(this, start, end)

						default:
							if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
							encoding = (encoding + '').toLowerCase()
							loweredCase = true
					}
				}
			}

			// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
			// Buffer instances.
			Buffer.prototype._isBuffer = true

			function swap(b, n, m) {
				var i = b[n]
				b[n] = b[m]
				b[m] = i
			}

			Buffer.prototype.swap16 = function swap16() {
				var len = this.length
				if (len % 2 !== 0) {
					throw new RangeError('Buffer size must be a multiple of 16-bits')
				}
				for (var i = 0; i < len; i += 2) {
					swap(this, i, i + 1)
				}
				return this
			}

			Buffer.prototype.swap32 = function swap32() {
				var len = this.length
				if (len % 4 !== 0) {
					throw new RangeError('Buffer size must be a multiple of 32-bits')
				}
				for (var i = 0; i < len; i += 4) {
					swap(this, i, i + 3)
					swap(this, i + 1, i + 2)
				}
				return this
			}

			Buffer.prototype.swap64 = function swap64() {
				var len = this.length
				if (len % 8 !== 0) {
					throw new RangeError('Buffer size must be a multiple of 64-bits')
				}
				for (var i = 0; i < len; i += 8) {
					swap(this, i, i + 7)
					swap(this, i + 1, i + 6)
					swap(this, i + 2, i + 5)
					swap(this, i + 3, i + 4)
				}
				return this
			}

			Buffer.prototype.toString = function toString() {
				var length = this.length | 0
				if (length === 0) return ''
				if (arguments.length === 0) return utf8Slice(this, 0, length)
				return slowToString.apply(this, arguments)
			}

			Buffer.prototype.equals = function equals(b) {
				if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
				if (this === b) return true
				return Buffer.compare(this, b) === 0
			}

			Buffer.prototype.inspect = function inspect() {
				var str = ''
				var max = exports.INSPECT_MAX_BYTES
				if (this.length > 0) {
					str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
					if (this.length > max) str += ' ... '
				}
				return '<Buffer ' + str + '>'
			}

			Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
				if (!Buffer.isBuffer(target)) {
					throw new TypeError('Argument must be a Buffer')
				}

				if (start === undefined) {
					start = 0
				}
				if (end === undefined) {
					end = target ? target.length : 0
				}
				if (thisStart === undefined) {
					thisStart = 0
				}
				if (thisEnd === undefined) {
					thisEnd = this.length
				}

				if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
					throw new RangeError('out of range index')
				}

				if (thisStart >= thisEnd && start >= end) {
					return 0
				}
				if (thisStart >= thisEnd) {
					return -1
				}
				if (start >= end) {
					return 1
				}

				start >>>= 0
				end >>>= 0
				thisStart >>>= 0
				thisEnd >>>= 0

				if (this === target) return 0

				var x = thisEnd - thisStart
				var y = end - start
				var len = Math.min(x, y)

				var thisCopy = this.slice(thisStart, thisEnd)
				var targetCopy = target.slice(start, end)

				for (var i = 0; i < len; ++i) {
					if (thisCopy[i] !== targetCopy[i]) {
						x = thisCopy[i]
						y = targetCopy[i]
						break
					}
				}

				if (x < y) return -1
				if (y < x) return 1
				return 0
			}

			// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
			// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
			//
			// Arguments:
			// - buffer - a Buffer to search
			// - val - a string, Buffer, or number
			// - byteOffset - an index into `buffer`; will be clamped to an int32
			// - encoding - an optional encoding, relevant is val is a string
			// - dir - true for indexOf, false for lastIndexOf
			function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
				// Empty buffer means no match
				if (buffer.length === 0) return -1

				// Normalize byteOffset
				if (typeof byteOffset === 'string') {
					encoding = byteOffset
					byteOffset = 0
				} else if (byteOffset > 0x7fffffff) {
					byteOffset = 0x7fffffff
				} else if (byteOffset < -0x80000000) {
					byteOffset = -0x80000000
				}
				byteOffset = +byteOffset // Coerce to Number.
				if (isNaN(byteOffset)) {
					// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
					byteOffset = dir ? 0 : (buffer.length - 1)
				}

				// Normalize byteOffset: negative offsets start from the end of the buffer
				if (byteOffset < 0) byteOffset = buffer.length + byteOffset
				if (byteOffset >= buffer.length) {
					if (dir) return -1
					else byteOffset = buffer.length - 1
				} else if (byteOffset < 0) {
					if (dir) byteOffset = 0
					else return -1
				}

				// Normalize val
				if (typeof val === 'string') {
					val = Buffer.from(val, encoding)
				}

				// Finally, search either indexOf (if dir is true) or lastIndexOf
				if (Buffer.isBuffer(val)) {
					// Special case: looking for empty string/buffer always fails
					if (val.length === 0) {
						return -1
					}
					return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
				} else if (typeof val === 'number') {
					val = val & 0xFF // Search for a byte value [0-255]
					if (Buffer.TYPED_ARRAY_SUPPORT &&
						typeof Uint8Array.prototype.indexOf === 'function') {
						if (dir) {
							return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
						} else {
							return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
						}
					}
					return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
				}

				throw new TypeError('val must be string, number or Buffer')
			}

			function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
				var indexSize = 1
				var arrLength = arr.length
				var valLength = val.length

				if (encoding !== undefined) {
					encoding = String(encoding).toLowerCase()
					if (encoding === 'ucs2' || encoding === 'ucs-2' ||
						encoding === 'utf16le' || encoding === 'utf-16le') {
						if (arr.length < 2 || val.length < 2) {
							return -1
						}
						indexSize = 2
						arrLength /= 2
						valLength /= 2
						byteOffset /= 2
					}
				}

				function read(buf, i) {
					if (indexSize === 1) {
						return buf[i]
					} else {
						return buf.readUInt16BE(i * indexSize)
					}
				}

				var i
				if (dir) {
					var foundIndex = -1
					for (i = byteOffset; i < arrLength; i++) {
						if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
							if (foundIndex === -1) foundIndex = i
							if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
						} else {
							if (foundIndex !== -1) i -= i - foundIndex
							foundIndex = -1
						}
					}
				} else {
					if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
					for (i = byteOffset; i >= 0; i--) {
						var found = true
						for (var j = 0; j < valLength; j++) {
							if (read(arr, i + j) !== read(val, j)) {
								found = false
								break
							}
						}
						if (found) return i
					}
				}

				return -1
			}

			Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
				return this.indexOf(val, byteOffset, encoding) !== -1
			}

			Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
				return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
			}

			Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
				return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
			}

			function hexWrite(buf, string, offset, length) {
				offset = Number(offset) || 0
				var remaining = buf.length - offset
				if (!length) {
					length = remaining
				} else {
					length = Number(length)
					if (length > remaining) {
						length = remaining
					}
				}

				// must be an even number of digits
				var strLen = string.length
				if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

				if (length > strLen / 2) {
					length = strLen / 2
				}
				for (var i = 0; i < length; ++i) {
					var parsed = parseInt(string.substr(i * 2, 2), 16)
					if (isNaN(parsed)) return i
					buf[offset + i] = parsed
				}
				return i
			}

			function utf8Write(buf, string, offset, length) {
				return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
			}

			function asciiWrite(buf, string, offset, length) {
				return blitBuffer(asciiToBytes(string), buf, offset, length)
			}

			function latin1Write(buf, string, offset, length) {
				return asciiWrite(buf, string, offset, length)
			}

			function base64Write(buf, string, offset, length) {
				return blitBuffer(base64ToBytes(string), buf, offset, length)
			}

			function ucs2Write(buf, string, offset, length) {
				return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
			}

			Buffer.prototype.write = function write(string, offset, length, encoding) {
				// Buffer#write(string)
				if (offset === undefined) {
					encoding = 'utf8'
					length = this.length
					offset = 0
					// Buffer#write(string, encoding)
				} else if (length === undefined && typeof offset === 'string') {
					encoding = offset
					length = this.length
					offset = 0
					// Buffer#write(string, offset[, length][, encoding])
				} else if (isFinite(offset)) {
					offset = offset | 0
					if (isFinite(length)) {
						length = length | 0
						if (encoding === undefined) encoding = 'utf8'
					} else {
						encoding = length
						length = undefined
					}
					// legacy write(string, encoding, offset, length) - remove in v0.13
				} else {
					throw new Error(
						'Buffer.write(string, encoding, offset[, length]) is no longer supported'
					)
				}

				var remaining = this.length - offset
				if (length === undefined || length > remaining) length = remaining

				if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
					throw new RangeError('Attempt to write outside buffer bounds')
				}

				if (!encoding) encoding = 'utf8'

				var loweredCase = false
				for (;;) {
					switch (encoding) {
						case 'hex':
							return hexWrite(this, string, offset, length)

						case 'utf8':
						case 'utf-8':
							return utf8Write(this, string, offset, length)

						case 'ascii':
							return asciiWrite(this, string, offset, length)

						case 'latin1':
						case 'binary':
							return latin1Write(this, string, offset, length)

						case 'base64':
							// Warning: maxLength not taken into account in base64Write
							return base64Write(this, string, offset, length)

						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return ucs2Write(this, string, offset, length)

						default:
							if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
							encoding = ('' + encoding).toLowerCase()
							loweredCase = true
					}
				}
			}

			Buffer.prototype.toJSON = function toJSON() {
				return {
					type: 'Buffer',
					data: Array.prototype.slice.call(this._arr || this, 0)
				}
			}

			function base64Slice(buf, start, end) {
				if (start === 0 && end === buf.length) {
					return base64.fromByteArray(buf)
				} else {
					return base64.fromByteArray(buf.slice(start, end))
				}
			}

			function utf8Slice(buf, start, end) {
				end = Math.min(buf.length, end)
				var res = []

				var i = start
				while (i < end) {
					var firstByte = buf[i]
					var codePoint = null
					var bytesPerSequence = (firstByte > 0xEF) ? 4 :
						(firstByte > 0xDF) ? 3 :
						(firstByte > 0xBF) ? 2 :
						1

					if (i + bytesPerSequence <= end) {
						var secondByte, thirdByte, fourthByte, tempCodePoint

						switch (bytesPerSequence) {
							case 1:
								if (firstByte < 0x80) {
									codePoint = firstByte
								}
								break
							case 2:
								secondByte = buf[i + 1]
								if ((secondByte & 0xC0) === 0x80) {
									tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
									if (tempCodePoint > 0x7F) {
										codePoint = tempCodePoint
									}
								}
								break
							case 3:
								secondByte = buf[i + 1]
								thirdByte = buf[i + 2]
								if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
									tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
									if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
										codePoint = tempCodePoint
									}
								}
								break
							case 4:
								secondByte = buf[i + 1]
								thirdByte = buf[i + 2]
								fourthByte = buf[i + 3]
								if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
									tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
									if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
										codePoint = tempCodePoint
									}
								}
						}
					}

					if (codePoint === null) {
						// we did not generate a valid codePoint so insert a
						// replacement char (U+FFFD) and advance only 1 byte
						codePoint = 0xFFFD
						bytesPerSequence = 1
					} else if (codePoint > 0xFFFF) {
						// encode to utf16 (surrogate pair dance)
						codePoint -= 0x10000
						res.push(codePoint >>> 10 & 0x3FF | 0xD800)
						codePoint = 0xDC00 | codePoint & 0x3FF
					}

					res.push(codePoint)
					i += bytesPerSequence
				}

				return decodeCodePointsArray(res)
			}

			// Based on http://stackoverflow.com/a/22747272/680742, the browser with
			// the lowest limit is Chrome, with 0x10000 args.
			// We go 1 magnitude less, for safety
			var MAX_ARGUMENTS_LENGTH = 0x1000

			function decodeCodePointsArray(codePoints) {
				var len = codePoints.length
				if (len <= MAX_ARGUMENTS_LENGTH) {
					return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
				}

				// Decode in chunks to avoid "call stack size exceeded".
				var res = ''
				var i = 0
				while (i < len) {
					res += String.fromCharCode.apply(
						String,
						codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
					)
				}
				return res
			}

			function asciiSlice(buf, start, end) {
				var ret = ''
				end = Math.min(buf.length, end)

				for (var i = start; i < end; ++i) {
					ret += String.fromCharCode(buf[i] & 0x7F)
				}
				return ret
			}

			function latin1Slice(buf, start, end) {
				var ret = ''
				end = Math.min(buf.length, end)

				for (var i = start; i < end; ++i) {
					ret += String.fromCharCode(buf[i])
				}
				return ret
			}

			function hexSlice(buf, start, end) {
				var len = buf.length

				if (!start || start < 0) start = 0
				if (!end || end < 0 || end > len) end = len

				var out = ''
				for (var i = start; i < end; ++i) {
					out += toHex(buf[i])
				}
				return out
			}

			function utf16leSlice(buf, start, end) {
				var bytes = buf.slice(start, end)
				var res = ''
				for (var i = 0; i < bytes.length; i += 2) {
					res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
				}
				return res
			}

			Buffer.prototype.slice = function slice(start, end) {
				var len = this.length
				start = ~~start
				end = end === undefined ? len : ~~end

				if (start < 0) {
					start += len
					if (start < 0) start = 0
				} else if (start > len) {
					start = len
				}

				if (end < 0) {
					end += len
					if (end < 0) end = 0
				} else if (end > len) {
					end = len
				}

				if (end < start) end = start

				var newBuf
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					newBuf = this.subarray(start, end)
					newBuf.__proto__ = Buffer.prototype
				} else {
					var sliceLen = end - start
					newBuf = new Buffer(sliceLen, undefined)
					for (var i = 0; i < sliceLen; ++i) {
						newBuf[i] = this[i + start]
					}
				}

				return newBuf
			}

			/*
			 * Need to make sure that buffer isn't trying to write out of bounds.
			 */
			function checkOffset(offset, ext, length) {
				if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
				if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
			}

			Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
				offset = offset | 0
				byteLength = byteLength | 0
				if (!noAssert) checkOffset(offset, byteLength, this.length)

				var val = this[offset]
				var mul = 1
				var i = 0
				while (++i < byteLength && (mul *= 0x100)) {
					val += this[offset + i] * mul
				}

				return val
			}

			Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
				offset = offset | 0
				byteLength = byteLength | 0
				if (!noAssert) {
					checkOffset(offset, byteLength, this.length)
				}

				var val = this[offset + --byteLength]
				var mul = 1
				while (byteLength > 0 && (mul *= 0x100)) {
					val += this[offset + --byteLength] * mul
				}

				return val
			}

			Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 1, this.length)
				return this[offset]
			}

			Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length)
				return this[offset] | (this[offset + 1] << 8)
			}

			Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length)
				return (this[offset] << 8) | this[offset + 1]
			}

			Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length)

				return ((this[offset]) |
						(this[offset + 1] << 8) |
						(this[offset + 2] << 16)) +
					(this[offset + 3] * 0x1000000)
			}

			Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length)

				return (this[offset] * 0x1000000) +
					((this[offset + 1] << 16) |
						(this[offset + 2] << 8) |
						this[offset + 3])
			}

			Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
				offset = offset | 0
				byteLength = byteLength | 0
				if (!noAssert) checkOffset(offset, byteLength, this.length)

				var val = this[offset]
				var mul = 1
				var i = 0
				while (++i < byteLength && (mul *= 0x100)) {
					val += this[offset + i] * mul
				}
				mul *= 0x80

				if (val >= mul) val -= Math.pow(2, 8 * byteLength)

				return val
			}

			Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
				offset = offset | 0
				byteLength = byteLength | 0
				if (!noAssert) checkOffset(offset, byteLength, this.length)

				var i = byteLength
				var mul = 1
				var val = this[offset + --i]
				while (i > 0 && (mul *= 0x100)) {
					val += this[offset + --i] * mul
				}
				mul *= 0x80

				if (val >= mul) val -= Math.pow(2, 8 * byteLength)

				return val
			}

			Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 1, this.length)
				if (!(this[offset] & 0x80)) return (this[offset])
				return ((0xff - this[offset] + 1) * -1)
			}

			Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length)
				var val = this[offset] | (this[offset + 1] << 8)
				return (val & 0x8000) ? val | 0xFFFF0000 : val
			}

			Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length)
				var val = this[offset + 1] | (this[offset] << 8)
				return (val & 0x8000) ? val | 0xFFFF0000 : val
			}

			Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length)

				return (this[offset]) |
					(this[offset + 1] << 8) |
					(this[offset + 2] << 16) |
					(this[offset + 3] << 24)
			}

			Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length)

				return (this[offset] << 24) |
					(this[offset + 1] << 16) |
					(this[offset + 2] << 8) |
					(this[offset + 3])
			}

			Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length)
				return ieee754.read(this, offset, true, 23, 4)
			}

			Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length)
				return ieee754.read(this, offset, false, 23, 4)
			}

			Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 8, this.length)
				return ieee754.read(this, offset, true, 52, 8)
			}

			Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 8, this.length)
				return ieee754.read(this, offset, false, 52, 8)
			}

			function checkInt(buf, value, offset, ext, max, min) {
				if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
				if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
				if (offset + ext > buf.length) throw new RangeError('Index out of range')
			}

			Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
				value = +value
				offset = offset | 0
				byteLength = byteLength | 0
				if (!noAssert) {
					var maxBytes = Math.pow(2, 8 * byteLength) - 1
					checkInt(this, value, offset, byteLength, maxBytes, 0)
				}

				var mul = 1
				var i = 0
				this[offset] = value & 0xFF
				while (++i < byteLength && (mul *= 0x100)) {
					this[offset + i] = (value / mul) & 0xFF
				}

				return offset + byteLength
			}

			Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
				value = +value
				offset = offset | 0
				byteLength = byteLength | 0
				if (!noAssert) {
					var maxBytes = Math.pow(2, 8 * byteLength) - 1
					checkInt(this, value, offset, byteLength, maxBytes, 0)
				}

				var i = byteLength - 1
				var mul = 1
				this[offset + i] = value & 0xFF
				while (--i >= 0 && (mul *= 0x100)) {
					this[offset + i] = (value / mul) & 0xFF
				}

				return offset + byteLength
			}

			Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
				if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
				this[offset] = (value & 0xff)
				return offset + 1
			}

			function objectWriteUInt16(buf, value, offset, littleEndian) {
				if (value < 0) value = 0xffff + value + 1
				for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
					buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
						(littleEndian ? i : 1 - i) * 8
				}
			}

			Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value & 0xff)
					this[offset + 1] = (value >>> 8)
				} else {
					objectWriteUInt16(this, value, offset, true)
				}
				return offset + 2
			}

			Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value >>> 8)
					this[offset + 1] = (value & 0xff)
				} else {
					objectWriteUInt16(this, value, offset, false)
				}
				return offset + 2
			}

			function objectWriteUInt32(buf, value, offset, littleEndian) {
				if (value < 0) value = 0xffffffff + value + 1
				for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
					buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
				}
			}

			Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset + 3] = (value >>> 24)
					this[offset + 2] = (value >>> 16)
					this[offset + 1] = (value >>> 8)
					this[offset] = (value & 0xff)
				} else {
					objectWriteUInt32(this, value, offset, true)
				}
				return offset + 4
			}

			Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value >>> 24)
					this[offset + 1] = (value >>> 16)
					this[offset + 2] = (value >>> 8)
					this[offset + 3] = (value & 0xff)
				} else {
					objectWriteUInt32(this, value, offset, false)
				}
				return offset + 4
			}

			Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) {
					var limit = Math.pow(2, 8 * byteLength - 1)

					checkInt(this, value, offset, byteLength, limit - 1, -limit)
				}

				var i = 0
				var mul = 1
				var sub = 0
				this[offset] = value & 0xFF
				while (++i < byteLength && (mul *= 0x100)) {
					if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
						sub = 1
					}
					this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
				}

				return offset + byteLength
			}

			Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) {
					var limit = Math.pow(2, 8 * byteLength - 1)

					checkInt(this, value, offset, byteLength, limit - 1, -limit)
				}

				var i = byteLength - 1
				var mul = 1
				var sub = 0
				this[offset + i] = value & 0xFF
				while (--i >= 0 && (mul *= 0x100)) {
					if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
						sub = 1
					}
					this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
				}

				return offset + byteLength
			}

			Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
				if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
				if (value < 0) value = 0xff + value + 1
				this[offset] = (value & 0xff)
				return offset + 1
			}

			Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value & 0xff)
					this[offset + 1] = (value >>> 8)
				} else {
					objectWriteUInt16(this, value, offset, true)
				}
				return offset + 2
			}

			Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value >>> 8)
					this[offset + 1] = (value & 0xff)
				} else {
					objectWriteUInt16(this, value, offset, false)
				}
				return offset + 2
			}

			Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value & 0xff)
					this[offset + 1] = (value >>> 8)
					this[offset + 2] = (value >>> 16)
					this[offset + 3] = (value >>> 24)
				} else {
					objectWriteUInt32(this, value, offset, true)
				}
				return offset + 4
			}

			Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
				value = +value
				offset = offset | 0
				if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
				if (value < 0) value = 0xffffffff + value + 1
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = (value >>> 24)
					this[offset + 1] = (value >>> 16)
					this[offset + 2] = (value >>> 8)
					this[offset + 3] = (value & 0xff)
				} else {
					objectWriteUInt32(this, value, offset, false)
				}
				return offset + 4
			}

			function checkIEEE754(buf, value, offset, ext, max, min) {
				if (offset + ext > buf.length) throw new RangeError('Index out of range')
				if (offset < 0) throw new RangeError('Index out of range')
			}

			function writeFloat(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
				}
				ieee754.write(buf, value, offset, littleEndian, 23, 4)
				return offset + 4
			}

			Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
				return writeFloat(this, value, offset, true, noAssert)
			}

			Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
				return writeFloat(this, value, offset, false, noAssert)
			}

			function writeDouble(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
				}
				ieee754.write(buf, value, offset, littleEndian, 52, 8)
				return offset + 8
			}

			Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
				return writeDouble(this, value, offset, true, noAssert)
			}

			Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
				return writeDouble(this, value, offset, false, noAssert)
			}

			// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
			Buffer.prototype.copy = function copy(target, targetStart, start, end) {
				if (!start) start = 0
				if (!end && end !== 0) end = this.length
				if (targetStart >= target.length) targetStart = target.length
				if (!targetStart) targetStart = 0
				if (end > 0 && end < start) end = start

				// Copy 0 bytes; we're done
				if (end === start) return 0
				if (target.length === 0 || this.length === 0) return 0

				// Fatal error conditions
				if (targetStart < 0) {
					throw new RangeError('targetStart out of bounds')
				}
				if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
				if (end < 0) throw new RangeError('sourceEnd out of bounds')

				// Are we oob?
				if (end > this.length) end = this.length
				if (target.length - targetStart < end - start) {
					end = target.length - targetStart + start
				}

				var len = end - start
				var i

				if (this === target && start < targetStart && targetStart < end) {
					// descending copy from end
					for (i = len - 1; i >= 0; --i) {
						target[i + targetStart] = this[i + start]
					}
				} else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
					// ascending copy from start
					for (i = 0; i < len; ++i) {
						target[i + targetStart] = this[i + start]
					}
				} else {
					Uint8Array.prototype.set.call(
						target,
						this.subarray(start, start + len),
						targetStart
					)
				}

				return len
			}

			// Usage:
			//    buffer.fill(number[, offset[, end]])
			//    buffer.fill(buffer[, offset[, end]])
			//    buffer.fill(string[, offset[, end]][, encoding])
			Buffer.prototype.fill = function fill(val, start, end, encoding) {
				// Handle string cases:
				if (typeof val === 'string') {
					if (typeof start === 'string') {
						encoding = start
						start = 0
						end = this.length
					} else if (typeof end === 'string') {
						encoding = end
						end = this.length
					}
					if (val.length === 1) {
						var code = val.charCodeAt(0)
						if (code < 256) {
							val = code
						}
					}
					if (encoding !== undefined && typeof encoding !== 'string') {
						throw new TypeError('encoding must be a string')
					}
					if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
						throw new TypeError('Unknown encoding: ' + encoding)
					}
				} else if (typeof val === 'number') {
					val = val & 255
				}

				// Invalid ranges are not set to a default, so can range check early.
				if (start < 0 || this.length < start || this.length < end) {
					throw new RangeError('Out of range index')
				}

				if (end <= start) {
					return this
				}

				start = start >>> 0
				end = end === undefined ? this.length : end >>> 0

				if (!val) val = 0

				var i
				if (typeof val === 'number') {
					for (i = start; i < end; ++i) {
						this[i] = val
					}
				} else {
					var bytes = Buffer.isBuffer(val) ?
						val :
						utf8ToBytes(new Buffer(val, encoding).toString())
					var len = bytes.length
					for (i = 0; i < end - start; ++i) {
						this[i + start] = bytes[i % len]
					}
				}

				return this
			}

			// HELPER FUNCTIONS
			// ================

			var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

			function base64clean(str) {
				// Node strips out invalid characters like \n and \t from the string, base64-js does not
				str = stringtrim(str).replace(INVALID_BASE64_RE, '')
				// Node converts strings with length < 2 to ''
				if (str.length < 2) return ''
				// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
				while (str.length % 4 !== 0) {
					str = str + '='
				}
				return str
			}

			function stringtrim(str) {
				if (str.trim) return str.trim()
				return str.replace(/^\s+|\s+$/g, '')
			}

			function toHex(n) {
				if (n < 16) return '0' + n.toString(16)
				return n.toString(16)
			}

			function utf8ToBytes(string, units) {
				units = units || Infinity
				var codePoint
				var length = string.length
				var leadSurrogate = null
				var bytes = []

				for (var i = 0; i < length; ++i) {
					codePoint = string.charCodeAt(i)

					// is surrogate component
					if (codePoint > 0xD7FF && codePoint < 0xE000) {
						// last char was a lead
						if (!leadSurrogate) {
							// no lead yet
							if (codePoint > 0xDBFF) {
								// unexpected trail
								if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
								continue
							} else if (i + 1 === length) {
								// unpaired lead
								if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
								continue
							}

							// valid lead
							leadSurrogate = codePoint

							continue
						}

						// 2 leads in a row
						if (codePoint < 0xDC00) {
							if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
							leadSurrogate = codePoint
							continue
						}

						// valid surrogate pair
						codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
					} else if (leadSurrogate) {
						// valid bmp char, but last char was a lead
						if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
					}

					leadSurrogate = null

					// encode utf8
					if (codePoint < 0x80) {
						if ((units -= 1) < 0) break
						bytes.push(codePoint)
					} else if (codePoint < 0x800) {
						if ((units -= 2) < 0) break
						bytes.push(
							codePoint >> 0x6 | 0xC0,
							codePoint & 0x3F | 0x80
						)
					} else if (codePoint < 0x10000) {
						if ((units -= 3) < 0) break
						bytes.push(
							codePoint >> 0xC | 0xE0,
							codePoint >> 0x6 & 0x3F | 0x80,
							codePoint & 0x3F | 0x80
						)
					} else if (codePoint < 0x110000) {
						if ((units -= 4) < 0) break
						bytes.push(
							codePoint >> 0x12 | 0xF0,
							codePoint >> 0xC & 0x3F | 0x80,
							codePoint >> 0x6 & 0x3F | 0x80,
							codePoint & 0x3F | 0x80
						)
					} else {
						throw new Error('Invalid code point')
					}
				}

				return bytes
			}

			function asciiToBytes(str) {
				var byteArray = []
				for (var i = 0; i < str.length; ++i) {
					// Node's code seems to be doing this and not & 0x7F..
					byteArray.push(str.charCodeAt(i) & 0xFF)
				}
				return byteArray
			}

			function utf16leToBytes(str, units) {
				var c, hi, lo
				var byteArray = []
				for (var i = 0; i < str.length; ++i) {
					if ((units -= 2) < 0) break

					c = str.charCodeAt(i)
					hi = c >> 8
					lo = c % 256
					byteArray.push(lo)
					byteArray.push(hi)
				}

				return byteArray
			}

			function base64ToBytes(str) {
				return base64.toByteArray(base64clean(str))
			}

			function blitBuffer(src, dst, offset, length) {
				for (var i = 0; i < length; ++i) {
					if ((i + offset >= dst.length) || (i >= src.length)) break
					dst[i + offset] = src[i]
				}
				return i
			}

			function isnan(val) {
				return val !== val // eslint-disable-line no-self-compare
			}

			/* WEBPACK VAR INJECTION */
		}.call(exports, (function () {
			return this;
		}())))

		/***/
	}),
	/* 3 */
	/***/
	(function (module, exports) {

		'use strict'

		exports.byteLength = byteLength
		exports.toByteArray = toByteArray
		exports.fromByteArray = fromByteArray

		var lookup = []
		var revLookup = []
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

		var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
		for (var i = 0, len = code.length; i < len; ++i) {
			lookup[i] = code[i]
			revLookup[code.charCodeAt(i)] = i
		}

		// Support decoding URL-safe base64 strings, as Node.js does.
		// See: https://en.wikipedia.org/wiki/Base64#URL_applications
		revLookup['-'.charCodeAt(0)] = 62
		revLookup['_'.charCodeAt(0)] = 63

		function getLens(b64) {
			var len = b64.length

			if (len % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// Trim off extra bytes after placeholder bytes are found
			// See: https://github.com/beatgammit/base64-js/issues/42
			var validLen = b64.indexOf('=')
			if (validLen === -1) validLen = len

			var placeHoldersLen = validLen === len ?
				0 :
				4 - (validLen % 4)

			return [validLen, placeHoldersLen]
		}

		// base64 is 4/3 + up to two characters of the original data
		function byteLength(b64) {
			var lens = getLens(b64)
			var validLen = lens[0]
			var placeHoldersLen = lens[1]
			return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
		}

		function _byteLength(b64, validLen, placeHoldersLen) {
			return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
		}

		function toByteArray(b64) {
			var tmp
			var lens = getLens(b64)
			var validLen = lens[0]
			var placeHoldersLen = lens[1]

			var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

			var curByte = 0

			// if there are placeholders, only get up to the last complete 4 chars
			var len = placeHoldersLen > 0 ?
				validLen - 4 :
				validLen

			var i
			for (i = 0; i < len; i += 4) {
				tmp =
					(revLookup[b64.charCodeAt(i)] << 18) |
					(revLookup[b64.charCodeAt(i + 1)] << 12) |
					(revLookup[b64.charCodeAt(i + 2)] << 6) |
					revLookup[b64.charCodeAt(i + 3)]
				arr[curByte++] = (tmp >> 16) & 0xFF
				arr[curByte++] = (tmp >> 8) & 0xFF
				arr[curByte++] = tmp & 0xFF
			}

			if (placeHoldersLen === 2) {
				tmp =
					(revLookup[b64.charCodeAt(i)] << 2) |
					(revLookup[b64.charCodeAt(i + 1)] >> 4)
				arr[curByte++] = tmp & 0xFF
			}

			if (placeHoldersLen === 1) {
				tmp =
					(revLookup[b64.charCodeAt(i)] << 10) |
					(revLookup[b64.charCodeAt(i + 1)] << 4) |
					(revLookup[b64.charCodeAt(i + 2)] >> 2)
				arr[curByte++] = (tmp >> 8) & 0xFF
				arr[curByte++] = tmp & 0xFF
			}

			return arr
		}

		function tripletToBase64(num) {
			return lookup[num >> 18 & 0x3F] +
				lookup[num >> 12 & 0x3F] +
				lookup[num >> 6 & 0x3F] +
				lookup[num & 0x3F]
		}

		function encodeChunk(uint8, start, end) {
			var tmp
			var output = []
			for (var i = start; i < end; i += 3) {
				tmp =
					((uint8[i] << 16) & 0xFF0000) +
					((uint8[i + 1] << 8) & 0xFF00) +
					(uint8[i + 2] & 0xFF)
				output.push(tripletToBase64(tmp))
			}
			return output.join('')
		}

		function fromByteArray(uint8) {
			var tmp
			var len = uint8.length
			var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
			var parts = []
			var maxChunkLength = 16383 // must be multiple of 3

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
				parts.push(encodeChunk(
					uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
				))
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			if (extraBytes === 1) {
				tmp = uint8[len - 1]
				parts.push(
					lookup[tmp >> 2] +
					lookup[(tmp << 4) & 0x3F] +
					'=='
				)
			} else if (extraBytes === 2) {
				tmp = (uint8[len - 2] << 8) + uint8[len - 1]
				parts.push(
					lookup[tmp >> 10] +
					lookup[(tmp >> 4) & 0x3F] +
					lookup[(tmp << 2) & 0x3F] +
					'='
				)
			}

			return parts.join('')
		}


		/***/
	}),
	/* 4 */
	/***/
	(function (module, exports) {

		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
			var e, m
			var eLen = (nBytes * 8) - mLen - 1
			var eMax = (1 << eLen) - 1
			var eBias = eMax >> 1
			var nBits = -7
			var i = isLE ? (nBytes - 1) : 0
			var d = isLE ? -1 : 1
			var s = buffer[offset + i]

			i += d

			e = s & ((1 << (-nBits)) - 1)
			s >>= (-nBits)
			nBits += eLen
			for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

			m = e & ((1 << (-nBits)) - 1)
			e >>= (-nBits)
			nBits += mLen
			for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

			if (e === 0) {
				e = 1 - eBias
			} else if (e === eMax) {
				return m ? NaN : ((s ? -1 : 1) * Infinity)
			} else {
				m = m + Math.pow(2, mLen)
				e = e - eBias
			}
			return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		}

		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
			var e, m, c
			var eLen = (nBytes * 8) - mLen - 1
			var eMax = (1 << eLen) - 1
			var eBias = eMax >> 1
			var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
			var i = isLE ? 0 : (nBytes - 1)
			var d = isLE ? 1 : -1
			var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

			value = Math.abs(value)

			if (isNaN(value) || value === Infinity) {
				m = isNaN(value) ? 1 : 0
				e = eMax
			} else {
				e = Math.floor(Math.log(value) / Math.LN2)
				if (value * (c = Math.pow(2, -e)) < 1) {
					e--
					c *= 2
				}
				if (e + eBias >= 1) {
					value += rt / c
				} else {
					value += rt * Math.pow(2, 1 - eBias)
				}
				if (value * c >= 2) {
					e++
					c /= 2
				}

				if (e + eBias >= eMax) {
					m = 0
					e = eMax
				} else if (e + eBias >= 1) {
					m = ((value * c) - 1) * Math.pow(2, mLen)
					e = e + eBias
				} else {
					m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
					e = 0
				}
			}

			for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

			e = (e << mLen) | m
			eLen += mLen
			for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

			buffer[offset + i - d] |= s * 128
		}


		/***/
	}),
	/* 5 */
	/***/
	(function (module, exports) {

		var toString = {}.toString;

		module.exports = Array.isArray || function (arr) {
			return toString.call(arr) == '[object Array]';
		};


		/***/
	}),
	/* 6 */
	/***/
	(function (module, exports, __webpack_require__) {

		"use strict";
		var window = __webpack_require__(7)
		var isFunction = __webpack_require__(8)
		var parseHeaders = __webpack_require__(9)
		var xtend = __webpack_require__(10)

		module.exports = createXHR
		// Allow use of default import syntax in TypeScript
		module.exports.default = createXHR;
		createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
		createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

		forEachArray(["get", "put", "post", "patch", "head", "delete"], function (method) {
			createXHR[method === "delete" ? "del" : method] = function (uri, options, callback) {
				options = initParams(uri, options, callback)
				options.method = method.toUpperCase()
				return _createXHR(options)
			}
		})

		function forEachArray(array, iterator) {
			for (var i = 0; i < array.length; i++) {
				iterator(array[i])
			}
		}

		function isEmpty(obj) {
			for (var i in obj) {
				if (obj.hasOwnProperty(i)) return false
			}
			return true
		}

		function initParams(uri, options, callback) {
			var params = uri

			if (isFunction(options)) {
				callback = options
				if (typeof uri === "string") {
					params = {
						uri: uri
					}
				}
			} else {
				params = xtend(options, {
					uri: uri
				})
			}

			params.callback = callback
			return params
		}

		function createXHR(uri, options, callback) {
			options = initParams(uri, options, callback)
			return _createXHR(options)
		}

		function _createXHR(options) {
			if (typeof options.callback === "undefined") {
				throw new Error("callback argument missing")
			}

			var called = false
			var callback = function cbOnce(err, response, body) {
				if (!called) {
					called = true
					options.callback(err, response, body)
				}
			}

			function readystatechange() {
				if (xhr.readyState === 4) {
					setTimeout(loadFunc, 0)
				}
			}

			function getBody() {
				// Chrome with requestType=blob throws errors arround when even testing access to responseText
				var body = undefined

				if (xhr.response) {
					body = xhr.response
				} else {
					body = xhr.responseText || getXml(xhr)
				}

				if (isJson) {
					try {
						body = JSON.parse(body)
					} catch (e) {}
				}

				return body
			}

			function errorFunc(evt) {
				clearTimeout(timeoutTimer)
				if (!(evt instanceof Error)) {
					evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"))
				}
				evt.statusCode = 0
				return callback(evt, failureResponse)
			}

			// will load the data & process the response in a special response object
			function loadFunc() {
				if (aborted) return
				var status
				clearTimeout(timeoutTimer)
				if (options.useXDR && xhr.status === undefined) {
					//IE8 CORS GET successful response doesn't have a status field, but body is fine
					status = 200
				} else {
					status = (xhr.status === 1223 ? 204 : xhr.status)
				}
				var response = failureResponse
				var err = null

				if (status !== 0) {
					response = {
						body: getBody(),
						statusCode: status,
						method: method,
						headers: {},
						url: uri,
						rawRequest: xhr
					}
					if (xhr.getAllResponseHeaders) { //remember xhr can in fact be XDR for CORS in IE
						response.headers = parseHeaders(xhr.getAllResponseHeaders())
					}
				} else {
					err = new Error("Internal XMLHttpRequest Error")
				}
				return callback(err, response, response.body)
			}

			var xhr = options.xhr || null

			if (!xhr) {
				if (options.cors || options.useXDR) {
					xhr = new createXHR.XDomainRequest()
				} else {
					xhr = new createXHR.XMLHttpRequest()
				}
			}

			var key
			var aborted
			var uri = xhr.url = options.uri || options.url
			var method = xhr.method = options.method || "GET"
			var body = options.body || options.data
			var headers = xhr.headers = options.headers || {}
			var sync = !!options.sync
			var isJson = false
			var timeoutTimer
			var failureResponse = {
				body: undefined,
				headers: {},
				statusCode: 0,
				method: method,
				url: uri,
				rawRequest: xhr
			}

			if ("json" in options && options.json !== false) {
				isJson = true
				headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
				if (method !== "GET" && method !== "HEAD") {
					headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
					body = JSON.stringify(options.json === true ? body : options.json)
				}
			}

			xhr.onreadystatechange = readystatechange
			xhr.onload = loadFunc
			xhr.onerror = errorFunc
			// IE9 must have onprogress be set to a unique function.
			xhr.onprogress = function () {
				// IE must die
			}
			xhr.onabort = function () {
				aborted = true;
			}
			xhr.ontimeout = errorFunc
			xhr.open(method, uri, !sync, options.username, options.password)
			//has to be after open
			if (!sync) {
				xhr.withCredentials = !!options.withCredentials
			}
			// Cannot set timeout with sync request
			// not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
			// both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
			if (!sync && options.timeout > 0) {
				timeoutTimer = setTimeout(function () {
					if (aborted) return
					aborted = true //IE9 may still call readystatechange
					xhr.abort("timeout")
					var e = new Error("XMLHttpRequest timeout")
					e.code = "ETIMEDOUT"
					errorFunc(e)
				}, options.timeout)
			}

			if (xhr.setRequestHeader) {
				for (key in headers) {
					if (headers.hasOwnProperty(key)) {
						xhr.setRequestHeader(key, headers[key])
					}
				}
			} else if (options.headers && !isEmpty(options.headers)) {
				throw new Error("Headers cannot be set on an XDomainRequest object")
			}

			if ("responseType" in options) {
				xhr.responseType = options.responseType
			}

			if ("beforeSend" in options &&
				typeof options.beforeSend === "function"
			) {
				options.beforeSend(xhr)
			}

			// Microsoft Edge browser sends "undefined" when send is called with undefined value.
			// XMLHttpRequest spec says to pass null as body to indicate no body
			// See https://github.com/naugtur/xhr/issues/100.
			xhr.send(body || null)

			return xhr


		}

		function getXml(xhr) {
			// xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
			// See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
			try {
				if (xhr.responseType === "document") {
					return xhr.responseXML
				}
				var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
				if (xhr.responseType === "" && !firefoxBugTakenEffect) {
					return xhr.responseXML
				}
			} catch (e) {}

			return null
		}

		function noop() {}


		/***/
	}),
	/* 7 */
	/***/
	(function (module, exports) {

		/* WEBPACK VAR INJECTION */
		(function (global) {
			var win;

			if (typeof window !== "undefined") {
				win = window;
			} else if (typeof global !== "undefined") {
				win = global;
			} else if (typeof self !== "undefined") {
				win = self;
			} else {
				win = {};
			}

			module.exports = win;

			/* WEBPACK VAR INJECTION */
		}.call(exports, (function () {
			return this;
		}())))

		/***/
	}),
	/* 8 */
	/***/
	(function (module, exports) {

		module.exports = isFunction

		var toString = Object.prototype.toString

		function isFunction(fn) {
			var string = toString.call(fn)
			return string === '[object Function]' ||
				(typeof fn === 'function' && string !== '[object RegExp]') ||
				(typeof window !== 'undefined' &&
					// IE8 and below
					(fn === window.setTimeout ||
						fn === window.alert ||
						fn === window.confirm ||
						fn === window.prompt))
		};


		/***/
	}),
	/* 9 */
	/***/
	(function (module, exports) {

		var trim = function (string) {
				return string.replace(/^\s+|\s+$/g, '');
			},
			isArray = function (arg) {
				return Object.prototype.toString.call(arg) === '[object Array]';
			}

		module.exports = function (headers) {
			if (!headers)
				return {}

			var result = {}

			var headersArr = trim(headers).split('\n')

			for (var i = 0; i < headersArr.length; i++) {
				var row = headersArr[i]
				var index = row.indexOf(':'),
					key = trim(row.slice(0, index)).toLowerCase(),
					value = trim(row.slice(index + 1))

				if (typeof (result[key]) === 'undefined') {
					result[key] = value
				} else if (isArray(result[key])) {
					result[key].push(value)
				} else {
					result[key] = [result[key], value]
				}
			}

			return result
		}


		/***/
	}),
	/* 10 */
	/***/
	(function (module, exports) {

		module.exports = extend

		var hasOwnProperty = Object.prototype.hasOwnProperty;

		function extend() {
			var target = {}

			for (var i = 0; i < arguments.length; i++) {
				var source = arguments[i]

				for (var key in source) {
					if (hasOwnProperty.call(source, key)) {
						target[key] = source[key]
					}
				}
			}

			return target
		}


		/***/
	}),
	/* 11 */
	/***/
	(function (module, exports) {

		module.exports = function parseBMFontAscii(data) {
			if (!data)
				throw new Error('no data provided')
			data = data.toString().trim()

			var output = {
				pages: [],
				chars: [],
				kernings: []
			}

			var lines = data.split(/\r\n?|\n/g)

			if (lines.length === 0)
				throw new Error('no data in BMFont file')

			for (var i = 0; i < lines.length; i++) {
				var lineData = splitLine(lines[i], i)
				if (!lineData) //skip empty lines
					continue

				if (lineData.key === 'page') {
					if (typeof lineData.data.id !== 'number')
						throw new Error('malformed file at line ' + i + ' -- needs page id=N')
					if (typeof lineData.data.file !== 'string')
						throw new Error('malformed file at line ' + i + ' -- needs page file="path"')
					output.pages[lineData.data.id] = lineData.data.file
				} else if (lineData.key === 'chars' || lineData.key === 'kernings') {
					//... do nothing for these two ...
				} else if (lineData.key === 'char') {
					output.chars.push(lineData.data)
				} else if (lineData.key === 'kerning') {
					output.kernings.push(lineData.data)
				} else {
					output[lineData.key] = lineData.data
				}
			}

			return output
		}

		function splitLine(line, idx) {
			line = line.replace(/\t+/g, ' ').trim()
			if (!line)
				return null

			var space = line.indexOf(' ')
			if (space === -1)
				throw new Error("no named row at line " + idx)

			var key = line.substring(0, space)

			line = line.substring(space + 1)
			//clear "letter" field as it is non-standard and
			//requires additional complexity to parse " / = symbols
			line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, '')
			line = line.split("=")
			line = line.map(function (str) {
				return str.trim().match((/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g))
			})

			var data = []
			for (var i = 0; i < line.length; i++) {
				var dt = line[i]
				if (i === 0) {
					data.push({
						key: dt[0],
						data: ""
					})
				} else if (i === line.length - 1) {
					data[data.length - 1].data = parseData(dt[0])
				} else {
					data[data.length - 1].data = parseData(dt[0])
					data.push({
						key: dt[1],
						data: ""
					})
				}
			}

			var out = {
				key: key,
				data: {}
			}

			data.forEach(function (v) {
				out.data[v.key] = v.data;
			})

			return out
		}

		function parseData(data) {
			if (!data || data.length === 0)
				return ""

			if (data.indexOf('"') === 0 || data.indexOf("'") === 0)
				return data.substring(1, data.length - 1)
			if (data.indexOf(',') !== -1)
				return parseIntList(data)
			return parseInt(data, 10)
		}

		function parseIntList(data) {
			return data.split(',').map(function (val) {
				return parseInt(val, 10)
			})
		}

		/***/
	}),
	/* 12 */
	/***/
	(function (module, exports, __webpack_require__) {

		var parseAttributes = __webpack_require__(13)
		var parseFromString = __webpack_require__(14)

		//In some cases element.attribute.nodeName can return
		//all lowercase values.. so we need to map them to the correct 
		//case
		var NAME_MAP = {
			scaleh: 'scaleH',
			scalew: 'scaleW',
			stretchh: 'stretchH',
			lineheight: 'lineHeight',
			alphachnl: 'alphaChnl',
			redchnl: 'redChnl',
			greenchnl: 'greenChnl',
			bluechnl: 'blueChnl'
		}

		module.exports = function parse(data) {
			data = data.toString()

			var xmlRoot = parseFromString(data)
			var output = {
				pages: [],
				chars: [],
				kernings: []
			}

			//get config settings
			;
			['info', 'common'].forEach(function (key) {
				var element = xmlRoot.getElementsByTagName(key)[0]
				if (element)
					output[key] = parseAttributes(getAttribs(element))
			})

			//get page info
			var pageRoot = xmlRoot.getElementsByTagName('pages')[0]
			if (!pageRoot)
				throw new Error('malformed file -- no <pages> element')
			var pages = pageRoot.getElementsByTagName('page')
			for (var i = 0; i < pages.length; i++) {
				var p = pages[i]
				var id = parseInt(p.getAttribute('id'), 10)
				var file = p.getAttribute('file')
				if (isNaN(id))
					throw new Error('malformed file -- page "id" attribute is NaN')
				if (!file)
					throw new Error('malformed file -- needs page "file" attribute')
				output.pages[parseInt(id, 10)] = file
			}

			//get kernings / chars
			;
			['chars', 'kernings'].forEach(function (key) {
				var element = xmlRoot.getElementsByTagName(key)[0]
				if (!element)
					return
				var childTag = key.substring(0, key.length - 1)
				var children = element.getElementsByTagName(childTag)
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					output[key].push(parseAttributes(getAttribs(child)))
				}
			})
			return output
		}

		function getAttribs(element) {
			var attribs = getAttribList(element)
			return attribs.reduce(function (dict, attrib) {
				var key = mapName(attrib.nodeName)
				dict[key] = attrib.nodeValue
				return dict
			}, {})
		}

		function getAttribList(element) {
			//IE8+ and modern browsers
			var attribs = []
			for (var i = 0; i < element.attributes.length; i++)
				attribs.push(element.attributes[i])
			return attribs
		}

		function mapName(nodeName) {
			return NAME_MAP[nodeName.toLowerCase()] || nodeName
		}

		/***/
	}),
	/* 13 */
	/***/
	(function (module, exports) {

		//Some versions of GlyphDesigner have a typo
		//that causes some bugs with parsing. 
		//Need to confirm with recent version of the software
		//to see whether this is still an issue or not.
		var GLYPH_DESIGNER_ERROR = 'chasrset'

		module.exports = function parseAttributes(obj) {
			if (GLYPH_DESIGNER_ERROR in obj) {
				obj['charset'] = obj[GLYPH_DESIGNER_ERROR]
				delete obj[GLYPH_DESIGNER_ERROR]
			}

			for (var k in obj) {
				if (k === 'face' || k === 'charset')
					continue
				else if (k === 'padding' || k === 'spacing')
					obj[k] = parseIntList(obj[k])
				else
					obj[k] = parseInt(obj[k], 10)
			}
			return obj
		}

		function parseIntList(data) {
			return data.split(',').map(function (val) {
				return parseInt(val, 10)
			})
		}

		/***/
	}),
	/* 14 */
	/***/
	(function (module, exports) {

		module.exports = (function xmlparser() {
			//common browsers
			if (typeof self.DOMParser !== 'undefined') {
				return function (str) {
					var parser = new self.DOMParser()
					return parser.parseFromString(str, 'application/xml')
				}
			}

			//IE8 fallback
			if (typeof self.ActiveXObject !== 'undefined' &&
				new self.ActiveXObject('Microsoft.XMLDOM')) {
				return function (str) {
					var xmlDoc = new self.ActiveXObject("Microsoft.XMLDOM")
					xmlDoc.async = "false"
					xmlDoc.loadXML(str)
					return xmlDoc
				}
			}

			//last resort fallback
			return function (str) {
				var div = document.createElement('div')
				div.innerHTML = str
				return div
			}
		})()


		/***/
	}),
	/* 15 */
	/***/
	(function (module, exports) {

		var HEADER = [66, 77, 70]

		module.exports = function readBMFontBinary(buf) {
			if (buf.length < 6)
				throw new Error('invalid buffer length for BMFont')

			var header = HEADER.every(function (byte, i) {
				return buf.readUInt8(i) === byte
			})

			if (!header)
				throw new Error('BMFont missing BMF byte header')

			var i = 3
			var vers = buf.readUInt8(i++)
			if (vers > 3)
				throw new Error('Only supports BMFont Binary v3 (BMFont App v1.10)')

			var target = {
				kernings: [],
				chars: []
			}
			for (var b = 0; b < 5; b++)
				i += readBlock(target, buf, i)
			return target
		}

		function readBlock(target, buf, i) {
			if (i > buf.length - 1)
				return 0

			var blockID = buf.readUInt8(i++)
			var blockSize = buf.readInt32LE(i)
			i += 4

			switch (blockID) {
				case 1:
					target.info = readInfo(buf, i)
					break
				case 2:
					target.common = readCommon(buf, i)
					break
				case 3:
					target.pages = readPages(buf, i, blockSize)
					break
				case 4:
					target.chars = readChars(buf, i, blockSize)
					break
				case 5:
					target.kernings = readKernings(buf, i, blockSize)
					break
			}
			return 5 + blockSize
		}

		function readInfo(buf, i) {
			var info = {}
			info.size = buf.readInt16LE(i)

			var bitField = buf.readUInt8(i + 2)
			info.smooth = (bitField >> 7) & 1
			info.unicode = (bitField >> 6) & 1
			info.italic = (bitField >> 5) & 1
			info.bold = (bitField >> 4) & 1

			//fixedHeight is only mentioned in binary spec 
			if ((bitField >> 3) & 1)
				info.fixedHeight = 1

			info.charset = buf.readUInt8(i + 3) || ''
			info.stretchH = buf.readUInt16LE(i + 4)
			info.aa = buf.readUInt8(i + 6)
			info.padding = [
				buf.readInt8(i + 7),
				buf.readInt8(i + 8),
				buf.readInt8(i + 9),
				buf.readInt8(i + 10)
			]
			info.spacing = [
				buf.readInt8(i + 11),
				buf.readInt8(i + 12)
			]
			info.outline = buf.readUInt8(i + 13)
			info.face = readStringNT(buf, i + 14)
			return info
		}

		function readCommon(buf, i) {
			var common = {}
			common.lineHeight = buf.readUInt16LE(i)
			common.base = buf.readUInt16LE(i + 2)
			common.scaleW = buf.readUInt16LE(i + 4)
			common.scaleH = buf.readUInt16LE(i + 6)
			common.pages = buf.readUInt16LE(i + 8)
			var bitField = buf.readUInt8(i + 10)
			common.packed = 0
			common.alphaChnl = buf.readUInt8(i + 11)
			common.redChnl = buf.readUInt8(i + 12)
			common.greenChnl = buf.readUInt8(i + 13)
			common.blueChnl = buf.readUInt8(i + 14)
			return common
		}

		function readPages(buf, i, size) {
			var pages = []
			var text = readNameNT(buf, i)
			var len = text.length + 1
			var count = size / len
			for (var c = 0; c < count; c++) {
				pages[c] = buf.slice(i, i + text.length).toString('utf8')
				i += len
			}
			return pages
		}

		function readChars(buf, i, blockSize) {
			var chars = []

			var count = blockSize / 20
			for (var c = 0; c < count; c++) {
				var char = {}
				var off = c * 20
				char.id = buf.readUInt32LE(i + 0 + off)
				char.x = buf.readUInt16LE(i + 4 + off)
				char.y = buf.readUInt16LE(i + 6 + off)
				char.width = buf.readUInt16LE(i + 8 + off)
				char.height = buf.readUInt16LE(i + 10 + off)
				char.xoffset = buf.readInt16LE(i + 12 + off)
				char.yoffset = buf.readInt16LE(i + 14 + off)
				char.xadvance = buf.readInt16LE(i + 16 + off)
				char.page = buf.readUInt8(i + 18 + off)
				char.chnl = buf.readUInt8(i + 19 + off)
				chars[c] = char
			}
			return chars
		}

		function readKernings(buf, i, blockSize) {
			var kernings = []
			var count = blockSize / 10
			for (var c = 0; c < count; c++) {
				var kern = {}
				var off = c * 10
				kern.first = buf.readUInt32LE(i + 0 + off)
				kern.second = buf.readUInt32LE(i + 4 + off)
				kern.amount = buf.readInt16LE(i + 8 + off)
				kernings[c] = kern
			}
			return kernings
		}

		function readNameNT(buf, offset) {
			var pos = offset
			for (; pos < buf.length; pos++) {
				if (buf[pos] === 0x00)
					break
			}
			return buf.slice(offset, pos)
		}

		function readStringNT(buf, offset) {
			return readNameNT(buf, offset).toString('utf8')
		}

		/***/
	}),
	/* 16 */
	/***/
	(function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (Buffer) {
			var equal = __webpack_require__(17)
			var HEADER = new Buffer([66, 77, 70, 3])

			module.exports = function (buf) {
				if (typeof buf === 'string')
					return buf.substring(0, 3) === 'BMF'
				return buf.length > 4 && equal(buf.slice(0, 4), HEADER)
			}
			/* WEBPACK VAR INJECTION */
		}.call(exports, __webpack_require__(2).Buffer))

		/***/
	}),
	/* 17 */
	/***/
	(function (module, exports, __webpack_require__) {

		var Buffer = __webpack_require__(2).Buffer; // for use with browserify

		module.exports = function (a, b) {
			if (!Buffer.isBuffer(a)) return undefined;
			if (!Buffer.isBuffer(b)) return undefined;
			if (typeof a.equals === 'function') return a.equals(b);
			if (a.length !== b.length) return false;

			for (var i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) return false;
			}

			return true;
		};


		/***/
	}),
	/* 18 */
	/***/
	(function (module, exports) {

		module.exports = function arraybufferEqual(buf1, buf2) {
			if (buf1 === buf2) {
				return true;
			}

			if (buf1.byteLength !== buf2.byteLength) {
				return false;
			}

			var view1 = new DataView(buf1);
			var view2 = new DataView(buf2);

			var i = buf1.byteLength;
			while (i--) {
				if (view1.getUint8(i) !== view2.getUint8(i)) {
					return false;
				}
			}

			return true;
		};


		/***/
	}),
	/* 19 */
	/***/
	(function (module, exports, __webpack_require__) {

		var wordWrap = __webpack_require__(20)
		var xtend = __webpack_require__(10)
		var number = __webpack_require__(21)

		var X_HEIGHTS = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z']
		var M_WIDTHS = ['m', 'w']
		var CAP_HEIGHTS = ['H', 'I', 'N', 'E', 'F', 'K', 'L', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']


		var TAB_ID = '\t'.charCodeAt(0)
		var SPACE_ID = ' '.charCodeAt(0)
		var ALIGN_LEFT = 0,
			ALIGN_CENTER = 1,
			ALIGN_RIGHT = 2

		module.exports = function createLayout(opt) {
			return new TextLayout(opt)
		}

		function TextLayout(opt) {
			this.glyphs = []
			this._measure = this.computeMetrics.bind(this)
			this.update(opt)
		}

		TextLayout.prototype.update = function (opt) {
			opt = xtend({
				measure: this._measure
			}, opt)
			this._opt = opt
			this._opt.tabSize = number(this._opt.tabSize, 4)

			if (!opt.font)
				throw new Error('must provide a valid bitmap font')

			var glyphs = this.glyphs
			var text = opt.text || ''
			var font = opt.font
			this._setupSpaceGlyphs(font)

			var lines = wordWrap.lines(text, opt)
			var minWidth = opt.width || 0

			//clear glyphs
			glyphs.length = 0

			//get max line width
			var maxLineWidth = lines.reduce(function (prev, line) {
				return Math.max(prev, line.width, minWidth)
			}, 0)

			//the pen position
			var x = 0
			var y = 0
			var lineHeight = number(opt.lineHeight, font.common.lineHeight)
			var baseline = font.common.base
			var descender = lineHeight - baseline
			var letterSpacing = opt.letterSpacing || 0
			var height = lineHeight * lines.length - descender
			var align = getAlignType(this._opt.align)

			//draw text along baseline
			y -= height

			//the metrics for this text layout
			this._width = maxLineWidth
			this._height = height
			this._descender = lineHeight - baseline
			this._baseline = baseline
			this._xHeight = getXHeight(font)
			this._capHeight = getCapHeight(font)
			this._lineHeight = lineHeight
			this._ascender = lineHeight - descender - this._xHeight

			//layout each glyph
			var self = this
			lines.forEach(function (line, lineIndex) {
				var start = line.start
				var end = line.end
				var lineWidth = line.width
				var lastGlyph

				//for each glyph in that line...
				for (var i = start; i < end; i++) {
					var id = text.charCodeAt(i)
					var glyph = self.getGlyph(font, id)
					if (glyph) {
						if (lastGlyph)
							x += getKerning(font, lastGlyph.id, glyph.id)

						var tx = x
						if (align === ALIGN_CENTER)
							tx += (maxLineWidth - lineWidth) / 2
						else if (align === ALIGN_RIGHT)
							tx += (maxLineWidth - lineWidth)

						glyphs.push({
							position: [tx, y],
							data: glyph,
							index: i,
							line: lineIndex
						})

						//move pen forward
						x += glyph.xadvance + letterSpacing
						lastGlyph = glyph
					}
				}

				//next line down
				y += lineHeight
				x = 0
			})
			this._linesTotal = lines.length;
		}

		TextLayout.prototype._setupSpaceGlyphs = function (font) {
			//These are fallbacks, when the font doesn't include
			//' ' or '\t' glyphs
			this._fallbackSpaceGlyph = null
			this._fallbackTabGlyph = null

			if (!font.chars || font.chars.length === 0)
				return

			//try to get space glyph
			//then fall back to the 'm' or 'w' glyphs
			//then fall back to the first glyph available
			var space = getGlyphById(font, SPACE_ID) ||
				getMGlyph(font) ||
				font.chars[0]

			//and create a fallback for tab
			var tabWidth = this._opt.tabSize * space.xadvance
			this._fallbackSpaceGlyph = space
			this._fallbackTabGlyph = xtend(space, {
				x: 0,
				y: 0,
				xadvance: tabWidth,
				id: TAB_ID,
				xoffset: 0,
				yoffset: 0,
				width: 0,
				height: 0
			})
		}

		TextLayout.prototype.getGlyph = function (font, id) {
			var glyph = getGlyphById(font, id)
			if (glyph)
				return glyph
			else if (id === TAB_ID)
				return this._fallbackTabGlyph
			else if (id === SPACE_ID)
				return this._fallbackSpaceGlyph
			return null
		}

		TextLayout.prototype.computeMetrics = function (text, start, end, width) {
			var letterSpacing = this._opt.letterSpacing || 0
			var font = this._opt.font
			var curPen = 0
			var curWidth = 0
			var count = 0
			var glyph
			var lastGlyph

			if (!font.chars || font.chars.length === 0) {
				return {
					start: start,
					end: start,
					width: 0
				}
			}

			end = Math.min(text.length, end)
			for (var i = start; i < end; i++) {
				var id = text.charCodeAt(i)
				var glyph = this.getGlyph(font, id)

				if (glyph) {
					//move pen forward
					var xoff = glyph.xoffset
					var kern = lastGlyph ? getKerning(font, lastGlyph.id, glyph.id) : 0
					curPen += kern

					var nextPen = curPen + glyph.xadvance + letterSpacing
					var nextWidth = curPen + glyph.width

					//we've hit our limit; we can't move onto the next glyph
					if (nextWidth >= width || nextPen >= width)
						break

					//otherwise continue along our line
					curPen = nextPen
					curWidth = nextWidth
					lastGlyph = glyph
				}
				count++
			}

			//make sure rightmost edge lines up with rendered glyphs
			if (lastGlyph)
				curWidth += lastGlyph.xoffset

			return {
				start: start,
				end: start + count,
				width: curWidth
			}
		}

		//getters for the private vars
		;
		['width', 'height',
			'descender', 'ascender',
			'xHeight', 'baseline',
			'capHeight',
			'lineHeight'
		].forEach(addGetter)

		function addGetter(name) {
			Object.defineProperty(TextLayout.prototype, name, {
				get: wrapper(name),
				configurable: true
			})
		}

		//create lookups for private vars
		function wrapper(name) {
			return (new Function([
				'return function ' + name + '() {',
				'  return this._' + name,
				'}'
			].join('\n')))()
		}

		function getGlyphById(font, id) {
			if (!font.chars || font.chars.length === 0)
				return null

			var glyphIdx = findChar(font.chars, id)
			if (glyphIdx >= 0)
				return font.chars[glyphIdx]
			return null
		}

		function getXHeight(font) {
			for (var i = 0; i < X_HEIGHTS.length; i++) {
				var id = X_HEIGHTS[i].charCodeAt(0)
				var idx = findChar(font.chars, id)
				if (idx >= 0)
					return font.chars[idx].height
			}
			return 0
		}

		function getMGlyph(font) {
			for (var i = 0; i < M_WIDTHS.length; i++) {
				var id = M_WIDTHS[i].charCodeAt(0)
				var idx = findChar(font.chars, id)
				if (idx >= 0)
					return font.chars[idx]
			}
			return 0
		}

		function getCapHeight(font) {
			for (var i = 0; i < CAP_HEIGHTS.length; i++) {
				var id = CAP_HEIGHTS[i].charCodeAt(0)
				var idx = findChar(font.chars, id)
				if (idx >= 0)
					return font.chars[idx].height
			}
			return 0
		}

		function getKerning(font, left, right) {
			if (!font.kernings || font.kernings.length === 0)
				return 0

			var table = font.kernings
			for (var i = 0; i < table.length; i++) {
				var kern = table[i]
				if (kern.first === left && kern.second === right)
					return kern.amount
			}
			return 0
		}

		function getAlignType(align) {
			if (align === 'center')
				return ALIGN_CENTER
			else if (align === 'right')
				return ALIGN_RIGHT
			return ALIGN_LEFT
		}

		function findChar(array, value, start) {
			start = start || 0
			for (var i = start; i < array.length; i++) {
				if (array[i].id === value) {
					return i
				}
			}
			return -1
		}

		/***/
	}),
	/* 20 */
	/***/
	(function (module, exports) {

		var newline = /\n/
		var newlineChar = '\n'
		var whitespace = /\s/

		module.exports = function (text, opt) {
			var lines = module.exports.lines(text, opt)
			return lines.map(function (line) {
				return text.substring(line.start, line.end)
			}).join('\n')
		}

		module.exports.lines = function wordwrap(text, opt) {
			opt = opt || {}

			//zero width results in nothing visible
			if (opt.width === 0 && opt.mode !== 'nowrap')
				return []

			text = text || ''
			var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE
			var start = Math.max(0, opt.start || 0)
			var end = typeof opt.end === 'number' ? opt.end : text.length
			var mode = opt.mode

			var measure = opt.measure || monospace
			if (mode === 'pre')
				return pre(measure, text, start, end, width)
			else
				return greedy(measure, text, start, end, width, mode)
		}

		function idxOf(text, chr, start, end) {
			var idx = text.indexOf(chr, start)
			if (idx === -1 || idx > end)
				return end
			return idx
		}

		function isWhitespace(chr) {
			return whitespace.test(chr)
		}

		function pre(measure, text, start, end, width) {
			var lines = []
			var lineStart = start
			for (var i = start; i < end && i < text.length; i++) {
				var chr = text.charAt(i)
				var isNewline = newline.test(chr)

				//If we've reached a newline, then step down a line
				//Or if we've reached the EOF
				if (isNewline || i === end - 1) {
					var lineEnd = isNewline ? i : i + 1
					var measured = measure(text, lineStart, lineEnd, width)
					lines.push(measured)

					lineStart = i + 1
				}
			}
			return lines
		}

		function greedy(measure, text, start, end, width, mode) {
			//A greedy word wrapper based on LibGDX algorithm
			//https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
			var lines = []

			var testWidth = width
			//if 'nowrap' is specified, we only wrap on newline chars
			if (mode === 'nowrap')
				testWidth = Number.MAX_VALUE

			while (start < end && start < text.length) {
				//get next newline position
				var newLine = idxOf(text, newlineChar, start, end)

				//eat whitespace at start of line
				while (start < newLine) {
					if (!isWhitespace(text.charAt(start)))
						break
					start++
				}

				//determine visible # of glyphs for the available width
				var measured = measure(text, start, newLine, testWidth)

				var lineEnd = start + (measured.end - measured.start)
				var nextStart = lineEnd + newlineChar.length

				//if we had to cut the line before the next newline...
				if (lineEnd < newLine) {
					//find char to break on
					while (lineEnd > start) {
						if (isWhitespace(text.charAt(lineEnd)))
							break
						lineEnd--
					}
					if (lineEnd === start) {
						if (nextStart > start + newlineChar.length) nextStart--
						lineEnd = nextStart // If no characters to break, show all.
					} else {
						nextStart = lineEnd
						//eat whitespace at end of line
						while (lineEnd > start) {
							if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))
								break
							lineEnd--
						}
					}
				}
				if (lineEnd >= start) {
					var result = measure(text, start, lineEnd, testWidth)
					lines.push(result)
				}
				start = nextStart
			}
			return lines
		}

		//determines the visible number of glyphs within a given width
		function monospace(text, start, end, width) {
			var glyphs = Math.min(width, end - start)
			return {
				start: start,
				end: start + glyphs
			}
		}

		/***/
	}),
	/* 21 */
	/***/
	(function (module, exports) {

		module.exports = function numtype(num, def) {
			return typeof num === 'number' ?
				num :
				(typeof def === 'number' ? def : 0)
		}

		/***/
	}),
	/* 22 */
	/***/
	(function (module, exports, __webpack_require__) {

		var dtype = __webpack_require__(23)
		var anArray = __webpack_require__(24)
		var isBuffer = __webpack_require__(25)

		var CW = [0, 2, 3]
		var CCW = [2, 1, 3]

		module.exports = function createQuadElements(array, opt) {
			//if user didn't specify an output array
			if (!array || !(anArray(array) || isBuffer(array))) {
				opt = array || {}
				array = null
			}

			if (typeof opt === 'number') //backwards-compatible
				opt = {
					count: opt
				}
			else
				opt = opt || {}

			var type = typeof opt.type === 'string' ? opt.type : 'uint16'
			var count = typeof opt.count === 'number' ? opt.count : 1
			var start = (opt.start || 0)

			var dir = opt.clockwise !== false ? CW : CCW,
				a = dir[0],
				b = dir[1],
				c = dir[2]

			var numIndices = count * 6

			var indices = array || new(dtype(type))(numIndices)
			for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
				var x = i + start
				indices[x + 0] = j + 0
				indices[x + 1] = j + 1
				indices[x + 2] = j + 2
				indices[x + 3] = j + a
				indices[x + 4] = j + b
				indices[x + 5] = j + c
			}
			return indices
		}

		/***/
	}),
	/* 23 */
	/***/
	(function (module, exports) {

		module.exports = function (dtype) {
			switch (dtype) {
				case 'int8':
					return Int8Array
				case 'int16':
					return Int16Array
				case 'int32':
					return Int32Array
				case 'uint8':
					return Uint8Array
				case 'uint16':
					return Uint16Array
				case 'uint32':
					return Uint32Array
				case 'float32':
					return Float32Array
				case 'float64':
					return Float64Array
				case 'array':
					return Array
				case 'uint8_clamped':
					return Uint8ClampedArray
			}
		}


		/***/
	}),
	/* 24 */
	/***/
	(function (module, exports) {

		var str = Object.prototype.toString

		module.exports = anArray

		function anArray(arr) {
			return (
				arr.BYTES_PER_ELEMENT &&
				str.call(arr.buffer) === '[object ArrayBuffer]' ||
				Array.isArray(arr)
			)
		}


		/***/
	}),
	/* 25 */
	/***/
	(function (module, exports) {

		/*!
		 * Determine if an object is a Buffer
		 *
		 * @author   Feross Aboukhadijeh <https://feross.org>
		 * @license  MIT
		 */

		// The _isBuffer check is for Safari 5-7 support, because it's missing
		// Object.prototype.constructor. Remove this eventually
		module.exports = function (obj) {
			return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
		}

		function isBuffer(obj) {
			return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
		}

		// For Node v0.10 support. Remove this eventually.
		function isSlowBuffer(obj) {
			return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
		}


		/***/
	}),
	/* 26 */
	/***/
	(function (module, exports) {

		"use strict";

		module.exports.pages = function pages(glyphs) {
			var pages = new Float32Array(glyphs.length * 4 * 1);
			var i = 0;
			glyphs.forEach(function (glyph) {
				var id = glyph.data.page || 0;
				pages[i++] = id;
				pages[i++] = id;
				pages[i++] = id;
				pages[i++] = id;
			});
			return pages;
		};

		module.exports.uvs = function uvs(glyphs, texWidth, texHeight, flipY) {
			var uvs = new Float32Array(glyphs.length * 4 * 2);
			var i = 0;
			glyphs.forEach(function (glyph) {
				var bitmap = glyph.data;
				var bw = bitmap.x + bitmap.width;
				var bh = bitmap.y + bitmap.height;

				// top left position
				var u0 = bitmap.x / texWidth;
				var v1 = bitmap.y / texHeight;
				var u1 = bw / texWidth;
				var v0 = bh / texHeight;

				if (flipY) {
					v1 = (texHeight - bitmap.y) / texHeight;
					v0 = (texHeight - bh) / texHeight;
				}

				// BL
				uvs[i++] = u0;
				uvs[i++] = v1;
				// TL
				uvs[i++] = u0;
				uvs[i++] = v0;
				// TR
				uvs[i++] = u1;
				uvs[i++] = v0;
				// BR
				uvs[i++] = u1;
				uvs[i++] = v1;
			});
			return uvs;
		};

		module.exports.positions = function positions(glyphs) {
			var positions = new Float32Array(glyphs.length * 4 * 2);
			var i = 0;
			glyphs.forEach(function (glyph) {
				var bitmap = glyph.data;

				// bottom left position
				var x = glyph.position[0] + bitmap.xoffset;
				var y = glyph.position[1] + bitmap.yoffset;

				// quad size
				var w = bitmap.width;
				var h = bitmap.height;

				// BL
				positions[i++] = x;
				positions[i++] = y;
				// TL
				positions[i++] = x;
				positions[i++] = y + h;
				// TR
				positions[i++] = x + w;
				positions[i++] = y + h;
				// BR
				positions[i++] = x + w;
				positions[i++] = y;
			});
			return positions;
		};

		/***/
	})
	/******/
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjViYTY0MmE5MjkzNDM2N2Y2ZTgiLCJ3ZWJwYWNrOi8vLy4vdGhlb3J5dHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvYWQtYm1mb250L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnVmZmVyL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3hoci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsb2JhbC93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZW5kL2ltbXV0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlLWJtZm9udC1hc2NpaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlLWJtZm9udC14bWwvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1ibWZvbnQteG1sL2xpYi9wYXJzZS1hdHRyaWJzLmpzIiwid2VicGFjazovLy8uL34veG1sLXBhcnNlLWZyb20tc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcGFyc2UtYm1mb250LWJpbmFyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvYWQtYm1mb250L2xpYi9pcy1iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXItZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hcnJheWJ1ZmZlci1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xheW91dC1ibWZvbnQtdGV4dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3dvcmQtd3JhcHBlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzLW51bWJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1YWQtaW5kaWNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2R0eXBlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYW4tYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGxpYi92ZXJ0aWNlcy5qcyJdLCJuYW1lcyI6WyJsb2FkRm9udCIsInJlcXVpcmUiLCJpc0VxdWFsIiwiY3JlYXRlTGF5b3V0IiwiY3JlYXRlSW5kaWNlcyIsInZlcnRpY2VzIiwidmVydGV4U3JjIiwiZnJhZ21lbnRTcmMiLCJUVF9TSEFERVIiLCJQSVhJIiwiUHJvZ3JhbSIsIlRoZW9yeVR5cGUiLCJ0ZXh0Iiwic3R5bGUiLCJnZW9tZXRyeSIsIkdlb21ldHJ5IiwiYWRkSW5kZXgiLCJhZGRBdHRyaWJ1dGUiLCJTaGFkZXIiLCJUZXh0U3R5bGUiLCJfdGV4dCIsIl9hbHBoYSIsIl9yZWFsQWxwaGEiLCJfbGFzdFdvcmxkQWxwaGEiLCJfY29weURpcnR5IiwibG9hZEFzc2V0cyIsIlRUTG9hZEZvbnQiLCJmb250VVJMIiwiaW1hZ2VVUkwiLCJyZCIsIl9mb250IiwiZm9udCIsIl90ZXh0dXJlIiwidGV4dHVyZSIsInVwZGF0ZVRleHQiLCJjb3B5RGlydHkiLCJvcHQiLCJnZXRGbGF0Q29weSIsImxheW91dCIsInRleFdpZHRoIiwiY29tbW9uIiwic2NhbGVXIiwidGV4SGVpZ2h0Iiwic2NhbGVIIiwiZ2x5cGhzIiwiZmlsdGVyIiwiZ2x5cGgiLCJiaXRtYXAiLCJkYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbnMiLCJ1dnMiLCJpbmRpY2VzIiwiY2xvY2t3aXNlIiwidHlwZSIsImNvdW50IiwibGVuZ3RoIiwiZ2V0SW5kZXgiLCJ1cGRhdGUiLCJnZXRCdWZmZXIiLCJzdHlsZUlEIiwic2hhZGVyIiwidW5pZm9ybXMiLCJ1U2FtcGxlciIsInVfYWxwaGEiLCJ3b3JsZEFscGhhIiwidV9yZWFsYWxwaGEiLCJyZWFsQWxwaGEiLCJ1X2NvbG9yIiwiZmlsbCIsInVfZm9udFNpemUiLCJmb250U2l6ZSIsInVfZm9udEluZm9TaXplIiwiaW5mbyIsInNpemUiLCJ1X3dlaWdodCIsIndlaWdodCIsInJlbmRlcmVyIiwidmFsdWUiLCJNZXNoIiwiVFRGb250Q2FjaGUiLCJjYWxsYmFjayIsImVyciIsIkxvYWRlciIsInNoYXJlZCIsImFkZCIsImxvYWQiLCJsb2FkZXIiLCJyZXNvdXJjZXMiLCJMb2FkRm9udCIsImRlZmF1bHRTdHlsZSIsImFsaWduIiwiZm9udFdlaWdodCIsImxldHRlclNwYWNpbmciLCJsaW5lSGVpZ2h0Iiwid29yZFdyYXAiLCJ3b3JkV3JhcFdpZHRoIiwiT2JqZWN0IiwiYXNzaWduIiwibW9kZSIsInVuZGVmaW5lZCIsIl9hbGlnbiIsIl93ZWlnaHQiLCJfZm9udFNpemUiLCJfbGV0dGVyU3BhY2luZyIsIl93b3JkV3JhcCIsIl9maWxsIiwib3V0cHV0Q29sb3IiLCJ1dGlscyIsImhleDJyZ2IiLCJldmVyeSIsInYiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhZ2VzIiwiRmxvYXQzMkFycmF5IiwiZm9yRWFjaCIsImlkIiwicGFnZSIsImZsaXBZIiwiYnciLCJ4IiwiYmgiLCJ5IiwidTAiLCJ2MSIsInUxIiwidjAiLCJwb3NpdGlvbiIsInhvZmZzZXQiLCJ5b2Zmc2V0IiwidyIsImgiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0EsS0FBSUEsV0FBVyxtQkFBQUMsQ0FBUSxDQUFSLENBQWY7QUFDQSxLQUFJQyxVQUFVLG1CQUFBRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLEtBQUlFLGVBQWUsbUJBQUFGLENBQVEsRUFBUixDQUFuQjtBQUNBLEtBQUlHLGdCQUFnQixtQkFBQUgsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsS0FBSUksV0FBVyxtQkFBQUosQ0FBUSxFQUFSLENBQWY7O0FBRUEsRUFBQyxZQUFNO0FBQ047O0FBRUEsTUFBTUssc2JBQU47O0FBZ0JBLE1BQU1DLGt5QkFBTjs7QUE0QkEsTUFBTUMsWUFBWSxJQUFJQyxLQUFLQyxPQUFULENBQWlCSixTQUFqQixFQUE0QkMsV0FBNUIsRUFBeUMsWUFBekMsQ0FBbEI7O0FBVUE7O0FBekRNLE1BMkRBSSxVQTNEQTtBQUFBOztBQTRETCx1QkFBWUMsSUFBWixFQUE4QjtBQUFBLFFBQVpDLEtBQVksdUVBQUosRUFBSTs7QUFBQTs7QUFDN0IsUUFBTUMsV0FBVyxJQUFJTCxLQUFLTSxRQUFULEdBQ2ZDLFFBRGUsQ0FDTixFQURNLEVBRVJDLFlBRlEsQ0FFSyxpQkFGTCxFQUV3QixFQUZ4QixFQUU0QixDQUY1QixFQUdSQSxZQUhRLENBR0ssZUFITCxFQUdzQixFQUh0QixFQUcwQixDQUgxQixDQUFqQjs7QUFENkIsd0hBS3ZCSCxRQUx1QixFQUtiLElBQUlMLEtBQUtTLE1BQVQsQ0FBZ0JWLFNBQWhCLEVBQTJCLEVBQTNCLENBTGE7O0FBTzdCLFVBQUtLLEtBQUwsR0FBYSxJQUFJTSxTQUFKLENBQWNOLEtBQWQsQ0FBYjtBQUNNLFVBQUtPLEtBQUwsR0FBYVIsSUFBYjtBQUNBLFVBQUtTLE1BQUwsR0FBYyxDQUFkO0FBQ0EsVUFBS0MsVUFBTCxHQUFrQixDQUFsQjtBQUNBLFVBQUtDLGVBQUwsR0FBdUIsQ0FBdkI7QUFDQSxVQUFLQyxVQUFMLEdBQWtCLElBQWxCOztBQUVBLFVBQUtDLFVBQUw7QUFkdUI7QUFlN0I7O0FBM0VJO0FBQUE7QUFBQSxpQ0E2RVE7QUFBQTs7QUFDTkMsZ0JBQVcsS0FBS2IsS0FBTCxDQUFXYyxPQUF0QixFQUErQixLQUFLZCxLQUFMLENBQVdlLFFBQTFDLEVBQW9ELFVBQUNDLEVBQUQsRUFBUTtBQUMzRCxhQUFLQyxLQUFMLEdBQWFELEdBQUdFLElBQWhCO0FBQ0EsYUFBS0MsUUFBTCxHQUFnQkgsR0FBR0ksT0FBbkI7QUFDQSxhQUFLQyxVQUFMO0FBQ0EsTUFKRDtBQUtIO0FBbkZDO0FBQUE7QUFBQSxpQ0FxRlc7QUFDWjtBQUNBLFNBQUksS0FBS1YsVUFBTCxJQUFtQixLQUFLWCxLQUFMLENBQVdzQixTQUFsQyxFQUE2QztBQUM1QyxVQUFJQztBQUNHeEIsYUFBTSxLQUFLUSxLQURkO0FBRUdXLGFBQU0sS0FBS0Q7QUFGZCxTQUdNLEtBQUtqQixLQUFMLENBQVd3QixXQUFYLEVBSE4sQ0FBSjs7QUFNRyxVQUFJLENBQUNELElBQUlMLElBQVQsRUFBZTtBQUNYLGFBQU0sb0NBQU47QUFDSDs7QUFFRCxVQUFJTyxTQUFTbkMsYUFBYWlDLEdBQWIsQ0FBYjs7QUFFQTtBQUNBLFVBQUlMLE9BQU9LLElBQUlMLElBQWY7O0FBRUE7QUFDQSxVQUFJUSxXQUFXUixLQUFLUyxNQUFMLENBQVlDLE1BQTNCO0FBQ0EsVUFBSUMsWUFBWVgsS0FBS1MsTUFBTCxDQUFZRyxNQUE1Qjs7QUFFQTtBQUNBLFVBQUlDLFNBQVNOLE9BQU9NLE1BQVAsQ0FBY0MsTUFBZCxDQUFxQixVQUFDQyxLQUFELEVBQVc7QUFDekMsV0FBSUMsU0FBU0QsTUFBTUUsSUFBbkI7QUFDQSxjQUFPRCxPQUFPRSxLQUFQLEdBQWVGLE9BQU9HLE1BQXRCLEdBQStCLENBQXRDO0FBQ0gsT0FIWSxDQUFiOztBQUtBO0FBQ0EsVUFBSUMsWUFBWTlDLFNBQVM4QyxTQUFULENBQW1CUCxNQUFuQixDQUFoQjtBQUNBLFVBQUlRLE1BQU0vQyxTQUFTK0MsR0FBVCxDQUFhUixNQUFiLEVBQXFCTCxRQUFyQixFQUErQkcsU0FBL0IsRUFBMEMsS0FBMUMsQ0FBVjs7QUFFQSxVQUFJVyxVQUFVakQsY0FBYztBQUN4QmtELGtCQUFXLElBRGE7QUFFeEJDLGFBQU0sUUFGa0I7QUFHeEJDLGNBQU9aLE9BQU9hO0FBSFUsT0FBZCxDQUFkOztBQU1BLFdBQUszQyxRQUFMLENBQWM0QyxRQUFkLEdBQXlCQyxNQUF6QixDQUFnQ04sT0FBaEM7QUFDQSxXQUFLdkMsUUFBTCxDQUFjOEMsU0FBZCxDQUF3QixpQkFBeEIsRUFBMkNELE1BQTNDLENBQWtEUixTQUFsRDtBQUNBLFdBQUtyQyxRQUFMLENBQWM4QyxTQUFkLENBQXdCLGVBQXhCLEVBQXlDRCxNQUF6QyxDQUFnRFAsR0FBaEQ7O0FBRUEsV0FBSzVCLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxXQUFLWCxLQUFMLENBQVdzQixTQUFYLEdBQXVCLEtBQXZCO0FBQ0g7O0FBRUQ7QUFDQSxTQUFJLEtBQUswQixPQUFMLEtBQWlCLEtBQUtoRCxLQUFMLENBQVdnRCxPQUFoQyxFQUF5QztBQUN4QyxXQUFLQyxNQUFMLENBQVlDLFFBQVosQ0FBcUJDLFFBQXJCLEdBQWdDLEtBQUtoQyxRQUFyQztBQUNBLFdBQUs4QixNQUFMLENBQVlDLFFBQVosQ0FBcUJFLE9BQXJCLEdBQStCLEtBQUtDLFVBQXBDO0FBQ0EsV0FBS0osTUFBTCxDQUFZQyxRQUFaLENBQXFCSSxXQUFyQixHQUFtQyxLQUFLQyxTQUF4QztBQUNHLFdBQUtOLE1BQUwsQ0FBWUMsUUFBWixDQUFxQk0sT0FBckIsR0FBK0IsS0FBS3hELEtBQUwsQ0FBV3lELElBQTFDO0FBQ0EsV0FBS1IsTUFBTCxDQUFZQyxRQUFaLENBQXFCUSxVQUFyQixHQUFrQyxLQUFLMUQsS0FBTCxDQUFXMkQsUUFBN0M7QUFDQSxXQUFLVixNQUFMLENBQVlDLFFBQVosQ0FBcUJVLGNBQXJCLEdBQXNDLEtBQUs1RCxLQUFMLENBQVcyRCxRQUFYLEdBQXNCLEtBQUsxQyxLQUFMLENBQVc0QyxJQUFYLENBQWdCQyxJQUE1RTtBQUNBLFdBQUtiLE1BQUwsQ0FBWUMsUUFBWixDQUFxQmEsUUFBckIsR0FBZ0MsS0FBSy9ELEtBQUwsQ0FBV2dFLE1BQTNDOztBQUVBLFdBQUtoQixPQUFMLEdBQWUsS0FBS2hELEtBQUwsQ0FBV2dELE9BQTFCO0FBQ0EsV0FBS3RDLGVBQUwsR0FBdUIsS0FBSzJDLFVBQTVCO0FBQ0g7QUFDRDtBQWhKQztBQUFBO0FBQUEsbUNBcUxhWSxRQXJMYixFQXFMdUI7QUFDeEIsU0FBSSxLQUFLWixVQUFMLEtBQW9CLEtBQUszQyxlQUE3QixFQUE4QztBQUM3QyxXQUFLVixLQUFMLENBQVdnRCxPQUFYO0FBQ0E7O0FBRUQsVUFBSzNCLFVBQUw7O0FBRUEsNEhBQXFCNEMsUUFBckI7QUFDQTtBQTdMQztBQUFBO0FBQUEsd0JBa0pTO0FBQ1AsWUFBTyxLQUFLMUQsS0FBWjtBQUNILEtBcEpDO0FBQUEsc0JBc0pPMkQsS0F0SlAsRUFzSmM7QUFDZixTQUFJLENBQUMsS0FBSzNELEtBQU4sS0FBZ0IyRCxLQUFwQixFQUEyQjtBQUMxQixXQUFLM0QsS0FBTCxHQUFhMkQsS0FBYjtBQUNHLFdBQUt2RCxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7QUFDRDtBQTNKQztBQUFBO0FBQUEsd0JBNkpVO0FBQ1IsWUFBTyxLQUFLSCxNQUFaO0FBQ0gsS0EvSkM7QUFBQSxzQkFpS1EwRCxLQWpLUixFQWlLZTtBQUNoQixTQUFJLENBQUMsS0FBSzFELE1BQU4sS0FBaUIwRCxLQUFyQixFQUE0QjtBQUMzQixXQUFLMUQsTUFBTCxHQUFjMEQsS0FBZDtBQUNBLFVBQUksS0FBS2xFLEtBQVQsRUFBZ0I7QUFDZixZQUFLQSxLQUFMLENBQVdnRCxPQUFYO0FBQ0E7QUFDRDtBQUNEO0FBeEtDO0FBQUE7QUFBQSx3QkEwS2M7QUFDWixZQUFPLEtBQUt2QyxVQUFaO0FBQ0gsS0E1S0M7QUFBQSxzQkE4S1l5RCxLQTlLWixFQThLbUI7QUFDcEIsU0FBSSxDQUFDLEtBQUt6RCxVQUFOLEtBQXFCeUQsS0FBekIsRUFBZ0M7QUFDL0IsV0FBS3pELFVBQUwsR0FBa0J5RCxLQUFsQjtBQUNBLFdBQUtsRSxLQUFMLENBQVdnRCxPQUFYO0FBQ0E7QUFDRDtBQW5MQzs7QUFBQTtBQUFBLElBMkRtQnBELEtBQUt1RSxJQTNEeEI7O0FBZ01OdkUsT0FBS0UsVUFBTCxHQUFrQkEsVUFBbEI7O0FBVUE7O0FBRUEsTUFBTXNFLGNBQWMsRUFBcEI7QUFDQSxXQUFTdkQsVUFBVCxDQUFvQkMsT0FBcEIsRUFBNkJDLFFBQTdCLEVBQXVDc0QsUUFBdkMsRUFBaUQ7QUFDaEQsT0FBSUQsaUJBQWV0RCxPQUFmLEdBQXlCQyxRQUF6QixDQUFKLEVBQTBDO0FBQ3pDc0QsYUFBU0QsaUJBQWV0RCxPQUFmLEdBQXlCQyxRQUF6QixDQUFUO0FBQ0E7QUFDQTs7QUFFRDVCLFlBQVMyQixPQUFULEVBQWtCLFVBQUN3RCxHQUFELEVBQU1wRCxJQUFOLEVBQWU7QUFDN0J0QixTQUFLMkUsTUFBTCxDQUFZQyxNQUFaLENBQW1CQyxHQUFuQixDQUF1QjFELFFBQXZCLEVBQWlDQSxRQUFqQyxFQUEyQzJELElBQTNDLENBQWdELFVBQUNDLE1BQUQsRUFBU0MsU0FBVCxFQUF1QjtBQUNuRSxTQUFNNUQsS0FBSztBQUNWRSxnQkFEVTtBQUVWRSxlQUFTd0QsVUFBVTdELFFBQVYsRUFBb0JLO0FBRm5CLE1BQVg7QUFJQWdELHNCQUFldEQsT0FBZixHQUF5QkMsUUFBekIsSUFBdUNDLEVBQXZDOztBQUVBcUQsY0FBU3JELEVBQVQ7QUFDQTtBQUNILEtBVEQ7QUFVSCxJQVhEO0FBWUE7QUFDRHBCLE9BQUtFLFVBQUwsQ0FBZ0IrRSxRQUFoQixHQUEyQmhFLFVBQTNCOztBQVVBOztBQUVBLE1BQU1pRSxlQUFlO0FBQ2pCQyxVQUFPLE1BRFU7QUFFakI7Ozs7OztBQU1BdEIsU0FBTSxRQVJXO0FBU2pCO0FBQ0FFLGFBQVUsRUFWTztBQVdqQnFCLGVBQVksUUFYSztBQVlqQkMsa0JBQWUsQ0FaRTtBQWFqQkMsZUFBWSxDQWJLO0FBY2pCO0FBQ0E7QUFDQUMsYUFBVSxLQWhCTztBQWlCakJDLGtCQUFlO0FBakJFLEdBQXJCOztBQTVPTSxNQWdRQTlFLFNBaFFBO0FBaVFGLHNCQUFZTixLQUFaLEVBQW1CO0FBQUE7O0FBQ2YsU0FBS2dELE9BQUwsR0FBZSxDQUFmO0FBQ0EsU0FBS3JDLFVBQUwsR0FBa0IsS0FBbEI7QUFDQTBFLFdBQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CUixZQUFwQixFQUFrQzlFLEtBQWxDO0FBQ0g7O0FBclFDO0FBQUE7QUFBQSxrQ0F3Vlk7QUFDVixZQUFPO0FBQ0grRSxhQUFPLEtBQUtBLEtBRFQ7QUFFSHBCLGdCQUFVLEtBQUtBLFFBRlo7QUFHSEYsWUFBTSxLQUFLQSxJQUhSO0FBSUh1QixrQkFBWSxLQUFLQSxVQUpkO0FBS0g1QyxhQUFPLEtBQUtnRCxhQUxUO0FBTUhBLHFCQUFlLEtBQUtBLGFBTmpCO0FBT0hHLFlBQU0sS0FBS0osUUFBTCxHQUFnQkssU0FBaEIsR0FBNEIsUUFQL0I7QUFRSE4sa0JBQVksS0FBS0EsVUFSZDtBQVNIRCxxQkFBZSxLQUFLQTtBQVRqQixNQUFQO0FBV0g7QUFwV0M7QUFBQTtBQUFBLHdCQXVRYztBQUNaLFlBQU8sS0FBS3RFLFVBQVo7QUFDSCxLQXpRQztBQUFBLHNCQTJRWXVELEtBM1FaLEVBMlFtQjtBQUNwQixVQUFLdkQsVUFBTCxHQUFrQnVELEtBQWxCO0FBQ0E7QUE3UUM7QUFBQTtBQUFBLHdCQStRVTtBQUNSLFlBQU8sS0FBS3VCLE1BQVo7QUFDSCxLQWpSQztBQUFBLHNCQW1SUXZCLEtBblJSLEVBbVJlO0FBQ2hCLFNBQUksQ0FBQyxLQUFLdUIsTUFBTixLQUFpQnZCLEtBQXJCLEVBQTRCO0FBQzNCLFdBQUt1QixNQUFMLEdBQWN2QixLQUFkO0FBQ0csV0FBS2xCLE9BQUw7QUFDQSxXQUFLckMsVUFBTCxHQUFrQixJQUFsQjtBQUNIO0FBQ0Q7QUF6UkM7QUFBQTtBQUFBLHdCQTJSVztBQUNULFlBQU8sS0FBSytFLE9BQVo7QUFDSDtBQTdSQztBQUFBO0FBQUEsd0JBK1JlO0FBQ2IsWUFBTyxLQUFLQSxPQUFaO0FBQ0gsS0FqU0M7QUFBQSxzQkFtU2F4QixLQW5TYixFQW1Tb0I7QUFDckIsU0FBSSxDQUFDLEtBQUt3QixPQUFOLEtBQWtCeEIsS0FBdEIsRUFBNkI7QUFDekIsV0FBS3dCLE9BQUwsR0FBZXhCLEtBQWY7QUFDQSxXQUFLbEIsT0FBTDtBQUNIO0FBQ0Q7QUF4U0M7QUFBQTtBQUFBLHdCQTBTYTtBQUNYLFlBQU8sS0FBSzJDLFNBQVo7QUFDSCxLQTVTQztBQUFBLHNCQThTV3pCLEtBOVNYLEVBOFNrQjtBQUNuQixTQUFJLENBQUMsS0FBS3lCLFNBQU4sS0FBb0J6QixLQUF4QixFQUErQjtBQUMzQixXQUFLeUIsU0FBTCxHQUFpQnpCLEtBQWpCO0FBQ0EsV0FBS2xCLE9BQUw7QUFDQSxXQUFLckMsVUFBTCxHQUFrQixJQUFsQjtBQUNIO0FBQ0Q7QUFwVEM7QUFBQTtBQUFBLHdCQXNUa0I7QUFDaEIsWUFBTyxLQUFLaUYsY0FBWjtBQUNILEtBeFRDO0FBQUEsc0JBMFRnQjFCLEtBMVRoQixFQTBUdUI7QUFDeEIsU0FBSSxDQUFDLEtBQUswQixjQUFOLEtBQXlCMUIsS0FBN0IsRUFBb0M7QUFDaEMsV0FBSzBCLGNBQUwsR0FBc0IxQixLQUF0QjtBQUNBLFdBQUt2RCxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7QUFDRDtBQS9UQztBQUFBO0FBQUEsd0JBaVVhO0FBQ1gsWUFBTyxLQUFLa0YsU0FBWjtBQUNILEtBblVDO0FBQUEsc0JBcVVXM0IsS0FyVVgsRUFxVWtCO0FBQ25CLFNBQUksQ0FBQyxLQUFLMkIsU0FBTixLQUFvQjNCLEtBQXhCLEVBQStCO0FBQzNCLFdBQUsyQixTQUFMLEdBQWlCM0IsS0FBakI7QUFDQSxXQUFLdkQsVUFBTCxHQUFrQixJQUFsQjtBQUNIO0FBQ0Q7QUExVUM7QUFBQTtBQUFBLHdCQTRVUztBQUNQLFlBQU8sS0FBS21GLEtBQVo7QUFDSCxLQTlVQztBQUFBLHNCQWdWTzVCLEtBaFZQLEVBZ1ZjO0FBQ1osU0FBTTZCLGNBQWNuRyxLQUFLb0csS0FBTCxDQUFXQyxPQUFYLENBQW1CL0IsS0FBbkIsQ0FBcEI7QUFDQSxTQUFJLENBQUMsS0FBSzRCLEtBQU4sSUFBZSxDQUFDLEtBQUtBLEtBQUwsQ0FBV0ksS0FBWCxDQUFpQixVQUFDQyxDQUFELEVBQUlDLENBQUosRUFBVTtBQUFFLGFBQU9ELE1BQU1KLFlBQVlLLENBQVosQ0FBYjtBQUE4QixNQUEzRCxDQUFwQixFQUFrRjtBQUM5RSxXQUFLTixLQUFMLEdBQWFDLFdBQWI7QUFDQSxXQUFLL0MsT0FBTDtBQUNIO0FBQ0o7QUF0VkM7O0FBQUE7QUFBQTtBQXNXTixFQXRXRCxJOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE07O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qiw4QkFBOEI7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EseUJBQXdCLFFBQVE7QUFDaEM7QUFDQSxzQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzV2REE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxTQUFRLFVBQVU7O0FBRWxCO0FBQ0E7Ozs7Ozs7QUNuRkEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBLE1BQUs7QUFDTCxrQ0FBaUMsU0FBUztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBOzs7Ozs7O0FDdFBBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNaQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMvQkE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGtCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEU7Ozs7OztBQzNHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixtQkFBbUIsTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFOzs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUMxQkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCO0FBQ2hCLGdCQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7OztBQy9KQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ1BBLDRDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDMVNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNwQkFxRCxRQUFPQyxPQUFQLENBQWVDLEtBQWYsR0FBdUIsU0FBU0EsS0FBVCxDQUFnQnhFLE1BQWhCLEVBQXdCO0FBQzdDLE9BQUl3RSxRQUFRLElBQUlDLFlBQUosQ0FBaUJ6RSxPQUFPYSxNQUFQLEdBQWdCLENBQWhCLEdBQW9CLENBQXJDLENBQVo7QUFDQSxPQUFJd0QsSUFBSSxDQUFSO0FBQ0FyRSxVQUFPMEUsT0FBUCxDQUFlLFVBQVV4RSxLQUFWLEVBQWlCO0FBQzlCLFNBQUl5RSxLQUFLekUsTUFBTUUsSUFBTixDQUFXd0UsSUFBWCxJQUFtQixDQUE1QjtBQUNBSixXQUFNSCxHQUFOLElBQWFNLEVBQWI7QUFDQUgsV0FBTUgsR0FBTixJQUFhTSxFQUFiO0FBQ0FILFdBQU1ILEdBQU4sSUFBYU0sRUFBYjtBQUNBSCxXQUFNSCxHQUFOLElBQWFNLEVBQWI7QUFDRCxJQU5EO0FBT0EsVUFBT0gsS0FBUDtBQUNELEVBWEQ7O0FBYUFGLFFBQU9DLE9BQVAsQ0FBZS9ELEdBQWYsR0FBcUIsU0FBU0EsR0FBVCxDQUFjUixNQUFkLEVBQXNCTCxRQUF0QixFQUFnQ0csU0FBaEMsRUFBMkMrRSxLQUEzQyxFQUFrRDtBQUNyRSxPQUFJckUsTUFBTSxJQUFJaUUsWUFBSixDQUFpQnpFLE9BQU9hLE1BQVAsR0FBZ0IsQ0FBaEIsR0FBb0IsQ0FBckMsQ0FBVjtBQUNBLE9BQUl3RCxJQUFJLENBQVI7QUFDQXJFLFVBQU8wRSxPQUFQLENBQWUsVUFBVXhFLEtBQVYsRUFBaUI7QUFDOUIsU0FBSUMsU0FBU0QsTUFBTUUsSUFBbkI7QUFDQSxTQUFJMEUsS0FBTTNFLE9BQU80RSxDQUFQLEdBQVc1RSxPQUFPRSxLQUE1QjtBQUNBLFNBQUkyRSxLQUFNN0UsT0FBTzhFLENBQVAsR0FBVzlFLE9BQU9HLE1BQTVCOztBQUVBO0FBQ0EsU0FBSTRFLEtBQUsvRSxPQUFPNEUsQ0FBUCxHQUFXcEYsUUFBcEI7QUFDQSxTQUFJd0YsS0FBS2hGLE9BQU84RSxDQUFQLEdBQVduRixTQUFwQjtBQUNBLFNBQUlzRixLQUFLTixLQUFLbkYsUUFBZDtBQUNBLFNBQUkwRixLQUFLTCxLQUFLbEYsU0FBZDs7QUFFQSxTQUFJK0UsS0FBSixFQUFXO0FBQ1RNLFlBQUssQ0FBQ3JGLFlBQVlLLE9BQU84RSxDQUFwQixJQUF5Qm5GLFNBQTlCO0FBQ0F1RixZQUFLLENBQUN2RixZQUFZa0YsRUFBYixJQUFtQmxGLFNBQXhCO0FBQ0Q7O0FBRUQ7QUFDQVUsU0FBSTZELEdBQUosSUFBV2EsRUFBWDtBQUNBMUUsU0FBSTZELEdBQUosSUFBV2MsRUFBWDtBQUNBO0FBQ0EzRSxTQUFJNkQsR0FBSixJQUFXYSxFQUFYO0FBQ0ExRSxTQUFJNkQsR0FBSixJQUFXZ0IsRUFBWDtBQUNBO0FBQ0E3RSxTQUFJNkQsR0FBSixJQUFXZSxFQUFYO0FBQ0E1RSxTQUFJNkQsR0FBSixJQUFXZ0IsRUFBWDtBQUNBO0FBQ0E3RSxTQUFJNkQsR0FBSixJQUFXZSxFQUFYO0FBQ0E1RSxTQUFJNkQsR0FBSixJQUFXYyxFQUFYO0FBQ0QsSUE1QkQ7QUE2QkEsVUFBTzNFLEdBQVA7QUFDRCxFQWpDRDs7QUFtQ0E4RCxRQUFPQyxPQUFQLENBQWVoRSxTQUFmLEdBQTJCLFNBQVNBLFNBQVQsQ0FBb0JQLE1BQXBCLEVBQTRCO0FBQ3JELE9BQUlPLFlBQVksSUFBSWtFLFlBQUosQ0FBaUJ6RSxPQUFPYSxNQUFQLEdBQWdCLENBQWhCLEdBQW9CLENBQXJDLENBQWhCO0FBQ0EsT0FBSXdELElBQUksQ0FBUjtBQUNBckUsVUFBTzBFLE9BQVAsQ0FBZSxVQUFVeEUsS0FBVixFQUFpQjtBQUM5QixTQUFJQyxTQUFTRCxNQUFNRSxJQUFuQjs7QUFFQTtBQUNBLFNBQUkyRSxJQUFJN0UsTUFBTW9GLFFBQU4sQ0FBZSxDQUFmLElBQW9CbkYsT0FBT29GLE9BQW5DO0FBQ0EsU0FBSU4sSUFBSS9FLE1BQU1vRixRQUFOLENBQWUsQ0FBZixJQUFvQm5GLE9BQU9xRixPQUFuQzs7QUFFQTtBQUNBLFNBQUlDLElBQUl0RixPQUFPRSxLQUFmO0FBQ0EsU0FBSXFGLElBQUl2RixPQUFPRyxNQUFmOztBQUVBO0FBQ0FDLGVBQVU4RCxHQUFWLElBQWlCVSxDQUFqQjtBQUNBeEUsZUFBVThELEdBQVYsSUFBaUJZLENBQWpCO0FBQ0E7QUFDQTFFLGVBQVU4RCxHQUFWLElBQWlCVSxDQUFqQjtBQUNBeEUsZUFBVThELEdBQVYsSUFBaUJZLElBQUlTLENBQXJCO0FBQ0E7QUFDQW5GLGVBQVU4RCxHQUFWLElBQWlCVSxJQUFJVSxDQUFyQjtBQUNBbEYsZUFBVThELEdBQVYsSUFBaUJZLElBQUlTLENBQXJCO0FBQ0E7QUFDQW5GLGVBQVU4RCxHQUFWLElBQWlCVSxJQUFJVSxDQUFyQjtBQUNBbEYsZUFBVThELEdBQVYsSUFBaUJZLENBQWpCO0FBQ0QsSUF2QkQ7QUF3QkEsVUFBTzFFLFNBQVA7QUFDRCxFQTVCRCxDIiwiZmlsZSI6InRoZW9yeXR5cGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBmNWJhNjQyYTkyOTM0MzY3ZjZlOCIsImxldCBsb2FkRm9udCA9IHJlcXVpcmUoJ2xvYWQtYm1mb250Jyk7XHJcbmxldCBpc0VxdWFsID0gcmVxdWlyZSgnYXJyYXlidWZmZXItZXF1YWwnKTtcclxubGV0IGNyZWF0ZUxheW91dCA9IHJlcXVpcmUoJ2xheW91dC1ibWZvbnQtdGV4dCcpO1xyXG5sZXQgY3JlYXRlSW5kaWNlcyA9IHJlcXVpcmUoJ3F1YWQtaW5kaWNlcycpO1xyXG5sZXQgdmVydGljZXMgPSByZXF1aXJlKCcuL3BsaWIvdmVydGljZXMnKTtcclxuXHJcbigoKSA9PiB7XHJcblx0LyogU2hhZGVycyAqL1xyXG5cclxuXHRjb25zdCB2ZXJ0ZXhTcmMgPSBgXHJcblx0ICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XHJcblxyXG5cdFx0dW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG5cdFx0dW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfZm9udEluZm9TaXplO1xyXG5cclxuXHRcdHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG5cclxuXHRcdHZvaWQgbWFpbih2b2lkKVxyXG5cdFx0e1xyXG5cdFx0ICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xyXG5cdFx0ICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24gKiB1X2ZvbnRJbmZvU2l6ZSwgMS4wKSkueHksIDAuMCwgMS4wKTtcclxuXHRcdH1gO1xyXG5cclxuXHRjb25zdCBmcmFnbWVudFNyYyA9IGBcclxuXHQgICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcblx0XHR1bmlmb3JtIHZlYzMgdV9jb2xvcjtcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2FscGhhO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3JlYWxhbHBoYTtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mb250U2l6ZTtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV93ZWlnaHQ7XHJcblxyXG5cdFx0dm9pZCBtYWluKHZvaWQpXHJcblx0XHR7XHJcblx0XHQgICAgZmxvYXQgc21vb3RoaW5nID0gMS4gLyB1X2ZvbnRTaXplICogNi47XHJcblx0XHQgICAgZmxvYXQgZGVidWcgPSAwLjA7XHJcblxyXG5cdFx0ICAgIHZlYzIgdGV4dHVyZUNvb3JkID0gdlRleHR1cmVDb29yZCAqIDIuO1xyXG5cdFx0ICAgIGZsb2F0IGRpc3QgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpLmE7XHJcblxyXG5cdFx0ICAgIGlmIChkZWJ1ZyA+IDAuMCkge1xyXG5cdFx0ICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRpc3QsIGRpc3QsIGRpc3QsIDEpO1xyXG5cdFx0ICAgIH0gZWxzZSB7XHJcblx0XHQgICAgICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgodV93ZWlnaHQgLSBzbW9vdGhpbmcpIC8gdV9hbHBoYSwgKHVfd2VpZ2h0ICsgc21vb3RoaW5nKSAvIHVfYWxwaGEsIGRpc3QpO1xyXG5cclxuXHRcdCAgICAgICAgdmVjMyBjb2xvciA9IHVfY29sb3IgKiBhbHBoYTtcclxuXHJcblx0XHQgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGFscGhhKSAqIHVfYWxwaGEgKiB1X3JlYWxhbHBoYTtcclxuXHRcdCAgICB9XHJcblx0XHR9YDtcclxuXHJcblx0Y29uc3QgVFRfU0hBREVSID0gbmV3IFBJWEkuUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCAnVEhFT1JZVFlQRScpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cdC8qIFBJWEkuVGhlb3J5VHlwZSAqL1xyXG5cclxuXHRjbGFzcyBUaGVvcnlUeXBlIGV4dGVuZHMgUElYSS5NZXNoIHtcclxuXHRcdGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlID0ge30pIHtcclxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgUElYSS5HZW9tZXRyeSgpXHJcblx0XHRcdFx0LmFkZEluZGV4KFtdKVxyXG5cdCAgICAgICAgIFx0LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgW10sIDIpXHJcblx0ICAgICAgICAgXHQuYWRkQXR0cmlidXRlKCdhVGV4dHVyZUNvb3JkJywgW10sIDIpO1xyXG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbmV3IFBJWEkuU2hhZGVyKFRUX1NIQURFUiwge30pKTtcclxuXHJcblx0XHRcdHRoaXMuc3R5bGUgPSBuZXcgVGV4dFN0eWxlKHN0eWxlKTtcclxuXHQgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xyXG5cdCAgICAgICAgdGhpcy5fYWxwaGEgPSAxO1xyXG5cdCAgICAgICAgdGhpcy5fcmVhbEFscGhhID0gMTtcclxuXHQgICAgICAgIHRoaXMuX2xhc3RXb3JsZEFscGhhID0gMTtcclxuXHQgICAgICAgIHRoaXMuX2NvcHlEaXJ0eSA9IHRydWU7XHJcblxyXG5cdCAgICAgICAgdGhpcy5sb2FkQXNzZXRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bG9hZEFzc2V0cygpIHtcclxuXHQgICAgICAgIFRUTG9hZEZvbnQodGhpcy5zdHlsZS5mb250VVJMLCB0aGlzLnN0eWxlLmltYWdlVVJMLCAocmQpID0+IHtcclxuXHQgICAgICAgIFx0dGhpcy5fZm9udCA9IHJkLmZvbnQ7XHJcblx0ICAgICAgICBcdHRoaXMuX3RleHR1cmUgPSByZC50ZXh0dXJlO1xyXG5cdCAgICAgICAgXHR0aGlzLnVwZGF0ZVRleHQoKTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB1cGRhdGVUZXh0KCkge1xyXG5cdCAgICBcdC8vIFVwZGF0ZSB0ZXh0IGNvcHlcclxuXHQgICAgXHRpZiAodGhpcy5fY29weURpcnR5IHx8IHRoaXMuc3R5bGUuY29weURpcnR5KSB7XHJcblx0ICAgIFx0XHRsZXQgb3B0ID0ge1xyXG5cdFx0ICAgICAgICAgICAgdGV4dDogdGhpcy5fdGV4dCxcclxuXHRcdCAgICAgICAgICAgIGZvbnQ6IHRoaXMuX2ZvbnQsXHJcblx0XHQgICAgICAgICAgICAuLi50aGlzLnN0eWxlLmdldEZsYXRDb3B5KClcclxuXHRcdCAgICAgICAgfTtcclxuXHJcblx0XHQgICAgICAgIGlmICghb3B0LmZvbnQpIHtcclxuXHRcdCAgICAgICAgICAgIHRocm93ICdtdXN0IHNwZWNpZnkgYSB7IGZvbnQgfSBpbiBvcHRpb25zJztcclxuXHRcdCAgICAgICAgfVxyXG5cclxuXHRcdCAgICAgICAgbGV0IGxheW91dCA9IGNyZWF0ZUxheW91dChvcHQpO1xyXG5cclxuXHRcdCAgICAgICAgLy8gdGhlIGRlc2lyZWQgQk1Gb250IGRhdGFcclxuXHRcdCAgICAgICAgbGV0IGZvbnQgPSBvcHQuZm9udDtcclxuXHJcblx0XHQgICAgICAgIC8vIGRldGVybWluZSB0ZXh0dXJlIHNpemUgZnJvbSBmb250IGZpbGVcclxuXHRcdCAgICAgICAgbGV0IHRleFdpZHRoID0gZm9udC5jb21tb24uc2NhbGVXO1xyXG5cdFx0ICAgICAgICBsZXQgdGV4SGVpZ2h0ID0gZm9udC5jb21tb24uc2NhbGVIO1xyXG5cclxuXHRcdCAgICAgICAgLy8gZ2V0IHZpc2libGUgZ2x5cGhzXHJcblx0XHQgICAgICAgIGxldCBnbHlwaHMgPSBsYXlvdXQuZ2x5cGhzLmZpbHRlcigoZ2x5cGgpID0+IHtcclxuXHRcdCAgICAgICAgICAgIGxldCBiaXRtYXAgPSBnbHlwaC5kYXRhO1xyXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGJpdG1hcC53aWR0aCAqIGJpdG1hcC5oZWlnaHQgPiAwO1xyXG5cdFx0ICAgICAgICB9KTtcclxuXHJcblx0XHQgICAgICAgIC8vIGdldCBjb21tb24gdmVydGV4IGRhdGFcclxuXHRcdCAgICAgICAgbGV0IHBvc2l0aW9ucyA9IHZlcnRpY2VzLnBvc2l0aW9ucyhnbHlwaHMpO1xyXG5cdFx0ICAgICAgICBsZXQgdXZzID0gdmVydGljZXMudXZzKGdseXBocywgdGV4V2lkdGgsIHRleEhlaWdodCwgZmFsc2UpO1xyXG5cclxuXHRcdCAgICAgICAgbGV0IGluZGljZXMgPSBjcmVhdGVJbmRpY2VzKHtcclxuXHRcdCAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZSxcclxuXHRcdCAgICAgICAgICAgIHR5cGU6ICd1aW50MTYnLFxyXG5cdFx0ICAgICAgICAgICAgY291bnQ6IGdseXBocy5sZW5ndGhcclxuXHRcdCAgICAgICAgfSk7XHJcblxyXG5cdFx0ICAgICAgICB0aGlzLmdlb21ldHJ5LmdldEluZGV4KCkudXBkYXRlKGluZGljZXMpO1xyXG5cdFx0ICAgICAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcignYVZlcnRleFBvc2l0aW9uJykudXBkYXRlKHBvc2l0aW9ucyk7XHJcblx0XHQgICAgICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKCdhVGV4dHVyZUNvb3JkJykudXBkYXRlKHV2cyk7XHJcblxyXG5cdFx0ICAgICAgICB0aGlzLl9jb3B5RGlydHkgPSBmYWxzZTtcclxuXHRcdCAgICAgICAgdGhpcy5zdHlsZS5jb3B5RGlydHkgPSBmYWxzZTtcclxuXHQgICAgXHR9XHJcblx0ICAgIFx0XHJcblx0ICAgIFx0Ly8gVXBkYXRlIHRleHQgc3R5bGVcclxuXHQgICAgXHRpZiAodGhpcy5zdHlsZUlEICE9PSB0aGlzLnN0eWxlLnN0eWxlSUQpIHtcclxuXHQgICAgXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gdGhpcy5fdGV4dHVyZTtcclxuXHRcdCAgICBcdHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVfYWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XHJcblx0XHQgICAgXHR0aGlzLnNoYWRlci51bmlmb3Jtcy51X3JlYWxhbHBoYSA9IHRoaXMucmVhbEFscGhhO1xyXG5cdCAgICAgICAgXHR0aGlzLnNoYWRlci51bmlmb3Jtcy51X2NvbG9yID0gdGhpcy5zdHlsZS5maWxsO1xyXG5cdCAgICAgICAgXHR0aGlzLnNoYWRlci51bmlmb3Jtcy51X2ZvbnRTaXplID0gdGhpcy5zdHlsZS5mb250U2l6ZTtcclxuXHQgICAgICAgIFx0dGhpcy5zaGFkZXIudW5pZm9ybXMudV9mb250SW5mb1NpemUgPSB0aGlzLnN0eWxlLmZvbnRTaXplIC8gdGhpcy5fZm9udC5pbmZvLnNpemU7XHJcblx0ICAgICAgICBcdHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVfd2VpZ2h0ID0gdGhpcy5zdHlsZS53ZWlnaHQ7XHJcblxyXG5cdFx0ICAgICAgICB0aGlzLnN0eWxlSUQgPSB0aGlzLnN0eWxlLnN0eWxlSUQ7XHJcblx0XHQgICAgICAgIHRoaXMuX2xhc3RXb3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xyXG5cdFx0ICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgZ2V0IHRleHQoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgc2V0IHRleHQodmFsdWUpIHtcclxuXHQgICAgXHRpZiAoIXRoaXMuX3RleHQgIT09IHZhbHVlKSB7XHJcblx0ICAgIFx0XHR0aGlzLl90ZXh0ID0gdmFsdWU7XHJcblx0ICAgICAgICBcdHRoaXMuX2NvcHlEaXJ0eSA9IHRydWU7XHJcblx0ICAgIFx0fVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBnZXQgYWxwaGEoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHNldCBhbHBoYSh2YWx1ZSkge1xyXG5cdCAgICBcdGlmICghdGhpcy5fYWxwaGEgIT09IHZhbHVlKSB7XHJcblx0ICAgIFx0XHR0aGlzLl9hbHBoYSA9IHZhbHVlO1xyXG5cdCAgICBcdFx0aWYgKHRoaXMuc3R5bGUpIHtcclxuXHQgICAgXHRcdFx0dGhpcy5zdHlsZS5zdHlsZUlEKys7XHJcblx0ICAgIFx0XHR9XHJcblx0ICAgIFx0fVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBnZXQgcmVhbEFscGhhKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWxBbHBoYTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgc2V0IHJlYWxBbHBoYSh2YWx1ZSkge1xyXG5cdCAgICBcdGlmICghdGhpcy5fcmVhbEFscGhhICE9PSB2YWx1ZSkge1xyXG5cdCAgICBcdFx0dGhpcy5fcmVhbEFscGhhID0gdmFsdWU7XHJcblx0ICAgIFx0XHR0aGlzLnN0eWxlLnN0eWxlSUQrKztcclxuXHQgICAgXHR9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIF9yZW5kZXJEZWZhdWx0KHJlbmRlcmVyKSB7XHJcblx0ICAgIFx0aWYgKHRoaXMud29ybGRBbHBoYSAhPT0gdGhpcy5fbGFzdFdvcmxkQWxwaGEpIHtcclxuXHQgICAgXHRcdHRoaXMuc3R5bGUuc3R5bGVJRCsrO1xyXG5cdCAgICBcdH1cclxuXHJcblx0ICAgIFx0dGhpcy51cGRhdGVUZXh0KCk7XHJcblxyXG5cdCAgICBcdHN1cGVyLl9yZW5kZXJEZWZhdWx0KHJlbmRlcmVyKTtcclxuXHQgICAgfVxyXG5cdH1cclxuXHJcblx0UElYSS5UaGVvcnlUeXBlID0gVGhlb3J5VHlwZTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHQvKiBQSVhJLlRoZW9yeVR5cGUuTG9hZEZvbnQgKi9cclxuXHJcblx0Y29uc3QgVFRGb250Q2FjaGUgPSB7fTtcclxuXHRmdW5jdGlvbiBUVExvYWRGb250KGZvbnRVUkwsIGltYWdlVVJMLCBjYWxsYmFjaykge1xyXG5cdFx0aWYgKFRURm9udENhY2hlW2Ake2ZvbnRVUkx9JHtpbWFnZVVSTH1gXSkge1xyXG5cdFx0XHRjYWxsYmFjayhUVEZvbnRDYWNoZVtgJHtmb250VVJMfSR7aW1hZ2VVUkx9YF0pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bG9hZEZvbnQoZm9udFVSTCwgKGVyciwgZm9udCkgPT4ge1xyXG5cdFx0ICAgIFBJWEkuTG9hZGVyLnNoYXJlZC5hZGQoaW1hZ2VVUkwsIGltYWdlVVJMKS5sb2FkKChsb2FkZXIsIHJlc291cmNlcykgPT4ge1xyXG5cdFx0ICAgICAgICBjb25zdCByZCA9IHtcclxuXHRcdCAgICAgICAgXHRmb250LFxyXG5cdFx0ICAgICAgICBcdHRleHR1cmU6IHJlc291cmNlc1tpbWFnZVVSTF0udGV4dHVyZVxyXG5cdFx0ICAgICAgICB9O1xyXG5cdFx0ICAgICAgICBUVEZvbnRDYWNoZVtgJHtmb250VVJMfSR7aW1hZ2VVUkx9YF0gPSByZDtcclxuXHJcblx0XHQgICAgICAgIGNhbGxiYWNrKHJkKTtcclxuXHRcdCAgICAgICAgcmV0dXJuO1xyXG5cdFx0ICAgIH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdFBJWEkuVGhlb3J5VHlwZS5Mb2FkRm9udCA9IFRUTG9hZEZvbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblx0LyogcHJpdmF0ZSBUZXh0U3R5bGUgKi9cclxuXHJcblx0Y29uc3QgZGVmYXVsdFN0eWxlID0ge1xyXG5cdCAgICBhbGlnbjogJ2xlZnQnLFxyXG5cdCAgICAvKmJyZWFrV29yZHM6IGZhbHNlLFxyXG5cdCAgICAgZHJvcFNoYWRvdzogZmFsc2UsXHJcblx0ICAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxyXG5cdCAgICAgZHJvcFNoYWRvd0JsdXI6IDAsXHJcblx0ICAgICBkcm9wU2hhZG93Q29sb3I6ICcjMDAwMDAwJyxcclxuXHQgICAgIGRyb3BTaGFkb3dEaXN0YW5jZTogNSwqL1xyXG5cdCAgICBmaWxsOiAweGZmZmZmZixcclxuXHQgICAgLy9maWxsR3JhZGllbnRUeXBlOiBURVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCxcclxuXHQgICAgZm9udFNpemU6IDI2LFxyXG5cdCAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcclxuXHQgICAgbGV0dGVyU3BhY2luZzogMCxcclxuXHQgICAgbGluZUhlaWdodDogMCxcclxuXHQgICAgLy9zdHJva2U6ICdibGFjaycsXHJcblx0ICAgIC8vc3Ryb2tlVGhpY2tuZXNzOiAwLFxyXG5cdCAgICB3b3JkV3JhcDogZmFsc2UsXHJcblx0ICAgIHdvcmRXcmFwV2lkdGg6IDEwMCxcclxuXHR9O1xyXG5cclxuXHRjbGFzcyBUZXh0U3R5bGUge1xyXG5cdCAgICBjb25zdHJ1Y3RvcihzdHlsZSkge1xyXG5cdCAgICAgICAgdGhpcy5zdHlsZUlEID0gMDtcclxuXHQgICAgICAgIHRoaXMuX2NvcHlEaXJ0eSA9IGZhbHNlO1xyXG5cdCAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZWZhdWx0U3R5bGUsIHN0eWxlKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgZ2V0IGNvcHlEaXJ0eSgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLl9jb3B5RGlydHk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHNldCBjb3B5RGlydHkodmFsdWUpIHtcclxuXHQgICAgXHR0aGlzLl9jb3B5RGlydHkgPSB2YWx1ZTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgZ2V0IGFsaWduKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBzZXQgYWxpZ24odmFsdWUpIHtcclxuXHQgICAgXHRpZiAoIXRoaXMuX2FsaWduICE9PSB2YWx1ZSkge1xyXG5cdCAgICBcdFx0dGhpcy5fYWxpZ24gPSB2YWx1ZTtcclxuXHQgICAgICAgIFx0dGhpcy5zdHlsZUlEKys7XHJcblx0ICAgICAgICBcdHRoaXMuX2NvcHlEaXJ0eSA9IHRydWU7XHJcblx0ICAgIFx0fVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBnZXQgd2VpZ2h0KCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3dlaWdodDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgZ2V0IGZvbnRXZWlnaHQoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fd2VpZ2h0O1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBzZXQgZm9udFdlaWdodCh2YWx1ZSkge1xyXG5cdCAgICBcdGlmICghdGhpcy5fd2VpZ2h0ICE9PSB2YWx1ZSkge1xyXG5cdFx0ICAgICAgICB0aGlzLl93ZWlnaHQgPSB2YWx1ZTtcclxuXHRcdCAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcblx0XHQgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBnZXQgZm9udFNpemUoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHNldCBmb250U2l6ZSh2YWx1ZSkge1xyXG5cdCAgICBcdGlmICghdGhpcy5fZm9udFNpemUgIT09IHZhbHVlKSB7XHJcblx0XHQgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gdmFsdWU7XHJcblx0XHQgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG5cdFx0ICAgICAgICB0aGlzLl9jb3B5RGlydHkgPSB0cnVlO1xyXG5cdFx0ICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcclxuXHQgICAgfVxyXG5cclxuXHQgICAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcclxuXHQgICAgXHRpZiAoIXRoaXMuX2xldHRlclNwYWNpbmcgIT09IHZhbHVlKSB7XHJcblx0XHQgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSB2YWx1ZTtcclxuXHRcdCAgICAgICAgdGhpcy5fY29weURpcnR5ID0gdHJ1ZTtcclxuXHRcdCAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGdldCB3b3JkV3JhcCgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgc2V0IHdvcmRXcmFwKHZhbHVlKSB7XHJcblx0ICAgIFx0aWYgKCF0aGlzLl93b3JkV3JhcCAhPT0gdmFsdWUpIHtcclxuXHRcdCAgICAgICAgdGhpcy5fd29yZFdyYXAgPSB2YWx1ZTtcclxuXHRcdCAgICAgICAgdGhpcy5fY29weURpcnR5ID0gdHJ1ZTtcclxuXHRcdCAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGdldCBmaWxsKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGw7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHNldCBmaWxsKHZhbHVlKSB7XHJcblx0ICAgICAgICBjb25zdCBvdXRwdXRDb2xvciA9IFBJWEkudXRpbHMuaGV4MnJnYih2YWx1ZSk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuX2ZpbGwgfHwgIXRoaXMuX2ZpbGwuZXZlcnkoKHYsIGkpID0+IHsgcmV0dXJuIHYgPT09IG91dHB1dENvbG9yW2ldOyB9KSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbGwgPSBvdXRwdXRDb2xvcjtcclxuXHQgICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgZ2V0RmxhdENvcHkoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFsaWduOiB0aGlzLmFsaWduLFxyXG5cdCAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplLFxyXG5cdCAgICAgICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcclxuXHQgICAgICAgICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXHJcblx0ICAgICAgICAgICAgd2lkdGg6IHRoaXMud29yZFdyYXBXaWR0aCxcclxuXHQgICAgICAgICAgICB3b3JkV3JhcFdpZHRoOiB0aGlzLndvcmRXcmFwV2lkdGgsXHJcblx0ICAgICAgICAgICAgbW9kZTogdGhpcy53b3JkV3JhcCA/IHVuZGVmaW5lZCA6ICdub3dyYXAnLFxyXG5cdCAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCxcclxuXHQgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmdcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHR9XHJcbn0pKCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdGhlb3J5dHlwZS5qcyIsInZhciB4aHIgPSByZXF1aXJlKCd4aHInKVxudmFyIG5vb3AgPSBmdW5jdGlvbigpe31cbnZhciBwYXJzZUFTQ0lJID0gcmVxdWlyZSgncGFyc2UtYm1mb250LWFzY2lpJylcbnZhciBwYXJzZVhNTCA9IHJlcXVpcmUoJ3BhcnNlLWJtZm9udC14bWwnKVxudmFyIHJlYWRCaW5hcnkgPSByZXF1aXJlKCdwYXJzZS1ibWZvbnQtYmluYXJ5JylcbnZhciBpc0JpbmFyeUZvcm1hdCA9IHJlcXVpcmUoJy4vbGliL2lzLWJpbmFyeScpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbnZhciB4bWwyID0gKGZ1bmN0aW9uIGhhc1hNTDIoKSB7XG4gIHJldHVybiBzZWxmLlhNTEh0dHBSZXF1ZXN0ICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0XG59KSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0LCBjYikge1xuICBjYiA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/IGNiIDogbm9vcFxuXG4gIGlmICh0eXBlb2Ygb3B0ID09PSAnc3RyaW5nJylcbiAgICBvcHQgPSB7IHVyaTogb3B0IH1cbiAgZWxzZSBpZiAoIW9wdClcbiAgICBvcHQgPSB7fVxuXG4gIHZhciBleHBlY3RCaW5hcnkgPSBvcHQuYmluYXJ5XG4gIGlmIChleHBlY3RCaW5hcnkpXG4gICAgb3B0ID0gZ2V0QmluYXJ5T3B0cyhvcHQpXG5cbiAgeGhyKG9wdCwgZnVuY3Rpb24oZXJyLCByZXMsIGJvZHkpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIS9eMi8udGVzdChyZXMuc3RhdHVzQ29kZSkpXG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdodHRwIHN0YXR1cyBjb2RlOiAnK3Jlcy5zdGF0dXNDb2RlKSlcbiAgICBpZiAoIWJvZHkpXG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdubyBib2R5IHJlc3VsdCcpKVxuXG4gICAgdmFyIGJpbmFyeSA9IGZhbHNlIFxuXG4gICAgLy9pZiB0aGUgcmVzcG9uc2UgdHlwZSBpcyBhbiBhcnJheSBidWZmZXIsXG4gICAgLy93ZSBuZWVkIHRvIGNvbnZlcnQgaXQgaW50byBhIHJlZ3VsYXIgQnVmZmVyIG9iamVjdFxuICAgIGlmIChpc0FycmF5QnVmZmVyKGJvZHkpKSB7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShib2R5KVxuICAgICAgYm9keSA9IG5ldyBCdWZmZXIoYXJyYXksICdiaW5hcnknKVxuICAgIH1cblxuICAgIC8vbm93IGNoZWNrIHRoZSBzdHJpbmcvQnVmZmVyIHJlc3BvbnNlXG4gICAgLy9hbmQgc2VlIGlmIGl0IGhhcyBhIGJpbmFyeSBCTUYgaGVhZGVyXG4gICAgaWYgKGlzQmluYXJ5Rm9ybWF0KGJvZHkpKSB7XG4gICAgICBiaW5hcnkgPSB0cnVlXG4gICAgICAvL2lmIHdlIGhhdmUgYSBzdHJpbmcsIHR1cm4gaXQgaW50byBhIEJ1ZmZlclxuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykgXG4gICAgICAgIGJvZHkgPSBuZXcgQnVmZmVyKGJvZHksICdiaW5hcnknKVxuICAgIH0gXG5cbiAgICAvL3dlIGFyZSBub3QgcGFyc2luZyBhIGJpbmFyeSBmb3JtYXQsIGp1c3QgQVNDSUkvWE1ML2V0Y1xuICAgIGlmICghYmluYXJ5KSB7XG4gICAgICAvL21pZ2h0IHN0aWxsIGJlIGEgYnVmZmVyIGlmIHJlc3BvbnNlVHlwZSBpcyAnYXJyYXlidWZmZXInXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKVxuICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZyhvcHQuZW5jb2RpbmcpXG4gICAgICBib2R5ID0gYm9keS50cmltKClcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0eXBlID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgICBpZiAoYmluYXJ5KVxuICAgICAgICByZXN1bHQgPSByZWFkQmluYXJ5KGJvZHkpXG4gICAgICBlbHNlIGlmICgvanNvbi8udGVzdCh0eXBlKSB8fCBib2R5LmNoYXJBdCgwKSA9PT0gJ3snKVxuICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICBlbHNlIGlmICgveG1sLy50ZXN0KHR5cGUpICB8fCBib2R5LmNoYXJBdCgwKSA9PT0gJzwnKVxuICAgICAgICByZXN1bHQgPSBwYXJzZVhNTChib2R5KVxuICAgICAgZWxzZVxuICAgICAgICByZXN1bHQgPSBwYXJzZUFTQ0lJKGJvZHkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IobmV3IEVycm9yKCdlcnJvciBwYXJzaW5nIGZvbnQgJytlLm1lc3NhZ2UpKVxuICAgICAgY2IgPSBub29wXG4gICAgfVxuICAgIGNiKG51bGwsIHJlc3VsdClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihhcnIpIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgcmV0dXJuIHN0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSdcbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5T3B0cyhvcHQpIHtcbiAgLy9JRTEwKyBhbmQgb3RoZXIgbW9kZXJuIGJyb3dzZXJzIHN1cHBvcnQgYXJyYXkgYnVmZmVyc1xuICBpZiAoeG1sMilcbiAgICByZXR1cm4geHRlbmQob3B0LCB7IHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyB9KVxuICBcbiAgaWYgKHR5cGVvZiBzZWxmLlhNTEh0dHBSZXF1ZXN0ID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3lvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhIUiBsb2FkaW5nJylcblxuICAvL0lFOSBhbmQgWE1MMSBicm93c2VycyBjb3VsZCBzdGlsbCB1c2UgYW4gb3ZlcnJpZGVcbiAgdmFyIHJlcSA9IG5ldyBzZWxmLlhNTEh0dHBSZXF1ZXN0KClcbiAgcmVxLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKVxuICByZXR1cm4geHRlbmQoe1xuICAgIHhocjogcmVxXG4gIH0sIG9wdClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2FkLWJtZm9udC9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1ZmZlci9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcImlzLWZ1bmN0aW9uXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZShcInBhcnNlLWhlYWRlcnNcIilcbnZhciB4dGVuZCA9IHJlcXVpcmUoXCJ4dGVuZFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlWEhSO1xuY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3BcbmNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKSkgPyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxuZm9yRWFjaEFycmF5KFtcImdldFwiLCBcInB1dFwiLCBcInBvc3RcIiwgXCJwYXRjaFwiLCBcImhlYWRcIiwgXCJkZWxldGVcIl0sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGNyZWF0ZVhIUlttZXRob2QgPT09IFwiZGVsZXRlXCIgPyBcImRlbFwiIDogbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgICAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxuICAgIH1cbn0pXG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmope1xuICAgIGZvcih2YXIgaSBpbiBvYmope1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gdXJpXG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt1cmk6dXJpfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0geHRlbmQob3B0aW9ucywge3VyaTogdXJpfSlcbiAgICB9XG5cbiAgICBwYXJhbXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHJldHVybiBwYXJhbXNcbn1cblxuZnVuY3Rpb24gY3JlYXRlWEhSKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVYSFIob3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKVxuICAgIH1cblxuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNiT25jZShlcnIsIHJlc3BvbnNlLCBib2R5KXtcbiAgICAgICAgaWYoIWNhbGxlZCl7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9hZEZ1bmMsIDApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgZ2V0WG1sKHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwiVW5rbm93biBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhldnQsIGZhaWx1cmVSZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgJiBwcm9jZXNzIHRoZSByZXNwb25zZSBpbiBhIHNwZWNpYWwgcmVzcG9uc2Ugb2JqZWN0XG4gICAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XG4gICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgdmFyIHN0YXR1c1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZihvcHRpb25zLnVzZVhEUiAmJiB4aHIuc3RhdHVzPT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL0lFOCBDT1JTIEdFVCBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cyBmaWVsZCwgYnV0IGJvZHkgaXMgZmluZVxuICAgICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlXG4gICAgICAgIHZhciBlcnIgPSBudWxsXG5cbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5XG4gICAgdmFyIGFib3J0ZWRcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG4gICAgdmFyIGZhaWx1cmVSZXNwb25zZSA9IHtcbiAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgc3RhdHVzQ29kZTogMCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHVybDogdXJpLFxuICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICB9XG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmpzb24gIT09IGZhbHNlKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcImFjY2VwdFwiXSB8fCBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdIHx8IChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uID09PSB0cnVlID8gYm9keSA6IG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICBpZighc3luYykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIH1cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlLy9JRTkgbWF5IHN0aWxsIGNhbGwgcmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCB0aW1lb3V0XCIpXG4gICAgICAgICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiXG4gICAgICAgICAgICBlcnJvckZ1bmMoZSlcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IClcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cblxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIC8vIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIgc2VuZHMgXCJ1bmRlZmluZWRcIiB3aGVuIHNlbmQgaXMgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHZhbHVlLlxuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IHNwZWMgc2F5cyB0byBwYXNzIG51bGwgYXMgYm9keSB0byBpbmRpY2F0ZSBubyBib2R5XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXVndHVyL3hoci9pc3N1ZXMvMTAwLlxuICAgIHhoci5zZW5kKGJvZHkgfHwgbnVsbClcblxuICAgIHJldHVybiB4aHJcblxuXG59XG5cbmZ1bmN0aW9uIGdldFhtbCh4aHIpIHtcbiAgICAvLyB4aHIucmVzcG9uc2VYTUwgd2lsbCB0aHJvdyBFeGNlcHRpb24gXCJJbnZhbGlkU3RhdGVFcnJvclwiIG9yIFwiRE9NRXhjZXB0aW9uXCJcbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3Jlc3BvbnNlWE1MLlxuICAgIHRyeSB7XG4gICAgICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyZWZveEJ1Z1Rha2VuRWZmZWN0ID0geGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIlxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJcIiAmJiAhZmlyZWZveEJ1Z1Rha2VuRWZmZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veGhyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsb2JhbC93aW5kb3cuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzLWZ1bmN0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0cmltID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIHZhciBoZWFkZXJzQXJyID0gdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gaGVhZGVyc0FycltpXVxuICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3h0ZW5kL2ltbXV0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUJNRm9udEFzY2lpKGRhdGEpIHtcbiAgaWYgKCFkYXRhKVxuICAgIHRocm93IG5ldyBFcnJvcignbm8gZGF0YSBwcm92aWRlZCcpXG4gIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCkudHJpbSgpXG5cbiAgdmFyIG91dHB1dCA9IHtcbiAgICBwYWdlczogW10sXG4gICAgY2hhcnM6IFtdLFxuICAgIGtlcm5pbmdzOiBbXVxuICB9XG5cbiAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdCgvXFxyXFxuP3xcXG4vZylcblxuICBpZiAobGluZXMubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignbm8gZGF0YSBpbiBCTUZvbnQgZmlsZScpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lRGF0YSA9IHNwbGl0TGluZShsaW5lc1tpXSwgaSlcbiAgICBpZiAoIWxpbmVEYXRhKSAvL3NraXAgZW1wdHkgbGluZXNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICBpZiAobGluZURhdGEua2V5ID09PSAncGFnZScpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZURhdGEuZGF0YS5pZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGZpbGUgYXQgbGluZSAnICsgaSArICcgLS0gbmVlZHMgcGFnZSBpZD1OJylcbiAgICAgIGlmICh0eXBlb2YgbGluZURhdGEuZGF0YS5maWxlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgZmlsZSBhdCBsaW5lICcgKyBpICsgJyAtLSBuZWVkcyBwYWdlIGZpbGU9XCJwYXRoXCInKVxuICAgICAgb3V0cHV0LnBhZ2VzW2xpbmVEYXRhLmRhdGEuaWRdID0gbGluZURhdGEuZGF0YS5maWxlXG4gICAgfSBlbHNlIGlmIChsaW5lRGF0YS5rZXkgPT09ICdjaGFycycgfHwgbGluZURhdGEua2V5ID09PSAna2VybmluZ3MnKSB7XG4gICAgICAvLy4uLiBkbyBub3RoaW5nIGZvciB0aGVzZSB0d28gLi4uXG4gICAgfSBlbHNlIGlmIChsaW5lRGF0YS5rZXkgPT09ICdjaGFyJykge1xuICAgICAgb3V0cHV0LmNoYXJzLnB1c2gobGluZURhdGEuZGF0YSlcbiAgICB9IGVsc2UgaWYgKGxpbmVEYXRhLmtleSA9PT0gJ2tlcm5pbmcnKSB7XG4gICAgICBvdXRwdXQua2VybmluZ3MucHVzaChsaW5lRGF0YS5kYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRbbGluZURhdGEua2V5XSA9IGxpbmVEYXRhLmRhdGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHNwbGl0TGluZShsaW5lLCBpZHgpIHtcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFx0Ky9nLCAnICcpLnRyaW0oKVxuICBpZiAoIWxpbmUpXG4gICAgcmV0dXJuIG51bGxcblxuICB2YXIgc3BhY2UgPSBsaW5lLmluZGV4T2YoJyAnKVxuICBpZiAoc3BhY2UgPT09IC0xKSBcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBuYW1lZCByb3cgYXQgbGluZSBcIiArIGlkeClcblxuICB2YXIga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgc3BhY2UpXG5cbiAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKHNwYWNlICsgMSlcbiAgLy9jbGVhciBcImxldHRlclwiIGZpZWxkIGFzIGl0IGlzIG5vbi1zdGFuZGFyZCBhbmRcbiAgLy9yZXF1aXJlcyBhZGRpdGlvbmFsIGNvbXBsZXhpdHkgdG8gcGFyc2UgXCIgLyA9IHN5bWJvbHNcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvbGV0dGVyPVtcXCdcXFwiXVxcUytbXFwnXFxcIl0vZ2ksICcnKSAgXG4gIGxpbmUgPSBsaW5lLnNwbGl0KFwiPVwiKVxuICBsaW5lID0gbGluZS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkubWF0Y2goKC8oXCIuKj9cInxbXlwiXFxzXSspKyg/PVxccyp8XFxzKiQpL2cpKVxuICB9KVxuXG4gIHZhciBkYXRhID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGR0ID0gbGluZVtpXVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBrZXk6IGR0WzBdLFxuICAgICAgICBkYXRhOiBcIlwiXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoaSA9PT0gbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZGF0YSA9IHBhcnNlRGF0YShkdFswXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmRhdGEgPSBwYXJzZURhdGEoZHRbMF0pXG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBrZXk6IGR0WzFdLFxuICAgICAgICBkYXRhOiBcIlwiXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBvdXQgPSB7XG4gICAga2V5OiBrZXksXG4gICAgZGF0YToge31cbiAgfVxuXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgb3V0LmRhdGFbdi5rZXldID0gdi5kYXRhO1xuICB9KVxuXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRhKGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBcIlwiXG5cbiAgaWYgKGRhdGEuaW5kZXhPZignXCInKSA9PT0gMCB8fCBkYXRhLmluZGV4T2YoXCInXCIpID09PSAwKVxuICAgIHJldHVybiBkYXRhLnN1YnN0cmluZygxLCBkYXRhLmxlbmd0aCAtIDEpXG4gIGlmIChkYXRhLmluZGV4T2YoJywnKSAhPT0gLTEpXG4gICAgcmV0dXJuIHBhcnNlSW50TGlzdChkYXRhKVxuICByZXR1cm4gcGFyc2VJbnQoZGF0YSwgMTApXG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50TGlzdChkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKVxuICB9KVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1ibWZvbnQtYXNjaWkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBwYXJzZUF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL3BhcnNlLWF0dHJpYnMnKVxudmFyIHBhcnNlRnJvbVN0cmluZyA9IHJlcXVpcmUoJ3htbC1wYXJzZS1mcm9tLXN0cmluZycpXG5cbi8vSW4gc29tZSBjYXNlcyBlbGVtZW50LmF0dHJpYnV0ZS5ub2RlTmFtZSBjYW4gcmV0dXJuXG4vL2FsbCBsb3dlcmNhc2UgdmFsdWVzLi4gc28gd2UgbmVlZCB0byBtYXAgdGhlbSB0byB0aGUgY29ycmVjdCBcbi8vY2FzZVxudmFyIE5BTUVfTUFQID0ge1xuICBzY2FsZWg6ICdzY2FsZUgnLFxuICBzY2FsZXc6ICdzY2FsZVcnLFxuICBzdHJldGNoaDogJ3N0cmV0Y2hIJyxcbiAgbGluZWhlaWdodDogJ2xpbmVIZWlnaHQnLFxuICBhbHBoYWNobmw6ICdhbHBoYUNobmwnLFxuICByZWRjaG5sOiAncmVkQ2hubCcsXG4gIGdyZWVuY2hubDogJ2dyZWVuQ2hubCcsXG4gIGJsdWVjaG5sOiAnYmx1ZUNobmwnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xuICBkYXRhID0gZGF0YS50b1N0cmluZygpXG4gIFxuICB2YXIgeG1sUm9vdCA9IHBhcnNlRnJvbVN0cmluZyhkYXRhKVxuICB2YXIgb3V0cHV0ID0ge1xuICAgIHBhZ2VzOiBbXSxcbiAgICBjaGFyczogW10sXG4gICAga2VybmluZ3M6IFtdXG4gIH1cblxuICAvL2dldCBjb25maWcgc2V0dGluZ3NcbiAgO1snaW5mbycsICdjb21tb24nXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBlbGVtZW50ID0geG1sUm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShrZXkpWzBdXG4gICAgaWYgKGVsZW1lbnQpXG4gICAgICBvdXRwdXRba2V5XSA9IHBhcnNlQXR0cmlidXRlcyhnZXRBdHRyaWJzKGVsZW1lbnQpKVxuICB9KVxuXG4gIC8vZ2V0IHBhZ2UgaW5mb1xuICB2YXIgcGFnZVJvb3QgPSB4bWxSb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlcycpWzBdXG4gIGlmICghcGFnZVJvb3QpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgZmlsZSAtLSBubyA8cGFnZXM+IGVsZW1lbnQnKVxuICB2YXIgcGFnZXMgPSBwYWdlUm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFnZScpXG4gIGZvciAodmFyIGk9MDsgaTxwYWdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcGFnZXNbaV1cbiAgICB2YXIgaWQgPSBwYXJzZUludChwLmdldEF0dHJpYnV0ZSgnaWQnKSwgMTApXG4gICAgdmFyIGZpbGUgPSBwLmdldEF0dHJpYnV0ZSgnZmlsZScpXG4gICAgaWYgKGlzTmFOKGlkKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGZpbGUgLS0gcGFnZSBcImlkXCIgYXR0cmlidXRlIGlzIE5hTicpXG4gICAgaWYgKCFmaWxlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgZmlsZSAtLSBuZWVkcyBwYWdlIFwiZmlsZVwiIGF0dHJpYnV0ZScpXG4gICAgb3V0cHV0LnBhZ2VzW3BhcnNlSW50KGlkLCAxMCldID0gZmlsZVxuICB9XG5cbiAgLy9nZXQga2VybmluZ3MgLyBjaGFyc1xuICA7WydjaGFycycsICdrZXJuaW5ncyddLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGVsZW1lbnQgPSB4bWxSb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKGtleSlbMF1cbiAgICBpZiAoIWVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB2YXIgY2hpbGRUYWcgPSBrZXkuc3Vic3RyaW5nKDAsIGtleS5sZW5ndGgtMSlcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKGNoaWxkVGFnKVxuICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKykgeyAgICAgIFxuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICAgIG91dHB1dFtrZXldLnB1c2gocGFyc2VBdHRyaWJ1dGVzKGdldEF0dHJpYnMoY2hpbGQpKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlicyhlbGVtZW50KSB7XG4gIHZhciBhdHRyaWJzID0gZ2V0QXR0cmliTGlzdChlbGVtZW50KVxuICByZXR1cm4gYXR0cmlicy5yZWR1Y2UoZnVuY3Rpb24oZGljdCwgYXR0cmliKSB7XG4gICAgdmFyIGtleSA9IG1hcE5hbWUoYXR0cmliLm5vZGVOYW1lKVxuICAgIGRpY3Rba2V5XSA9IGF0dHJpYi5ub2RlVmFsdWVcbiAgICByZXR1cm4gZGljdFxuICB9LCB7fSlcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmliTGlzdChlbGVtZW50KSB7XG4gIC8vSUU4KyBhbmQgbW9kZXJuIGJyb3dzZXJzXG4gIHZhciBhdHRyaWJzID0gW11cbiAgZm9yICh2YXIgaT0wOyBpPGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICBhdHRyaWJzLnB1c2goZWxlbWVudC5hdHRyaWJ1dGVzW2ldKVxuICByZXR1cm4gYXR0cmlic1xufVxuXG5mdW5jdGlvbiBtYXBOYW1lKG5vZGVOYW1lKSB7XG4gIHJldHVybiBOQU1FX01BUFtub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBub2RlTmFtZVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1ibWZvbnQteG1sL2xpYi9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1NvbWUgdmVyc2lvbnMgb2YgR2x5cGhEZXNpZ25lciBoYXZlIGEgdHlwb1xuLy90aGF0IGNhdXNlcyBzb21lIGJ1Z3Mgd2l0aCBwYXJzaW5nLiBcbi8vTmVlZCB0byBjb25maXJtIHdpdGggcmVjZW50IHZlcnNpb24gb2YgdGhlIHNvZnR3YXJlXG4vL3RvIHNlZSB3aGV0aGVyIHRoaXMgaXMgc3RpbGwgYW4gaXNzdWUgb3Igbm90LlxudmFyIEdMWVBIX0RFU0lHTkVSX0VSUk9SID0gJ2NoYXNyc2V0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhvYmopIHtcbiAgaWYgKEdMWVBIX0RFU0lHTkVSX0VSUk9SIGluIG9iaikge1xuICAgIG9ialsnY2hhcnNldCddID0gb2JqW0dMWVBIX0RFU0lHTkVSX0VSUk9SXVxuICAgIGRlbGV0ZSBvYmpbR0xZUEhfREVTSUdORVJfRVJST1JdXG4gIH1cblxuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGlmIChrID09PSAnZmFjZScgfHwgayA9PT0gJ2NoYXJzZXQnKSBcbiAgICAgIGNvbnRpbnVlXG4gICAgZWxzZSBpZiAoayA9PT0gJ3BhZGRpbmcnIHx8IGsgPT09ICdzcGFjaW5nJylcbiAgICAgIG9ialtrXSA9IHBhcnNlSW50TGlzdChvYmpba10pXG4gICAgZWxzZVxuICAgICAgb2JqW2tdID0gcGFyc2VJbnQob2JqW2tdLCAxMCkgXG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBwYXJzZUludExpc3QoZGF0YSkge1xuICByZXR1cm4gZGF0YS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMClcbiAgfSlcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2UtYm1mb250LXhtbC9saWIvcGFyc2UtYXR0cmlicy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24geG1scGFyc2VyKCkge1xuICAvL2NvbW1vbiBicm93c2Vyc1xuICBpZiAodHlwZW9mIHNlbGYuRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgc2VsZi5ET01QYXJzZXIoKVxuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyLCAnYXBwbGljYXRpb24veG1sJylcbiAgICB9XG4gIH0gXG5cbiAgLy9JRTggZmFsbGJhY2tcbiAgaWYgKHR5cGVvZiBzZWxmLkFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiBuZXcgc2VsZi5BY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgeG1sRG9jID0gbmV3IHNlbGYuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIilcbiAgICAgIHhtbERvYy5hc3luYyA9IFwiZmFsc2VcIlxuICAgICAgeG1sRG9jLmxvYWRYTUwoc3RyKVxuICAgICAgcmV0dXJuIHhtbERvY1xuICAgIH1cbiAgfVxuXG4gIC8vbGFzdCByZXNvcnQgZmFsbGJhY2tcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGRpdi5pbm5lckhUTUwgPSBzdHJcbiAgICByZXR1cm4gZGl2XG4gIH1cbn0pKClcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94bWwtcGFyc2UtZnJvbS1zdHJpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIRUFERVIgPSBbNjYsIDc3LCA3MF1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWFkQk1Gb250QmluYXJ5KGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA8IDYpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ1ZmZlciBsZW5ndGggZm9yIEJNRm9udCcpXG5cbiAgdmFyIGhlYWRlciA9IEhFQURFUi5ldmVyeShmdW5jdGlvbihieXRlLCBpKSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkVUludDgoaSkgPT09IGJ5dGVcbiAgfSlcblxuICBpZiAoIWhlYWRlcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JNRm9udCBtaXNzaW5nIEJNRiBieXRlIGhlYWRlcicpXG5cbiAgdmFyIGkgPSAzXG4gIHZhciB2ZXJzID0gYnVmLnJlYWRVSW50OChpKyspXG4gIGlmICh2ZXJzID4gMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgc3VwcG9ydHMgQk1Gb250IEJpbmFyeSB2MyAoQk1Gb250IEFwcCB2MS4xMCknKVxuICBcbiAgdmFyIHRhcmdldCA9IHsga2VybmluZ3M6IFtdLCBjaGFyczogW10gfVxuICBmb3IgKHZhciBiPTA7IGI8NTsgYisrKVxuICAgIGkgKz0gcmVhZEJsb2NrKHRhcmdldCwgYnVmLCBpKVxuICByZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9jayh0YXJnZXQsIGJ1ZiwgaSkge1xuICBpZiAoaSA+IGJ1Zi5sZW5ndGgtMSlcbiAgICByZXR1cm4gMFxuXG4gIHZhciBibG9ja0lEID0gYnVmLnJlYWRVSW50OChpKyspXG4gIHZhciBibG9ja1NpemUgPSBidWYucmVhZEludDMyTEUoaSlcbiAgaSArPSA0XG5cbiAgc3dpdGNoKGJsb2NrSUQpIHtcbiAgICBjYXNlIDE6IFxuICAgICAgdGFyZ2V0LmluZm8gPSByZWFkSW5mbyhidWYsIGkpXG4gICAgICBicmVha1xuICAgIGNhc2UgMjpcbiAgICAgIHRhcmdldC5jb21tb24gPSByZWFkQ29tbW9uKGJ1ZiwgaSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAzOlxuICAgICAgdGFyZ2V0LnBhZ2VzID0gcmVhZFBhZ2VzKGJ1ZiwgaSwgYmxvY2tTaXplKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDQ6XG4gICAgICB0YXJnZXQuY2hhcnMgPSByZWFkQ2hhcnMoYnVmLCBpLCBibG9ja1NpemUpXG4gICAgICBicmVha1xuICAgIGNhc2UgNTpcbiAgICAgIHRhcmdldC5rZXJuaW5ncyA9IHJlYWRLZXJuaW5ncyhidWYsIGksIGJsb2NrU2l6ZSlcbiAgICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIDUgKyBibG9ja1NpemVcbn1cblxuZnVuY3Rpb24gcmVhZEluZm8oYnVmLCBpKSB7XG4gIHZhciBpbmZvID0ge31cbiAgaW5mby5zaXplID0gYnVmLnJlYWRJbnQxNkxFKGkpXG5cbiAgdmFyIGJpdEZpZWxkID0gYnVmLnJlYWRVSW50OChpKzIpXG4gIGluZm8uc21vb3RoID0gKGJpdEZpZWxkID4+IDcpICYgMVxuICBpbmZvLnVuaWNvZGUgPSAoYml0RmllbGQgPj4gNikgJiAxXG4gIGluZm8uaXRhbGljID0gKGJpdEZpZWxkID4+IDUpICYgMVxuICBpbmZvLmJvbGQgPSAoYml0RmllbGQgPj4gNCkgJiAxXG4gIFxuICAvL2ZpeGVkSGVpZ2h0IGlzIG9ubHkgbWVudGlvbmVkIGluIGJpbmFyeSBzcGVjIFxuICBpZiAoKGJpdEZpZWxkID4+IDMpICYgMSlcbiAgICBpbmZvLmZpeGVkSGVpZ2h0ID0gMVxuICBcbiAgaW5mby5jaGFyc2V0ID0gYnVmLnJlYWRVSW50OChpKzMpIHx8ICcnXG4gIGluZm8uc3RyZXRjaEggPSBidWYucmVhZFVJbnQxNkxFKGkrNClcbiAgaW5mby5hYSA9IGJ1Zi5yZWFkVUludDgoaSs2KVxuICBpbmZvLnBhZGRpbmcgPSBbXG4gICAgYnVmLnJlYWRJbnQ4KGkrNyksXG4gICAgYnVmLnJlYWRJbnQ4KGkrOCksXG4gICAgYnVmLnJlYWRJbnQ4KGkrOSksXG4gICAgYnVmLnJlYWRJbnQ4KGkrMTApXG4gIF1cbiAgaW5mby5zcGFjaW5nID0gW1xuICAgIGJ1Zi5yZWFkSW50OChpKzExKSxcbiAgICBidWYucmVhZEludDgoaSsxMilcbiAgXVxuICBpbmZvLm91dGxpbmUgPSBidWYucmVhZFVJbnQ4KGkrMTMpXG4gIGluZm8uZmFjZSA9IHJlYWRTdHJpbmdOVChidWYsIGkrMTQpXG4gIHJldHVybiBpbmZvXG59XG5cbmZ1bmN0aW9uIHJlYWRDb21tb24oYnVmLCBpKSB7XG4gIHZhciBjb21tb24gPSB7fVxuICBjb21tb24ubGluZUhlaWdodCA9IGJ1Zi5yZWFkVUludDE2TEUoaSlcbiAgY29tbW9uLmJhc2UgPSBidWYucmVhZFVJbnQxNkxFKGkrMilcbiAgY29tbW9uLnNjYWxlVyA9IGJ1Zi5yZWFkVUludDE2TEUoaSs0KVxuICBjb21tb24uc2NhbGVIID0gYnVmLnJlYWRVSW50MTZMRShpKzYpXG4gIGNvbW1vbi5wYWdlcyA9IGJ1Zi5yZWFkVUludDE2TEUoaSs4KVxuICB2YXIgYml0RmllbGQgPSBidWYucmVhZFVJbnQ4KGkrMTApXG4gIGNvbW1vbi5wYWNrZWQgPSAwXG4gIGNvbW1vbi5hbHBoYUNobmwgPSBidWYucmVhZFVJbnQ4KGkrMTEpXG4gIGNvbW1vbi5yZWRDaG5sID0gYnVmLnJlYWRVSW50OChpKzEyKVxuICBjb21tb24uZ3JlZW5DaG5sID0gYnVmLnJlYWRVSW50OChpKzEzKVxuICBjb21tb24uYmx1ZUNobmwgPSBidWYucmVhZFVJbnQ4KGkrMTQpXG4gIHJldHVybiBjb21tb25cbn1cblxuZnVuY3Rpb24gcmVhZFBhZ2VzKGJ1ZiwgaSwgc2l6ZSkge1xuICB2YXIgcGFnZXMgPSBbXVxuICB2YXIgdGV4dCA9IHJlYWROYW1lTlQoYnVmLCBpKVxuICB2YXIgbGVuID0gdGV4dC5sZW5ndGgrMVxuICB2YXIgY291bnQgPSBzaXplIC8gbGVuXG4gIGZvciAodmFyIGM9MDsgYzxjb3VudDsgYysrKSB7XG4gICAgcGFnZXNbY10gPSBidWYuc2xpY2UoaSwgaSt0ZXh0Lmxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIGkgKz0gbGVuXG4gIH1cbiAgcmV0dXJuIHBhZ2VzXG59XG5cbmZ1bmN0aW9uIHJlYWRDaGFycyhidWYsIGksIGJsb2NrU2l6ZSkge1xuICB2YXIgY2hhcnMgPSBbXVxuXG4gIHZhciBjb3VudCA9IGJsb2NrU2l6ZSAvIDIwXG4gIGZvciAodmFyIGM9MDsgYzxjb3VudDsgYysrKSB7XG4gICAgdmFyIGNoYXIgPSB7fVxuICAgIHZhciBvZmYgPSBjKjIwXG4gICAgY2hhci5pZCA9IGJ1Zi5yZWFkVUludDMyTEUoaSArIDAgKyBvZmYpXG4gICAgY2hhci54ID0gYnVmLnJlYWRVSW50MTZMRShpICsgNCArIG9mZilcbiAgICBjaGFyLnkgPSBidWYucmVhZFVJbnQxNkxFKGkgKyA2ICsgb2ZmKVxuICAgIGNoYXIud2lkdGggPSBidWYucmVhZFVJbnQxNkxFKGkgKyA4ICsgb2ZmKVxuICAgIGNoYXIuaGVpZ2h0ID0gYnVmLnJlYWRVSW50MTZMRShpICsgMTAgKyBvZmYpXG4gICAgY2hhci54b2Zmc2V0ID0gYnVmLnJlYWRJbnQxNkxFKGkgKyAxMiArIG9mZilcbiAgICBjaGFyLnlvZmZzZXQgPSBidWYucmVhZEludDE2TEUoaSArIDE0ICsgb2ZmKVxuICAgIGNoYXIueGFkdmFuY2UgPSBidWYucmVhZEludDE2TEUoaSArIDE2ICsgb2ZmKVxuICAgIGNoYXIucGFnZSA9IGJ1Zi5yZWFkVUludDgoaSArIDE4ICsgb2ZmKVxuICAgIGNoYXIuY2hubCA9IGJ1Zi5yZWFkVUludDgoaSArIDE5ICsgb2ZmKVxuICAgIGNoYXJzW2NdID0gY2hhclxuICB9XG4gIHJldHVybiBjaGFyc1xufVxuXG5mdW5jdGlvbiByZWFkS2VybmluZ3MoYnVmLCBpLCBibG9ja1NpemUpIHtcbiAgdmFyIGtlcm5pbmdzID0gW11cbiAgdmFyIGNvdW50ID0gYmxvY2tTaXplIC8gMTBcbiAgZm9yICh2YXIgYz0wOyBjPGNvdW50OyBjKyspIHtcbiAgICB2YXIga2VybiA9IHt9XG4gICAgdmFyIG9mZiA9IGMqMTBcbiAgICBrZXJuLmZpcnN0ID0gYnVmLnJlYWRVSW50MzJMRShpICsgMCArIG9mZilcbiAgICBrZXJuLnNlY29uZCA9IGJ1Zi5yZWFkVUludDMyTEUoaSArIDQgKyBvZmYpXG4gICAga2Vybi5hbW91bnQgPSBidWYucmVhZEludDE2TEUoaSArIDggKyBvZmYpXG4gICAga2VybmluZ3NbY10gPSBrZXJuXG4gIH1cbiAgcmV0dXJuIGtlcm5pbmdzXG59XG5cbmZ1bmN0aW9uIHJlYWROYW1lTlQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHBvcz1vZmZzZXRcbiAgZm9yICg7IHBvczxidWYubGVuZ3RoOyBwb3MrKykge1xuICAgIGlmIChidWZbcG9zXSA9PT0gMHgwMCkgXG4gICAgICBicmVha1xuICB9XG4gIHJldHVybiBidWYuc2xpY2Uob2Zmc2V0LCBwb3MpXG59XG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmdOVChidWYsIG9mZnNldCkge1xuICByZXR1cm4gcmVhZE5hbWVOVChidWYsIG9mZnNldCkudG9TdHJpbmcoJ3V0ZjgnKVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1ibWZvbnQtYmluYXJ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXF1YWwgPSByZXF1aXJlKCdidWZmZXItZXF1YWwnKVxudmFyIEhFQURFUiA9IG5ldyBCdWZmZXIoWzY2LCA3NywgNzAsIDNdKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1Zikge1xuICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIGJ1Zi5zdWJzdHJpbmcoMCwgMykgPT09ICdCTUYnXG4gIHJldHVybiBidWYubGVuZ3RoID4gNCAmJiBlcXVhbChidWYuc2xpY2UoMCwgNCksIEhFQURFUilcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9hZC1ibWZvbnQvbGliL2lzLWJpbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjsgLy8gZm9yIHVzZSB3aXRoIGJyb3dzZXJpZnlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBhLmVxdWFscyhiKTtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXItZXF1YWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXJyYXlidWZmZXJFcXVhbCAoYnVmMSwgYnVmMikge1xuICBpZiAoYnVmMSA9PT0gYnVmMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGJ1ZjEuYnl0ZUxlbmd0aCAhPT0gYnVmMi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZpZXcxID0gbmV3IERhdGFWaWV3KGJ1ZjEpO1xuICB2YXIgdmlldzIgPSBuZXcgRGF0YVZpZXcoYnVmMik7XG5cbiAgdmFyIGkgPSBidWYxLmJ5dGVMZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodmlldzEuZ2V0VWludDgoaSkgIT09IHZpZXcyLmdldFVpbnQ4KGkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FycmF5YnVmZmVyLWVxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgd29yZFdyYXAgPSByZXF1aXJlKCd3b3JkLXdyYXBwZXInKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIG51bWJlciA9IHJlcXVpcmUoJ2FzLW51bWJlcicpXG5cbnZhciBYX0hFSUdIVFMgPSBbJ3gnLCAnZScsICdhJywgJ28nLCAnbicsICdzJywgJ3InLCAnYycsICd1JywgJ20nLCAndicsICd3JywgJ3onXVxudmFyIE1fV0lEVEhTID0gWydtJywgJ3cnXVxudmFyIENBUF9IRUlHSFRTID0gWydIJywgJ0knLCAnTicsICdFJywgJ0YnLCAnSycsICdMJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXVxuXG5cbnZhciBUQUJfSUQgPSAnXFx0Jy5jaGFyQ29kZUF0KDApXG52YXIgU1BBQ0VfSUQgPSAnICcuY2hhckNvZGVBdCgwKVxudmFyIEFMSUdOX0xFRlQgPSAwLCBcbiAgICBBTElHTl9DRU5URVIgPSAxLCBcbiAgICBBTElHTl9SSUdIVCA9IDJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXQob3B0KSB7XG4gIHJldHVybiBuZXcgVGV4dExheW91dChvcHQpXG59XG5cbmZ1bmN0aW9uIFRleHRMYXlvdXQob3B0KSB7XG4gIHRoaXMuZ2x5cGhzID0gW11cbiAgdGhpcy5fbWVhc3VyZSA9IHRoaXMuY29tcHV0ZU1ldHJpY3MuYmluZCh0aGlzKVxuICB0aGlzLnVwZGF0ZShvcHQpXG59XG5cblRleHRMYXlvdXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSB4dGVuZCh7XG4gICAgbWVhc3VyZTogdGhpcy5fbWVhc3VyZVxuICB9LCBvcHQpXG4gIHRoaXMuX29wdCA9IG9wdFxuICB0aGlzLl9vcHQudGFiU2l6ZSA9IG51bWJlcih0aGlzLl9vcHQudGFiU2l6ZSwgNClcblxuICBpZiAoIW9wdC5mb250KVxuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGEgdmFsaWQgYml0bWFwIGZvbnQnKVxuXG4gIHZhciBnbHlwaHMgPSB0aGlzLmdseXBoc1xuICB2YXIgdGV4dCA9IG9wdC50ZXh0fHwnJyBcbiAgdmFyIGZvbnQgPSBvcHQuZm9udFxuICB0aGlzLl9zZXR1cFNwYWNlR2x5cGhzKGZvbnQpXG4gIFxuICB2YXIgbGluZXMgPSB3b3JkV3JhcC5saW5lcyh0ZXh0LCBvcHQpXG4gIHZhciBtaW5XaWR0aCA9IG9wdC53aWR0aCB8fCAwXG5cbiAgLy9jbGVhciBnbHlwaHNcbiAgZ2x5cGhzLmxlbmd0aCA9IDBcblxuICAvL2dldCBtYXggbGluZSB3aWR0aFxuICB2YXIgbWF4TGluZVdpZHRoID0gbGluZXMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGxpbmUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgbGluZS53aWR0aCwgbWluV2lkdGgpXG4gIH0sIDApXG5cbiAgLy90aGUgcGVuIHBvc2l0aW9uXG4gIHZhciB4ID0gMFxuICB2YXIgeSA9IDBcbiAgdmFyIGxpbmVIZWlnaHQgPSBudW1iZXIob3B0LmxpbmVIZWlnaHQsIGZvbnQuY29tbW9uLmxpbmVIZWlnaHQpXG4gIHZhciBiYXNlbGluZSA9IGZvbnQuY29tbW9uLmJhc2VcbiAgdmFyIGRlc2NlbmRlciA9IGxpbmVIZWlnaHQtYmFzZWxpbmVcbiAgdmFyIGxldHRlclNwYWNpbmcgPSBvcHQubGV0dGVyU3BhY2luZyB8fCAwXG4gIHZhciBoZWlnaHQgPSBsaW5lSGVpZ2h0ICogbGluZXMubGVuZ3RoIC0gZGVzY2VuZGVyXG4gIHZhciBhbGlnbiA9IGdldEFsaWduVHlwZSh0aGlzLl9vcHQuYWxpZ24pXG5cbiAgLy9kcmF3IHRleHQgYWxvbmcgYmFzZWxpbmVcbiAgeSAtPSBoZWlnaHRcbiAgXG4gIC8vdGhlIG1ldHJpY3MgZm9yIHRoaXMgdGV4dCBsYXlvdXRcbiAgdGhpcy5fd2lkdGggPSBtYXhMaW5lV2lkdGhcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0XG4gIHRoaXMuX2Rlc2NlbmRlciA9IGxpbmVIZWlnaHQgLSBiYXNlbGluZVxuICB0aGlzLl9iYXNlbGluZSA9IGJhc2VsaW5lXG4gIHRoaXMuX3hIZWlnaHQgPSBnZXRYSGVpZ2h0KGZvbnQpXG4gIHRoaXMuX2NhcEhlaWdodCA9IGdldENhcEhlaWdodChmb250KVxuICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodFxuICB0aGlzLl9hc2NlbmRlciA9IGxpbmVIZWlnaHQgLSBkZXNjZW5kZXIgLSB0aGlzLl94SGVpZ2h0XG4gICAgXG4gIC8vbGF5b3V0IGVhY2ggZ2x5cGhcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSwgbGluZUluZGV4KSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluZS5zdGFydFxuICAgIHZhciBlbmQgPSBsaW5lLmVuZFxuICAgIHZhciBsaW5lV2lkdGggPSBsaW5lLndpZHRoXG4gICAgdmFyIGxhc3RHbHlwaFxuICAgIFxuICAgIC8vZm9yIGVhY2ggZ2x5cGggaW4gdGhhdCBsaW5lLi4uXG4gICAgZm9yICh2YXIgaT1zdGFydDsgaTxlbmQ7IGkrKykge1xuICAgICAgdmFyIGlkID0gdGV4dC5jaGFyQ29kZUF0KGkpXG4gICAgICB2YXIgZ2x5cGggPSBzZWxmLmdldEdseXBoKGZvbnQsIGlkKVxuICAgICAgaWYgKGdseXBoKSB7XG4gICAgICAgIGlmIChsYXN0R2x5cGgpIFxuICAgICAgICAgIHggKz0gZ2V0S2VybmluZyhmb250LCBsYXN0R2x5cGguaWQsIGdseXBoLmlkKVxuXG4gICAgICAgIHZhciB0eCA9IHhcbiAgICAgICAgaWYgKGFsaWduID09PSBBTElHTl9DRU5URVIpIFxuICAgICAgICAgIHR4ICs9IChtYXhMaW5lV2lkdGgtbGluZVdpZHRoKS8yXG4gICAgICAgIGVsc2UgaWYgKGFsaWduID09PSBBTElHTl9SSUdIVClcbiAgICAgICAgICB0eCArPSAobWF4TGluZVdpZHRoLWxpbmVXaWR0aClcblxuICAgICAgICBnbHlwaHMucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IFt0eCwgeV0sXG4gICAgICAgICAgZGF0YTogZ2x5cGgsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgbGluZTogbGluZUluZGV4XG4gICAgICAgIH0pICBcblxuICAgICAgICAvL21vdmUgcGVuIGZvcndhcmRcbiAgICAgICAgeCArPSBnbHlwaC54YWR2YW5jZSArIGxldHRlclNwYWNpbmdcbiAgICAgICAgbGFzdEdseXBoID0gZ2x5cGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL25leHQgbGluZSBkb3duXG4gICAgeSArPSBsaW5lSGVpZ2h0XG4gICAgeCA9IDBcbiAgfSlcbiAgdGhpcy5fbGluZXNUb3RhbCA9IGxpbmVzLmxlbmd0aDtcbn1cblxuVGV4dExheW91dC5wcm90b3R5cGUuX3NldHVwU3BhY2VHbHlwaHMgPSBmdW5jdGlvbihmb250KSB7XG4gIC8vVGhlc2UgYXJlIGZhbGxiYWNrcywgd2hlbiB0aGUgZm9udCBkb2Vzbid0IGluY2x1ZGVcbiAgLy8nICcgb3IgJ1xcdCcgZ2x5cGhzXG4gIHRoaXMuX2ZhbGxiYWNrU3BhY2VHbHlwaCA9IG51bGxcbiAgdGhpcy5fZmFsbGJhY2tUYWJHbHlwaCA9IG51bGxcblxuICBpZiAoIWZvbnQuY2hhcnMgfHwgZm9udC5jaGFycy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuXG5cbiAgLy90cnkgdG8gZ2V0IHNwYWNlIGdseXBoXG4gIC8vdGhlbiBmYWxsIGJhY2sgdG8gdGhlICdtJyBvciAndycgZ2x5cGhzXG4gIC8vdGhlbiBmYWxsIGJhY2sgdG8gdGhlIGZpcnN0IGdseXBoIGF2YWlsYWJsZVxuICB2YXIgc3BhY2UgPSBnZXRHbHlwaEJ5SWQoZm9udCwgU1BBQ0VfSUQpIFxuICAgICAgICAgIHx8IGdldE1HbHlwaChmb250KSBcbiAgICAgICAgICB8fCBmb250LmNoYXJzWzBdXG5cbiAgLy9hbmQgY3JlYXRlIGEgZmFsbGJhY2sgZm9yIHRhYlxuICB2YXIgdGFiV2lkdGggPSB0aGlzLl9vcHQudGFiU2l6ZSAqIHNwYWNlLnhhZHZhbmNlXG4gIHRoaXMuX2ZhbGxiYWNrU3BhY2VHbHlwaCA9IHNwYWNlXG4gIHRoaXMuX2ZhbGxiYWNrVGFiR2x5cGggPSB4dGVuZChzcGFjZSwge1xuICAgIHg6IDAsIHk6IDAsIHhhZHZhbmNlOiB0YWJXaWR0aCwgaWQ6IFRBQl9JRCwgXG4gICAgeG9mZnNldDogMCwgeW9mZnNldDogMCwgd2lkdGg6IDAsIGhlaWdodDogMFxuICB9KVxufVxuXG5UZXh0TGF5b3V0LnByb3RvdHlwZS5nZXRHbHlwaCA9IGZ1bmN0aW9uKGZvbnQsIGlkKSB7XG4gIHZhciBnbHlwaCA9IGdldEdseXBoQnlJZChmb250LCBpZClcbiAgaWYgKGdseXBoKVxuICAgIHJldHVybiBnbHlwaFxuICBlbHNlIGlmIChpZCA9PT0gVEFCX0lEKSBcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUYWJHbHlwaFxuICBlbHNlIGlmIChpZCA9PT0gU1BBQ0VfSUQpIFxuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1NwYWNlR2x5cGhcbiAgcmV0dXJuIG51bGxcbn1cblxuVGV4dExheW91dC5wcm90b3R5cGUuY29tcHV0ZU1ldHJpY3MgPSBmdW5jdGlvbih0ZXh0LCBzdGFydCwgZW5kLCB3aWR0aCkge1xuICB2YXIgbGV0dGVyU3BhY2luZyA9IHRoaXMuX29wdC5sZXR0ZXJTcGFjaW5nIHx8IDBcbiAgdmFyIGZvbnQgPSB0aGlzLl9vcHQuZm9udFxuICB2YXIgY3VyUGVuID0gMFxuICB2YXIgY3VyV2lkdGggPSAwXG4gIHZhciBjb3VudCA9IDBcbiAgdmFyIGdseXBoXG4gIHZhciBsYXN0R2x5cGhcblxuICBpZiAoIWZvbnQuY2hhcnMgfHwgZm9udC5jaGFycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBzdGFydCxcbiAgICAgIHdpZHRoOiAwXG4gICAgfVxuICB9XG5cbiAgZW5kID0gTWF0aC5taW4odGV4dC5sZW5ndGgsIGVuZClcbiAgZm9yICh2YXIgaT1zdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGlkID0gdGV4dC5jaGFyQ29kZUF0KGkpXG4gICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChmb250LCBpZClcblxuICAgIGlmIChnbHlwaCkge1xuICAgICAgLy9tb3ZlIHBlbiBmb3J3YXJkXG4gICAgICB2YXIgeG9mZiA9IGdseXBoLnhvZmZzZXRcbiAgICAgIHZhciBrZXJuID0gbGFzdEdseXBoID8gZ2V0S2VybmluZyhmb250LCBsYXN0R2x5cGguaWQsIGdseXBoLmlkKSA6IDBcbiAgICAgIGN1clBlbiArPSBrZXJuXG5cbiAgICAgIHZhciBuZXh0UGVuID0gY3VyUGVuICsgZ2x5cGgueGFkdmFuY2UgKyBsZXR0ZXJTcGFjaW5nXG4gICAgICB2YXIgbmV4dFdpZHRoID0gY3VyUGVuICsgZ2x5cGgud2lkdGhcblxuICAgICAgLy93ZSd2ZSBoaXQgb3VyIGxpbWl0OyB3ZSBjYW4ndCBtb3ZlIG9udG8gdGhlIG5leHQgZ2x5cGhcbiAgICAgIGlmIChuZXh0V2lkdGggPj0gd2lkdGggfHwgbmV4dFBlbiA+PSB3aWR0aClcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy9vdGhlcndpc2UgY29udGludWUgYWxvbmcgb3VyIGxpbmVcbiAgICAgIGN1clBlbiA9IG5leHRQZW5cbiAgICAgIGN1cldpZHRoID0gbmV4dFdpZHRoXG4gICAgICBsYXN0R2x5cGggPSBnbHlwaFxuICAgIH1cbiAgICBjb3VudCsrXG4gIH1cbiAgXG4gIC8vbWFrZSBzdXJlIHJpZ2h0bW9zdCBlZGdlIGxpbmVzIHVwIHdpdGggcmVuZGVyZWQgZ2x5cGhzXG4gIGlmIChsYXN0R2x5cGgpXG4gICAgY3VyV2lkdGggKz0gbGFzdEdseXBoLnhvZmZzZXRcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IHN0YXJ0ICsgY291bnQsXG4gICAgd2lkdGg6IGN1cldpZHRoXG4gIH1cbn1cblxuLy9nZXR0ZXJzIGZvciB0aGUgcHJpdmF0ZSB2YXJzXG47Wyd3aWR0aCcsICdoZWlnaHQnLCBcbiAgJ2Rlc2NlbmRlcicsICdhc2NlbmRlcicsXG4gICd4SGVpZ2h0JywgJ2Jhc2VsaW5lJyxcbiAgJ2NhcEhlaWdodCcsXG4gICdsaW5lSGVpZ2h0JyBdLmZvckVhY2goYWRkR2V0dGVyKVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIobmFtZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dExheW91dC5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICBnZXQ6IHdyYXBwZXIobmFtZSksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8vY3JlYXRlIGxvb2t1cHMgZm9yIHByaXZhdGUgdmFyc1xuZnVuY3Rpb24gd3JhcHBlcihuYW1lKSB7XG4gIHJldHVybiAobmV3IEZ1bmN0aW9uKFtcbiAgICAncmV0dXJuIGZ1bmN0aW9uICcrbmFtZSsnKCkgeycsXG4gICAgJyAgcmV0dXJuIHRoaXMuXycrbmFtZSxcbiAgICAnfSdcbiAgXS5qb2luKCdcXG4nKSkpKClcbn1cblxuZnVuY3Rpb24gZ2V0R2x5cGhCeUlkKGZvbnQsIGlkKSB7XG4gIGlmICghZm9udC5jaGFycyB8fCBmb250LmNoYXJzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbFxuXG4gIHZhciBnbHlwaElkeCA9IGZpbmRDaGFyKGZvbnQuY2hhcnMsIGlkKVxuICBpZiAoZ2x5cGhJZHggPj0gMClcbiAgICByZXR1cm4gZm9udC5jaGFyc1tnbHlwaElkeF1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gZ2V0WEhlaWdodChmb250KSB7XG4gIGZvciAodmFyIGk9MDsgaTxYX0hFSUdIVFMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWQgPSBYX0hFSUdIVFNbaV0uY2hhckNvZGVBdCgwKVxuICAgIHZhciBpZHggPSBmaW5kQ2hhcihmb250LmNoYXJzLCBpZClcbiAgICBpZiAoaWR4ID49IDApIFxuICAgICAgcmV0dXJuIGZvbnQuY2hhcnNbaWR4XS5oZWlnaHRcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBnZXRNR2x5cGgoZm9udCkge1xuICBmb3IgKHZhciBpPTA7IGk8TV9XSURUSFMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWQgPSBNX1dJRFRIU1tpXS5jaGFyQ29kZUF0KDApXG4gICAgdmFyIGlkeCA9IGZpbmRDaGFyKGZvbnQuY2hhcnMsIGlkKVxuICAgIGlmIChpZHggPj0gMCkgXG4gICAgICByZXR1cm4gZm9udC5jaGFyc1tpZHhdXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gZ2V0Q2FwSGVpZ2h0KGZvbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPENBUF9IRUlHSFRTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlkID0gQ0FQX0hFSUdIVFNbaV0uY2hhckNvZGVBdCgwKVxuICAgIHZhciBpZHggPSBmaW5kQ2hhcihmb250LmNoYXJzLCBpZClcbiAgICBpZiAoaWR4ID49IDApIFxuICAgICAgcmV0dXJuIGZvbnQuY2hhcnNbaWR4XS5oZWlnaHRcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBnZXRLZXJuaW5nKGZvbnQsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghZm9udC5rZXJuaW5ncyB8fCBmb250Lmtlcm5pbmdzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gMFxuXG4gIHZhciB0YWJsZSA9IGZvbnQua2VybmluZ3NcbiAgZm9yICh2YXIgaT0wOyBpPHRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtlcm4gPSB0YWJsZVtpXVxuICAgIGlmIChrZXJuLmZpcnN0ID09PSBsZWZ0ICYmIGtlcm4uc2Vjb25kID09PSByaWdodClcbiAgICAgIHJldHVybiBrZXJuLmFtb3VudFxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGdldEFsaWduVHlwZShhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKVxuICAgIHJldHVybiBBTElHTl9DRU5URVJcbiAgZWxzZSBpZiAoYWxpZ24gPT09ICdyaWdodCcpXG4gICAgcmV0dXJuIEFMSUdOX1JJR0hUXG4gIHJldHVybiBBTElHTl9MRUZUXG59XG5cbmZ1bmN0aW9uIGZpbmRDaGFyIChhcnJheSwgdmFsdWUsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXS5pZCA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sYXlvdXQtYm1mb250LXRleHQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuZXdsaW5lID0gL1xcbi9cbnZhciBuZXdsaW5lQ2hhciA9ICdcXG4nXG52YXIgd2hpdGVzcGFjZSA9IC9cXHMvXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGV4dCwgb3B0KSB7XG4gICAgdmFyIGxpbmVzID0gbW9kdWxlLmV4cG9ydHMubGluZXModGV4dCwgb3B0KVxuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcobGluZS5zdGFydCwgbGluZS5lbmQpXG4gICAgfSkuam9pbignXFxuJylcbn1cblxubW9kdWxlLmV4cG9ydHMubGluZXMgPSBmdW5jdGlvbiB3b3Jkd3JhcCh0ZXh0LCBvcHQpIHtcbiAgICBvcHQgPSBvcHR8fHt9XG5cbiAgICAvL3plcm8gd2lkdGggcmVzdWx0cyBpbiBub3RoaW5nIHZpc2libGVcbiAgICBpZiAob3B0LndpZHRoID09PSAwICYmIG9wdC5tb2RlICE9PSAnbm93cmFwJykgXG4gICAgICAgIHJldHVybiBbXVxuXG4gICAgdGV4dCA9IHRleHR8fCcnXG4gICAgdmFyIHdpZHRoID0gdHlwZW9mIG9wdC53aWR0aCA9PT0gJ251bWJlcicgPyBvcHQud2lkdGggOiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgb3B0LnN0YXJ0fHwwKVxuICAgIHZhciBlbmQgPSB0eXBlb2Ygb3B0LmVuZCA9PT0gJ251bWJlcicgPyBvcHQuZW5kIDogdGV4dC5sZW5ndGhcbiAgICB2YXIgbW9kZSA9IG9wdC5tb2RlXG5cbiAgICB2YXIgbWVhc3VyZSA9IG9wdC5tZWFzdXJlIHx8IG1vbm9zcGFjZVxuICAgIGlmIChtb2RlID09PSAncHJlJylcbiAgICAgICAgcmV0dXJuIHByZShtZWFzdXJlLCB0ZXh0LCBzdGFydCwgZW5kLCB3aWR0aClcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBncmVlZHkobWVhc3VyZSwgdGV4dCwgc3RhcnQsIGVuZCwgd2lkdGgsIG1vZGUpXG59XG5cbmZ1bmN0aW9uIGlkeE9mKHRleHQsIGNociwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBpZHggPSB0ZXh0LmluZGV4T2YoY2hyLCBzdGFydClcbiAgICBpZiAoaWR4ID09PSAtMSB8fCBpZHggPiBlbmQpXG4gICAgICAgIHJldHVybiBlbmRcbiAgICByZXR1cm4gaWR4XG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjaHIpIHtcbiAgICByZXR1cm4gd2hpdGVzcGFjZS50ZXN0KGNocilcbn1cblxuZnVuY3Rpb24gcHJlKG1lYXN1cmUsIHRleHQsIHN0YXJ0LCBlbmQsIHdpZHRoKSB7XG4gICAgdmFyIGxpbmVzID0gW11cbiAgICB2YXIgbGluZVN0YXJ0ID0gc3RhcnRcbiAgICBmb3IgKHZhciBpPXN0YXJ0OyBpPGVuZCAmJiBpPHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IHRleHQuY2hhckF0KGkpXG4gICAgICAgIHZhciBpc05ld2xpbmUgPSBuZXdsaW5lLnRlc3QoY2hyKVxuXG4gICAgICAgIC8vSWYgd2UndmUgcmVhY2hlZCBhIG5ld2xpbmUsIHRoZW4gc3RlcCBkb3duIGEgbGluZVxuICAgICAgICAvL09yIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIEVPRlxuICAgICAgICBpZiAoaXNOZXdsaW5lIHx8IGk9PT1lbmQtMSkge1xuICAgICAgICAgICAgdmFyIGxpbmVFbmQgPSBpc05ld2xpbmUgPyBpIDogaSsxXG4gICAgICAgICAgICB2YXIgbWVhc3VyZWQgPSBtZWFzdXJlKHRleHQsIGxpbmVTdGFydCwgbGluZUVuZCwgd2lkdGgpXG4gICAgICAgICAgICBsaW5lcy5wdXNoKG1lYXN1cmVkKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBpKzFcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXNcbn1cblxuZnVuY3Rpb24gZ3JlZWR5KG1lYXN1cmUsIHRleHQsIHN0YXJ0LCBlbmQsIHdpZHRoLCBtb2RlKSB7XG4gICAgLy9BIGdyZWVkeSB3b3JkIHdyYXBwZXIgYmFzZWQgb24gTGliR0RYIGFsZ29yaXRobVxuICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9CaXRtYXBGb250Q2FjaGUuamF2YVxuICAgIHZhciBsaW5lcyA9IFtdXG5cbiAgICB2YXIgdGVzdFdpZHRoID0gd2lkdGhcbiAgICAvL2lmICdub3dyYXAnIGlzIHNwZWNpZmllZCwgd2Ugb25seSB3cmFwIG9uIG5ld2xpbmUgY2hhcnNcbiAgICBpZiAobW9kZSA9PT0gJ25vd3JhcCcpXG4gICAgICAgIHRlc3RXaWR0aCA9IE51bWJlci5NQVhfVkFMVUVcblxuICAgIHdoaWxlIChzdGFydCA8IGVuZCAmJiBzdGFydCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vZ2V0IG5leHQgbmV3bGluZSBwb3NpdGlvblxuICAgICAgICB2YXIgbmV3TGluZSA9IGlkeE9mKHRleHQsIG5ld2xpbmVDaGFyLCBzdGFydCwgZW5kKVxuXG4gICAgICAgIC8vZWF0IHdoaXRlc3BhY2UgYXQgc3RhcnQgb2YgbGluZVxuICAgICAgICB3aGlsZSAoc3RhcnQgPCBuZXdMaW5lKSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZSggdGV4dC5jaGFyQXQoc3RhcnQpICkpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIHN0YXJ0KytcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZGV0ZXJtaW5lIHZpc2libGUgIyBvZiBnbHlwaHMgZm9yIHRoZSBhdmFpbGFibGUgd2lkdGhcbiAgICAgICAgdmFyIG1lYXN1cmVkID0gbWVhc3VyZSh0ZXh0LCBzdGFydCwgbmV3TGluZSwgdGVzdFdpZHRoKVxuXG4gICAgICAgIHZhciBsaW5lRW5kID0gc3RhcnQgKyAobWVhc3VyZWQuZW5kLW1lYXN1cmVkLnN0YXJ0KVxuICAgICAgICB2YXIgbmV4dFN0YXJ0ID0gbGluZUVuZCArIG5ld2xpbmVDaGFyLmxlbmd0aFxuXG4gICAgICAgIC8vaWYgd2UgaGFkIHRvIGN1dCB0aGUgbGluZSBiZWZvcmUgdGhlIG5leHQgbmV3bGluZS4uLlxuICAgICAgICBpZiAobGluZUVuZCA8IG5ld0xpbmUpIHtcbiAgICAgICAgICAgIC8vZmluZCBjaGFyIHRvIGJyZWFrIG9uXG4gICAgICAgICAgICB3aGlsZSAobGluZUVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZSh0ZXh0LmNoYXJBdChsaW5lRW5kKSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgbGluZUVuZC0tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZUVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXJ0ID4gc3RhcnQgKyBuZXdsaW5lQ2hhci5sZW5ndGgpIG5leHRTdGFydC0tXG4gICAgICAgICAgICAgICAgbGluZUVuZCA9IG5leHRTdGFydCAvLyBJZiBubyBjaGFyYWN0ZXJzIHRvIGJyZWFrLCBzaG93IGFsbC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gbGluZUVuZFxuICAgICAgICAgICAgICAgIC8vZWF0IHdoaXRlc3BhY2UgYXQgZW5kIG9mIGxpbmVcbiAgICAgICAgICAgICAgICB3aGlsZSAobGluZUVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKHRleHQuY2hhckF0KGxpbmVFbmQgLSBuZXdsaW5lQ2hhci5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGxpbmVFbmQtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZUVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1lYXN1cmUodGV4dCwgc3RhcnQsIGxpbmVFbmQsIHRlc3RXaWR0aClcbiAgICAgICAgICAgIGxpbmVzLnB1c2gocmVzdWx0KVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gbmV4dFN0YXJ0XG4gICAgfVxuICAgIHJldHVybiBsaW5lc1xufVxuXG4vL2RldGVybWluZXMgdGhlIHZpc2libGUgbnVtYmVyIG9mIGdseXBocyB3aXRoaW4gYSBnaXZlbiB3aWR0aFxuZnVuY3Rpb24gbW9ub3NwYWNlKHRleHQsIHN0YXJ0LCBlbmQsIHdpZHRoKSB7XG4gICAgdmFyIGdseXBocyA9IE1hdGgubWluKHdpZHRoLCBlbmQtc3RhcnQpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IHN0YXJ0K2dseXBoc1xuICAgIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd29yZC13cmFwcGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG51bXR5cGUobnVtLCBkZWYpIHtcblx0cmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInXG5cdFx0PyBudW0gXG5cdFx0OiAodHlwZW9mIGRlZiA9PT0gJ251bWJlcicgPyBkZWYgOiAwKVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hcy1udW1iZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkdHlwZSA9IHJlcXVpcmUoJ2R0eXBlJylcbnZhciBhbkFycmF5ID0gcmVxdWlyZSgnYW4tYXJyYXknKVxudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJylcblxudmFyIENXID0gWzAsIDIsIDNdXG52YXIgQ0NXID0gWzIsIDEsIDNdXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlUXVhZEVsZW1lbnRzKGFycmF5LCBvcHQpIHtcbiAgICAvL2lmIHVzZXIgZGlkbid0IHNwZWNpZnkgYW4gb3V0cHV0IGFycmF5XG4gICAgaWYgKCFhcnJheSB8fCAhKGFuQXJyYXkoYXJyYXkpIHx8IGlzQnVmZmVyKGFycmF5KSkpIHtcbiAgICAgICAgb3B0ID0gYXJyYXkgfHwge31cbiAgICAgICAgYXJyYXkgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdudW1iZXInKSAvL2JhY2t3YXJkcy1jb21wYXRpYmxlXG4gICAgICAgIG9wdCA9IHsgY291bnQ6IG9wdCB9XG4gICAgZWxzZVxuICAgICAgICBvcHQgPSBvcHQgfHwge31cblxuICAgIHZhciB0eXBlID0gdHlwZW9mIG9wdC50eXBlID09PSAnc3RyaW5nJyA/IG9wdC50eXBlIDogJ3VpbnQxNidcbiAgICB2YXIgY291bnQgPSB0eXBlb2Ygb3B0LmNvdW50ID09PSAnbnVtYmVyJyA/IG9wdC5jb3VudCA6IDFcbiAgICB2YXIgc3RhcnQgPSAob3B0LnN0YXJ0IHx8IDApIFxuXG4gICAgdmFyIGRpciA9IG9wdC5jbG9ja3dpc2UgIT09IGZhbHNlID8gQ1cgOiBDQ1csXG4gICAgICAgIGEgPSBkaXJbMF0sIFxuICAgICAgICBiID0gZGlyWzFdLFxuICAgICAgICBjID0gZGlyWzJdXG5cbiAgICB2YXIgbnVtSW5kaWNlcyA9IGNvdW50ICogNlxuXG4gICAgdmFyIGluZGljZXMgPSBhcnJheSB8fCBuZXcgKGR0eXBlKHR5cGUpKShudW1JbmRpY2VzKVxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IG51bUluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICAgIHZhciB4ID0gaSArIHN0YXJ0XG4gICAgICAgIGluZGljZXNbeCArIDBdID0gaiArIDBcbiAgICAgICAgaW5kaWNlc1t4ICsgMV0gPSBqICsgMVxuICAgICAgICBpbmRpY2VzW3ggKyAyXSA9IGogKyAyXG4gICAgICAgIGluZGljZXNbeCArIDNdID0gaiArIGFcbiAgICAgICAgaW5kaWNlc1t4ICsgNF0gPSBqICsgYlxuICAgICAgICBpbmRpY2VzW3ggKyA1XSA9IGogKyBjXG4gICAgfVxuICAgIHJldHVybiBpbmRpY2VzXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1YWQtaW5kaWNlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkdHlwZSkge1xuICBzd2l0Y2ggKGR0eXBlKSB7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gSW50OEFycmF5XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIEludDE2QXJyYXlcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gSW50MzJBcnJheVxuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBVaW50MTZBcnJheVxuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXlcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXlcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBGbG9hdDY0QXJyYXlcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4gQXJyYXlcbiAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgIHJldHVybiBVaW50OENsYW1wZWRBcnJheVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZHR5cGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gYW5BcnJheVxuXG5mdW5jdGlvbiBhbkFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGFyci5CWVRFU19QRVJfRUxFTUVOVFxuICAgICYmIHN0ci5jYWxsKGFyci5idWZmZXIpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nXG4gICAgfHwgQXJyYXkuaXNBcnJheShhcnIpXG4gIClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbi1hcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXMtYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cy5wYWdlcyA9IGZ1bmN0aW9uIHBhZ2VzIChnbHlwaHMpIHtcclxuICB2YXIgcGFnZXMgPSBuZXcgRmxvYXQzMkFycmF5KGdseXBocy5sZW5ndGggKiA0ICogMSlcclxuICB2YXIgaSA9IDBcclxuICBnbHlwaHMuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGgpIHtcclxuICAgIHZhciBpZCA9IGdseXBoLmRhdGEucGFnZSB8fCAwXHJcbiAgICBwYWdlc1tpKytdID0gaWRcclxuICAgIHBhZ2VzW2krK10gPSBpZFxyXG4gICAgcGFnZXNbaSsrXSA9IGlkXHJcbiAgICBwYWdlc1tpKytdID0gaWRcclxuICB9KVxyXG4gIHJldHVybiBwYWdlc1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy51dnMgPSBmdW5jdGlvbiB1dnMgKGdseXBocywgdGV4V2lkdGgsIHRleEhlaWdodCwgZmxpcFkpIHtcclxuICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheShnbHlwaHMubGVuZ3RoICogNCAqIDIpXHJcbiAgdmFyIGkgPSAwXHJcbiAgZ2x5cGhzLmZvckVhY2goZnVuY3Rpb24gKGdseXBoKSB7XHJcbiAgICB2YXIgYml0bWFwID0gZ2x5cGguZGF0YVxyXG4gICAgdmFyIGJ3ID0gKGJpdG1hcC54ICsgYml0bWFwLndpZHRoKVxyXG4gICAgdmFyIGJoID0gKGJpdG1hcC55ICsgYml0bWFwLmhlaWdodClcclxuXHJcbiAgICAvLyB0b3AgbGVmdCBwb3NpdGlvblxyXG4gICAgdmFyIHUwID0gYml0bWFwLnggLyB0ZXhXaWR0aFxyXG4gICAgdmFyIHYxID0gYml0bWFwLnkgLyB0ZXhIZWlnaHRcclxuICAgIHZhciB1MSA9IGJ3IC8gdGV4V2lkdGhcclxuICAgIHZhciB2MCA9IGJoIC8gdGV4SGVpZ2h0XHJcblxyXG4gICAgaWYgKGZsaXBZKSB7XHJcbiAgICAgIHYxID0gKHRleEhlaWdodCAtIGJpdG1hcC55KSAvIHRleEhlaWdodFxyXG4gICAgICB2MCA9ICh0ZXhIZWlnaHQgLSBiaCkgLyB0ZXhIZWlnaHRcclxuICAgIH1cclxuXHJcbiAgICAvLyBCTFxyXG4gICAgdXZzW2krK10gPSB1MFxyXG4gICAgdXZzW2krK10gPSB2MVxyXG4gICAgLy8gVExcclxuICAgIHV2c1tpKytdID0gdTBcclxuICAgIHV2c1tpKytdID0gdjBcclxuICAgIC8vIFRSXHJcbiAgICB1dnNbaSsrXSA9IHUxXHJcbiAgICB1dnNbaSsrXSA9IHYwXHJcbiAgICAvLyBCUlxyXG4gICAgdXZzW2krK10gPSB1MVxyXG4gICAgdXZzW2krK10gPSB2MVxyXG4gIH0pXHJcbiAgcmV0dXJuIHV2c1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5wb3NpdGlvbnMgPSBmdW5jdGlvbiBwb3NpdGlvbnMgKGdseXBocykge1xyXG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KGdseXBocy5sZW5ndGggKiA0ICogMilcclxuICB2YXIgaSA9IDBcclxuICBnbHlwaHMuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGgpIHtcclxuICAgIHZhciBiaXRtYXAgPSBnbHlwaC5kYXRhXHJcblxyXG4gICAgLy8gYm90dG9tIGxlZnQgcG9zaXRpb25cclxuICAgIHZhciB4ID0gZ2x5cGgucG9zaXRpb25bMF0gKyBiaXRtYXAueG9mZnNldFxyXG4gICAgdmFyIHkgPSBnbHlwaC5wb3NpdGlvblsxXSArIGJpdG1hcC55b2Zmc2V0XHJcblxyXG4gICAgLy8gcXVhZCBzaXplXHJcbiAgICB2YXIgdyA9IGJpdG1hcC53aWR0aFxyXG4gICAgdmFyIGggPSBiaXRtYXAuaGVpZ2h0XHJcblxyXG4gICAgLy8gQkxcclxuICAgIHBvc2l0aW9uc1tpKytdID0geFxyXG4gICAgcG9zaXRpb25zW2krK10gPSB5XHJcbiAgICAvLyBUTFxyXG4gICAgcG9zaXRpb25zW2krK10gPSB4XHJcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHkgKyBoXHJcbiAgICAvLyBUUlxyXG4gICAgcG9zaXRpb25zW2krK10gPSB4ICsgd1xyXG4gICAgcG9zaXRpb25zW2krK10gPSB5ICsgaFxyXG4gICAgLy8gQlJcclxuICAgIHBvc2l0aW9uc1tpKytdID0geCArIHdcclxuICAgIHBvc2l0aW9uc1tpKytdID0geVxyXG4gIH0pXHJcbiAgcmV0dXJuIHBvc2l0aW9uc1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BsaWIvdmVydGljZXMuanMiXSwic291cmNlUm9vdCI6IiJ9

/*! howler.js v2.1.3 | (c) 2013-2019, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
! function () {
	"use strict";
	var e = function () {
		this.init()
	};
	e.prototype = {
		init: function () {
			var e = this || n;
			return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e
		},
		volume: function (e) {
			var o = this || n;
			if (e = parseFloat(e), o.ctx || _(), void 0 !== e && e >= 0 && e <= 1) {
				if (o._volume = e, o._muted) return o;
				o.usingWebAudio && o.masterGain.gain.setValueAtTime(e, n.ctx.currentTime);
				for (var t = 0; t < o._howls.length; t++)
					if (!o._howls[t]._webAudio)
						for (var r = o._howls[t]._getSoundIds(), a = 0; a < r.length; a++) {
							var u = o._howls[t]._soundById(r[a]);
							u && u._node && (u._node.volume = u._volume * e)
						}
				return o
			}
			return o._volume
		},
		mute: function (e) {
			var o = this || n;
			o.ctx || _(), o._muted = e, o.usingWebAudio && o.masterGain.gain.setValueAtTime(e ? 0 : o._volume, n.ctx.currentTime);
			for (var t = 0; t < o._howls.length; t++)
				if (!o._howls[t]._webAudio)
					for (var r = o._howls[t]._getSoundIds(), a = 0; a < r.length; a++) {
						var u = o._howls[t]._soundById(r[a]);
						u && u._node && (u._node.muted = !!e || u._muted)
					}
			return o
		},
		unload: function () {
			for (var e = this || n, o = e._howls.length - 1; o >= 0; o--) e._howls[o].unload();
			return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, _()), e
		},
		codecs: function (e) {
			return (this || n)._codecs[e.replace(/^x-/, "")]
		},
		_setup: function () {
			var e = this || n;
			if (e.state = e.ctx ? e.ctx.state || "suspended" : "suspended", e._autoSuspend(), !e.usingWebAudio)
				if ("undefined" != typeof Audio) try {
					var o = new Audio;
					void 0 === o.oncanplaythrough && (e._canPlayEvent = "canplay")
				} catch (n) {
					e.noAudio = !0
				} else e.noAudio = !0;
			try {
				var o = new Audio;
				o.muted && (e.noAudio = !0)
			} catch (e) {}
			return e.noAudio || e._setupCodecs(), e
		},
		_setupCodecs: function () {
			var e = this || n,
				o = null;
			try {
				o = "undefined" != typeof Audio ? new Audio : null
			} catch (n) {
				return e
			}
			if (!o || "function" != typeof o.canPlayType) return e;
			var t = o.canPlayType("audio/mpeg;").replace(/^no$/, ""),
				r = e._navigator && e._navigator.userAgent.match(/OPR\/([0-6].)/g),
				a = r && parseInt(r[0].split("/")[1], 10) < 33;
			return e._codecs = {
				mp3: !(a || !t && !o.canPlayType("audio/mp3;").replace(/^no$/, "")),
				mpeg: !!t,
				opus: !!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
				ogg: !!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
				oga: !!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
				wav: !!o.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
				aac: !!o.canPlayType("audio/aac;").replace(/^no$/, ""),
				caf: !!o.canPlayType("audio/x-caf;").replace(/^no$/, ""),
				m4a: !!(o.canPlayType("audio/x-m4a;") || o.canPlayType("audio/m4a;") || o.canPlayType("audio/aac;")).replace(/^no$/, ""),
				mp4: !!(o.canPlayType("audio/x-mp4;") || o.canPlayType("audio/mp4;") || o.canPlayType("audio/aac;")).replace(/^no$/, ""),
				weba: !!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
				webm: !!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
				dolby: !!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
				flac: !!(o.canPlayType("audio/x-flac;") || o.canPlayType("audio/flac;")).replace(/^no$/, "")
			}, e
		},
		_unlockAudio: function () {
			var e = this || n;
			if (!e._audioUnlocked && e.ctx) {
				e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
				var o = function (n) {
					for (var t = 0; t < e.html5PoolSize; t++) try {
						var r = new Audio;
						r._unlocked = !0, e._releaseHtml5Audio(r)
					} catch (n) {
						e.noAudio = !0
					}
					for (var t = 0; t < e._howls.length; t++)
						if (!e._howls[t]._webAudio)
							for (var a = e._howls[t]._getSoundIds(), u = 0; u < a.length; u++) {
								var i = e._howls[t]._soundById(a[u]);
								i && i._node && !i._node._unlocked && (i._node._unlocked = !0, i._node.load())
							}
					e._autoResume();
					var d = e.ctx.createBufferSource();
					d.buffer = e._scratchBuffer, d.connect(e.ctx.destination), void 0 === d.start ? d.noteOn(0) : d.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), d.onended = function () {
						d.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", o, !0), document.removeEventListener("touchend", o, !0), document.removeEventListener("click", o, !0);
						for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("unlock")
					}
				};
				return document.addEventListener("touchstart", o, !0), document.addEventListener("touchend", o, !0), document.addEventListener("click", o, !0), e
			}
		},
		_obtainHtml5Audio: function () {
			var e = this || n;
			if (e._html5AudioPool.length) return e._html5AudioPool.pop();
			var o = (new Audio).play();
			return o && "undefined" != typeof Promise && (o instanceof Promise || "function" == typeof o.then) && o.catch(function () {
				console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
			}), new Audio
		},
		_releaseHtml5Audio: function (e) {
			var o = this || n;
			return e._unlocked && o._html5AudioPool.push(e), o
		},
		_autoSuspend: function () {
			var e = this;
			if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && n.usingWebAudio) {
				for (var o = 0; o < e._howls.length; o++)
					if (e._howls[o]._webAudio)
						for (var t = 0; t < e._howls[o]._sounds.length; t++)
							if (!e._howls[o]._sounds[t]._paused) return e;
				return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function () {
					e.autoSuspend && (e._suspendTimer = null, e.state = "suspending", e.ctx.suspend().then(function () {
						e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume())
					}))
				}, 3e4), e
			}
		},
		_autoResume: function () {
			var e = this;
			if (e.ctx && void 0 !== e.ctx.resume && n.usingWebAudio) return "running" === e.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state ? (e.ctx.resume().then(function () {
				e.state = "running";
				for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("resume")
			}), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e
		}
	};
	var n = new e,
		o = function (e) {
			var n = this;
			if (!e.src || 0 === e.src.length) return void console.error("An array of source files must be passed with any new Howl.");
			n.init(e)
		};
	o.prototype = {
		init: function (e) {
			var o = this;
			return n.ctx || _(), o._autoplay = e.autoplay || !1, o._format = "string" != typeof e.format ? e.format : [e.format], o._html5 = e.html5 || !1, o._muted = e.mute || !1, o._loop = e.loop || !1, o._pool = e.pool || 5, o._preload = "boolean" != typeof e.preload || e.preload, o._rate = e.rate || 1, o._sprite = e.sprite || {}, o._src = "string" != typeof e.src ? e.src : [e.src], o._volume = void 0 !== e.volume ? e.volume : 1, o._xhrWithCredentials = e.xhrWithCredentials || !1, o._duration = 0, o._state = "unloaded", o._sounds = [], o._endTimers = {}, o._queue = [], o._playLock = !1, o._onend = e.onend ? [{
				fn: e.onend
			}] : [], o._onfade = e.onfade ? [{
				fn: e.onfade
			}] : [], o._onload = e.onload ? [{
				fn: e.onload
			}] : [], o._onloaderror = e.onloaderror ? [{
				fn: e.onloaderror
			}] : [], o._onplayerror = e.onplayerror ? [{
				fn: e.onplayerror
			}] : [], o._onpause = e.onpause ? [{
				fn: e.onpause
			}] : [], o._onplay = e.onplay ? [{
				fn: e.onplay
			}] : [], o._onstop = e.onstop ? [{
				fn: e.onstop
			}] : [], o._onmute = e.onmute ? [{
				fn: e.onmute
			}] : [], o._onvolume = e.onvolume ? [{
				fn: e.onvolume
			}] : [], o._onrate = e.onrate ? [{
				fn: e.onrate
			}] : [], o._onseek = e.onseek ? [{
				fn: e.onseek
			}] : [], o._onunlock = e.onunlock ? [{
				fn: e.onunlock
			}] : [], o._onresume = [], o._webAudio = n.usingWebAudio && !o._html5, void 0 !== n.ctx && n.ctx && n.autoUnlock && n._unlockAudio(), n._howls.push(o), o._autoplay && o._queue.push({
				event: "play",
				action: function () {
					o.play()
				}
			}), o._preload && o.load(), o
		},
		load: function () {
			var e = this,
				o = null;
			if (n.noAudio) return void e._emit("loaderror", null, "No audio support.");
			"string" == typeof e._src && (e._src = [e._src]);
			for (var r = 0; r < e._src.length; r++) {
				var u, i;
				if (e._format && e._format[r]) u = e._format[r];
				else {
					if ("string" != typeof (i = e._src[r])) {
						e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
						continue
					}
					u = /^data:audio\/([^;,]+);/i.exec(i), u || (u = /\.([^.]+)$/.exec(i.split("?", 1)[0])), u && (u = u[1].toLowerCase())
				}
				if (u || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), u && n.codecs(u)) {
					o = e._src[r];
					break
				}
			}
			return o ? (e._src = o, e._state = "loading", "https:" === window.location.protocol && "http:" === o.slice(0, 5) && (e._html5 = !0, e._webAudio = !1), new t(e), e._webAudio && a(e), e) : void e._emit("loaderror", null, "No codec support for selected audio sources.")
		},
		play: function (e, o) {
			var t = this,
				r = null;
			if ("number" == typeof e) r = e, e = null;
			else {
				if ("string" == typeof e && "loaded" === t._state && !t._sprite[e]) return null;
				if (void 0 === e && (e = "__default", !t._playLock)) {
					for (var a = 0, u = 0; u < t._sounds.length; u++) t._sounds[u]._paused && !t._sounds[u]._ended && (a++, r = t._sounds[u]._id);
					1 === a ? e = null : r = null
				}
			}
			var i = r ? t._soundById(r) : t._inactiveSound();
			if (!i) return null;
			if (r && !e && (e = i._sprite || "__default"), "loaded" !== t._state) {
				i._sprite = e, i._ended = !1;
				var d = i._id;
				return t._queue.push({
					event: "play",
					action: function () {
						t.play(d)
					}
				}), d
			}
			if (r && !i._paused) return o || t._loadQueue("play"), i._id;
			t._webAudio && n._autoResume();
			var _ = Math.max(0, i._seek > 0 ? i._seek : t._sprite[e][0] / 1e3),
				s = Math.max(0, (t._sprite[e][0] + t._sprite[e][1]) / 1e3 - _),
				l = 1e3 * s / Math.abs(i._rate),
				c = t._sprite[e][0] / 1e3,
				f = (t._sprite[e][0] + t._sprite[e][1]) / 1e3;
			i._sprite = e, i._ended = !1;
			var p = function () {
				i._paused = !1, i._seek = _, i._start = c, i._stop = f, i._loop = !(!i._loop && !t._sprite[e][2])
			};
			if (_ >= f) return void t._ended(i);
			var m = i._node;
			if (t._webAudio) {
				var v = function () {
					t._playLock = !1, p(), t._refreshBuffer(i);
					var e = i._muted || t._muted ? 0 : i._volume;
					m.gain.setValueAtTime(e, n.ctx.currentTime), i._playStart = n.ctx.currentTime, void 0 === m.bufferSource.start ? i._loop ? m.bufferSource.noteGrainOn(0, _, 86400) : m.bufferSource.noteGrainOn(0, _, s) : i._loop ? m.bufferSource.start(0, _, 86400) : m.bufferSource.start(0, _, s), l !== 1 / 0 && (t._endTimers[i._id] = setTimeout(t._ended.bind(t, i), l)), o || setTimeout(function () {
						t._emit("play", i._id), t._loadQueue()
					}, 0)
				};
				"running" === n.state ? v() : (t._playLock = !0, t.once("resume", v), t._clearTimer(i._id))
			} else {
				var h = function () {
					m.currentTime = _, m.muted = i._muted || t._muted || n._muted || m.muted, m.volume = i._volume * n.volume(), m.playbackRate = i._rate;
					try {
						var r = m.play();
						if (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then) ? (t._playLock = !0, p(), r.then(function () {
								t._playLock = !1, m._unlocked = !0, o || (t._emit("play", i._id), t._loadQueue())
							}).catch(function () {
								t._playLock = !1, t._emit("playerror", i._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), i._ended = !0, i._paused = !0
							})) : o || (t._playLock = !1, p(), t._emit("play", i._id), t._loadQueue()), m.playbackRate = i._rate, m.paused) return void t._emit("playerror", i._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
						"__default" !== e || i._loop ? t._endTimers[i._id] = setTimeout(t._ended.bind(t, i), l) : (t._endTimers[i._id] = function () {
							t._ended(i), m.removeEventListener("ended", t._endTimers[i._id], !1)
						}, m.addEventListener("ended", t._endTimers[i._id], !1))
					} catch (e) {
						t._emit("playerror", i._id, e)
					}
				};
				"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = t._src, m.load());
				var y = window && window.ejecta || !m.readyState && n._navigator.isCocoonJS;
				if (m.readyState >= 3 || y) h();
				else {
					t._playLock = !0;
					var g = function () {
						h(), m.removeEventListener(n._canPlayEvent, g, !1)
					};
					m.addEventListener(n._canPlayEvent, g, !1), t._clearTimer(i._id)
				}
			}
			return i._id
		},
		pause: function (e) {
			var n = this;
			if ("loaded" !== n._state || n._playLock) return n._queue.push({
				event: "pause",
				action: function () {
					n.pause(e)
				}
			}), n;
			for (var o = n._getSoundIds(e), t = 0; t < o.length; t++) {
				n._clearTimer(o[t]);
				var r = n._soundById(o[t]);
				if (r && !r._paused && (r._seek = n.seek(o[t]), r._rateSeek = 0, r._paused = !0, n._stopFade(o[t]), r._node))
					if (n._webAudio) {
						if (!r._node.bufferSource) continue;
						void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), n._cleanBuffer(r._node)
					} else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
				arguments[1] || n._emit("pause", r ? r._id : null)
			}
			return n
		},
		stop: function (e, n) {
			var o = this;
			if ("loaded" !== o._state || o._playLock) return o._queue.push({
				event: "stop",
				action: function () {
					o.stop(e)
				}
			}), o;
			for (var t = o._getSoundIds(e), r = 0; r < t.length; r++) {
				o._clearTimer(t[r]);
				var a = o._soundById(t[r]);
				a && (a._seek = a._start || 0, a._rateSeek = 0, a._paused = !0, a._ended = !0, o._stopFade(t[r]), a._node && (o._webAudio ? a._node.bufferSource && (void 0 === a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0), o._cleanBuffer(a._node)) : isNaN(a._node.duration) && a._node.duration !== 1 / 0 || (a._node.currentTime = a._start || 0, a._node.pause(), a._node.duration === 1 / 0 && o._clearSound(a._node))), n || o._emit("stop", a._id))
			}
			return o
		},
		mute: function (e, o) {
			var t = this;
			if ("loaded" !== t._state || t._playLock) return t._queue.push({
				event: "mute",
				action: function () {
					t.mute(e, o)
				}
			}), t;
			if (void 0 === o) {
				if ("boolean" != typeof e) return t._muted;
				t._muted = e
			}
			for (var r = t._getSoundIds(o), a = 0; a < r.length; a++) {
				var u = t._soundById(r[a]);
				u && (u._muted = e, u._interval && t._stopFade(u._id), t._webAudio && u._node ? u._node.gain.setValueAtTime(e ? 0 : u._volume, n.ctx.currentTime) : u._node && (u._node.muted = !!n._muted || e), t._emit("mute", u._id))
			}
			return t
		},
		volume: function () {
			var e, o, t = this,
				r = arguments;
			if (0 === r.length) return t._volume;
			if (1 === r.length || 2 === r.length && void 0 === r[1]) {
				t._getSoundIds().indexOf(r[0]) >= 0 ? o = parseInt(r[0], 10) : e = parseFloat(r[0])
			} else r.length >= 2 && (e = parseFloat(r[0]), o = parseInt(r[1], 10));
			var a;
			if (!(void 0 !== e && e >= 0 && e <= 1)) return a = o ? t._soundById(o) : t._sounds[0], a ? a._volume : 0;
			if ("loaded" !== t._state || t._playLock) return t._queue.push({
				event: "volume",
				action: function () {
					t.volume.apply(t, r)
				}
			}), t;
			void 0 === o && (t._volume = e), o = t._getSoundIds(o);
			for (var u = 0; u < o.length; u++)(a = t._soundById(o[u])) && (a._volume = e, r[2] || t._stopFade(o[u]), t._webAudio && a._node && !a._muted ? a._node.gain.setValueAtTime(e, n.ctx.currentTime) : a._node && !a._muted && (a._node.volume = e * n.volume()), t._emit("volume", a._id));
			return t
		},
		fade: function (e, o, t, r) {
			var a = this;
			if ("loaded" !== a._state || a._playLock) return a._queue.push({
				event: "fade",
				action: function () {
					a.fade(e, o, t, r)
				}
			}), a;
			e = parseFloat(e), o = parseFloat(o), t = parseFloat(t), a.volume(e, r);
			for (var u = a._getSoundIds(r), i = 0; i < u.length; i++) {
				var d = a._soundById(u[i]);
				if (d) {
					if (r || a._stopFade(u[i]), a._webAudio && !d._muted) {
						var _ = n.ctx.currentTime,
							s = _ + t / 1e3;
						d._volume = e, d._node.gain.setValueAtTime(e, _), d._node.gain.linearRampToValueAtTime(o, s)
					}
					a._startFadeInterval(d, e, o, t, u[i], void 0 === r)
				}
			}
			return a
		},
		_startFadeInterval: function (e, n, o, t, r, a) {
			var u = this,
				i = n,
				d = o - n,
				_ = Math.abs(d / .01),
				s = Math.max(4, _ > 0 ? t / _ : t),
				l = Date.now();
			e._fadeTo = o, e._interval = setInterval(function () {
				var r = (Date.now() - l) / t;
				l = Date.now(), i += d * r, i = Math.max(0, i), i = Math.min(1, i), i = Math.round(100 * i) / 100, u._webAudio ? e._volume = i : u.volume(i, e._id, !0), a && (u._volume = i), (o < n && i <= o || o > n && i >= o) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, u.volume(o, e._id), u._emit("fade", e._id))
			}, s)
		},
		_stopFade: function (e) {
			var o = this,
				t = o._soundById(e);
			return t && t._interval && (o._webAudio && t._node.gain.cancelScheduledValues(n.ctx.currentTime), clearInterval(t._interval), t._interval = null, o.volume(t._fadeTo, e), t._fadeTo = null, o._emit("fade", e)), o
		},
		loop: function () {
			var e, n, o, t = this,
				r = arguments;
			if (0 === r.length) return t._loop;
			if (1 === r.length) {
				if ("boolean" != typeof r[0]) return !!(o = t._soundById(parseInt(r[0], 10))) && o._loop;
				e = r[0], t._loop = e
			} else 2 === r.length && (e = r[0], n = parseInt(r[1], 10));
			for (var a = t._getSoundIds(n), u = 0; u < a.length; u++)(o = t._soundById(a[u])) && (o._loop = e, t._webAudio && o._node && o._node.bufferSource && (o._node.bufferSource.loop = e, e && (o._node.bufferSource.loopStart = o._start || 0, o._node.bufferSource.loopEnd = o._stop)));
			return t
		},
		rate: function () {
			var e, o, t = this,
				r = arguments;
			if (0 === r.length) o = t._sounds[0]._id;
			else if (1 === r.length) {
				var a = t._getSoundIds(),
					u = a.indexOf(r[0]);
				u >= 0 ? o = parseInt(r[0], 10) : e = parseFloat(r[0])
			} else 2 === r.length && (e = parseFloat(r[0]), o = parseInt(r[1], 10));
			var i;
			if ("number" != typeof e) return i = t._soundById(o), i ? i._rate : t._rate;
			if ("loaded" !== t._state || t._playLock) return t._queue.push({
				event: "rate",
				action: function () {
					t.rate.apply(t, r)
				}
			}), t;
			void 0 === o && (t._rate = e), o = t._getSoundIds(o);
			for (var d = 0; d < o.length; d++)
				if (i = t._soundById(o[d])) {
					t.playing(o[d]) && (i._rateSeek = t.seek(o[d]), i._playStart = t._webAudio ? n.ctx.currentTime : i._playStart), i._rate = e, t._webAudio && i._node && i._node.bufferSource ? i._node.bufferSource.playbackRate.setValueAtTime(e, n.ctx.currentTime) : i._node && (i._node.playbackRate = e);
					var _ = t.seek(o[d]),
						s = (t._sprite[i._sprite][0] + t._sprite[i._sprite][1]) / 1e3 - _,
						l = 1e3 * s / Math.abs(i._rate);
					!t._endTimers[o[d]] && i._paused || (t._clearTimer(o[d]), t._endTimers[o[d]] = setTimeout(t._ended.bind(t, i), l)), t._emit("rate", i._id)
				} return t
		},
		seek: function () {
			var e, o, t = this,
				r = arguments;
			if (0 === r.length) o = t._sounds[0]._id;
			else if (1 === r.length) {
				var a = t._getSoundIds(),
					u = a.indexOf(r[0]);
				u >= 0 ? o = parseInt(r[0], 10) : t._sounds.length && (o = t._sounds[0]._id, e = parseFloat(r[0]))
			} else 2 === r.length && (e = parseFloat(r[0]), o = parseInt(r[1], 10));
			if (void 0 === o) return t;
			if ("loaded" !== t._state || t._playLock) return t._queue.push({
				event: "seek",
				action: function () {
					t.seek.apply(t, r)
				}
			}), t;
			var i = t._soundById(o);
			if (i) {
				if (!("number" == typeof e && e >= 0)) {
					if (t._webAudio) {
						var d = t.playing(o) ? n.ctx.currentTime - i._playStart : 0,
							_ = i._rateSeek ? i._rateSeek - i._seek : 0;
						return i._seek + (_ + d * Math.abs(i._rate))
					}
					return i._node.currentTime
				}
				var s = t.playing(o);
				s && t.pause(o, !0), i._seek = e, i._ended = !1, t._clearTimer(o), t._webAudio || !i._node || isNaN(i._node.duration) || (i._node.currentTime = e);
				var l = function () {
					t._emit("seek", o), s && t.play(o, !0)
				};
				if (s && !t._webAudio) {
					var c = function () {
						t._playLock ? setTimeout(c, 0) : l()
					};
					setTimeout(c, 0)
				} else l()
			}
			return t
		},
		playing: function (e) {
			var n = this;
			if ("number" == typeof e) {
				var o = n._soundById(e);
				return !!o && !o._paused
			}
			for (var t = 0; t < n._sounds.length; t++)
				if (!n._sounds[t]._paused) return !0;
			return !1
		},
		duration: function (e) {
			var n = this,
				o = n._duration,
				t = n._soundById(e);
			return t && (o = n._sprite[t._sprite][1] / 1e3), o
		},
		state: function () {
			return this._state
		},
		unload: function () {
			for (var e = this, o = e._sounds, t = 0; t < o.length; t++) o[t]._paused || e.stop(o[t]._id), e._webAudio || (e._clearSound(o[t]._node), o[t]._node.removeEventListener("error", o[t]._errorFn, !1), o[t]._node.removeEventListener(n._canPlayEvent, o[t]._loadFn, !1), n._releaseHtml5Audio(o[t]._node)), delete o[t]._node, e._clearTimer(o[t]._id);
			var a = n._howls.indexOf(e);
			a >= 0 && n._howls.splice(a, 1);
			var u = !0;
			for (t = 0; t < n._howls.length; t++)
				if (n._howls[t]._src === e._src || e._src.indexOf(n._howls[t]._src) >= 0) {
					u = !1;
					break
				} return r && u && delete r[e._src], n.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null
		},
		on: function (e, n, o, t) {
			var r = this,
				a = r["_on" + e];
			return "function" == typeof n && a.push(t ? {
				id: o,
				fn: n,
				once: t
			} : {
				id: o,
				fn: n
			}), r
		},
		off: function (e, n, o) {
			var t = this,
				r = t["_on" + e],
				a = 0;
			if ("number" == typeof n && (o = n, n = null), n || o)
				for (a = 0; a < r.length; a++) {
					var u = o === r[a].id;
					if (n === r[a].fn && u || !n && u) {
						r.splice(a, 1);
						break
					}
				} else if (e) t["_on" + e] = [];
				else {
					var i = Object.keys(t);
					for (a = 0; a < i.length; a++) 0 === i[a].indexOf("_on") && Array.isArray(t[i[a]]) && (t[i[a]] = [])
				} return t
		},
		once: function (e, n, o) {
			var t = this;
			return t.on(e, n, o, 1), t
		},
		_emit: function (e, n, o) {
			for (var t = this, r = t["_on" + e], a = r.length - 1; a >= 0; a--) r[a].id && r[a].id !== n && "load" !== e || (setTimeout(function (e) {
				e.call(this, n, o)
			}.bind(t, r[a].fn), 0), r[a].once && t.off(e, r[a].fn, r[a].id));
			return t._loadQueue(e), t
		},
		_loadQueue: function (e) {
			var n = this;
			if (n._queue.length > 0) {
				var o = n._queue[0];
				o.event === e && (n._queue.shift(), n._loadQueue()), e || o.action()
			}
			return n
		},
		_ended: function (e) {
			var o = this,
				t = e._sprite;
			if (!o._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(o._ended.bind(o, e), 100), o;
			var r = !(!e._loop && !o._sprite[t][2]);
			if (o._emit("end", e._id), !o._webAudio && r && o.stop(e._id, !0).play(e._id), o._webAudio && r) {
				o._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = n.ctx.currentTime;
				var a = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
				o._endTimers[e._id] = setTimeout(o._ended.bind(o, e), a)
			}
			return o._webAudio && !r && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, o._clearTimer(e._id), o._cleanBuffer(e._node), n._autoSuspend()), o._webAudio || r || o.stop(e._id, !0), o
		},
		_clearTimer: function (e) {
			var n = this;
			if (n._endTimers[e]) {
				if ("function" != typeof n._endTimers[e]) clearTimeout(n._endTimers[e]);
				else {
					var o = n._soundById(e);
					o && o._node && o._node.removeEventListener("ended", n._endTimers[e], !1)
				}
				delete n._endTimers[e]
			}
			return n
		},
		_soundById: function (e) {
			for (var n = this, o = 0; o < n._sounds.length; o++)
				if (e === n._sounds[o]._id) return n._sounds[o];
			return null
		},
		_inactiveSound: function () {
			var e = this;
			e._drain();
			for (var n = 0; n < e._sounds.length; n++)
				if (e._sounds[n]._ended) return e._sounds[n].reset();
			return new t(e)
		},
		_drain: function () {
			var e = this,
				n = e._pool,
				o = 0,
				t = 0;
			if (!(e._sounds.length < n)) {
				for (t = 0; t < e._sounds.length; t++) e._sounds[t]._ended && o++;
				for (t = e._sounds.length - 1; t >= 0; t--) {
					if (o <= n) return;
					e._sounds[t]._ended && (e._webAudio && e._sounds[t]._node && e._sounds[t]._node.disconnect(0), e._sounds.splice(t, 1), o--)
				}
			}
		},
		_getSoundIds: function (e) {
			var n = this;
			if (void 0 === e) {
				for (var o = [], t = 0; t < n._sounds.length; t++) o.push(n._sounds[t]._id);
				return o
			}
			return [e]
		},
		_refreshBuffer: function (e) {
			var o = this;
			return e._node.bufferSource = n.ctx.createBufferSource(), e._node.bufferSource.buffer = r[o._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, n.ctx.currentTime), o
		},
		_cleanBuffer: function (e) {
			var o = this,
				t = n._navigator && n._navigator.vendor.indexOf("Apple") >= 0;
			if (n._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try {
				e.bufferSource.buffer = n._scratchBuffer
			} catch (e) {}
			return e.bufferSource = null, o
		},
		_clearSound: function (e) {
			/MSIE |Trident\//.test(n._navigator && n._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
		}
	};
	var t = function (e) {
		this._parent = e, this.init()
	};
	t.prototype = {
		init: function () {
			var e = this,
				o = e._parent;
			return e._muted = o._muted, e._loop = o._loop, e._volume = o._volume, e._rate = o._rate, e._seek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++n._counter, o._sounds.push(e), e.create(), e
		},
		create: function () {
			var e = this,
				o = e._parent,
				t = n._muted || e._muted || e._parent._muted ? 0 : e._volume;
			return o._webAudio ? (e._node = void 0 === n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain(), e._node.gain.setValueAtTime(t, n.ctx.currentTime), e._node.paused = !0, e._node.connect(n.masterGain)) : n.noAudio || (e._node = n._obtainHtml5Audio(), e._errorFn = e._errorListener.bind(e), e._node.addEventListener("error", e._errorFn, !1), e._loadFn = e._loadListener.bind(e), e._node.addEventListener(n._canPlayEvent, e._loadFn, !1), e._node.src = o._src, e._node.preload = "auto", e._node.volume = t * n.volume(), e._node.load()), e
		},
		reset: function () {
			var e = this,
				o = e._parent;
			return e._muted = o._muted, e._loop = o._loop, e._volume = o._volume, e._rate = o._rate, e._seek = 0, e._rateSeek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++n._counter, e
		},
		_errorListener: function () {
			var e = this;
			e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0), e._node.removeEventListener("error", e._errorFn, !1)
		},
		_loadListener: function () {
			var e = this,
				o = e._parent;
			o._duration = Math.ceil(10 * e._node.duration) / 10, 0 === Object.keys(o._sprite).length && (o._sprite = {
				__default: [0, 1e3 * o._duration]
			}), "loaded" !== o._state && (o._state = "loaded", o._emit("load"), o._loadQueue()), e._node.removeEventListener(n._canPlayEvent, e._loadFn, !1)
		}
	};
	var r = {},
		a = function (e) {
			var n = e._src;
			if (r[n]) return e._duration = r[n].duration, void d(e);
			if (/^data:[^;]+;base64,/.test(n)) {
				for (var o = atob(n.split(",")[1]), t = new Uint8Array(o.length), a = 0; a < o.length; ++a) t[a] = o.charCodeAt(a);
				i(t.buffer, e)
			} else {
				var _ = new XMLHttpRequest;
				_.open("GET", n, !0), _.withCredentials = e._xhrWithCredentials, _.responseType = "arraybuffer", _.onload = function () {
					var n = (_.status + "")[0];
					if ("0" !== n && "2" !== n && "3" !== n) return void e._emit("loaderror", null, "Failed loading audio file with status: " + _.status + ".");
					i(_.response, e)
				}, _.onerror = function () {
					e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete r[n], e.load())
				}, u(_)
			}
		},
		u = function (e) {
			try {
				e.send()
			} catch (n) {
				e.onerror()
			}
		},
		i = function (e, o) {
			var t = function () {
					o._emit("loaderror", null, "Decoding audio data failed.")
				},
				a = function (e) {
					e && o._sounds.length > 0 ? (r[o._src] = e, d(o, e)) : t()
				};
			"undefined" != typeof Promise && 1 === n.ctx.decodeAudioData.length ? n.ctx.decodeAudioData(e).then(a).catch(t) : n.ctx.decodeAudioData(e, a, t)
		},
		d = function (e, n) {
			n && !e._duration && (e._duration = n.duration), 0 === Object.keys(e._sprite).length && (e._sprite = {
				__default: [0, 1e3 * e._duration]
			}), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue())
		},
		_ = function () {
			if (n.usingWebAudio) {
				try {
					"undefined" != typeof AudioContext ? n.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? n.ctx = new webkitAudioContext : n.usingWebAudio = !1
				} catch (e) {
					n.usingWebAudio = !1
				}
				n.ctx || (n.usingWebAudio = !1);
				var e = /iP(hone|od|ad)/.test(n._navigator && n._navigator.platform),
					o = n._navigator && n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
					t = o ? parseInt(o[1], 10) : null;
				if (e && t && t < 9) {
					var r = /safari/.test(n._navigator && n._navigator.userAgent.toLowerCase());
					(n._navigator && n._navigator.standalone && !r || n._navigator && !n._navigator.standalone && !r) && (n.usingWebAudio = !1)
				}
				n.usingWebAudio && (n.masterGain = void 0 === n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain(), n.masterGain.gain.setValueAtTime(n._muted ? 0 : n._volume, n.ctx.currentTime), n.masterGain.connect(n.ctx.destination)), n._setup()
			}
		};
	"function" == typeof define && define.amd && define([], function () {
		return {
			Howler: n,
			Howl: o
		}
	}), "undefined" != typeof exports && (exports.Howler = n, exports.Howl = o), "undefined" != typeof window ? (window.HowlerGlobal = e, window.Howler = n, window.Howl = o, window.Sound = t) : "undefined" != typeof global && (global.HowlerGlobal = e, global.Howler = n, global.Howl = o, global.Sound = t)
}();
/*! Spatial Plugin */
! function () {
	"use strict";
	HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) {
		var n = this;
		if (!n.ctx || !n.ctx.listener) return n;
		for (var t = n._howls.length - 1; t >= 0; t--) n._howls[t].stereo(e);
		return n
	}, HowlerGlobal.prototype.pos = function (e, n, t) {
		var r = this;
		return r.ctx && r.ctx.listener ? (n = "number" != typeof n ? r._pos[1] : n, t = "number" != typeof t ? r._pos[2] : t, "number" != typeof e ? r._pos : (r._pos = [e, n, t], void 0 !== r.ctx.listener.positionX ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]), r)) : r
	}, HowlerGlobal.prototype.orientation = function (e, n, t, r, o, i) {
		var a = this;
		if (!a.ctx || !a.ctx.listener) return a;
		var s = a._orientation;
		return n = "number" != typeof n ? s[1] : n, t = "number" != typeof t ? s[2] : t, r = "number" != typeof r ? s[3] : r, o = "number" != typeof o ? s[4] : o, i = "number" != typeof i ? s[5] : i, "number" != typeof e ? s : (a._orientation = [e, n, t, r, o, i], void 0 !== a.ctx.listener.forwardX ? (a.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), a.ctx.listener.forwardY.setTargetAtTime(n, Howler.ctx.currentTime, .1), a.ctx.listener.forwardZ.setTargetAtTime(t, Howler.ctx.currentTime, .1), a.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), a.ctx.listener.upY.setTargetAtTime(o, Howler.ctx.currentTime, .1), a.ctx.listener.upZ.setTargetAtTime(i, Howler.ctx.currentTime, .1)) : a.ctx.listener.setOrientation(e, n, t, r, o, i), a)
	}, Howl.prototype.init = function (e) {
		return function (n) {
			var t = this;
			return t._orientation = n.orientation || [1, 0, 0], t._stereo = n.stereo || null, t._pos = n.pos || null, t._pannerAttr = {
				coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : 360,
				coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : 360,
				coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : 0,
				distanceModel: void 0 !== n.distanceModel ? n.distanceModel : "inverse",
				maxDistance: void 0 !== n.maxDistance ? n.maxDistance : 1e4,
				panningModel: void 0 !== n.panningModel ? n.panningModel : "HRTF",
				refDistance: void 0 !== n.refDistance ? n.refDistance : 1,
				rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : 1
			}, t._onstereo = n.onstereo ? [{
				fn: n.onstereo
			}] : [], t._onpos = n.onpos ? [{
				fn: n.onpos
			}] : [], t._onorientation = n.onorientation ? [{
				fn: n.onorientation
			}] : [], e.call(this, n)
		}
	}(Howl.prototype.init), Howl.prototype.stereo = function (n, t) {
		var r = this;
		if (!r._webAudio) return r;
		if ("loaded" !== r._state) return r._queue.push({
			event: "stereo",
			action: function () {
				r.stereo(n, t)
			}
		}), r;
		var o = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
		if (void 0 === t) {
			if ("number" != typeof n) return r._stereo;
			r._stereo = n, r._pos = [n, 0, 0]
		}
		for (var i = r._getSoundIds(t), a = 0; a < i.length; a++) {
			var s = r._soundById(i[a]);
			if (s) {
				if ("number" != typeof n) return s._stereo;
				s._stereo = n, s._pos = [n, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || e(s, o), "spatial" === o ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(n, 0, 0) : s._panner.pan.setValueAtTime(n, Howler.ctx.currentTime)), r._emit("stereo", s._id)
			}
		}
		return r
	}, Howl.prototype.pos = function (n, t, r, o) {
		var i = this;
		if (!i._webAudio) return i;
		if ("loaded" !== i._state) return i._queue.push({
			event: "pos",
			action: function () {
				i.pos(n, t, r, o)
			}
		}), i;
		if (t = "number" != typeof t ? 0 : t, r = "number" != typeof r ? -.5 : r, void 0 === o) {
			if ("number" != typeof n) return i._pos;
			i._pos = [n, t, r]
		}
		for (var a = i._getSoundIds(o), s = 0; s < a.length; s++) {
			var p = i._soundById(a[s]);
			if (p) {
				if ("number" != typeof n) return p._pos;
				p._pos = [n, t, r], p._node && (p._panner && !p._panner.pan || e(p, "spatial"), void 0 !== p._panner.positionX ? (p._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), p._panner.positionY.setValueAtTime(t, Howler.ctx.currentTime), p._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : p._panner.setPosition(n, t, r)), i._emit("pos", p._id)
			}
		}
		return i
	}, Howl.prototype.orientation = function (n, t, r, o) {
		var i = this;
		if (!i._webAudio) return i;
		if ("loaded" !== i._state) return i._queue.push({
			event: "orientation",
			action: function () {
				i.orientation(n, t, r, o)
			}
		}), i;
		if (t = "number" != typeof t ? i._orientation[1] : t, r = "number" != typeof r ? i._orientation[2] : r, void 0 === o) {
			if ("number" != typeof n) return i._orientation;
			i._orientation = [n, t, r]
		}
		for (var a = i._getSoundIds(o), s = 0; s < a.length; s++) {
			var p = i._soundById(a[s]);
			if (p) {
				if ("number" != typeof n) return p._orientation;
				p._orientation = [n, t, r], p._node && (p._panner || (p._pos || (p._pos = i._pos || [0, 0, -.5]), e(p, "spatial")), void 0 !== p._panner.orientationX ? (p._panner.orientationX.setValueAtTime(n, Howler.ctx.currentTime), p._panner.orientationY.setValueAtTime(t, Howler.ctx.currentTime), p._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : p._panner.setOrientation(n, t, r)), i._emit("orientation", p._id)
			}
		}
		return i
	}, Howl.prototype.pannerAttr = function () {
		var n, t, r, o = this,
			i = arguments;
		if (!o._webAudio) return o;
		if (0 === i.length) return o._pannerAttr;
		if (1 === i.length) {
			if ("object" != typeof i[0]) return r = o._soundById(parseInt(i[0], 10)), r ? r._pannerAttr : o._pannerAttr;
			n = i[0], void 0 === t && (n.pannerAttr || (n.pannerAttr = {
				coneInnerAngle: n.coneInnerAngle,
				coneOuterAngle: n.coneOuterAngle,
				coneOuterGain: n.coneOuterGain,
				distanceModel: n.distanceModel,
				maxDistance: n.maxDistance,
				refDistance: n.refDistance,
				rolloffFactor: n.rolloffFactor,
				panningModel: n.panningModel
			}), o._pannerAttr = {
				coneInnerAngle: void 0 !== n.pannerAttr.coneInnerAngle ? n.pannerAttr.coneInnerAngle : o._coneInnerAngle,
				coneOuterAngle: void 0 !== n.pannerAttr.coneOuterAngle ? n.pannerAttr.coneOuterAngle : o._coneOuterAngle,
				coneOuterGain: void 0 !== n.pannerAttr.coneOuterGain ? n.pannerAttr.coneOuterGain : o._coneOuterGain,
				distanceModel: void 0 !== n.pannerAttr.distanceModel ? n.pannerAttr.distanceModel : o._distanceModel,
				maxDistance: void 0 !== n.pannerAttr.maxDistance ? n.pannerAttr.maxDistance : o._maxDistance,
				refDistance: void 0 !== n.pannerAttr.refDistance ? n.pannerAttr.refDistance : o._refDistance,
				rolloffFactor: void 0 !== n.pannerAttr.rolloffFactor ? n.pannerAttr.rolloffFactor : o._rolloffFactor,
				panningModel: void 0 !== n.pannerAttr.panningModel ? n.pannerAttr.panningModel : o._panningModel
			})
		} else 2 === i.length && (n = i[0], t = parseInt(i[1], 10));
		for (var a = o._getSoundIds(t), s = 0; s < a.length; s++)
			if (r = o._soundById(a[s])) {
				var p = r._pannerAttr;
				p = {
					coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : p.coneInnerAngle,
					coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : p.coneOuterAngle,
					coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : p.coneOuterGain,
					distanceModel: void 0 !== n.distanceModel ? n.distanceModel : p.distanceModel,
					maxDistance: void 0 !== n.maxDistance ? n.maxDistance : p.maxDistance,
					refDistance: void 0 !== n.refDistance ? n.refDistance : p.refDistance,
					rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : p.rolloffFactor,
					panningModel: void 0 !== n.panningModel ? n.panningModel : p.panningModel
				};
				var c = r._panner;
				c ? (c.coneInnerAngle = p.coneInnerAngle, c.coneOuterAngle = p.coneOuterAngle, c.coneOuterGain = p.coneOuterGain, c.distanceModel = p.distanceModel, c.maxDistance = p.maxDistance, c.refDistance = p.refDistance, c.rolloffFactor = p.rolloffFactor, c.panningModel = p.panningModel) : (r._pos || (r._pos = o._pos || [0, 0, -.5]), e(r, "spatial"))
			} return o
	}, Sound.prototype.init = function (e) {
		return function () {
			var n = this,
				t = n._parent;
			n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, e.call(this), n._stereo ? t.stereo(n._stereo) : n._pos && t.pos(n._pos[0], n._pos[1], n._pos[2], n._id)
		}
	}(Sound.prototype.init), Sound.prototype.reset = function (e) {
		return function () {
			var n = this,
				t = n._parent;
			return n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, n._stereo ? t.stereo(n._stereo) : n._pos ? t.pos(n._pos[0], n._pos[1], n._pos[2], n._id) : n._panner && (n._panner.disconnect(0), n._panner = void 0, t._refreshBuffer(n)), e.call(this)
		}
	}(Sound.prototype.reset);
	var e = function (e, n) {
		n = n || "spatial", "spatial" === n ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0)
	}
}();

/*! howler.js v2.1.3 | Spatial Plugin | (c) 2013-2019, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
! function () {
	"use strict";
	HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) {
		var n = this;
		if (!n.ctx || !n.ctx.listener) return n;
		for (var t = n._howls.length - 1; t >= 0; t--) n._howls[t].stereo(e);
		return n
	}, HowlerGlobal.prototype.pos = function (e, n, t) {
		var r = this;
		return r.ctx && r.ctx.listener ? (n = "number" != typeof n ? r._pos[1] : n, t = "number" != typeof t ? r._pos[2] : t, "number" != typeof e ? r._pos : (r._pos = [e, n, t], void 0 !== r.ctx.listener.positionX ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]), r)) : r
	}, HowlerGlobal.prototype.orientation = function (e, n, t, r, o, i) {
		var a = this;
		if (!a.ctx || !a.ctx.listener) return a;
		var s = a._orientation;
		return n = "number" != typeof n ? s[1] : n, t = "number" != typeof t ? s[2] : t, r = "number" != typeof r ? s[3] : r, o = "number" != typeof o ? s[4] : o, i = "number" != typeof i ? s[5] : i, "number" != typeof e ? s : (a._orientation = [e, n, t, r, o, i], void 0 !== a.ctx.listener.forwardX ? (a.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), a.ctx.listener.forwardY.setTargetAtTime(n, Howler.ctx.currentTime, .1), a.ctx.listener.forwardZ.setTargetAtTime(t, Howler.ctx.currentTime, .1), a.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), a.ctx.listener.upY.setTargetAtTime(o, Howler.ctx.currentTime, .1), a.ctx.listener.upZ.setTargetAtTime(i, Howler.ctx.currentTime, .1)) : a.ctx.listener.setOrientation(e, n, t, r, o, i), a)
	}, Howl.prototype.init = function (e) {
		return function (n) {
			var t = this;
			return t._orientation = n.orientation || [1, 0, 0], t._stereo = n.stereo || null, t._pos = n.pos || null, t._pannerAttr = {
				coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : 360,
				coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : 360,
				coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : 0,
				distanceModel: void 0 !== n.distanceModel ? n.distanceModel : "inverse",
				maxDistance: void 0 !== n.maxDistance ? n.maxDistance : 1e4,
				panningModel: void 0 !== n.panningModel ? n.panningModel : "HRTF",
				refDistance: void 0 !== n.refDistance ? n.refDistance : 1,
				rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : 1
			}, t._onstereo = n.onstereo ? [{
				fn: n.onstereo
			}] : [], t._onpos = n.onpos ? [{
				fn: n.onpos
			}] : [], t._onorientation = n.onorientation ? [{
				fn: n.onorientation
			}] : [], e.call(this, n)
		}
	}(Howl.prototype.init), Howl.prototype.stereo = function (n, t) {
		var r = this;
		if (!r._webAudio) return r;
		if ("loaded" !== r._state) return r._queue.push({
			event: "stereo",
			action: function () {
				r.stereo(n, t)
			}
		}), r;
		var o = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
		if (void 0 === t) {
			if ("number" != typeof n) return r._stereo;
			r._stereo = n, r._pos = [n, 0, 0]
		}
		for (var i = r._getSoundIds(t), a = 0; a < i.length; a++) {
			var s = r._soundById(i[a]);
			if (s) {
				if ("number" != typeof n) return s._stereo;
				s._stereo = n, s._pos = [n, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || e(s, o), "spatial" === o ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(n, 0, 0) : s._panner.pan.setValueAtTime(n, Howler.ctx.currentTime)), r._emit("stereo", s._id)
			}
		}
		return r
	}, Howl.prototype.pos = function (n, t, r, o) {
		var i = this;
		if (!i._webAudio) return i;
		if ("loaded" !== i._state) return i._queue.push({
			event: "pos",
			action: function () {
				i.pos(n, t, r, o)
			}
		}), i;
		if (t = "number" != typeof t ? 0 : t, r = "number" != typeof r ? -.5 : r, void 0 === o) {
			if ("number" != typeof n) return i._pos;
			i._pos = [n, t, r]
		}
		for (var a = i._getSoundIds(o), s = 0; s < a.length; s++) {
			var p = i._soundById(a[s]);
			if (p) {
				if ("number" != typeof n) return p._pos;
				p._pos = [n, t, r], p._node && (p._panner && !p._panner.pan || e(p, "spatial"), void 0 !== p._panner.positionX ? (p._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), p._panner.positionY.setValueAtTime(t, Howler.ctx.currentTime), p._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : p._panner.setPosition(n, t, r)), i._emit("pos", p._id)
			}
		}
		return i
	}, Howl.prototype.orientation = function (n, t, r, o) {
		var i = this;
		if (!i._webAudio) return i;
		if ("loaded" !== i._state) return i._queue.push({
			event: "orientation",
			action: function () {
				i.orientation(n, t, r, o)
			}
		}), i;
		if (t = "number" != typeof t ? i._orientation[1] : t, r = "number" != typeof r ? i._orientation[2] : r, void 0 === o) {
			if ("number" != typeof n) return i._orientation;
			i._orientation = [n, t, r]
		}
		for (var a = i._getSoundIds(o), s = 0; s < a.length; s++) {
			var p = i._soundById(a[s]);
			if (p) {
				if ("number" != typeof n) return p._orientation;
				p._orientation = [n, t, r], p._node && (p._panner || (p._pos || (p._pos = i._pos || [0, 0, -.5]), e(p, "spatial")), void 0 !== p._panner.orientationX ? (p._panner.orientationX.setValueAtTime(n, Howler.ctx.currentTime), p._panner.orientationY.setValueAtTime(t, Howler.ctx.currentTime), p._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : p._panner.setOrientation(n, t, r)), i._emit("orientation", p._id)
			}
		}
		return i
	}, Howl.prototype.pannerAttr = function () {
		var n, t, r, o = this,
			i = arguments;
		if (!o._webAudio) return o;
		if (0 === i.length) return o._pannerAttr;
		if (1 === i.length) {
			if ("object" != typeof i[0]) return r = o._soundById(parseInt(i[0], 10)), r ? r._pannerAttr : o._pannerAttr;
			n = i[0], void 0 === t && (n.pannerAttr || (n.pannerAttr = {
				coneInnerAngle: n.coneInnerAngle,
				coneOuterAngle: n.coneOuterAngle,
				coneOuterGain: n.coneOuterGain,
				distanceModel: n.distanceModel,
				maxDistance: n.maxDistance,
				refDistance: n.refDistance,
				rolloffFactor: n.rolloffFactor,
				panningModel: n.panningModel
			}), o._pannerAttr = {
				coneInnerAngle: void 0 !== n.pannerAttr.coneInnerAngle ? n.pannerAttr.coneInnerAngle : o._coneInnerAngle,
				coneOuterAngle: void 0 !== n.pannerAttr.coneOuterAngle ? n.pannerAttr.coneOuterAngle : o._coneOuterAngle,
				coneOuterGain: void 0 !== n.pannerAttr.coneOuterGain ? n.pannerAttr.coneOuterGain : o._coneOuterGain,
				distanceModel: void 0 !== n.pannerAttr.distanceModel ? n.pannerAttr.distanceModel : o._distanceModel,
				maxDistance: void 0 !== n.pannerAttr.maxDistance ? n.pannerAttr.maxDistance : o._maxDistance,
				refDistance: void 0 !== n.pannerAttr.refDistance ? n.pannerAttr.refDistance : o._refDistance,
				rolloffFactor: void 0 !== n.pannerAttr.rolloffFactor ? n.pannerAttr.rolloffFactor : o._rolloffFactor,
				panningModel: void 0 !== n.pannerAttr.panningModel ? n.pannerAttr.panningModel : o._panningModel
			})
		} else 2 === i.length && (n = i[0], t = parseInt(i[1], 10));
		for (var a = o._getSoundIds(t), s = 0; s < a.length; s++)
			if (r = o._soundById(a[s])) {
				var p = r._pannerAttr;
				p = {
					coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : p.coneInnerAngle,
					coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : p.coneOuterAngle,
					coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : p.coneOuterGain,
					distanceModel: void 0 !== n.distanceModel ? n.distanceModel : p.distanceModel,
					maxDistance: void 0 !== n.maxDistance ? n.maxDistance : p.maxDistance,
					refDistance: void 0 !== n.refDistance ? n.refDistance : p.refDistance,
					rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : p.rolloffFactor,
					panningModel: void 0 !== n.panningModel ? n.panningModel : p.panningModel
				};
				var c = r._panner;
				c ? (c.coneInnerAngle = p.coneInnerAngle, c.coneOuterAngle = p.coneOuterAngle, c.coneOuterGain = p.coneOuterGain, c.distanceModel = p.distanceModel, c.maxDistance = p.maxDistance, c.refDistance = p.refDistance, c.rolloffFactor = p.rolloffFactor, c.panningModel = p.panningModel) : (r._pos || (r._pos = o._pos || [0, 0, -.5]), e(r, "spatial"))
			} return o
	}, Sound.prototype.init = function (e) {
		return function () {
			var n = this,
				t = n._parent;
			n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, e.call(this), n._stereo ? t.stereo(n._stereo) : n._pos && t.pos(n._pos[0], n._pos[1], n._pos[2], n._id)
		}
	}(Sound.prototype.init), Sound.prototype.reset = function (e) {
		return function () {
			var n = this,
				t = n._parent;
			return n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, n._stereo ? t.stereo(n._stereo) : n._pos ? t.pos(n._pos[0], n._pos[1], n._pos[2], n._id) : n._panner && (n._panner.disconnect(0), n._panner = void 0, t._refreshBuffer(n)), e.call(this)
		}
	}(Sound.prototype.reset);
	var e = function (e, n) {
		n = n || "spatial", "spatial" === n ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0)
	}
}();

/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing(0.25, 0.1, 0.25, 1.0)
 * spline(x) => returns the easing value | x must be in [0, 1] range
 *
 */
(function (definition) {
	if (typeof exports === "object") {
		module.exports = definition();
	} else if (typeof define === 'function' && define.amd) {
		define([], definition);
	} else {
		window.BezierEasing = definition();
	}
}(function () {
	var global = this;

	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	var NEWTON_ITERATIONS = 4;
	var NEWTON_MIN_SLOPE = 0.001;
	var SUBDIVISION_PRECISION = 0.0000001;
	var SUBDIVISION_MAX_ITERATIONS = 10;

	var kSplineTableSize = 11;
	var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	var float32ArraySupported = 'Float32Array' in global;

	function A(aA1, aA2) {
		return 1.0 - 3.0 * aA2 + 3.0 * aA1;
	}

	function B(aA1, aA2) {
		return 3.0 * aA2 - 6.0 * aA1;
	}

	function C(aA1) {
		return 3.0 * aA1;
	}

	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	function calcBezier(aT, aA1, aA2) {
		return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
	}

	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	function getSlope(aT, aA1, aA2) {
		return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	}

	function binarySubdivide(aX, aA, aB) {
		var currentX, currentT, i = 0;
		do {
			currentT = aA + (aB - aA) / 2.0;
			currentX = calcBezier(currentT, mX1, mX2) - aX;
			if (currentX > 0.0) {
				aB = currentT;
			} else {
				aA = currentT;
			}
		} while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
		return currentT;
	}

	function BezierEasing(mX1, mY1, mX2, mY2) {
		// Validate arguments
		if (arguments.length !== 4) {
			throw new Error("BezierEasing requires 4 arguments.");
		}
		for (var i = 0; i < 4; ++i) {
			if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
				throw new Error("BezierEasing arguments should be integers.");
			}
		}
		if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
			throw new Error("BezierEasing x values must be in [0, 1] range.");
		}

		var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

		function newtonRaphsonIterate(aX, aGuessT) {
			for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
				var currentSlope = getSlope(aGuessT, mX1, mX2);
				if (currentSlope === 0.0) return aGuessT;
				var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
				aGuessT -= currentX / currentSlope;
			}
			return aGuessT;
		}

		function calcSampleValues() {
			for (var i = 0; i < kSplineTableSize; ++i) {
				mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
			}
		}

		function getTForX(aX) {
			var intervalStart = 0.0;
			var currentSample = 1;
			var lastSample = kSplineTableSize - 1;

			for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
				intervalStart += kSampleStepSize;
			}
			--currentSample;

			// Interpolate to provide an initial guess for t
			var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
			var guessForT = intervalStart + dist * kSampleStepSize;

			var initialSlope = getSlope(guessForT, mX1, mX2);
			if (initialSlope >= NEWTON_MIN_SLOPE) {
				return newtonRaphsonIterate(aX, guessForT);
			} else if (initialSlope === 0.0) {
				return guessForT;
			} else {
				return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
			}
		}

		var _precomputed = false;

		function precompute() {
			_precomputed = true;
			if (mX1 != mY1 || mX2 != mY2)
				calcSampleValues();
		}

		var f = function (aX) {
			if (!_precomputed) precompute();
			if (mX1 === mY1 && mX2 === mY2) return aX; // linear
			// Because JavaScript number are imprecise, we should guarantee the extremes are right.
			if (aX === 0) return 0;
			if (aX === 1) return 1;
			return calcBezier(getTForX(aX), mY1, mY2);
		};

		f.getControlPoints = function () {
			return [{
				x: mX1,
				y: mY1
			}, {
				x: mX2,
				y: mY2
			}];
		};

		var args = [mX1, mY1, mX2, mY2];
		var str = "BezierEasing(" + args + ")";
		f.toString = function () {
			return str;
		};

		var css = "cubic-bezier(" + args + ")";
		f.toCSS = function () {
			return css;
		};

		return f;
	}

	// CSS mapping
	BezierEasing.css = {
		"ease": BezierEasing(0.25, 0.1, 0.25, 1.0),
		"linear": BezierEasing(0.00, 0.0, 1.00, 1.0),
		"ease-in": BezierEasing(0.42, 0.0, 1.00, 1.0),
		"ease-out": BezierEasing(0.00, 0.0, 0.58, 1.0),
		"ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0)
	};

	return BezierEasing;

}));

function getSetDescendantProp(obj, desc, value) {
	var arr = desc ? desc.split(".") : [];

	while (arr.length && obj) {
		var comp = arr.shift();
		var match = new RegExp("(.+)\\[([0-9]*)\\]").exec(comp);

		// handle arrays
		if ((match !== null) && (match.length == 3)) {
			var arrayData = {
				arrName: match[1],
				arrIndex: match[2]
			};
			if (obj[arrayData.arrName] !== undefined) {
				if (typeof value !== 'undefined' && arr.length === 0) {
					obj[arrayData.arrName][arrayData.arrIndex] = value;
				}
				obj = obj[arrayData.arrName][arrayData.arrIndex];
			} else {
				obj = undefined;
			}

			continue;
		}

		// handle regular things
		if (typeof value !== 'undefined') {
			if (obj[comp] === undefined) {
				obj[comp] = {};
			}

			if (arr.length === 0) {
				obj[comp] = value;
			}
		}

		obj = obj[comp];
	}

	return obj;
}

/******/
(function (modules) { // webpackBootstrap
	/******/ // The module cache
	/******/
	var installedModules = {};
	/******/
	/******/ // The require function
	/******/
	function __webpack_require__(moduleId) {
		/******/
		/******/ // Check if module is in cache
		/******/
		if (installedModules[moduleId])
			/******/
			return installedModules[moduleId].exports;
		/******/
		/******/ // Create a new module (and put it into the cache)
		/******/
		var module = installedModules[moduleId] = {
			/******/
			exports: {},
			/******/
			id: moduleId,
			/******/
			loaded: false
			/******/
		};
		/******/
		/******/ // Execute the module function
		/******/
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ // Flag the module as loaded
		/******/
		module.loaded = true;
		/******/
		/******/ // Return the exports of the module
		/******/
		return module.exports;
		/******/
	}
	/******/
	/******/
	/******/ // expose the modules object (__webpack_modules__)
	/******/
	__webpack_require__.m = modules;
	/******/
	/******/ // expose the module cache
	/******/
	__webpack_require__.c = installedModules;
	/******/
	/******/ // __webpack_public_path__
	/******/
	__webpack_require__.p = "";
	/******/
	/******/ // Load entry module and return exports
	/******/
	return __webpack_require__(0);
	/******/
})
/************************************************************************/
/******/
([
	/* 0 */
	/***/
	(function (module, exports, __webpack_require__) {

		'use strict';

		var msgpack = __webpack_require__(1);
		var Emitter = __webpack_require__(4);

		/**
		 * Packet types (see https://github.com/socketio/socket.io-protocol)
		 */

		exports.CONNECT = 0;
		exports.DISCONNECT = 1;
		exports.EVENT = 2;
		exports.ACK = 3;
		exports.ERROR = 4;
		exports.BINARY_EVENT = 5;
		exports.BINARY_ACK = 6;

		var errorPacket = {
			type: exports.ERROR,
			data: 'parser error'
		};

		function Encoder() {}

		Encoder.prototype.encode = function (packet, callback) {
			switch (packet.type) {
				case exports.CONNECT:
				case exports.DISCONNECT:
				case exports.ERROR:
					return callback([JSON.stringify(packet)]);
				default:
					return callback([msgpack.encode(packet)]);
			}
		};

		function Decoder() {}

		Emitter(Decoder.prototype);

		Decoder.prototype.add = function (obj) {
			if (typeof obj === 'string') {
				this.parseJSON(obj);
			} else {
				this.parseBinary(obj);
			}
		};

		Decoder.prototype.parseJSON = function (obj) {
			try {
				var decoded = JSON.parse(obj);
				this.emit('decoded', decoded);
			} catch (e) {
				this.emit('decoded', errorPacket);
			}
		};

		Decoder.prototype.parseBinary = function (obj) {
			try {
				var decoded = msgpack.decode(obj);
				this.emit('decoded', decoded);
			} catch (e) {
				this.emit('decoded', errorPacket);
			}
		};

		Decoder.prototype.destroy = function () {};

		exports.Encoder = Encoder;
		exports.Decoder = Decoder;

		window.msgPackEncoder = exports;

		/***/
	}),
	/* 1 */
	/***/
	(function (module, exports, __webpack_require__) {

		exports.encode = __webpack_require__(2);
		exports.decode = __webpack_require__(3);


		/***/
	}),
	/* 2 */
	/***/
	(function (module, exports) {

		'use strict';

		function utf8Write(view, offset, str) {
			var c = 0;
			for (var i = 0, l = str.length; i < l; i++) {
				c = str.charCodeAt(i);
				if (c < 0x80) {
					view.setUint8(offset++, c);
				} else if (c < 0x800) {
					view.setUint8(offset++, 0xc0 | (c >> 6));
					view.setUint8(offset++, 0x80 | (c & 0x3f));
				} else if (c < 0xd800 || c >= 0xe000) {
					view.setUint8(offset++, 0xe0 | (c >> 12));
					view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
					view.setUint8(offset++, 0x80 | (c & 0x3f));
				} else {
					i++;
					c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
					view.setUint8(offset++, 0xf0 | (c >> 18));
					view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);
					view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
					view.setUint8(offset++, 0x80 | (c & 0x3f));
				}
			}
		}

		function utf8Length(str) {
			var c = 0,
				length = 0;
			for (var i = 0, l = str.length; i < l; i++) {
				c = str.charCodeAt(i);
				if (c < 0x80) {
					length += 1;
				} else if (c < 0x800) {
					length += 2;
				} else if (c < 0xd800 || c >= 0xe000) {
					length += 3;
				} else {
					i++;
					length += 4;
				}
			}
			return length;
		}

		function _encode(bytes, defers, value) {
			var type = typeof value,
				i = 0,
				l = 0,
				hi = 0,
				lo = 0,
				length = 0,
				size = 0;

			if (type === 'string') {
				length = utf8Length(value);

				// fixstr
				if (length < 0x20) {
					bytes.push(length | 0xa0);
					size = 1;
				}
				// str 8
				else if (length < 0x100) {
					bytes.push(0xd9, length);
					size = 2;
				}
				// str 16
				else if (length < 0x10000) {
					bytes.push(0xda, length >> 8, length);
					size = 3;
				}
				// str 32
				else if (length < 0x100000000) {
					bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);
					size = 5;
				} else {
					throw new Error('String too long');
				}
				defers.push({
					str: value,
					length: length,
					offset: bytes.length
				});
				return size + length;
			}
			if (type === 'number') {
				// TODO: encode to float 32?

				// float 64
				if (Math.floor(value) !== value || !isFinite(value)) {
					bytes.push(0xcb);
					defers.push({
						float: value,
						length: 8,
						offset: bytes.length
					});
					return 9;
				}

				if (value >= 0) {
					// positive fixnum
					if (value < 0x80) {
						bytes.push(value);
						return 1;
					}
					// uint 8
					if (value < 0x100) {
						bytes.push(0xcc, value);
						return 2;
					}
					// uint 16
					if (value < 0x10000) {
						bytes.push(0xcd, value >> 8, value);
						return 3;
					}
					// uint 32
					if (value < 0x100000000) {
						bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);
						return 5;
					}
					// uint 64
					hi = (value / Math.pow(2, 32)) >> 0;
					lo = value >>> 0;
					bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
					return 9;
				} else {
					// negative fixnum
					if (value >= -0x20) {
						bytes.push(value);
						return 1;
					}
					// int 8
					if (value >= -0x80) {
						bytes.push(0xd0, value);
						return 2;
					}
					// int 16
					if (value >= -0x8000) {
						bytes.push(0xd1, value >> 8, value);
						return 3;
					}
					// int 32
					if (value >= -0x80000000) {
						bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);
						return 5;
					}
					// int 64
					hi = Math.floor(value / Math.pow(2, 32));
					lo = value >>> 0;
					bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
					return 9;
				}
			}
			if (type === 'object') {
				// nil
				if (value === null) {
					bytes.push(0xc0);
					return 1;
				}

				if (Array.isArray(value)) {
					length = value.length;

					// fixarray
					if (length < 0x10) {
						bytes.push(length | 0x90);
						size = 1;
					}
					// array 16
					else if (length < 0x10000) {
						bytes.push(0xdc, length >> 8, length);
						size = 3;
					}
					// array 32
					else if (length < 0x100000000) {
						bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);
						size = 5;
					} else {
						throw new Error('Array too large');
					}
					for (i = 0; i < length; i++) {
						size += _encode(bytes, defers, value[i]);
					}
					return size;
				}

				// fixext 8 / Date
				if (value instanceof Date) {
					var time = value.getTime();
					hi = Math.floor(time / Math.pow(2, 32));
					lo = time >>> 0;
					bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
					return 10;
				}

				if (value instanceof ArrayBuffer) {
					length = value.byteLength;

					// bin 8
					if (length < 0x100) {
						bytes.push(0xc4, length);
						size = 2;
					} else
						// bin 16
						if (length < 0x10000) {
							bytes.push(0xc5, length >> 8, length);
							size = 3;
						} else
							// bin 32
							if (length < 0x100000000) {
								bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);
								size = 5;
							} else {
								throw new Error('Buffer too large');
							}
					defers.push({
						bin: value,
						length: length,
						offset: bytes.length
					});
					return size + length;
				}

				if (typeof value.toJSON === 'function') {
					return _encode(bytes, defers, value.toJSON());
				}

				var keys = [],
					key = '';

				var allKeys = Object.keys(value);
				for (i = 0, l = allKeys.length; i < l; i++) {
					key = allKeys[i];
					if (typeof value[key] !== 'function') {
						keys.push(key);
					}
				}
				length = keys.length;

				// fixmap
				if (length < 0x10) {
					bytes.push(length | 0x80);
					size = 1;
				}
				// map 16
				else if (length < 0x10000) {
					bytes.push(0xde, length >> 8, length);
					size = 3;
				}
				// map 32
				else if (length < 0x100000000) {
					bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);
					size = 5;
				} else {
					throw new Error('Object too large');
				}

				for (i = 0; i < length; i++) {
					key = keys[i];
					size += _encode(bytes, defers, key);
					size += _encode(bytes, defers, value[key]);
				}
				return size;
			}
			// false/true
			if (type === 'boolean') {
				bytes.push(value ? 0xc3 : 0xc2);
				return 1;
			}
			// fixext 1 / undefined
			if (type === 'undefined') {
				bytes.push(0xd4, 0, 0);
				return 3;
			}
			throw new Error('Could not encode');
		}

		function encode(value) {
			var bytes = [];
			var defers = [];
			var size = _encode(bytes, defers, value);
			var buf = new ArrayBuffer(size);
			var view = new DataView(buf);

			var deferIndex = 0;
			var deferWritten = 0;
			var nextOffset = -1;
			if (defers.length > 0) {
				nextOffset = defers[0].offset;
			}

			var defer, deferLength = 0,
				offset = 0;
			for (var i = 0, l = bytes.length; i < l; i++) {
				view.setUint8(deferWritten + i, bytes[i]);
				if (i + 1 !== nextOffset) {
					continue;
				}
				defer = defers[deferIndex];
				deferLength = defer.length;
				offset = deferWritten + nextOffset;
				if (defer.bin) {
					var bin = new Uint8Array(defer.bin);
					for (var j = 0; j < deferLength; j++) {
						view.setUint8(offset + j, bin[j]);
					}
				} else if (defer.str) {
					utf8Write(view, offset, defer.str);
				} else if (defer.float !== undefined) {
					view.setFloat64(offset, defer.float);
				}
				deferIndex++;
				deferWritten += deferLength;
				if (defers[deferIndex]) {
					nextOffset = defers[deferIndex].offset;
				}
			}
			return buf;
		}

		module.exports = encode;


		/***/
	}),
	/* 3 */
	/***/
	(function (module, exports) {

		'use strict';

		function Decoder(buffer) {
			this.offset = 0;
			if (buffer instanceof ArrayBuffer) {
				this.buffer = buffer;
				this.view = new DataView(this.buffer);
			} else if (ArrayBuffer.isView(buffer)) {
				this.buffer = buffer.buffer;
				this.view = new DataView(this.buffer, buffer.byteOffset, buffer.byteLength);
			} else {
				throw new Error('Invalid argument');
			}
		}

		function utf8Read(view, offset, length) {
			var string = '',
				chr = 0;
			for (var i = offset, end = offset + length; i < end; i++) {
				var byte = view.getUint8(i);
				if ((byte & 0x80) === 0x00) {
					string += String.fromCharCode(byte);
					continue;
				}
				if ((byte & 0xe0) === 0xc0) {
					string += String.fromCharCode(
						((byte & 0x1f) << 6) |
						(view.getUint8(++i) & 0x3f)
					);
					continue;
				}
				if ((byte & 0xf0) === 0xe0) {
					string += String.fromCharCode(
						((byte & 0x0f) << 12) |
						((view.getUint8(++i) & 0x3f) << 6) |
						((view.getUint8(++i) & 0x3f) << 0)
					);
					continue;
				}
				if ((byte & 0xf8) === 0xf0) {
					chr = ((byte & 0x07) << 18) |
						((view.getUint8(++i) & 0x3f) << 12) |
						((view.getUint8(++i) & 0x3f) << 6) |
						((view.getUint8(++i) & 0x3f) << 0);
					if (chr >= 0x010000) { // surrogate pair
						chr -= 0x010000;
						string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
					} else {
						string += String.fromCharCode(chr);
					}
					continue;
				}
				throw new Error('Invalid byte ' + byte.toString(16));
			}
			return string;
		}

		Decoder.prototype.array = function (length) {
			var value = new Array(length);
			for (var i = 0; i < length; i++) {
				value[i] = this.parse();
			}
			return value;
		};

		Decoder.prototype.map = function (length) {
			var key = '',
				value = {};
			for (var i = 0; i < length; i++) {
				key = this.parse();
				value[key] = this.parse();
			}
			return value;
		};

		Decoder.prototype.str = function (length) {
			var value = utf8Read(this.view, this.offset, length);
			this.offset += length;
			return value;
		};

		Decoder.prototype.bin = function (length) {
			var value = this.buffer.slice(this.offset, this.offset + length);
			this.offset += length;
			return value;
		};

		Decoder.prototype.parse = function () {
			var prefix = this.view.getUint8(this.offset++);
			var value, length = 0,
				type = 0,
				hi = 0,
				lo = 0;

			if (prefix < 0xc0) {
				// positive fixint
				if (prefix < 0x80) {
					return prefix;
				}
				// fixmap
				if (prefix < 0x90) {
					return this.map(prefix & 0x0f);
				}
				// fixarray
				if (prefix < 0xa0) {
					return this.array(prefix & 0x0f);
				}
				// fixstr
				return this.str(prefix & 0x1f);
			}

			// negative fixint
			if (prefix > 0xdf) {
				return (0xff - prefix + 1) * -1;
			}

			switch (prefix) {
				// nil
				case 0xc0:
					return null;
					// false
				case 0xc2:
					return false;
					// true
				case 0xc3:
					return true;

					// bin
				case 0xc4:
					length = this.view.getUint8(this.offset);
					this.offset += 1;
					return this.bin(length);
				case 0xc5:
					length = this.view.getUint16(this.offset);
					this.offset += 2;
					return this.bin(length);
				case 0xc6:
					length = this.view.getUint32(this.offset);
					this.offset += 4;
					return this.bin(length);

					// ext
				case 0xc7:
					length = this.view.getUint8(this.offset);
					type = this.view.getInt8(this.offset + 1);
					this.offset += 2;
					return [type, this.bin(length)];
				case 0xc8:
					length = this.view.getUint16(this.offset);
					type = this.view.getInt8(this.offset + 2);
					this.offset += 3;
					return [type, this.bin(length)];
				case 0xc9:
					length = this.view.getUint32(this.offset);
					type = this.view.getInt8(this.offset + 4);
					this.offset += 5;
					return [type, this.bin(length)];

					// float
				case 0xca:
					value = this.view.getFloat32(this.offset);
					this.offset += 4;
					return value;
				case 0xcb:
					value = this.view.getFloat64(this.offset);
					this.offset += 8;
					return value;

					// uint
				case 0xcc:
					value = this.view.getUint8(this.offset);
					this.offset += 1;
					return value;
				case 0xcd:
					value = this.view.getUint16(this.offset);
					this.offset += 2;
					return value;
				case 0xce:
					value = this.view.getUint32(this.offset);
					this.offset += 4;
					return value;
				case 0xcf:
					hi = this.view.getUint32(this.offset) * Math.pow(2, 32);
					lo = this.view.getUint32(this.offset + 4);
					this.offset += 8;
					return hi + lo;

					// int
				case 0xd0:
					value = this.view.getInt8(this.offset);
					this.offset += 1;
					return value;
				case 0xd1:
					value = this.view.getInt16(this.offset);
					this.offset += 2;
					return value;
				case 0xd2:
					value = this.view.getInt32(this.offset);
					this.offset += 4;
					return value;
				case 0xd3:
					hi = this.view.getInt32(this.offset) * Math.pow(2, 32);
					lo = this.view.getUint32(this.offset + 4);
					this.offset += 8;
					return hi + lo;

					// fixext
				case 0xd4:
					type = this.view.getInt8(this.offset);
					this.offset += 1;
					if (type === 0x00) {
						this.offset += 1;
						return void 0;
					}
					return [type, this.bin(1)];
				case 0xd5:
					type = this.view.getInt8(this.offset);
					this.offset += 1;
					return [type, this.bin(2)];
				case 0xd6:
					type = this.view.getInt8(this.offset);
					this.offset += 1;
					return [type, this.bin(4)];
				case 0xd7:
					type = this.view.getInt8(this.offset);
					this.offset += 1;
					if (type === 0x00) {
						hi = this.view.getInt32(this.offset) * Math.pow(2, 32);
						lo = this.view.getUint32(this.offset + 4);
						this.offset += 8;
						return new Date(hi + lo);
					}
					return [type, this.bin(8)];
				case 0xd8:
					type = this.view.getInt8(this.offset);
					this.offset += 1;
					return [type, this.bin(16)];

					// str
				case 0xd9:
					length = this.view.getUint8(this.offset);
					this.offset += 1;
					return this.str(length);
				case 0xda:
					length = this.view.getUint16(this.offset);
					this.offset += 2;
					return this.str(length);
				case 0xdb:
					length = this.view.getUint32(this.offset);
					this.offset += 4;
					return this.str(length);

					// array
				case 0xdc:
					length = this.view.getUint16(this.offset);
					this.offset += 2;
					return this.array(length);
				case 0xdd:
					length = this.view.getUint32(this.offset);
					this.offset += 4;
					return this.array(length);

					// map
				case 0xde:
					length = this.view.getUint16(this.offset);
					this.offset += 2;
					return this.map(length);
				case 0xdf:
					length = this.view.getUint32(this.offset);
					this.offset += 4;
					return this.map(length);
			}

			throw new Error('Could not parse');
		};

		function decode(buffer) {
			var decoder = new Decoder(buffer);
			var value = decoder.parse();
			if (decoder.offset !== buffer.byteLength) {
				throw new Error((buffer.byteLength - decoder.offset) + ' trailing bytes');
			}
			return value;
		}

		module.exports = decode;


		/***/
	}),
	/* 4 */
	/***/
	(function (module, exports, __webpack_require__) {


		/**
		 * Expose `Emitter`.
		 */

		if (true) {
			module.exports = Emitter;
		}

		/**
		 * Initialize a new `Emitter`.
		 *
		 * @api public
		 */

		function Emitter(obj) {
			if (obj) return mixin(obj);
		};

		/**
		 * Mixin the emitter properties.
		 *
		 * @param {Object} obj
		 * @return {Object}
		 * @api private
		 */

		function mixin(obj) {
			for (var key in Emitter.prototype) {
				obj[key] = Emitter.prototype[key];
			}
			return obj;
		}

		/**
		 * Listen on the given `event` with `fn`.
		 *
		 * @param {String} event
		 * @param {Function} fn
		 * @return {Emitter}
		 * @api public
		 */

		Emitter.prototype.on =
			Emitter.prototype.addEventListener = function (event, fn) {
				this._callbacks = this._callbacks || {};
				(this._callbacks['$' + event] = this._callbacks['$' + event] || [])
				.push(fn);
				return this;
			};

		/**
		 * Adds an `event` listener that will be invoked a single
		 * time then automatically removed.
		 *
		 * @param {String} event
		 * @param {Function} fn
		 * @return {Emitter}
		 * @api public
		 */

		Emitter.prototype.once = function (event, fn) {
			function on() {
				this.off(event, on);
				fn.apply(this, arguments);
			}

			on.fn = fn;
			this.on(event, on);
			return this;
		};

		/**
		 * Remove the given callback for `event` or all
		 * registered callbacks.
		 *
		 * @param {String} event
		 * @param {Function} fn
		 * @return {Emitter}
		 * @api public
		 */

		Emitter.prototype.off =
			Emitter.prototype.removeListener =
			Emitter.prototype.removeAllListeners =
			Emitter.prototype.removeEventListener = function (event, fn) {
				this._callbacks = this._callbacks || {};

				// all
				if (0 == arguments.length) {
					this._callbacks = {};
					return this;
				}

				// specific event
				var callbacks = this._callbacks['$' + event];
				if (!callbacks) return this;

				// remove all handlers
				if (1 == arguments.length) {
					delete this._callbacks['$' + event];
					return this;
				}

				// remove specific handler
				var cb;
				for (var i = 0; i < callbacks.length; i++) {
					cb = callbacks[i];
					if (cb === fn || cb.fn === fn) {
						callbacks.splice(i, 1);
						break;
					}
				}
				return this;
			};

		/**
		 * Emit `event` with the given args.
		 *
		 * @param {String} event
		 * @param {Mixed} ...
		 * @return {Emitter}
		 */

		Emitter.prototype.emit = function (event) {
			this._callbacks = this._callbacks || {};
			var args = [].slice.call(arguments, 1),
				callbacks = this._callbacks['$' + event];

			if (callbacks) {
				callbacks = callbacks.slice(0);
				for (var i = 0, len = callbacks.length; i < len; ++i) {
					callbacks[i].apply(this, args);
				}
			}

			return this;
		};

		/**
		 * Return array of callbacks for `event`.
		 *
		 * @param {String} event
		 * @return {Array}
		 * @api public
		 */

		Emitter.prototype.listeners = function (event) {
			this._callbacks = this._callbacks || {};
			return this._callbacks['$' + event] || [];
		};

		/**
		 * Check if this emitter has `event` handlers.
		 *
		 * @param {String} event
		 * @return {Boolean}
		 * @api public
		 */

		Emitter.prototype.hasListeners = function (event) {
			return !!this.listeners(event).length;
		};


		/***/
	})
	/******/
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOGYwNTI3OGRhMzJmYTVhZGQ1YTAiLCJ3ZWJwYWNrOi8vLy4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub3RlcGFjay5pby9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub3RlcGFjay5pby9icm93c2VyL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25vdGVwYWNrLmlvL2Jyb3dzZXIvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiXSwibmFtZXMiOlsibXNncGFjayIsInJlcXVpcmUiLCJFbWl0dGVyIiwiZXhwb3J0cyIsIkNPTk5FQ1QiLCJESVNDT05ORUNUIiwiRVZFTlQiLCJBQ0siLCJFUlJPUiIsIkJJTkFSWV9FVkVOVCIsIkJJTkFSWV9BQ0siLCJlcnJvclBhY2tldCIsInR5cGUiLCJkYXRhIiwiRW5jb2RlciIsInByb3RvdHlwZSIsImVuY29kZSIsInBhY2tldCIsImNhbGxiYWNrIiwiSlNPTiIsInN0cmluZ2lmeSIsIkRlY29kZXIiLCJhZGQiLCJvYmoiLCJwYXJzZUpTT04iLCJwYXJzZUJpbmFyeSIsImRlY29kZWQiLCJwYXJzZSIsImVtaXQiLCJlIiwiZGVjb2RlIiwiZGVzdHJveSIsIndpbmRvdyIsIm1zZ1BhY2tFbmNvZGVyIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDckNBLEtBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkO0FBQ0EsS0FBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUE7Ozs7QUFJQUUsU0FBUUMsT0FBUixHQUFrQixDQUFsQjtBQUNBRCxTQUFRRSxVQUFSLEdBQXFCLENBQXJCO0FBQ0FGLFNBQVFHLEtBQVIsR0FBZ0IsQ0FBaEI7QUFDQUgsU0FBUUksR0FBUixHQUFjLENBQWQ7QUFDQUosU0FBUUssS0FBUixHQUFnQixDQUFoQjtBQUNBTCxTQUFRTSxZQUFSLEdBQXVCLENBQXZCO0FBQ0FOLFNBQVFPLFVBQVIsR0FBcUIsQ0FBckI7O0FBRUEsS0FBSUMsY0FBYztBQUNoQkMsU0FBTVQsUUFBUUssS0FERTtBQUVoQkssU0FBTTtBQUZVLEVBQWxCOztBQUtBLFVBQVNDLE9BQVQsR0FBb0IsQ0FBRTs7QUFFdEJBLFNBQVFDLFNBQVIsQ0FBa0JDLE1BQWxCLEdBQTJCLFVBQVVDLE1BQVYsRUFBa0JDLFFBQWxCLEVBQTRCO0FBQ3JELFdBQVFELE9BQU9MLElBQWY7QUFDRSxVQUFLVCxRQUFRQyxPQUFiO0FBQ0EsVUFBS0QsUUFBUUUsVUFBYjtBQUNBLFVBQUtGLFFBQVFLLEtBQWI7QUFDRSxjQUFPVSxTQUFTLENBQUVDLEtBQUtDLFNBQUwsQ0FBZUgsTUFBZixDQUFGLENBQVQsQ0FBUDtBQUNGO0FBQ0UsY0FBT0MsU0FBUyxDQUFFbEIsUUFBUWdCLE1BQVIsQ0FBZUMsTUFBZixDQUFGLENBQVQsQ0FBUDtBQU5KO0FBUUQsRUFURDs7QUFXQSxVQUFTSSxPQUFULEdBQW9CLENBQUU7O0FBRXRCbkIsU0FBUW1CLFFBQVFOLFNBQWhCOztBQUVBTSxTQUFRTixTQUFSLENBQWtCTyxHQUFsQixHQUF3QixVQUFVQyxHQUFWLEVBQWU7QUFDckMsT0FBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsVUFBS0MsU0FBTCxDQUFlRCxHQUFmO0FBQ0QsSUFGRCxNQUVPO0FBQ0wsVUFBS0UsV0FBTCxDQUFpQkYsR0FBakI7QUFDRDtBQUNGLEVBTkQ7O0FBUUFGLFNBQVFOLFNBQVIsQ0FBa0JTLFNBQWxCLEdBQThCLFVBQVVELEdBQVYsRUFBZTtBQUMzQyxPQUFJO0FBQ0YsU0FBSUcsVUFBVVAsS0FBS1EsS0FBTCxDQUFXSixHQUFYLENBQWQ7QUFDQSxVQUFLSyxJQUFMLENBQVUsU0FBVixFQUFxQkYsT0FBckI7QUFDRCxJQUhELENBR0UsT0FBT0csQ0FBUCxFQUFVO0FBQ1YsVUFBS0QsSUFBTCxDQUFVLFNBQVYsRUFBcUJqQixXQUFyQjtBQUNEO0FBQ0YsRUFQRDs7QUFTQVUsU0FBUU4sU0FBUixDQUFrQlUsV0FBbEIsR0FBZ0MsVUFBVUYsR0FBVixFQUFlO0FBQzdDLE9BQUk7QUFDRixTQUFJRyxVQUFVMUIsUUFBUThCLE1BQVIsQ0FBZVAsR0FBZixDQUFkO0FBQ0EsVUFBS0ssSUFBTCxDQUFVLFNBQVYsRUFBcUJGLE9BQXJCO0FBQ0QsSUFIRCxDQUdFLE9BQU9HLENBQVAsRUFBVTtBQUNWLFVBQUtELElBQUwsQ0FBVSxTQUFWLEVBQXFCakIsV0FBckI7QUFDRDtBQUNGLEVBUEQ7O0FBU0FVLFNBQVFOLFNBQVIsQ0FBa0JnQixPQUFsQixHQUE0QixZQUFZLENBQUUsQ0FBMUM7O0FBRUE1QixTQUFRVyxPQUFSLEdBQWtCQSxPQUFsQjtBQUNBWCxTQUFRa0IsT0FBUixHQUFrQkEsT0FBbEI7O0FBRUFXLFFBQU9DLGNBQVAsR0FBd0I5QixPQUF4QixDOzs7Ozs7QUNyRUE7QUFDQTs7Ozs7OztBQ0RBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWlCLG1EQUFtRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZ0RBQWdEO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFtQixtREFBbUQ7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBLGdCQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdlJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxNQUFNO0FBQ2pCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoic29ja2V0LmlvLW1zZ3BhY2stcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOGYwNTI3OGRhMzJmYTVhZGQ1YTAiLCJcbnZhciBtc2dwYWNrID0gcmVxdWlyZSgnbm90ZXBhY2suaW8nKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vc29ja2V0LmlvLXByb3RvY29sKVxuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuZXhwb3J0cy5FVkVOVCA9IDI7XG5leHBvcnRzLkFDSyA9IDM7XG5leHBvcnRzLkVSUk9SID0gNDtcbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbnZhciBlcnJvclBhY2tldCA9IHtcbiAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgZGF0YTogJ3BhcnNlciBlcnJvcidcbn07XG5cbmZ1bmN0aW9uIEVuY29kZXIgKCkge31cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5DT05ORUNUOlxuICAgIGNhc2UgZXhwb3J0cy5ESVNDT05ORUNUOlxuICAgIGNhc2UgZXhwb3J0cy5FUlJPUjpcbiAgICAgIHJldHVybiBjYWxsYmFjayhbIEpTT04uc3RyaW5naWZ5KHBhY2tldCkgXSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjYWxsYmFjayhbIG1zZ3BhY2suZW5jb2RlKHBhY2tldCkgXSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIERlY29kZXIgKCkge31cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5wYXJzZUpTT04ob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlQmluYXJ5KG9iaik7XG4gIH1cbn07XG5cbkRlY29kZXIucHJvdG90eXBlLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdHJ5IHtcbiAgICB2YXIgZGVjb2RlZCA9IEpTT04ucGFyc2Uob2JqKTtcbiAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBkZWNvZGVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIGVycm9yUGFja2V0KTtcbiAgfVxufTtcblxuRGVjb2Rlci5wcm90b3R5cGUucGFyc2VCaW5hcnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHRyeSB7XG4gICAgdmFyIGRlY29kZWQgPSBtc2dwYWNrLmRlY29kZShvYmopO1xuICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIGRlY29kZWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgZXJyb3JQYWNrZXQpO1xuICB9XG59O1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG53aW5kb3cubXNnUGFja0VuY29kZXIgPSBleHBvcnRzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2luZGV4LmpzIiwiZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuZXhwb3J0cy5kZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25vdGVwYWNrLmlvL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cikge1xuICB2YXIgYyA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ZTAgfCAoYyA+PiAxMikpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHg4MCB8IChjID4+IDYpICYgMHgzZik7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweGYwIHwgKGMgPj4gMTgpKTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ODAgfCAoYyA+PiAxMikgJiAweDNmKTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ODAgfCAoYyA+PiA2KSAmIDB4M2YpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xuICB2YXIgYyA9IDAsIGxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGxlbmd0aCArPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIGxlbmd0aCArPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICBsZW5ndGggKz0gMztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBsZW5ndGggKz0gNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuZnVuY3Rpb24gX2VuY29kZShieXRlcywgZGVmZXJzLCB2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSwgaSA9IDAsIGwgPSAwLCBoaSA9IDAsIGxvID0gMCwgbGVuZ3RoID0gMCwgc2l6ZSA9IDA7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbGVuZ3RoID0gdXRmOExlbmd0aCh2YWx1ZSk7XG5cbiAgICAvLyBmaXhzdHJcbiAgICBpZiAobGVuZ3RoIDwgMHgyMCkge1xuICAgICAgYnl0ZXMucHVzaChsZW5ndGggfCAweGEwKTtcbiAgICAgIHNpemUgPSAxO1xuICAgIH1cbiAgICAvLyBzdHIgOFxuICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICBieXRlcy5wdXNoKDB4ZDksIGxlbmd0aCk7XG4gICAgICBzaXplID0gMjtcbiAgICB9XG4gICAgLy8gc3RyIDE2XG4gICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgYnl0ZXMucHVzaCgweGRhLCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgIHNpemUgPSAzO1xuICAgIH1cbiAgICAvLyBzdHIgMzJcbiAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgYnl0ZXMucHVzaCgweGRiLCBsZW5ndGggPj4gMjQsIGxlbmd0aCA+PiAxNiwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICBzaXplID0gNTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdG9vIGxvbmcnKTtcbiAgICB9XG4gICAgZGVmZXJzLnB1c2goeyBzdHI6IHZhbHVlLCBsZW5ndGg6IGxlbmd0aCwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHNpemUgKyBsZW5ndGg7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gVE9ETzogZW5jb2RlIHRvIGZsb2F0IDMyP1xuXG4gICAgLy8gZmxvYXQgNjRcbiAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIGJ5dGVzLnB1c2goMHhjYik7XG4gICAgICBkZWZlcnMucHVzaCh7IGZsb2F0OiB2YWx1ZSwgbGVuZ3RoOiA4LCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICAgIHJldHVybiA5O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAvLyBwb3NpdGl2ZSBmaXhudW1cbiAgICAgIGlmICh2YWx1ZSA8IDB4ODApIHtcbiAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgLy8gdWludCA4XG4gICAgICBpZiAodmFsdWUgPCAweDEwMCkge1xuICAgICAgICBieXRlcy5wdXNoKDB4Y2MsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG4gICAgICAvLyB1aW50IDE2XG4gICAgICBpZiAodmFsdWUgPCAweDEwMDAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhjZCwgdmFsdWUgPj4gOCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH1cbiAgICAgIC8vIHVpbnQgMzJcbiAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhjZSwgdmFsdWUgPj4gMjQsIHZhbHVlID4+IDE2LCB2YWx1ZSA+PiA4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiA1O1xuICAgICAgfVxuICAgICAgLy8gdWludCA2NFxuICAgICAgaGkgPSAodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpID4+IDA7XG4gICAgICBsbyA9IHZhbHVlID4+PiAwO1xuICAgICAgYnl0ZXMucHVzaCgweGNmLCBoaSA+PiAyNCwgaGkgPj4gMTYsIGhpID4+IDgsIGhpLCBsbyA+PiAyNCwgbG8gPj4gMTYsIGxvID4+IDgsIGxvKTtcbiAgICAgIHJldHVybiA5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZWdhdGl2ZSBmaXhudW1cbiAgICAgIGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuICAgICAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICAvLyBpbnQgOFxuICAgICAgaWYgKHZhbHVlID49IC0weDgwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhkMCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIC8vIGludCAxNlxuICAgICAgaWYgKHZhbHVlID49IC0weDgwMDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGQxLCB2YWx1ZSA+PiA4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfVxuICAgICAgLy8gaW50IDMyXG4gICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGQyLCB2YWx1ZSA+PiAyNCwgdmFsdWUgPj4gMTYsIHZhbHVlID4+IDgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICB9XG4gICAgICAvLyBpbnQgNjRcbiAgICAgIGhpID0gTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDIsIDMyKSk7XG4gICAgICBsbyA9IHZhbHVlID4+PiAwO1xuICAgICAgYnl0ZXMucHVzaCgweGQzLCBoaSA+PiAyNCwgaGkgPj4gMTYsIGhpID4+IDgsIGhpLCBsbyA+PiAyNCwgbG8gPj4gMTYsIGxvID4+IDgsIGxvKTtcbiAgICAgIHJldHVybiA5O1xuICAgIH1cbiAgfVxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBuaWxcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGJ5dGVzLnB1c2goMHhjMCk7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgLy8gZml4YXJyYXlcbiAgICAgIGlmIChsZW5ndGggPCAweDEwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2gobGVuZ3RoIHwgMHg5MCk7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfVxuICAgICAgLy8gYXJyYXkgMTZcbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGRjLCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgc2l6ZSA9IDM7XG4gICAgICB9XG4gICAgICAvLyBhcnJheSAzMlxuICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGRkLCBsZW5ndGggPj4gMjQsIGxlbmd0aCA+PiAxNiwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgIHNpemUgPSA1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSB0b28gbGFyZ2UnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzaXplICs9IF9lbmNvZGUoYnl0ZXMsIGRlZmVycywgdmFsdWVbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgLy8gZml4ZXh0IDggLyBEYXRlXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdmFyIHRpbWUgPSB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICBoaSA9IE1hdGguZmxvb3IodGltZSAvIE1hdGgucG93KDIsIDMyKSk7XG4gICAgICBsbyA9IHRpbWUgPj4+IDA7XG4gICAgICBieXRlcy5wdXNoKDB4ZDcsIDAsIGhpID4+IDI0LCBoaSA+PiAxNiwgaGkgPj4gOCwgaGksIGxvID4+IDI0LCBsbyA+PiAxNiwgbG8gPj4gOCwgbG8pO1xuICAgICAgcmV0dXJuIDEwO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG4gICAgICAvLyBiaW4gOFxuICAgICAgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhjNCwgbGVuZ3RoKTtcbiAgICAgICAgc2l6ZSA9IDI7XG4gICAgICB9IGVsc2VcbiAgICAgIC8vIGJpbiAxNlxuICAgICAgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGM1LCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgc2l6ZSA9IDM7XG4gICAgICB9IGVsc2VcbiAgICAgIC8vIGJpbiAzMlxuICAgICAgaWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhjNiwgbGVuZ3RoID4+IDI0LCBsZW5ndGggPj4gMTYsIGxlbmd0aCA+PiA4LCBsZW5ndGgpO1xuICAgICAgICBzaXplID0gNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyIHRvbyBsYXJnZScpO1xuICAgICAgfVxuICAgICAgZGVmZXJzLnB1c2goeyBiaW46IHZhbHVlLCBsZW5ndGg6IGxlbmd0aCwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgICByZXR1cm4gc2l6ZSArIGxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF9lbmNvZGUoYnl0ZXMsIGRlZmVycywgdmFsdWUudG9KU09OKCkpO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW10sIGtleSA9ICcnO1xuXG4gICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgZm9yIChpID0gMCwgbCA9IGFsbEtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBhbGxLZXlzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtrZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIC8vIGZpeG1hcFxuICAgIGlmIChsZW5ndGggPCAweDEwKSB7XG4gICAgICBieXRlcy5wdXNoKGxlbmd0aCB8IDB4ODApO1xuICAgICAgc2l6ZSA9IDE7XG4gICAgfVxuICAgIC8vIG1hcCAxNlxuICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgIGJ5dGVzLnB1c2goMHhkZSwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICBzaXplID0gMztcbiAgICB9XG4gICAgLy8gbWFwIDMyXG4gICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgIGJ5dGVzLnB1c2goMHhkZiwgbGVuZ3RoID4+IDI0LCBsZW5ndGggPj4gMTYsIGxlbmd0aCA+PiA4LCBsZW5ndGgpO1xuICAgICAgc2l6ZSA9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IHRvbyBsYXJnZScpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHNpemUgKz0gX2VuY29kZShieXRlcywgZGVmZXJzLCBrZXkpO1xuICAgICAgc2l6ZSArPSBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICAvLyBmYWxzZS90cnVlXG4gIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICBieXRlcy5wdXNoKHZhbHVlID8gMHhjMyA6IDB4YzIpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIC8vIGZpeGV4dCAxIC8gdW5kZWZpbmVkXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgIGJ5dGVzLnB1c2goMHhkNCwgMCwgMCk7XG4gICAgcmV0dXJuIDM7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZW5jb2RlJyk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICB2YXIgYnl0ZXMgPSBbXTtcbiAgdmFyIGRlZmVycyA9IFtdO1xuICB2YXIgc2l6ZSA9IF9lbmNvZGUoYnl0ZXMsIGRlZmVycywgdmFsdWUpO1xuICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWYpO1xuXG4gIHZhciBkZWZlckluZGV4ID0gMDtcbiAgdmFyIGRlZmVyV3JpdHRlbiA9IDA7XG4gIHZhciBuZXh0T2Zmc2V0ID0gLTE7XG4gIGlmIChkZWZlcnMubGVuZ3RoID4gMCkge1xuICAgIG5leHRPZmZzZXQgPSBkZWZlcnNbMF0ub2Zmc2V0O1xuICB9XG5cbiAgdmFyIGRlZmVyLCBkZWZlckxlbmd0aCA9IDAsIG9mZnNldCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYnl0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmlldy5zZXRVaW50OChkZWZlcldyaXR0ZW4gKyBpLCBieXRlc1tpXSk7XG4gICAgaWYgKGkgKyAxICE9PSBuZXh0T2Zmc2V0KSB7IGNvbnRpbnVlOyB9XG4gICAgZGVmZXIgPSBkZWZlcnNbZGVmZXJJbmRleF07XG4gICAgZGVmZXJMZW5ndGggPSBkZWZlci5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gZGVmZXJXcml0dGVuICsgbmV4dE9mZnNldDtcbiAgICBpZiAoZGVmZXIuYmluKSB7XG4gICAgICB2YXIgYmluID0gbmV3IFVpbnQ4QXJyYXkoZGVmZXIuYmluKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVmZXJMZW5ndGg7IGorKykge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGosIGJpbltqXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWZlci5zdHIpIHtcbiAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIGRlZmVyLnN0cik7XG4gICAgfSBlbHNlIGlmIChkZWZlci5mbG9hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0LCBkZWZlci5mbG9hdCk7XG4gICAgfVxuICAgIGRlZmVySW5kZXgrKztcbiAgICBkZWZlcldyaXR0ZW4gKz0gZGVmZXJMZW5ndGg7XG4gICAgaWYgKGRlZmVyc1tkZWZlckluZGV4XSkge1xuICAgICAgbmV4dE9mZnNldCA9IGRlZmVyc1tkZWZlckluZGV4XS5vZmZzZXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25vdGVwYWNrLmlvL2Jyb3dzZXIvZW5jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRGVjb2RlcihidWZmZXIpIHtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4UmVhZCh2aWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgc3RyaW5nID0gJycsIGNociA9IDA7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgIGlmICgoYnl0ZSAmIDB4ODApID09PSAweDAwKSB7XG4gICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKGJ5dGUgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICgoYnl0ZSAmIDB4MWYpIDw8IDYpIHxcbiAgICAgICAgKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoYnl0ZSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgKChieXRlICYgMHgwZikgPDwgMTIpIHxcbiAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMClcbiAgICAgICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChieXRlICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIGNociA9ICgoYnl0ZSAmIDB4MDcpIDw8IDE4KSB8XG4gICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMTIpIHxcbiAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCk7XG4gICAgICBpZiAoY2hyID49IDB4MDEwMDAwKSB7IC8vIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgIGNociAtPSAweDAxMDAwMDtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNociA+Pj4gMTApICsgMHhEODAwLCAoY2hyICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGUudG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgdmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZVtpXSA9IHRoaXMucGFyc2UoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5EZWNvZGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIHZhciBrZXkgPSAnJywgdmFsdWUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHRoaXMucGFyc2UoKTtcbiAgICB2YWx1ZVtrZXldID0gdGhpcy5wYXJzZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbkRlY29kZXIucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgdmFyIHZhbHVlID0gdXRmOFJlYWQodGhpcy52aWV3LCB0aGlzLm9mZnNldCwgbGVuZ3RoKTtcbiAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5EZWNvZGVyLnByb3RvdHlwZS5iaW4gPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIHZhciB2YWx1ZSA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbmd0aCk7XG4gIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuRGVjb2Rlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcmVmaXggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQrKyk7XG4gIHZhciB2YWx1ZSwgbGVuZ3RoID0gMCwgdHlwZSA9IDAsIGhpID0gMCwgbG8gPSAwO1xuXG4gIGlmIChwcmVmaXggPCAweGMwKSB7XG4gICAgLy8gcG9zaXRpdmUgZml4aW50XG4gICAgaWYgKHByZWZpeCA8IDB4ODApIHtcbiAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxuICAgIC8vIGZpeG1hcFxuICAgIGlmIChwcmVmaXggPCAweDkwKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAocHJlZml4ICYgMHgwZik7XG4gICAgfVxuICAgIC8vIGZpeGFycmF5XG4gICAgaWYgKHByZWZpeCA8IDB4YTApIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KHByZWZpeCAmIDB4MGYpO1xuICAgIH1cbiAgICAvLyBmaXhzdHJcbiAgICByZXR1cm4gdGhpcy5zdHIocHJlZml4ICYgMHgxZik7XG4gIH1cblxuICAvLyBuZWdhdGl2ZSBmaXhpbnRcbiAgaWYgKHByZWZpeCA+IDB4ZGYpIHtcbiAgICByZXR1cm4gKDB4ZmYgLSBwcmVmaXggKyAxKSAqIC0xO1xuICB9XG5cbiAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICAvLyBuaWxcbiAgICBjYXNlIDB4YzA6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBmYWxzZVxuICAgIGNhc2UgMHhjMjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyB0cnVlXG4gICAgY2FzZSAweGMzOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBiaW5cbiAgICBjYXNlIDB4YzQ6XG4gICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgIGNhc2UgMHhjNTpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgIGNhc2UgMHhjNjpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuXG4gICAgLy8gZXh0XG4gICAgY2FzZSAweGM3OlxuICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0KTtcbiAgICAgIHR5cGUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5iaW4obGVuZ3RoKV07XG4gICAgY2FzZSAweGM4OlxuICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCk7XG4gICAgICB0eXBlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQgKyAyKTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICByZXR1cm4gW3R5cGUsIHRoaXMuYmluKGxlbmd0aCldO1xuICAgIGNhc2UgMHhjOTpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQpO1xuICAgICAgdHlwZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgNCk7XG4gICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcblxuICAgIC8vIGZsb2F0XG4gICAgY2FzZSAweGNhOlxuICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgMHhjYjpcbiAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0NjQodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIC8vIHVpbnRcbiAgICBjYXNlIDB4Y2M6XG4gICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgMHhjZDpcbiAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgMHhjZTpcbiAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgMHhjZjpcbiAgICAgIGhpID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICBsbyA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyA0KTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICByZXR1cm4gaGkgKyBsbztcblxuICAgIC8vIGludFxuICAgIGNhc2UgMHhkMDpcbiAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlIDB4ZDE6XG4gICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgMHhkMjpcbiAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMub2Zmc2V0KTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAweGQzOlxuICAgICAgaGkgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5vZmZzZXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgbG8gPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgNCk7XG4gICAgICB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgcmV0dXJuIGhpICsgbG87XG5cbiAgICAvLyBmaXhleHRcbiAgICBjYXNlIDB4ZDQ6XG4gICAgICB0eXBlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgIGlmICh0eXBlID09PSAweDAwKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIHRoaXMuYmluKDEpXTtcbiAgICBjYXNlIDB4ZDU6XG4gICAgICB0eXBlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5iaW4oMildO1xuICAgIGNhc2UgMHhkNjpcbiAgICAgIHR5cGUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLmJpbig0KV07XG4gICAgY2FzZSAweGQ3OlxuICAgICAgdHlwZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICBpZiAodHlwZSA9PT0gMHgwMCkge1xuICAgICAgICBoaSA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLm9mZnNldCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgIGxvID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoaGkgKyBsbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIHRoaXMuYmluKDgpXTtcbiAgICBjYXNlIDB4ZDg6XG4gICAgICB0eXBlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5iaW4oMTYpXTtcblxuICAgIC8vIHN0clxuICAgIGNhc2UgMHhkOTpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgY2FzZSAweGRhOlxuICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgY2FzZSAweGRiOlxuICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cbiAgICAvLyBhcnJheVxuICAgIGNhc2UgMHhkYzpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgY2FzZSAweGRkOlxuICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCk7XG4gICAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcblxuICAgIC8vIG1hcFxuICAgIGNhc2UgMHhkZTpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgIGNhc2UgMHhkZjpcbiAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UnKTtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgdmFyIGRlY29kZXIgPSBuZXcgRGVjb2RlcihidWZmZXIpO1xuICB2YXIgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XG4gIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQpICsgJyB0cmFpbGluZyBieXRlcycpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm90ZXBhY2suaW8vYnJvd3Nlci9kZWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=

(() => {
	function e(e) {
		"loading" === document.readyState ? document.addEventListener("DOMContentLoaded", e, !1) : e()
	}
	let t;

	function n() {
		const e = TETRIO_ENV.countdown - Date.now();
		if (e <= 0) document.getElementById("prelaunch_countdown").innerHTML = "00:00:00", clearInterval(t), document.getElementById("prelaunch").classList.add("hiding"), setTimeout(() => {
			document.getElementById("prelaunch").classList.add("hidden")
		}, 7500);
		else {
			var n = Math.floor(e / 36e5),
				a = Math.floor(e % 36e5 / 6e4),
				o = Math.floor(e % 6e4 / 1e3);
			n < 10 && (n = "0" + n), a < 10 && (a = "0" + a), o < 10 && (o = "0" + o), document.getElementById("prelaunch_countdown").innerHTML = n + ":" + a + '<span class="sec">:' + o + "</span>"
		}
	}

	function a(e) {
		e()
	}

	function o(e) {}

	function i() {
		return !1
	}

	function s(e) {
		return JSON.parse(JSON.stringify(e))
	}
	e(() => {
		TETRIO_ENV.countdown && TETRIO_ENV.countdown > Date.now() && (document.getElementById("prelaunch").classList.remove("hidden"), t = setInterval(() => {
			n()
		}, 100), n())
	});
	const r = {
			send: (e, t, n, a = !1, o = !1, i = !1) => new Promise((s, r) => {
				const l = new XMLHttpRequest;
				l.open(e, t, !0), l.setRequestHeader("Content-Type", "application/json"), a && w.loggedIn() && l.setRequestHeader("Authorization", `Bearer ${w.token()}`), l.onload = () => {
					if (4 === l.readyState)
						if (o) s(l.responseText);
						else {
							const e = JSON.parse(l.responseText);
							e.success || i ? s(e) : r(e)
						}
				}, l.onerror = () => {
					r({
						success: !1,
						errors: [{
							msg: "a connection error has occured"
						}]
					})
				}, l.send(JSON.stringify(n))
			}),
			get: (e, t, n = !1, a = !1, o = !1) => {
				let i = !1;
				return Object.keys(t).forEach(n => {
					e += `${i?"&":"?"}${encodeURIComponent(n)}=${encodeURIComponent(t[n])}`, i = !0
				}), r.send("GET", e, [], n, a, o)
			},
			post: (e, t, n = !1, a = !1, o = !1) => r.send("POST", e, t, n, a, o)
		},
		l = (() => {
			let t = null;
			return e(() => {
				! function () {
					let e = "No-GPU";
					const n = document.createElement("canvas").getContext("webgl");
					if (n) {
						const t = n.getExtension("WEBGL_debug_renderer_info");
						t && (e = n.getParameter(t.UNMASKED_RENDERER_WEBGL))
					}
					let a = navigator.hardwareConcurrency || 0,
						o = navigator.deviceMemory || 0,
						i = navigator.userAgent || "No-UA";
					t = `${i} // ${a}-core // ${o}-GB // ${e}`
				}()
			}), {
				get: () => t
			}
		})();

	function d(e) {
		let t = e;
		"string" == typeof e && (t = {
			msg: e
		});
		const n = document.createElement("div");
		if (n.classList.add("notification"), n.classList.add("ns"), n.style.borderColor = t.color || "#FFFFFF", document.getElementById("notifications").appendChild(n), t.icon) {
			n.classList.add("has_image");
			const e = document.createElement("img");
			e.src = `res/icon/${t.icon}.svg`, n.appendChild(e)
		}
		const a = document.createElement("p");
		return a.innerHTML = t.msg, n.appendChild(a), setTimeout(() => {
			g(n)
		}, t.timeout || 5e3), n.addEventListener("click", onclick || (() => {
			g(n)
		})), n
	}

	function c(e) {
		return d({
			msg: e,
			color: "#FF4200",
			icon: "error"
		})
	}

	function m(e) {
		return d({
			msg: e,
			color: "#6AFF3C",
			icon: "ok"
		})
	}

	function u(e) {
		let t = "";
		return e.errors.forEach(e => {
			t += `• ${e.msg}<br>`
		}), d({
			msg: t,
			color: "#FF4200",
			icon: "error"
		})
	}

	function g(e) {
		e.classList.add("despawning"), setTimeout(() => {
			e.parentNode && e.parentNode.removeChild(e)
		}, 500)
	}

	function h(e) {
		let t = e;
		"string" == typeof e && (t = {
			msg: e
		});
		const n = document.createElement("div");
		n.classList.add("waterfall_item"), n.classList.add("ns"), n.style.setProperty("--bgc", t.bgcolor || "#888888"), n.style.color = t.fgcolor || "#FFFFFF", document.getElementById("waterfall").prepend(n);
		const a = document.createElement("p");
		a.classList.add("ns"), a.innerHTML = t.msg, n.appendChild(a), setTimeout(() => {
			y(n)
		}, t.timeout || 5e3);
		const o = n.getBoundingClientRect();
		return pn(window.innerWidth / 2 - 75, o.top + 1.35 * o.height, t.bgcolor || "#888888", 5, .75, .25, 150, o.height / 2, .04, 177.5, 182.5, 0, 450, 0, .15, 0, .1, !0), yn(window.innerWidth / 2 - 75, o.top + 1.35 * o.height, t.bgcolor || "#888888", 5, .75, .25, 150, o.height / 2, .04, 177.5, 182.5, 0, 450, 0, .15, 0, .1, !0), pn(window.innerWidth / 2 + 75, o.top + 1.35 * o.height, t.bgcolor || "#888888", 5, .75, .25, 150, o.height / 2, .04, -2.5, 2.5, 0, 450, 0, .15, 0, .1, !0), yn(window.innerWidth / 2 + 75, o.top + 1.35 * o.height, t.bgcolor || "#888888", 5, .75, .25, 150, o.height / 2, .04, -2.5, 2.5, 0, 450, 0, .15, 0, .1, !0), n
	}

	function y(e) {
		e.classList.add("despawning"), setTimeout(() => {
			e.parentNode.removeChild(e)
		}, 500)
	}

	function f(e) {
		const t = document.createElement("div");
		if (t.classList.add("killfeed_item"), t.classList.add("ns"), t.classList.toggle("killer", e.killer == w.username()), t.classList.toggle("victim", e.victim == w.username()), document.getElementById("killfeed").prepend(t), null !== e.killer && void 0 !== e.killer) {
			const n = document.createElement("p");
			n.classList.add("ns"), n.innerHTML = e.killer.toUpperCase(), t.appendChild(n)
		}
		const n = document.createElement("img");
		if (n.src = `/res/icon/elim-${e.type||"sizzle"}.svg`, t.appendChild(n), null !== e.victim && void 0 !== e.victim) {
			const n = document.createElement("p");
			n.classList.add("ns"), n.innerHTML = e.victim.toUpperCase(), t.appendChild(n)
		}
		return setTimeout(() => {
			_(t)
		}, 1e4), t
	}

	function _(e) {
		e.classList.add("despawning"), setTimeout(() => {
			e.parentNode.removeChild(e)
		}, 500)
	}

	function E(e) {
		const t = document.createElement("div");
		if (t.classList.add("oob_modal"), t.classList.add("hidden"), document.getElementById("dialogs").appendChild(t), e.title) {
			const n = document.createElement("h1");
			n.innerHTML = e.title, t.appendChild(n)
		}
		if (e.msg) {
			const n = document.createElement("p");
			n.innerHTML = e.msg, t.appendChild(n)
		}
		e.classes && e.classes.forEach(e => {
			t.classList.add(e)
		});
		const n = document.createElement("div");
		return n.classList.add("oob_button_holder"), n.classList.add("flex-row"), n.classList.add("ns"), t.appendChild(n), e.buttons.forEach(e => {
			const a = document.createElement("div");
			a.classList.add("oob_button"), a.classList.add("flex-item"), a.innerHTML = e.label, e.classes.forEach(e => {
				a.classList.add(e)
			}), e.id && (a.id = e.id), a.addEventListener("click", () => {
				e.callback(() => {
					v(t)
				})
			}), n.appendChild(a)
		}), setTimeout(() => {
			t.classList.remove("hidden"), pe.push(), pe.bindGuide(he.dialog)
		}, 1), document.getElementById("dialogs").classList.remove("hidden"), Xe(), t
	}

	function v(e) {
		e.classList.add("hidden"), Ke(), pe.pop(), setTimeout(() => {
			1 === e.parentNode.childElementCount && e.parentNode.classList.add("hidden"), e.parentNode.removeChild(e)
		}, 500)
	}
	e(() => {
		document.getElementById("dialogs").addEventListener("click", e => {
			if (e.target !== document.getElementById("dialogs")) return;
			if (!document.getElementById("dialogs").children.length) return;
			const t = document.getElementById("dialogs").children[document.getElementById("dialogs").children.length - 1];
			t.classList.contains("noclickout") || t.classList.contains("hidden") || (v(t), yt.play("menuclick"))
		})
	}), e(() => {
		document.addEventListener("keydown", (function (e) {
			if (e.repeat) return;
			let t = e.code;
			if ("NumpadEnter" === t && (t = "Enter"), "Enter" !== t && "Escape" !== t) return;
			if (!e.target.getAttribute(`data-${t.toLowerCase()}`)) return;
			const n = document.getElementById(e.target.getAttribute(`data-${t.toLowerCase()}`));
			"input" === n.tagName.toLowerCase() || "textarea" === n.tagName.toLowerCase() ? n.focus() : n.click(), e.preventDefault()
		}))
	});
	let b = !1;
	const I = function () {
			let t = window.I;
			window.I = void 0, e(() => {
				"devel" === TETRIO_ENV.mode && document.body.classList.add("devel"), document.getElementById("js_load_error").classList.add("handled"), PIXI.utils.isWebGLSupported() || document.getElementById("no_webgl_error").classList.remove("hidden"), document.querySelector(".preload_item.pi_ch").addEventListener("click", (function (e) {
					d("coming soon!"), e.preventDefault()
				}))
			});
			let n = 0;
			const a = [];
			let o = !1;

			function i() {
				document.getElementById("preload").classList.add("hidden"), a.forEach(e => {
						e()
					}),
					function () {
						const e = k.quickjoin;
						if (!e) return;
						switch (e.substring(0, 2)) {
							case "R:":
								_t.navigateToShortID(e);
								break;
							case "P:":
								break;
							default:
								He("connecting to live servers…"), Dt.connect(), Dt.once("connect_error", e => {
									Ne(), c("could not connect to live servers")
								}), Dt.once("authorize", t => {
									Ne(), Fe("playmulti"), t.maintenance && document.body.classList.add("maintenance"), jt.joinRoom(e)
								})
						}
					}()
			}
			return e(() => {
				console.log("%cTETR.IO", "color: #DFC0F3;\n\t\t\t\t\t display: block;\n\t\t\t\t\t font-size: 5em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px #9150BA;\n\t\t\t\t\t background-color: #45345088;\n\t\t\t\t\t padding: 0 0.25em;\n\t\t\t\t\t border-radius: 3px;"), console.log("%cPlease be careful when pasting anything in the console. Attackers may be out to steal your login information.", "color: #FFA69F;\n\t\t\t\t\t display: block;\n\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px #D53428;\n\t\t\t\t\t background-color: #993B2288;\n\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t border-radius: 3px;")
			}), {
				i: function () {
					return t
				},
				finishLoad: function () {
					4 == ++n && (document.getElementById("preload").classList.add("ready"), o && i())
				},
				finish: function () {
					4 === n && i(), o = !0
				},
				ready: function (e) {
					a.push(e)
				},
				unready: function () {
					o && (document.getElementById("preload").classList.remove("hidden"), o = !1, De())
				},
				update: function (e = !1) {
					b = !0, e || d({
						msg: "installing a required update...",
						color: "#0060FF",
						icon: "update"
					});
					try {
						M()
					} catch (e) {
						console.error(e)
					}
					location.reload(!0)
				}
			}
		}(),
		w = (() => {
			const e = {
				loggedIn: !1,
				token: "",
				id: "",
				username: ""
			};

			function t() {
				localStorage.setItem("userToken", e.token), localStorage.setItem("userID", e.id), localStorage.setItem("username", e.username)
			}
			return function () {
				const t = localStorage.getItem("userToken"),
					n = localStorage.getItem("userID"),
					a = localStorage.getItem("username");
				t ? (e.loggedIn = !0, e.token = t, e.id = n, e.username = a) : (e.loggedIn = !1, e.token = "", e.id = "", e.username = "")
			}(), {
				loggedIn: () => e.loggedIn,
				id: () => e.id,
				token: () => e.token,
				username: () => e.username,
				logout: (n = !1) => {
					e.loggedIn = !1, e.token = "", e.id = "", e.username = "", et.resetZen(), t()
				},
				login: (n, a, o, i = !0) => {
					e.loggedIn = !0, e.token = n, e.id = a, e.username = o, i && t()
				},
				anon: () => document.body.classList.contains("anon"),
				getUserInfoOrDie: function () {
					return new Promise((e, t) => {
						r.get("/api/users/me", {
							hwid: l.get()
						}, !0).then(t => {
							e(t.user)
						}, e => {
							I.unready(), t()
						})
					})
				},
				requestPassword: function (e) {
					E({
						title: "PASSWORD REQUESTED",
						msg: `to continue, please re-enter the password for <span class="inline_self">${localStorage.getItem("username").toUpperCase()}</span><br><input data-escape="request_password_cancel" data-enter="request_password_submit" id="request_password" type="password" placeholder="PASSWORD" autocomplete="current-password">`,
						buttons: [{
							label: "CANCEL",
							classes: [],
							id: "request_password_cancel",
							callback: e => {
								e()
							}
						}, {
							label: "SUBMIT",
							classes: ["pri"],
							id: "request_password_submit",
							callback: t => {
								e(document.getElementById("request_password").value), t()
							}
						}]
					}), document.getElementById("request_password").focus()
				}
			}
		})(),
		k = (() => {
			const t = window.location.hash.substring(1);
			history.replaceState(null, null, " ");
			let n = !1,
				a = [];

			function o(e) {
				return new Promise((t, n) => {
					w.getUserInfoOrDie().then(n => {
						e && (e.classList.remove("busy"), s(e), document.getElementById("captcha_form").classList.remove("busy"), s(document.getElementById("captcha_form"))), document.getElementById("me_username").innerHTML = n.username, document.getElementById("tetra_me_username").innerHTML = n.username, wt(vt(n.xp), document.getElementById("me_level")), Tt(n.xp, !0), et.loadZen(n.zen), "anon" === n.role ? document.body.classList.add("anon") : (document.body.classList.remove("anon"), n.email || d({
							msg: "you have not yet set an email on your account. if you forget your password, you will have no way to recover your account!<br>you can set an email at CONFIG -> ACCOUNT.",
							color: "#FFD800",
							icon: "warning",
							timeout: 15e3
						}), et.setRecords(n.records || {})), document.body.classList.toggle("bot", "bot" === n.role);
						try {
							_paq.push(["setCustomDimension", 1, n.role])
						} catch (e) {
							console.error(e)
						}
						if (document.body.classList.toggle("supporter", !!n.supporter), a = n.warnings, "ok" === n.bannedstatus) g();
						else {
							let e = "silence" == n.bannedstatus ? "SILENCED users may not chat or create rooms, but can still submit scores and play online." : "RESTRICTED users may not play online or submit scores.",
								t = 1;
							n.banlist.forEach(n => {
								e += `</p><p>&nbsp;</p><p class="modal_also">#${t++}: ban id ${n._id}</p><p>your ${n.from} was ${"silence"==n.type?"silenced":"restricted"} at ${new Date(n.ts).toLocaleString()} for the following reason:</p><p class="banreason">${U(n.reason)}</p><p>this ban ${Date.parse(n.expires)-Date.parse(n.ts)>=54e12?"will not expire":`expires in ${N(Date.parse(n.expires))}`}.`
							}), document.getElementById("ban_header").innerHTML = `YOU HAVE BEEN ${"silence"==n.bannedstatus?"SILENCED":"RESTRICTED"}`, document.getElementById("ban_reasons").outerHTML = `<p id="ban_reasons">${e}</p>`, document.getElementById("banned_warning").classList.remove("hidden"), document.body.classList.add(`banstatus_${n.bannedstatus}`)
						}
						document.getElementById("me_leaguerank").classList.toggle("hidden", "z" === n.league.rank), document.getElementById("me_leaguerank").src = `/res/league-ranks/${n.league.rank}.png`, t(n)
					}).catch(t => {
						console.log(t), I.unready(), e && (e.classList.remove("busy"), s(e), document.getElementById("captcha_form").classList.remove("busy"), s(document.getElementById("captcha_form"))), c("you were logged out. please log in again!"), document.getElementById("entry_username").value = w.username(), w.logout(), document.getElementById("entry_button").click()
					})
				})
			}

			function i() {
				PIXI.utils.isWebGLSupported() && (! function () {
					if (!t) return;
					const e = t.substring(0, 2);
					"P:" !== e && (document.querySelectorAll(".quickjoin").forEach(n => {
						switch (e) {
							case "R:":
								n.innerHTML = "opening replay <span></span>", n.querySelector("span").textContent = t;
								break;
							default:
								n.innerHTML = "joining room <span></span>", n.querySelector("span").textContent = !1 !== G.video.hideroomids ? `#${t}` : "<hidden>"
						}
						n.classList.remove("hidden")
					}), document.querySelectorAll(".electron_jump").forEach(e => {
						e.classList.remove("hidden"), e.addEventListener("click", (function (e) {
							s(document.getElementById("entry_form")), s(document.getElementById("return_form")), l(document.getElementById("electron_form")), window.location = `tetrio://${t}`
						}))
					}), document.querySelectorAll(".electron_jump_also").forEach(e => {
						e.classList.remove("hidden")
					}))
				}(), "P:" !== t.substring(0, 2) ? w.loggedIn() ? (l(document.getElementById("return_form")), document.getElementById("return_is").innerHTML = w.username().toUpperCase(), IS_ELECTRON && "never" !== G.electron.loginskip && (t && "P:" === t.substring(0, 2) || ("always" === G.electron.loginskip || t) && (document.getElementById("return_form").classList.add("busy"), o(document.getElementById("return_form"))))) : l(document.getElementById("entry_form")) : l(document.getElementById("reset_step2_form")))
			}

			function s(e) {
				e.classList.add("hidden"), setTimeout(() => {
					e.classList.contains("hidden") && e.classList.add("noop")
				}, 300)
			}

			function l(e) {
				e.classList.remove("noop"), e.getBoundingClientRect(), e.classList.remove("hidden")
			}

			function g() {
				if (!a.length) return void I.finish();
				const e = a.shift();
				E({
					title: "YOU HAVE BEEN WARNED",
					msg: `a TETR.IO moderator has left a message for you. please read it thoroughly.</p><p>&nbsp;</p><p class="modal_also">warning id ${e._id}</p><p>you were warned at ${new Date(e.ts).toLocaleString()} for the following reason:</p><p class="banreason">${U(e.reason)}`,
					classes: ["ban_modal", "noclickout"],
					buttons: [{
						label: "OK",
						classes: [],
						callback: e => {
							e(), g()
						}
					}]
				})
			}
			return e(() => {
				r.get("/api/server/environment", {}).then(e => {
					I.finishLoad(), window && window.process && window.process.type && (console.log("%cUsing the Desktop Client", "color: #F3E5C0;\n\t\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t\t text-shadow: 0px 0px 2px #BAB650;\n\t\t\t\t\t\t background-color: #504C3488;\n\t\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t\t border-radius: 3px;"), B()), e.signature.build.id !== TETRIO_ENV.build.id ? (console.log(`%cOut of date. Local build ${TETRIO_ENV.build.id} does not match server build ${e.signature.build.id}`, "color: #FF8E8E;\n\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px #E83737;\n\t\t\t\t\t background-color: #B6181888;\n\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t border-radius: 3px;"), I.update()) : (console.log(`%cUp to date. Local version ${TETRIO_ENV.version}-${TETRIO_ENV.mode} | Commit ${TETRIO_ENV.commit.id} (${new Date(TETRIO_ENV.commit.time).toLocaleString()}) | Server cycle ${TETRIO_ENV.serverCycle} | Build ${TETRIO_ENV.build.id} (${new Date(TETRIO_ENV.build.time).toLocaleString()}) | PID ${e.signature.process}`, "color: #C0F3C8;\n\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px #50BA5C;\n\t\t\t\t\t background-color: #34503788;\n\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t border-radius: 3px;"), i()), document.getElementById("preform_players_entry").innerHTML = e.stats.users.toLocaleString("en-US"), document.getElementById("preform_players_return").innerHTML = e.stats.users.toLocaleString("en-US"), document.getElementById("preform_games_entry").innerHTML = e.stats.gamesplayed.toLocaleString("en-US"), document.getElementById("preform_games_return").innerHTML = e.stats.gamesplayed.toLocaleString("en-US"), document.getElementById("preform_hours_entry").innerHTML = Math.floor(e.stats.gametime / 3600).toLocaleString("en-US"), document.getElementById("preform_hours_return").innerHTML = Math.floor(e.stats.gametime / 3600).toLocaleString("en-US")
				}, e => {
					I.finishLoad(), window && window.process && window.process.type && (console.log("%cUsing the Desktop Client", "color: #F3E5C0;\n\t\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t\t text-shadow: 0px 0px 2px #BAB650;\n\t\t\t\t\t\t background-color: #504C3488;\n\t\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t\t border-radius: 3px;"), B()), c("failed to check for updates. check your connection!"), i()
				}), document.getElementById("entry_button").addEventListener("click", (function (e) {
					const t = document.getElementById("entry_username").value.toLowerCase();
					t ? (document.getElementById("entry_form").classList.add("busy"), r.get(`/api/users/${encodeURIComponent(t)}/exists`, {}).then(e => {
						document.getElementById("entry_form").classList.remove("busy"), s(document.getElementById("entry_form")), e.exists ? (document.getElementById("login_is").innerHTML = t.toUpperCase(), document.getElementById("login_password_username_field").value = t.toUpperCase(), l(document.getElementById("login_form")), document.getElementById("login_password").focus()) : (document.getElementById("askregister_is").innerHTML = t.toUpperCase(), document.getElementById("register_password_username_field").value = t.toUpperCase(), l(document.getElementById("askregister_form")))
					}, e => {
						document.getElementById("entry_form").classList.remove("busy"), u(e)
					})) : document.getElementById("entry_form").classList.remove("busy")
				})), document.getElementById("askregister_back").addEventListener("click", (function (e) {
					s(document.getElementById("askregister_form")), l(document.getElementById("entry_form")), document.getElementById("entry_username").focus()
				})), document.getElementById("askregister_register").addEventListener("click", (function (e) {
					s(document.getElementById("askregister_form")), l(document.getElementById("register_form")), document.getElementById("register_password").focus()
				})), document.getElementById("register_button").addEventListener("click", (function (e) {
					const t = document.getElementById("entry_username").value.toLowerCase(),
						a = document.getElementById("register_password").value;
					a === document.getElementById("register_password_confirmation").value ? (document.getElementById("register_form").classList.add("busy"), r.post("/api/users/create", {
						username: t,
						password: a,
						captcha: document.getElementById("captcha").value
					}).then(e => {
						document.getElementById("register_password").value = "", document.getElementById("register_password_confirmation").value = "", d("welcome!"), n = !0, e.newname || d("this name has been used before"), w.login(e.token, e.userid, t), o(document.getElementById("register_form"))
					}, e => {
						if (e.errors[0] && "BLOCK" === e.errors[0].msg) {
							let t = "BLOCKED users or IPs may not create accounts. try using an existing account.",
								n = 1;
							return e.banlist.forEach(e => {
								t += `</p><p>&nbsp;</p><p class="modal_also">#${n++}: ban id ${e._id}</p><p>your ${e.from} was ${"silence"==e.type?"silenced":"restrict"==e.type?"restricted":"blocked"} at ${new Date(e.ts).toLocaleString()} for the following reason:</p><p class="banreason">${U(e.reason)}</p><p>this ban ${Date.parse(e.expires)-Date.parse(e.ts)>=54e12?"will not expire":`expires in ${N(Date.parse(e.expires))}`}.`
							}), document.getElementById("block_reasons").outerHTML = `<p id="block_reasons">${t}</p>`, document.getElementById("blocked_warning").classList.remove("hidden"), e.infinite && (document.getElementById("block_header").innerHTML = "YOU HAVE BEEN BANNED FROM TETR.IO", document.getElementById("blocked_warning").classList.remove("ban_modal"), document.getElementById("blocked_warning").classList.add("crash_modal")), document.getElementById("register_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), s(document.getElementById("register_form")), void s(document.getElementById("captcha_form"))
						}
						if (e.errors[0] && "CAPTCHA" === e.errors[0].msg) return document.getElementById("captcha").value = "", document.getElementById("register_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), document.getElementById("captcha_button").setAttribute("data-for", "register_button"), document.getElementById("captcha_image").innerHTML = e.captcha, s(document.getElementById("register_form")), void l(document.getElementById("captcha_form"));
						document.getElementById("register_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), u(e)
					})) : c("those passwords don't match")
				})), document.getElementById("register_back").addEventListener("click", (function (e) {
					s(document.getElementById("register_form")), l(document.getElementById("askregister_form")), document.getElementById("register_password").value = "", document.getElementById("register_password_confirmation").value = ""
				})), document.getElementById("login_button").addEventListener("click", (function (e) {
					const t = document.getElementById("entry_username").value.toLowerCase(),
						n = document.getElementById("login_password").value;
					document.getElementById("login_form").classList.add("busy"), r.post("/api/users/authenticate", {
						username: t,
						password: n
					}).then(e => {
						document.getElementById("login_password").value = "", w.login(e.token, e.userid, t), o(document.getElementById("login_form"))
					}, e => {
						if (e.errors[0] && "BLOCK" === e.errors[0].msg) {
							let t = "BLOCKED users or IPs may not use TETR.IO.",
								n = 1;
							return e.banlist.forEach(e => {
								t += `</p><p>&nbsp;</p><p class="modal_also">#${n++}: ban id ${e._id}</p><p>your ${e.from} was ${"silence"==e.type?"silenced":"restrict"==e.type?"restricted":"blocked"} at ${new Date(e.ts).toLocaleString()} for the following reason:</p><p class="banreason">${U(e.reason)}</p><p>this ban ${Date.parse(e.expires)-Date.parse(e.ts)>=54e12?"will not expire":`expires in ${N(Date.parse(e.expires))}`}.`
							}), document.getElementById("block_reasons").outerHTML = `<p id="block_reasons">${t}</p>`, document.getElementById("blocked_warning").classList.remove("hidden"), e.infinite && (document.getElementById("block_header").innerHTML = "YOU HAVE BEEN BANNED FROM TETR.IO", document.getElementById("blocked_warning").classList.remove("ban_modal"), document.getElementById("blocked_warning").classList.add("crash_modal")), document.getElementById("login_form").classList.remove("busy"), void s(document.getElementById("login_form"))
						}
						document.getElementById("login_form").classList.remove("busy"), u(e)
					})
				})), document.getElementById("login_back").addEventListener("click", (function (e) {
					s(document.getElementById("login_form")), l(document.getElementById("entry_form")), document.getElementById("entry_username").focus(), document.getElementById("login_password").value = ""
				})), document.getElementById("login_reset").addEventListener("click", (function (e) {
					s(document.getElementById("login_form")), l(document.getElementById("request_reset_form")), document.getElementById("request_reset_email").focus(), document.getElementById("login_password").value = ""
				})), document.getElementById("request_reset_back").addEventListener("click", (function (e) {
					s(document.getElementById("request_reset_form")), l(document.getElementById("login_form")), document.getElementById("login_password").focus(), document.getElementById("request_reset_email").value = ""
				})), document.getElementById("request_reset_button").addEventListener("click", (function (e) {
					const t = document.getElementById("entry_username").value.toLowerCase(),
						n = document.getElementById("request_reset_email").value;
					document.getElementById("request_reset_form").classList.add("busy"), r.post("/api/users/requestPasswordReset", {
						username: t,
						email: n,
						captcha: document.getElementById("captcha").value
					}).then(e => {
						m("if the email you entered was correct, you should be receiving an email shortly!"), document.getElementById("request_reset_form").classList.remove("busy"), document.getElementById("request_reset_back").click(), document.getElementById("captcha_form").classList.remove("busy"), s(document.getElementById("captcha_form"))
					}, e => {
						if (e.errors[0] && "CAPTCHA" === e.errors[0].msg) return document.getElementById("captcha").value = "", document.getElementById("request_reset_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), document.getElementById("captcha_button").setAttribute("data-for", "request_reset_button"), document.getElementById("captcha_image").innerHTML = e.captcha, s(document.getElementById("request_reset_form")), l(document.getElementById("captcha_form")), void document.getElementById("captcha_form").classList.remove("busy");
						document.getElementById("request_reset_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), u(e)
					})
				})), document.getElementById("reset_step2_button").addEventListener("click", (function (e) {
					const n = t.substring(2),
						a = document.getElementById("reset_step2_password").value;
					a === document.getElementById("reset_step2_password_confirmation").value ? (document.getElementById("reset_step2_form").classList.add("busy"), r.post("/api/users/resetPassword", {
						recoveryid: n,
						password: a
					}).then(e => {
						document.getElementById("reset_step2_password").value = "", document.getElementById("reset_step2_password_confirmation").value = "", m("password reset!"), s(document.getElementById("reset_step2_form")), l(document.getElementById("entry_form")), document.getElementById("entry_username").focus()
					}, e => {
						document.getElementById("reset_step2_form").classList.remove("busy"), u(e)
					})) : c("those passwords don't match")
				})), document.getElementById("askregister_anon").addEventListener("click", (function (e) {
					const t = document.getElementById("entry_username").value.toLowerCase();
					document.getElementById("askregister_form").classList.add("busy"), r.post("/api/users/anonymousJoin", {
						username: t,
						captcha: document.getElementById("captcha").value
					}).then(e => {
						e.newname || d("this name has been used before - please consider registering a full account!"), n = !0, w.login(e.token, e.userid, t, !1), o(document.getElementById("askregister_form"))
					}, e => {
						if (e.errors[0] && "BLOCK" === e.errors[0].msg) {
							let t = "BLOCKED users or IPs may not use TETR.IO. try using an existing account.",
								n = 1;
							return e.banlist.forEach(e => {
								t += `</p><p>&nbsp;</p><p class="modal_also">#${n++}: ban id ${e._id}</p><p>your ${e.from} was ${"silence"==e.type?"silenced":"restrict"==e.type?"restricted":"blocked"} at ${new Date(e.ts).toLocaleString()} for the following reason:</p><p class="banreason">${U(e.reason)}</p><p>this ban ${Date.parse(e.expires)-Date.parse(e.ts)>=54e12?"will not expire":`expires in ${N(Date.parse(e.expires))}`}.`
							}), document.getElementById("block_reasons").outerHTML = `<p id="block_reasons">${t}</p>`, document.getElementById("blocked_warning").classList.remove("hidden"), e.infinite && (document.getElementById("block_header").innerHTML = "YOU HAVE BEEN BANNED FROM TETR.IO", document.getElementById("blocked_warning").classList.remove("ban_modal"), document.getElementById("blocked_warning").classList.add("crash_modal")), document.getElementById("askregister_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), s(document.getElementById("askregister_form")), void s(document.getElementById("captcha_form"))
						}
						if (e.errors[0] && "CAPTCHA" === e.errors[0].msg) return document.getElementById("captcha").value = "", document.getElementById("askregister_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), document.getElementById("captcha_button").setAttribute("data-for", "askregister_anon"), document.getElementById("captcha_image").innerHTML = e.captcha, s(document.getElementById("askregister_form")), void l(document.getElementById("captcha_form"));
						document.getElementById("askregister_form").classList.remove("busy"), document.getElementById("captcha_form").classList.remove("busy"), u(e)
					})
				})), document.getElementById("captcha_button").addEventListener("click", (function (e) {
					document.getElementById("captcha").value && (document.getElementById("captcha_form").classList.add("busy"), document.getElementById(document.getElementById("captcha_button").getAttribute("data-for")).click())
				})), document.getElementById("return_logout").addEventListener("click", (function (e) {
					s(document.getElementById("return_form")), w.logout(!0), l(document.getElementById("entry_form"))
				})), document.getElementById("return_button").addEventListener("click", (function (e) {
					document.getElementById("return_form").classList.add("busy"), o(document.getElementById("return_form"))
				})), document.getElementById("ban_skip_button").addEventListener("click", (function (e) {
					document.getElementById("banned_warning").classList.add("hidden"), g()
				}))
			}), {
				quickjoin: t,
				newacc: () => n
			}
		})();
	window.IS_ELECTRON = !1;
	let L = null,
		x = null;

	function B() {
		window.REMOTE = require("electron").remote, window.IS_ELECTRON = !0, window.IPC = require("electron").ipcRenderer, document.body.classList.add("electron"), navigator.onLine || document.body.classList.add("offline"), window.addEventListener("offline", (function (e) {
			document.body.classList.add("offline")
		})), window.addEventListener("online", (function (e) {
			document.body.classList.remove("offline")
		})), document.addEventListener("keydown", e => {
			if (!e.repeat) {
				if ("f5" === e.key.toLowerCase() || "r" === e.key.toLowerCase() && e.ctrlKey) {
					if (!b && document.body.classList.contains("ingame_phys") && document.getElementById("menus").classList.contains("hidden") && 0 === We) return;
					I.update(!0)
				}
				"I" === e.key && e.ctrlKey && REMOTE.getCurrentWindow().webContents.openDevTools(), "f11" === e.key.toLowerCase() && "darwin" !== PLATFORM_TYPE && REMOTE.getCurrentWindow().setFullScreen(!REMOTE.getCurrentWindow().isFullScreen()), "f4" !== e.key.toLowerCase() || L || (L = setTimeout(() => {
					IPC.send("fpscap", !FPS_CAPPED)
				}, 5e3), x = setTimeout(() => {
					d(FPS_CAPPED ? "keep holding F4 to disable frame rate limit" : "keep holding F4 to enable frame rate limit")
				}, 500))
			}
		}, !1), document.addEventListener("keyup", e => {
			"f4" === e.key.toLowerCase() && L && (clearTimeout(L), clearTimeout(x), L = null, x = null)
		}, !1)
	}

	function T() {}

	function F() {
		IS_ELECTRON ? (b = !0, REMOTE.getCurrentWindow().close()) : console.error("Tried to exit while not on Electron")
	}

	function M() {
		IS_ELECTRON && caches.delete("tetrio-dyn")
	}
	let S = {},
		C = {};

	function R(e) {
		IS_ELECTRON && !1 !== G.electron.presence && (e.largeImageText = w.anon() ? "Playing anonymously" : `${w.username().toUpperCase()} - Lv. ${document.getElementById("me_level").innerHTML}${document.getElementById("me_leaguerank").classList.contains("hidden")?"":` - ${document.getElementById("me_leaguerank").getAttribute("src").replace("/res/league-ranks/","").replace(".png","").toUpperCase()}`}`, IPC.send("presence", e), S = e, "Idle" !== e.state && (A = !1, C = e))
	}
	let A = !1;

	function $() {
		"In Menus" === S.state && (A = !0, C = S, R({
			state: "Idle",
			largeImageKey: "logo",
			instance: !1
		}))
	}

	function O() {
		A = !1, R(C)
	}

	function D() {
		IS_ELECTRON && !1 !== G.electron.taskbarflash && (REMOTE.getCurrentWindow().once("focus", () => {
			REMOTE.getCurrentWindow().flashFrame(!1)
		}), REMOTE.getCurrentWindow().flashFrame(!0))
	}

	function H(e) {
		const t = Math.round(e),
			n = t % 1e3,
			a = Math.floor(t / 1e3) % 60,
			o = Math.floor(t / 6e4);
		return {
			ms: n.toString().padStart(3, "0"),
			s: a.toString().padStart(2, "0"),
			m: o.toString()
		}
	}

	function N(e) {
		const t = Math.abs(Math.floor((new Date - e) / 1e3));
		let n = Math.floor(t / 31536e3);
		return n > 1 ? `${n} years` : (n = Math.floor(t / 2592e3)) > 1 ? `${n} months` : (n = Math.floor(t / 86400)) > 1 ? `${n} days` : (n = Math.floor(t / 3600)) > 1 ? `${n} hours` : (n = Math.floor(t / 60)) > 1 ? `${n} minutes` : `${Math.floor(t)} seconds`
	}

	function P(e) {
		let t = Math.floor(e / 3600);
		return t > 1 ? `${t}<span>H</span>` : (t = Math.floor(e / 60)) > 1 ? `${t}<span>M</span>` : `${Math.floor(e)}<span>S</span>`
	}

	function U(e) {
		const t = document.createElement("div");
		return t.textContent = e, t.innerHTML
	}
	const z = {
		5e5: "ǰ",
		4e5: "ǯǰ",
		1e5: "ǯ",
		9e4: "ǭǯ",
		5e4: "Ǯ",
		4e4: "ǭǮ",
		1e4: "ǭ",
		9e3: "ǫǭ",
		5e3: "Ǭ",
		4e3: "ǫǬ",
		1e3: "ǫ",
		900: "ǩǫ",
		500: "Ǫ",
		400: "ǩǪ",
		100: "ǩ",
		90: "ǧǩ",
		50: "Ǩ",
		40: "ǧǨ",
		10: "ǧ",
		9: "ǥǧ",
		5: "Ǧ",
		4: "ǥǦ",
		1: "ǥ"
	};

	function j(e) {
		const t = Object.keys(z);
		let n = "";
		for (e = Math.max(0, Math.floor(e)); e >= 1;)
			for (let a = t.length - 1; a >= 0; a--)
				if (e / parseInt(t[a]) >= 1) {
					e -= parseInt(t[a]), n += z[t[a]];
					break
				} return n
	}
	const W = (() => {
			let e = !1,
				t = !1;
			window.addEventListener("gamepadconnected", () => {
				e = !0, d({
					msg: "a controller was connected",
					color: "#6AFF3C",
					icon: "connect"
				}), PIXI.Ticker.shared.add(i)
			}), window.addEventListener("gamepaddisconnected", () => {
				e = !1, d({
					msg: "a controller was disconnected",
					color: "#FF783C",
					icon: "disconnect"
				})
			}), window.addEventListener("keydown", () => {
				t = !1
			}, !0);
			const n = {};
			let a = 10,
				o = 2;

			function i(i) {
				if (!e) return;
				const s = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads : [];
				let r;
				for (let e = 0; e < s.length; e++) s[e] && (r = s[e]);
				for (let e = 0; e < r.axes.length; e++) {
					const s = `Axis_${e}_Pos`,
						l = r.axes[e] > (G.controls.sensitivity || .5),
						d = `Axis_${e}_Neg`,
						c = r.axes[e] < -1 * (G.controls.sensitivity || .5);
					void 0 !== n[s] && n[s] !== l ? (n[s] = l, a = 10, o = 2, t = !0, document.dispatchEvent(new CustomEvent(`gp${l?"down":"up"}`, {
						detail: s
					}))) : void 0 === n[s] ? n[s] = l : l && (a > 0 ? a -= i : o > 0 ? o -= i : (o = 2, t = !0, document.dispatchEvent(new CustomEvent("gprepeat", {
						detail: s
					})))), void 0 !== n[d] && n[d] !== c ? (n[d] = c, a = 10, o = 2, t = !0, document.dispatchEvent(new CustomEvent(`gp${c?"down":"up"}`, {
						detail: d
					}))) : void 0 === n[d] ? n[d] = c : c && (a > 0 ? a -= i : o > 0 ? o -= i : (o = 2, t = !0, document.dispatchEvent(new CustomEvent("gprepeat", {
						detail: d
					}))))
				}
				for (let e = 0; e < r.buttons.length; e++) {
					const s = `Button_${e}`,
						l = r.buttons[e].value > (G.controls.sensitivity || .5);
					void 0 !== n[s] && n[s] !== l ? (n[s] = l, a = 10, o = 2, t = !0, document.dispatchEvent(new CustomEvent(`gp${l?"down":"up"}`, {
						detail: s
					}))) : void 0 === n[s] ? n[s] = l : l && (a > 0 ? a -= i : o > 0 ? o -= i : (o = 2, t = !0, document.dispatchEvent(new CustomEvent("gprepeat", {
						detail: s
					}))))
				}
			}
			return {
				pulse: function (n, a, o) {
					if (!e || !t) return;
					if (0 == G.controls.vibration) return;
					const i = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads : [];
					let s;
					for (let e = 0; e < i.length; e++) i[e] && (s = i[e]);
					s.vibrationActuator && s.vibrationActuator.playEffect && s.vibrationActuator.playEffect("dual-rumble", {
						startDelay: 0,
						duration: n,
						weakMagnitude: Math.min(1, (G.controls.vibration || 1) * a),
						strongMagnitude: Math.min(1, (G.controls.vibration || 1) * o)
					})
				},
				WEAK_GLIDE: [25, 0, .15],
				WEAK_TAP: [50, 0, .15],
				HARDDROP: [25, 0, .2],
				CLEARLINE: [200, .3, .3],
				CLEARSPIN: [200, 1, .3],
				CLEARQUAD: [300, .3, .6],
				CLEARB2B: [300, .6, .6],
				SPIN: [50, 1, 0],
				DAMAGE_SMALL: [150, .7, 0],
				DAMAGE_MEDIUM: [250, .7, .7],
				DAMAGE_LARGE: [350, 1, 1],
				GARBAGERISE: [150, .5, 0],
				CLEAR: [300, .5, 1],
				TOPOUT: [500, .5, 1],
				GARBAGESMASH: [500, 1, 1]
			}
		})(),
		G = {
			controls: {
				style: "guideline",
				custom: {
					moveLeft: [],
					moveRight: [],
					softDrop: [],
					hardDrop: [],
					rotateCCW: [],
					rotateCW: [],
					rotate180: [],
					hold: [],
					exit: [],
					retry: [],
					chat: [],
					target1: [],
					target2: [],
					target3: [],
					target4: [],
					menuUp: [],
					menuDown: [],
					menuLeft: [],
					menuRight: [],
					menuBack: [],
					menuConfirm: []
				},
				sensitivity: .5,
				vibration: 1
			},
			handling: {
				arr: 2,
				das: 10,
				sdf: 6,
				safelock: !0
			},
			volume: {
				disable: !1,
				music: .45,
				sfx: .4,
				stereo: .5,
				others: !0,
				attacks: !0,
				next: !1,
				noreset: !0,
				oof: !0
			},
			video: {
				graphics: "high",
				caching: "medium",
				actiontext: "all",
				particles: .6,
				background: .3,
				bounciness: 1,
				shakiness: 1,
				gridopacity: .1,
				boardopacity: .85,
				shadowopacity: .15,
				zoom: 1,
				alwaystiny: !1,
				colorshadow: !1,
				sidebyside: !0,
				spin: !0,
				chatfilter: !0,
				background_url: null,
				background_usecustom: null,
				nochat: !1,
				hideroomids: !1,
				spikes: !0,
				emotes: !0,
				siren: !0,
				powersave: !1,
				invert: !1,
				nobg: !1,
				chatbg: !0,
				kos: !0,
				fire: !0,
				focuswarning: !0,
				hidenetwork: !1,
				guide: !0,
				lowrescounters: !1,
				desktopnotifications: !0,
				lowres: !1,
				webgl: "webgl2",
				bloom: 1,
				chroma: .5,
				flashwave: 1,
				pieceflash: 1
			},
			gameoptions: {
				pro_40l: !1,
				pro_40l_alert: !1,
				pro_40l_retry: !1,
				stride_40l: !1,
				pro_blitz: !1,
				pro_blitz_alert: !1,
				pro_blitz_retry: !1,
				stride_blitz: !1
			},
			electron: {
				loginskip: "always",
				presence: !0,
				taskbarflash: !0
			}
		},
		q = "ID_1";
	let X = {
		moveLeft: ["A", "KEYA", "NUMPAD4"],
		moveRight: ["D", "KEYD", "NUMPAD6"],
		softDrop: ["W", "KEYW", "NUMPAD8"],
		hardDrop: ["S", "KEYS", "NUMPAD5"],
		rotateCCW: ["ARROWLEFT", "LEFT", "NUMPAD7"],
		rotateCW: ["ARROWRIGHT", "RIGHT", "NUMPAD9"],
		rotate180: ["ARROWUP", "UP", "NUMPAD2"],
		hold: ["SHIFT", "SHIFTLEFT", "NUMPADENTER"],
		exit: ["ESCAPE"],
		retry: ["R", "KEYR"],
		chat: ["T", "KEYT"],
		target1: ["1", "DIGIT1"],
		target2: ["2", "DIGIT2"],
		target3: ["3", "DIGIT3"],
		target4: ["4", "DIGIT4"],
		menuUp: ["W", "KEYW", "ARROWUP", "UP"],
		menuDown: ["S", "KEYS", "ARROWDOWN", "DOWN"],
		menuLeft: ["A", "KEYA", "ARROWLEFT", "LEFT"],
		menuRight: ["D", "KEYD", "ARROWRIGHT", "RIGHT"],
		menuBack: ["ESCAPE", "BACKSPACE"],
		menuConfirm: ["ENTER", "NUMPADENTER", "SPACE"]
	};
	const K = {
			moveLeft: ["ARROWLEFT", "LEFT", "NUMPAD4"],
			moveRight: ["ARROWRIGHT", "RIGHT", "NUMPAD6"],
			softDrop: ["ARROWDOWN", "DOWN", "NUMPAD2"],
			hardDrop: ["SPACE", "NUMPAD8"],
			rotateCCW: ["CONTROL", "CONTROLLEFT", "Z", "KEYZ", "NUMPAD3", "NUMPAD7"],
			rotateCW: ["ARROWUP", "UP", "X", "KEYX", "NUMPAD1", "NUMPAD5", "NUMPAD9"],
			rotate180: ["A", "KEYA"],
			hold: ["SHIFT", "SHIFTLEFT", "C", "KEYC", "NUMPAD0"],
			exit: ["ESCAPE"],
			retry: ["R", "KEYR"],
			chat: ["T", "KEYT"],
			target1: ["1", "DIGIT1"],
			target2: ["2", "DIGIT2"],
			target3: ["3", "DIGIT3"],
			target4: ["4", "DIGIT4"],
			menuUp: ["W", "KEYW", "ARROWUP", "UP"],
			menuDown: ["S", "KEYS", "ARROWDOWN", "DOWN"],
			menuLeft: ["A", "KEYA", "ARROWLEFT", "LEFT"],
			menuRight: ["D", "KEYD", "ARROWRIGHT", "RIGHT"],
			menuBack: ["ESCAPE", "BACKSPACE"],
			menuConfirm: ["ENTER", "NUMPADENTER", "SPACE"]
		},
		Y = {
			moveLeft: ["A", "KEYA", "NUMPAD4"],
			moveRight: ["D", "KEYD", "NUMPAD6"],
			softDrop: ["W", "KEYW", "NUMPAD8"],
			hardDrop: ["S", "KEYS", "NUMPAD5"],
			rotateCCW: ["ARROWLEFT", "LEFT", "NUMPAD7"],
			rotateCW: ["ARROWRIGHT", "RIGHT", "NUMPAD9"],
			rotate180: ["ARROWUP", "UP", "NUMPAD2"],
			hold: ["SHIFT", "SHIFTLEFT", "NUMPADENTER"],
			exit: ["ESCAPE"],
			retry: ["R", "KEYR"],
			chat: ["T", "KEYT"],
			target1: ["1", "DIGIT1"],
			target2: ["2", "DIGIT2"],
			target3: ["3", "DIGIT3"],
			target4: ["4", "DIGIT4"],
			menuUp: ["W", "KEYW", "ARROWUP", "UP"],
			menuDown: ["S", "KEYS", "ARROWDOWN", "DOWN"],
			menuLeft: ["A", "KEYA", "ARROWLEFT", "LEFT"],
			menuRight: ["D", "KEYD", "ARROWRIGHT", "RIGHT"],
			menuBack: ["ESCAPE", "BACKSPACE"],
			menuConfirm: ["ENTER", "NUMPADENTER", "SPACE"]
		};
	let V = ["../res/bg/1.jpg", "../res/bg/2.jpg", "../res/bg/3.jpg", "../res/bg/4.jpg", "../res/bg/5.jpg", "../res/bg/6.jpg", "../res/bg/7.jpg", "../res/bg/8.jpg", "../res/bg/9.jpg", "../res/bg/10.jpg", "../res/bg/11.jpg", "../res/bg/12.jpg", "../res/bg/13.jpg", "../res/bg/14.jpg", "../res/bg/15.jpg", "../res/bg/16.jpg", "../res/bg/17.jpg", "../res/bg/18.jpg", "../res/bg/19.jpg", "../res/bg/20.jpg", "../res/bg/21.jpg", "../res/bg/22.jpg", "../res/bg/23.jpg", "../res/bg/24.jpg", "../res/bg/25.jpg", "../res/bg/26.jpg", "../res/bg/27.jpg", "../res/bg/28.jpg", "../res/bg/29.jpg", "../res/bg/30.jpg", "../res/bg/31.jpg", "../res/bg/32.jpg", "../res/bg/33.jpg", "../res/bg/34.jpg", "../res/bg/35.jpg"],
		Z = [],
		J = "";

	function Q() {
		localStorage.setItem("userConfig", JSON.stringify(G))
	}

	function ee() {
		const e = localStorage.getItem("userConfig");
		e && Object.assign(G, JSON.parse(e))
	}
	let te = -1;

	function ne() {
		switch (Object.keys(K).forEach(e => {
			void 0 === G.controls.custom[e] && (G.controls.custom[e] = [])
		}), G.controls.style) {
			case "guideline":
				Object.assign(X, K);
				break;
			case "wasd":
				Object.assign(X, Y);
				break;
			case "custom":
				Object.assign(X, G.controls.custom);
				let e = !1;
				Object.keys(X).forEach(t => {
					X[t].forEach(t => {
						null !== t && t !== t.toUpperCase() && (e = !0)
					})
				}), e && (G.controls.custom = K, Object.assign(X, G.controls.custom), d({
					msg: "your keybinds were reset due to an update. please re-enter them!",
					color: "#FF4200",
					icon: "error",
					timeout: 15e3
				}))
		}
		ft.setVolume(G.volume.music), "low" === G.video.graphics || "minimal" === G.video.graphics ? (ca("res/minos.png"), ua("res/signs.png")) : (ca("res/minos.svg"), ua("res/signs.svg")), document.body.setAttribute("data-graphics", G.video.graphics), Fn && G.video.background !== te && (Fn.alpha = G.video.background, te = G.video.background), Z = [], (G.video.background_url || "").split(",").forEach(e => {
			Z.push(e.trim())
		}), xn && (xn.alpha = Math.min(1, 10 * G.video.background)), document.body.classList.toggle("noingamechat", !!G.video.nochat), document.body.classList.toggle("hideroomids", !!G.video.hideroomids), document.getElementById("multi_join").type = G.video.hideroomids ? "password" : "text", document.body.classList.toggle("invert", !!G.video.invert), document.body.classList.toggle("nobg", !!G.video.nobg), document.body.classList.toggle("chatbg", !!G.video.chatbg), document.body.classList.toggle("hidenetwork", !!G.video.hidenetwork), document.body.classList.toggle("hidefocuswarning", !1 === G.video.focuswarning), document.getElementById("sys_guide").classList.toggle("hidden", !1 === G.video.guide), document.getElementById("room_opts_welcome").classList.toggle("hidden", !1 === G.video.guide), Zn(), ae()
	}

	function ae() {
		ie(!1, !0);
		for (const e of document.getElementsByClassName("controls_keybinds_style")) e.classList.remove("pressed");
		document.getElementById(`controls_keybinds_style_${G.controls.style}`).classList.add("pressed");
		for (const e of document.getElementsByClassName("controls_keybinds_list")) e.classList.add("hidden");
		document.getElementById(`controls_keybinds_list_${G.controls.style}`).classList.remove("hidden");
		for (const e of document.getElementsByClassName("keybind_custom")) {
			const t = G.controls.custom[e.getAttribute("data-key")],
				n = t && t.length && t[parseInt(e.getAttribute("data-id"))] || "[NOT SET]";
			e.textContent = n, e.setAttribute("data-value", n)
		}
		for (const e of document.getElementsByClassName("keybind_custom")) {
			const t = e.getAttribute("data-value"),
				n = e.getAttribute("data-scope");
			"[NOT SET]" !== t && document.querySelectorAll(`.keybind_custom[data-scope="${n}"][data-value="${t.replace('"',"&quot;")}"]`).length >= 2 ? e.classList.add("keybind_warning") : e.classList.remove("keybind_warning")
		}
		for (const e of document.getElementsByClassName("guide_keybind")) {
			const t = X[e.getAttribute("data-key")].filter(e => !!e);
			e.textContent = t && t.length ? t.join(", ") : "[NOT SET]"
		}
		document.getElementById("controls_sensitivity").value = G.controls.sensitivity || .5, document.getElementById("controls_sensitivity_field").value = 100 - Math.round(100 * (G.controls.sensitivity || .5)), document.getElementById("controls_vibration").value = G.controls.vibration || 1, document.getElementById("controls_vibration_field").value = 0 == G.controls.vibration ? "OFF" : Math.round(100 * (G.controls.vibration || 1)), document.getElementById("handling_arr").value = G.handling.arr, document.getElementById("handling_arr_field").value = G.handling.arr, document.getElementById("handling_arr_field_ms").value = `${Math.round(G.handling.arr*(1e3/60))}MS`, document.getElementById("handling_das").value = G.handling.das, document.getElementById("handling_das_field").value = G.handling.das, document.getElementById("handling_das_field_ms").value = `${Math.round(G.handling.das*(1e3/60))}MS`, document.getElementById("handling_sdf").value = G.handling.sdf, document.getElementById("handling_sdf_field").value = 41 == G.handling.sdf ? "MAX" : G.handling.sdf, document.getElementById("handling_safelock").classList.toggle("checked", !1 !== G.handling.safelock), document.getElementById("volume_music").value = G.volume.music, document.getElementById("volume_music_field").value = 0 == G.volume.music ? "MUTE" : Math.round(100 * G.volume.music), document.getElementById("volume_overlay_mus_value").style.backgroundImage = `linear-gradient(to top, #FFF 0%, #FFF ${Math.round(100*G.volume.music)}%, #FFF2 ${Math.round(100*G.volume.music)}%, #FFF2 100%)`, document.getElementById("volume_sfx").value = G.volume.sfx, document.getElementById("volume_sfx_field").value = 0 == G.volume.sfx ? "MUTE" : Math.round(100 * G.volume.sfx), document.getElementById("volume_overlay_sfx_value").style.backgroundImage = `linear-gradient(to top, #FFF 0%, #FFF ${Math.round(100*G.volume.sfx)}%, #FFF2 ${Math.round(100*G.volume.sfx)}%, #FFF2 100%)`, document.getElementById("volume_stereo").value = G.volume.stereo, document.getElementById("volume_stereo_field").value = 0 == G.volume.stereo ? "OFF" : Math.round(100 * G.volume.stereo), document.getElementById("volume_disable").classList.toggle("checked", !!G.volume.disable), document.getElementById("volume_next").classList.toggle("checked", G.volume.next), document.getElementById("volume_others").classList.toggle("checked", G.volume.others), document.getElementById("volume_attacks").classList.toggle("checked", !1 !== G.volume.attacks), document.getElementById("volume_noreset").classList.toggle("checked", !1 !== G.volume.noreset), document.getElementById("volume_oof").classList.toggle("checked", !1 !== G.volume.oof);
		for (const e of document.getElementsByClassName("video_graphics")) e.classList.remove("pressed");
		document.getElementById(`video_graphics_${G.video.graphics}`).classList.add("pressed");
		for (const e of document.getElementsByClassName("video_caching")) e.classList.remove("pressed");
		document.getElementById(`video_caching_${G.video.caching||"medium"}`).classList.add("pressed");
		for (const e of document.getElementsByClassName("video_actiontext")) e.classList.remove("pressed");
		document.getElementById(`video_actiontext_${G.video.actiontext||"all"}`).classList.add("pressed");
		for (const e of document.getElementsByClassName("video_webgl")) e.classList.remove("pressed");
		document.getElementById(`video_webgl_${G.video.webgl||"webgl2"}`).classList.add("pressed"), document.getElementById("video_particles").value = G.video.particles || .6, document.getElementById("video_particles_field").value = Math.round(100 * (G.video.particles || .6)), document.getElementById("video_background").value = G.video.background, document.getElementById("video_background_field").value = Math.round(100 * G.video.background), document.getElementById("video_bounciness").value = G.video.bounciness, document.getElementById("video_bounciness_field").value = Math.round(100 * G.video.bounciness), document.getElementById("video_shakiness").value = G.video.shakiness, document.getElementById("video_shakiness_field").value = Math.round(100 * G.video.shakiness), document.getElementById("video_gridopacity").value = void 0 === G.video.gridopacity ? .1 : G.video.gridopacity, document.getElementById("video_gridopacity_field").value = Math.round(100 * (void 0 === G.video.gridopacity ? .1 : G.video.gridopacity)), document.getElementById("video_boardopacity").value = void 0 === G.video.boardopacity ? .85 : G.video.boardopacity, document.getElementById("video_boardopacity_field").value = Math.round(100 * (void 0 === G.video.boardopacity ? .85 : G.video.boardopacity)), document.getElementById("video_shadowopacity").value = void 0 === G.video.shadowopacity ? .15 : G.video.shadowopacity, document.getElementById("video_shadowopacity_field").value = Math.round(100 * (void 0 === G.video.shadowopacity ? .15 : G.video.shadowopacity)), document.getElementById("video_zoom").value = void 0 === G.video.zoom ? 1 : G.video.zoom, document.getElementById("video_zoom_field").value = Math.round(100 * (void 0 === G.video.zoom ? 1 : G.video.zoom)), document.getElementById("video_bloom").value = void 0 === G.video.bloom ? 1 : G.video.bloom, document.getElementById("video_bloom_field").value = 0 == G.video.bloom ? "OFF" : Math.round(100 * (void 0 === G.video.bloom ? 1 : G.video.bloom)), document.getElementById("video_chroma").value = void 0 === G.video.chroma ? .5 : G.video.chroma, document.getElementById("video_chroma_field").value = 0 == G.video.chroma ? "OFF" : Math.round(100 * (void 0 === G.video.chroma ? .5 : G.video.chroma)), document.getElementById("video_flashwave").value = void 0 === G.video.flashwave ? 1 : G.video.flashwave, document.getElementById("video_flashwave_field").value = 0 == G.video.flashwave ? "OFF" : Math.round(100 * (void 0 === G.video.flashwave ? 1 : G.video.flashwave)), document.getElementById("video_pieceflash").value = void 0 === G.video.pieceflash ? 1 : G.video.pieceflash, document.getElementById("video_pieceflash_field").value = 0 == G.video.pieceflash ? "OFF" : Math.round(100 * (void 0 === G.video.pieceflash ? 1 : G.video.pieceflash)), document.getElementById("video_powersave").classList.toggle("checked", !!G.video.powersave), document.getElementById("video_alwaystiny").classList.toggle("checked", !!G.video.alwaystiny), document.getElementById("video_colorshadow").classList.toggle("checked", !!G.video.colorshadow), document.getElementById("video_sidebyside").classList.toggle("checked", !!G.video.sidebyside), document.getElementById("video_spin").classList.toggle("checked", !!G.video.spin), document.getElementById("video_chatfilter").classList.toggle("checked", !1 !== G.video.chatfilter), document.getElementById("video_nochat").classList.toggle("checked", !!G.video.nochat), document.getElementById("video_hideroomids").classList.toggle("checked", !!G.video.hideroomids), document.getElementById("video_spikes").classList.toggle("checked", !1 !== G.video.spikes), document.getElementById("video_emotes").classList.toggle("checked", !1 !== G.video.emotes), document.getElementById("video_invert").classList.toggle("checked", !!G.video.invert), document.getElementById("video_nobg").classList.toggle("checked", !!G.video.nobg), document.getElementById("video_chatbg").classList.toggle("checked", !!G.video.chatbg), document.getElementById("video_kos").classList.toggle("checked", !1 !== G.video.kos), document.getElementById("video_fire").classList.toggle("checked", !1 !== G.video.fire), document.getElementById("video_focuswarning").classList.toggle("checked", !1 !== G.video.focuswarning), document.getElementById("video_hidenetwork").classList.toggle("checked", !!G.video.hidenetwork), document.getElementById("video_guide").classList.toggle("checked", !1 !== G.video.guide), document.getElementById("video_desktopnotifications").classList.toggle("checked", !1 !== G.video.desktopnotifications), document.getElementById("video_siren").classList.toggle("checked", !1 !== G.video.siren), document.getElementById("video_lowrescounters").classList.toggle("checked", !!G.video.lowrescounters), document.getElementById("video_lowres").classList.toggle("checked", !!G.video.lowres), document.getElementById("config_background_usecustom").classList.toggle("checked", G.video.background_usecustom === q), document.getElementById("config_background_url").value = G.video.background_url || "", document.getElementById("diyusi_strategy_1").querySelector("h1").textContent = (X.target1[0] || "*").toLowerCase(), document.getElementById("diyusi_strategy_2").querySelector("h1").textContent = (X.target2[0] || "*").toLowerCase(), document.getElementById("diyusi_strategy_3").querySelector("h1").textContent = (X.target3[0] || "*").toLowerCase(), document.getElementById("diyusi_strategy_4").querySelector("h1").textContent = (X.target4[0] || "*").toLowerCase(), document.getElementById("pro_40l").classList.toggle("checked", !!G.gameoptions.pro_40l), document.getElementById("pro_40l_alert").classList.toggle("checked", !!G.gameoptions.pro_40l_alert), document.getElementById("pro_40l_retry").classList.toggle("checked", !!G.gameoptions.pro_40l_retry), document.getElementById("stride_40l").classList.toggle("checked", !!G.gameoptions.stride_40l), document.getElementById("pro_blitz").classList.toggle("checked", !!G.gameoptions.pro_blitz), document.getElementById("pro_blitz_alert").classList.toggle("checked", !!G.gameoptions.pro_blitz_alert), document.getElementById("pro_blitz_retry").classList.toggle("checked", !!G.gameoptions.pro_blitz_retry), document.getElementById("stride_blitz").classList.toggle("checked", !!G.gameoptions.stride_blitz);
		for (const e of document.getElementsByClassName("electron_loginskip")) e.classList.remove("pressed");
		document.getElementById(`electron_loginskip_${G.electron.loginskip||"quickjoin"}`).classList.add("pressed"), document.getElementById("config_electron_presence").classList.toggle("checked", !1 !== G.electron.presence), document.getElementById("config_electron_taskbarflash").classList.toggle("checked", !1 !== G.electron.taskbarflash)
	}
	let oe = -1;

	function ie(e, t, n = !1) {
		if (!Ln) return;
		const a = G.video.background_usecustom === q ? Z : V,
			o = a.join(",");
		if (!e && o === J) return;
		if (e && o === J && 1 === a.length) return;
		J = o;
		let i = Math.floor(Math.random() * a.length);
		for (; i === oe && a.length > 1;) i = Math.floor(Math.random() * a.length);
		oe = i, t ? Ln.setBackground(a[i], !0) : (Ln.setBackground(a[i]), n || kn.circleblocksplash(mt(20 * da.x), .03, 200, .04, 1e3, "#FFFFFF"))
	}
	let se = () => {};

	function re(e) {
		document.getElementById("keybind_request").classList.remove("hidden"), se = e, document.addEventListener("keydown", le, !1), document.addEventListener("gpdown", le, !1), setTimeout(() => {
			document.addEventListener("click", de, !1)
		}, 0)
	}

	function le(e) {
		document.removeEventListener("keydown", le, !1), document.removeEventListener("gpdown", le, !1), document.removeEventListener("click", de, !1), document.getElementById("keybind_request").classList.add("hidden"), se(ce(e) || e.detail.toUpperCase()), e.preventDefault()
	}

	function de(e) {
		document.removeEventListener("keydown", le, !1), document.removeEventListener("gpdown", le, !1), document.removeEventListener("click", de, !1), document.getElementById("keybind_request").classList.add("hidden"), se("X-NOKEY"), e.preventDefault()
	}

	function ce(e) {
		return e.code ? e.code.toUpperCase() : !!e.key && (" " === e.key ? "SPACE" : 3 === e.location ? `NUMPAD${e.key.toUpperCase()}` : e.key.toUpperCase())
	}
	ee(), I.ready((function (e) {
		ee(), ne(), "legacy" === G.video.webgl && d({
			msg: "using LEGACY WEBGL - this may slow down your game. if your device supports it, switch to WEBGL 2 in CONFIG!",
			color: "#FFC600",
			icon: "warning",
			timeout: 1e4
		}), setTimeout(() => {
			ie(!1, !1, !0)
		}, 300), document.getElementById("finish_guide_room").addEventListener("click", (function (e) {
			G.video.guide = !1, document.getElementById("room_opts_room").click(), Q(), ne()
		})), document.getElementById("finish_guide_sys").addEventListener("click", (function (e) {
			document.getElementById("sys_guide").classList.add("hiding"), document.getElementById("room_opts_room").click(), setTimeout(() => {
				G.video.guide = !1, Q(), ne()
			}, 1e3)
		})), document.getElementById("controls_keybinds_style_guideline").addEventListener("click", (function (e) {
			G.controls.style = "guideline", Q(), ne()
		})), document.getElementById("controls_keybinds_style_wasd").addEventListener("click", (function (e) {
			G.controls.style = "wasd", Q(), ne()
		})), document.getElementById("controls_keybinds_style_custom").addEventListener("click", (function (e) {
			G.controls.style = "custom", Q(), ne()
		}));
		for (const e of document.getElementsByClassName("keybind_custom")) e.addEventListener("click", (function (t) {
			re(t => {
				G.controls.custom[e.getAttribute("data-key")][parseInt(e.getAttribute("data-id"))] = "X-NOKEY" === t ? "" : t, Q(), ne()
			})
		}));
		document.getElementById("controls_sensitivity").addEventListener("input", (function (e) {
			G.controls.sensitivity = document.getElementById("controls_sensitivity").value, Q(), ne()
		})), document.getElementById("controls_vibration").addEventListener("input", (function (e) {
			G.controls.vibration = document.getElementById("controls_vibration").value, Q(), ne()
		})), document.getElementById("handling_arr").addEventListener("input", (function (e) {
			G.handling.arr = document.getElementById("handling_arr").value, Q(), ne()
		})), document.getElementById("handling_das").addEventListener("input", (function (e) {
			G.handling.das = document.getElementById("handling_das").value, Q(), ne()
		})), document.getElementById("handling_sdf").addEventListener("input", (function (e) {
			G.handling.sdf = document.getElementById("handling_sdf").value, Q(), ne()
		})), document.getElementById("handling_safelock").addEventListener("click", (function (e) {
			G.handling.safelock = !document.getElementById("handling_safelock").classList.contains("checked"), Q(), ne()
		}));
		for (const e of document.getElementsByClassName("stat_field")) e.addEventListener("click", (function (t) {
			const n = e.closest(".stat");
			we(n.querySelector(".stat_name").textContent, "enter a new value", n.querySelector(".stat_range").getAttribute("min"), n.querySelector(".stat_range").getAttribute("max"), n.querySelector(".stat_range").getAttribute("step") || "1", n.querySelector(".stat_range").value, e => {
				n.querySelector(".stat_range").value = e, n.querySelector(".stat_range").dispatchEvent(new Event("input", {
					bubbles: !0,
					cancelable: !0
				})), Q(), ne()
			})
		}));
		document.getElementById("handling_reset").addEventListener("click", (function (e) {
			G.handling.arr = 2, G.handling.das = 10, G.handling.sdf = 6, Q(), ne()
		})), document.getElementById("handling_test").addEventListener("click", (function (e) {
			et.testControls()
		})), document.getElementById("volume_music").addEventListener("input", (function (e) {
			G.volume.music = document.getElementById("volume_music").value, Q(), ne()
		})), document.getElementById("volume_sfx").addEventListener("input", (function (e) {
			G.volume.sfx = document.getElementById("volume_sfx").value, Q(), ne()
		})), document.getElementById("volume_stereo").addEventListener("input", (function (e) {
			G.volume.stereo = document.getElementById("volume_stereo").value, Q(), ne()
		})), document.getElementById("volume_next").addEventListener("click", (function (e) {
			G.volume.next = !document.getElementById("volume_next").classList.contains("checked"), Q(), ne()
		})), document.getElementById("volume_others").addEventListener("click", (function (e) {
			G.volume.others = !document.getElementById("volume_others").classList.contains("checked"), Q(), ne()
		})), document.getElementById("volume_attacks").addEventListener("click", (function (e) {
			G.volume.attacks = !document.getElementById("volume_attacks").classList.contains("checked"), Q(), ne()
		})), document.getElementById("volume_noreset").addEventListener("click", (function (e) {
			G.volume.noreset = !document.getElementById("volume_noreset").classList.contains("checked"), Q(), ne()
		})), document.getElementById("volume_oof").addEventListener("click", (function (e) {
			G.volume.oof = !document.getElementById("volume_oof").classList.contains("checked"), Q(), ne()
		})), document.getElementById("volume_disable").addEventListener("click", (function (e) {
			G.volume.disable = !document.getElementById("volume_disable").classList.contains("checked"), Q(), ne()
		}));
		let t = null;
		window.addEventListener("wheel", (function (e) {
			if (!document.body.classList.contains("ingame")) return;
			if (e.target.closest("#ingame_chat_container")) return;
			if (e.target.closest("#zen_panel_content")) return;
			const n = Math.sign(-e.deltaY);
			if (e.target.closest("#volume_overlay_sfx")) G.volume.sfx = Math.max(0, Math.min(1, G.volume.sfx + .05 * n));
			else if (e.target.closest("#volume_overlay_mus")) G.volume.music = Math.max(0, Math.min(1, G.volume.music + .05 * n));
			else {
				let e = G.volume.sfx * (.25 * n);
				e = 1 === n ? Math.max(.05, e) : Math.min(-.05, e), G.volume.sfx = Math.max(0, Math.min(1, parseFloat(G.volume.sfx) + e));
				let t = G.volume.music * (.25 * n);
				t = 1 === n ? Math.max(.05, t) : Math.min(-.05, t), G.volume.music = Math.max(0, Math.min(1, parseFloat(G.volume.music) + t))
			}
			document.getElementById("volume_overlay").classList.remove("hidden"), document.getElementById("volume_overlay").classList.remove("hiding"), setTimeout(() => {
				document.getElementById("volume_overlay").classList.add("hiding")
			}, 100), t && clearTimeout(t), t = setTimeout(() => {
				document.getElementById("volume_overlay").classList.add("hidden")
			}, 5100), Q(), ne()
		}), {
			passive: !0
		}), document.getElementById("video_graphics_minimal").addEventListener("click", (function (e) {
			G.video.graphics = "minimal", G.video.lowres = !0, G.video.sidebyside = !1, kn.unset(), Q(), ne(), d({
				msg: "changing GRAPHICS LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_graphics_low").addEventListener("click", (function (e) {
			"minimal" === G.video.graphics && (G.video.lowres = !1, G.video.sidebyside = !0), G.video.graphics = "low", kn.unset(), Q(), ne(), d({
				msg: "changing GRAPHICS LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_graphics_medium").addEventListener("click", (function (e) {
			"minimal" === G.video.graphics && (G.video.lowres = !1, G.video.sidebyside = !0), G.video.graphics = "medium", kn.unset(), Q(), ne(), d({
				msg: "changing GRAPHICS LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_graphics_high").addEventListener("click", (function (e) {
			"minimal" === G.video.graphics && (G.video.lowres = !1, G.video.sidebyside = !0), G.video.graphics = "high", kn.set(), Q(), ne(), d({
				msg: "changing GRAPHICS LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_graphics_ultra").addEventListener("click", (function (e) {
			"minimal" === G.video.graphics && (G.video.lowres = !1, G.video.sidebyside = !0), G.video.graphics = "ultra", kn.set(), Q(), ne(), d({
				msg: "changing GRAPHICS LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			}), IS_ELECTRON || d({
				msg: "you are not using TETR.IO DESKTOP - ULTRA graphics may be less performant.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_caching_low").addEventListener("click", (function (e) {
			G.video.caching = "low", Q(), ne(), d({
				msg: "changing CACHING LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_caching_medium").addEventListener("click", (function (e) {
			G.video.caching = "medium", Q(), ne(), d({
				msg: "changing CACHING LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_caching_high").addEventListener("click", (function (e) {
			G.video.caching = "high", Q(), ne(), d({
				msg: "changing CACHING LEVEL requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_webgl_legacy").addEventListener("click", (function (e) {
			E({
				title: "USE LEGACY WEBGL?",
				msg: 'LEGACY WEBGL is the slowest WEBGL mode and may introduce bugs. only use it if the other modes do not work for you (for example, you see graphical glitches or flickering while playing)!</p><p class="modal_also">when reporting a bug, please mention LEGACY WEBGL is enabled.',
				buttons: [{
					label: "CANCEL",
					classes: [],
					callback: e => {
						e()
					}
				}, {
					label: "USE LEGACY WEBGL",
					classes: ["sec"],
					callback: e => {
						G.video.webgl = "legacy", Q(), ne(), d({
							msg: "changing WEBGL MODE requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
							color: "#FFC600",
							icon: "warning"
						}), e()
					}
				}]
			})
		})), document.getElementById("video_webgl_webgl1").addEventListener("click", (function (e) {
			G.video.webgl = "webgl1", Q(), ne(), d({
				msg: "changing WEBGL MODE requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_webgl_webgl2").addEventListener("click", (function (e) {
			G.video.webgl = "webgl2", Q(), ne(), d({
				msg: "changing WEBGL MODE requires a restart to fully go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_actiontext_off").addEventListener("click", (function (e) {
			G.video.actiontext = "off", Q(), ne()
		})), document.getElementById("video_actiontext_some").addEventListener("click", (function (e) {
			G.video.actiontext = "some", Q(), ne()
		})), document.getElementById("video_actiontext_all").addEventListener("click", (function (e) {
			G.video.actiontext = "all", Q(), ne()
		})), document.getElementById("video_particles").addEventListener("input", (function (e) {
			G.video.particles = document.getElementById("video_particles").value, Q(), ne()
		})), document.getElementById("video_background").addEventListener("input", (function (e) {
			G.video.background = document.getElementById("video_background").value, Q(), ne()
		})), document.getElementById("video_bounciness").addEventListener("input", (function (e) {
			G.video.bounciness = document.getElementById("video_bounciness").value, Q(), ne()
		})), document.getElementById("video_shakiness").addEventListener("input", (function (e) {
			G.video.shakiness = document.getElementById("video_shakiness").value, Q(), ne()
		})), document.getElementById("video_gridopacity").addEventListener("input", (function (e) {
			G.video.gridopacity = document.getElementById("video_gridopacity").value, Q(), ne()
		})), document.getElementById("video_boardopacity").addEventListener("input", (function (e) {
			G.video.boardopacity = document.getElementById("video_boardopacity").value, Q(), ne()
		})), document.getElementById("video_shadowopacity").addEventListener("input", (function (e) {
			G.video.shadowopacity = document.getElementById("video_shadowopacity").value, Q(), ne()
		})), document.getElementById("video_zoom").addEventListener("input", (function (e) {
			G.video.zoom = document.getElementById("video_zoom").value, Q(), ne(), ct()
		})), document.getElementById("video_bloom").addEventListener("input", (function (e) {
			G.video.bloom = document.getElementById("video_bloom").value, Q(), ne(), Zn()
		})), document.getElementById("video_chroma").addEventListener("input", (function (e) {
			G.video.chroma = document.getElementById("video_chroma").value, Q(), ne(), Zn()
		})), document.getElementById("video_flashwave").addEventListener("input", (function (e) {
			G.video.flashwave = document.getElementById("video_flashwave").value, Q(), ne()
		})), document.getElementById("video_pieceflash").addEventListener("input", (function (e) {
			G.video.pieceflash = document.getElementById("video_pieceflash").value, Q(), ne()
		})), document.getElementById("video_powersave").addEventListener("click", (function (e) {
			G.video.powersave = !document.getElementById("video_powersave").classList.contains("checked"), Q(), ne(), d({
				msg: "changing POWER SAVE requires a restart to go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_lowrescounters").addEventListener("click", (function (e) {
			G.video.lowrescounters = !document.getElementById("video_lowrescounters").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_lowres").addEventListener("click", (function (e) {
			G.video.lowres = !document.getElementById("video_lowres").classList.contains("checked"), Q(), ne(), d({
				msg: "changing LOW RESOLUTION MODE requires a restart to go in effect. hit F5 on your keyboard to restart.",
				color: "#FFC600",
				icon: "warning"
			})
		})), document.getElementById("video_alwaystiny").addEventListener("click", (function (e) {
			G.video.alwaystiny = !document.getElementById("video_alwaystiny").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_colorshadow").addEventListener("click", (function (e) {
			G.video.colorshadow = !document.getElementById("video_colorshadow").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_sidebyside").addEventListener("click", (function (e) {
			G.video.sidebyside = !document.getElementById("video_sidebyside").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_spin").addEventListener("click", (function (e) {
			G.video.spin = !document.getElementById("video_spin").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_chatfilter").addEventListener("click", (function (e) {
			G.video.chatfilter = !document.getElementById("video_chatfilter").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_nochat").addEventListener("click", (function (e) {
			G.video.nochat = !document.getElementById("video_nochat").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_hideroomids").addEventListener("click", (function (e) {
			G.video.hideroomids = !document.getElementById("video_hideroomids").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_spikes").addEventListener("click", (function (e) {
			G.video.spikes = !document.getElementById("video_spikes").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_emotes").addEventListener("click", (function (e) {
			G.video.emotes = !document.getElementById("video_emotes").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_invert").addEventListener("click", (function (e) {
			G.video.invert = !document.getElementById("video_invert").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_nobg").addEventListener("click", (function (e) {
			G.video.nobg = !document.getElementById("video_nobg").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_chatbg").addEventListener("click", (function (e) {
			G.video.chatbg = !document.getElementById("video_chatbg").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_kos").addEventListener("click", (function (e) {
			G.video.kos = !document.getElementById("video_kos").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_fire").addEventListener("click", (function (e) {
			G.video.fire = !document.getElementById("video_fire").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_focuswarning").addEventListener("click", (function (e) {
			G.video.focuswarning = !document.getElementById("video_focuswarning").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_hidenetwork").addEventListener("click", (function (e) {
			G.video.hidenetwork = !document.getElementById("video_hidenetwork").classList.contains("checked"), Q(), ne()
		})), document.getElementById("video_guide").addEventListener("click", (function (e) {
			G.video.guide = !document.getElementById("video_guide").classList.contains("checked"), G.video.guide ? document.getElementById("room_opts_welcome").click() : document.getElementById("room_opts_room").click(), Q(), ne()
		})), document.getElementById("video_desktopnotifications").addEventListener("click", (function (e) {
			G.video.desktopnotifications = !document.getElementById("video_desktopnotifications").classList.contains("checked"), G.video.desktopnotifications && Ze(!0), Q(), ne()
		})), document.getElementById("video_siren").addEventListener("click", (function (e) {
			G.video.siren = !document.getElementById("video_siren").classList.contains("checked"), Q(), ne()
		})), document.getElementById("config_background_url").addEventListener("keyup", (function (e) {
			G.video.background_url = document.getElementById("config_background_url").value, Q(), ne()
		})), document.getElementById("config_background_usecustom").addEventListener("click", (function (e) {
			G.video.background_usecustom = document.getElementById("config_background_usecustom").classList.contains("checked") ? null : q, Q(), ne()
		})), document.getElementById("pro_40l").addEventListener("click", (function (e) {
			G.gameoptions.pro_40l = !document.getElementById("pro_40l").classList.contains("checked"), Q(), ne()
		})), document.getElementById("pro_40l_alert").addEventListener("click", (function (e) {
			G.gameoptions.pro_40l_alert = !document.getElementById("pro_40l_alert").classList.contains("checked"), Q(), ne()
		})), document.getElementById("pro_40l_retry").addEventListener("click", (function (e) {
			G.gameoptions.pro_40l_retry = !document.getElementById("pro_40l_retry").classList.contains("checked"), Q(), ne()
		})), document.getElementById("stride_40l").addEventListener("click", (function (e) {
			G.gameoptions.stride_40l = !document.getElementById("stride_40l").classList.contains("checked"), Q(), ne()
		})), document.getElementById("pro_blitz").addEventListener("click", (function (e) {
			G.gameoptions.pro_blitz = !document.getElementById("pro_blitz").classList.contains("checked"), Q(), ne()
		})), document.getElementById("pro_blitz_alert").addEventListener("click", (function (e) {
			G.gameoptions.pro_blitz_alert = !document.getElementById("pro_blitz_alert").classList.contains("checked"), Q(), ne()
		})), document.getElementById("pro_blitz_retry").addEventListener("click", (function (e) {
			G.gameoptions.pro_blitz_retry = !document.getElementById("pro_blitz_retry").classList.contains("checked"), Q(), ne()
		})), document.getElementById("stride_blitz").addEventListener("click", (function (e) {
			G.gameoptions.stride_blitz = !document.getElementById("stride_blitz").classList.contains("checked"), Q(), ne()
		})), document.getElementById("electron_loginskip_never").addEventListener("click", (function (e) {
			G.electron.loginskip = "never", Q(), ne()
		})), document.getElementById("electron_loginskip_quickjoin").addEventListener("click", (function (e) {
			G.electron.loginskip = "quickjoin", Q(), ne()
		})), document.getElementById("electron_loginskip_always").addEventListener("click", (function (e) {
			G.electron.loginskip = "always", Q(), ne()
		})), document.getElementById("config_electron_presence").addEventListener("click", (function (e) {
			G.electron.presence = !document.getElementById("config_electron_presence").classList.contains("checked"), Q(), ne()
		})), document.getElementById("config_electron_taskbarflash").addEventListener("click", (function (e) {
			G.electron.taskbarflash = !document.getElementById("config_electron_taskbarflash").classList.contains("checked"), Q(), ne()
		}))
	}));
	const me = [{
			id: "room_content_room",
			classes: "hidden",
			blocks: [{
				title: "GENERAL",
				options: [{
					id: "meta.name",
					label: "room name",
					title: "Name this room will display in the listing as",
					type: "text",
					classes: "imp",
					attributes: 'maxlength="64" minlength="1"'
				}, {
					id: "meta.userlimit",
					label: "player limit",
					title: "Maximum players in this room. 0 = no limit. Does not apply retroactively.",
					type: "number",
					classes: "",
					attributes: 'max="999" min="0"'
				}, {
					id: "meta.allowAnonymous",
					label: "allow anonymous users to join",
					title: "Whether to allow anonymous users to enter this room. Does not apply retroactively.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "meta.bgm",
					label: "music",
					title: "Background song to play. If random, not everyone will hear the same song.",
					type: "music",
					classes: "imp",
					attributes: ""
				}]
			}]
		}, {
			id: "room_content_match",
			classes: "hidden",
			blocks: [{
				title: "GENERAL",
				options: [{
					id: "meta.match.type",
					label: "game mode",
					title: "Game mode.",
					type: "spinner",
					classes: "super-imp",
					attributes: 'data-items="versus,VERSUS,a battle royale! who can survive the longest?"'
				}, {
					id: "meta.match.ft",
					label: "first to (FT)",
					title: "Amount of rounds one must win to win the game.",
					type: "number",
					classes: "imp",
					attributes: 'max="1000" min="1"'
				}, {
					id: "game.options.stock",
					label: "stock",
					title: "Amount of extra lives one has.",
					type: "number",
					classes: "",
					attributes: 'max="10" min="0"'
				}]
			}]
		}, {
			id: "room_content_game",
			classes: "hidden",
			blocks: [{
				title: "GENERAL",
				options: [{
					id: "game.options.bagtype",
					label: "random bag type",
					title: "The type of system used to generate random pieces.",
					type: "spinner",
					classes: "imp",
					attributes: 'data-items="7-bag,7-BAG,keep shuffling a bag of the 7 tetrominoes;14-bag,14-BAG,keep shuffling a bag of 2x the 7 tetrominoes;classic,CLASSIC,random with repetition protection;pairs,PAIRS,alternate between 2 tetrominoes;total mayhem,TOTAL MAYHEM,completely random generation"'
				}, {
					id: "game.options.spinbonuses",
					label: "allowed spins",
					title: "The type of pieces allowed to do spins.",
					type: "spinner",
					classes: "imp",
					attributes: 'data-items="T-spins,T-SPINS,receive bonuses for spinning T-pieces;all,ALL-SPIN,receive bonuses for spinning all pieces;stupid,STUPID,everything is a spin because YEAH WHY NOT (O-spin SUPPORTED!);none,NONE,receive no spin bonuses"'
				}, {
					id: "game.options.allow180",
					label: "allow 180 spins",
					title: "Whether to allow the 180 rotation key to be used.",
					type: "checkbox",
					classes: "imp",
					attributes: ""
				}, {
					id: "game.options.kickset",
					label: "kick table",
					title: "The type of kicks that pieces can do.",
					type: "spinner",
					classes: "",
					attributes: 'data-items="SRS,SRS,the default natural rotation system;SRS-X,SRS-X,SRS with more powerful 180 spins;TETRA-X,TETRA-X,novel rotation system by DR OCELOT;NRS,NRS,the classic rotation system;ARS,ARS,rotation system used in arcade games;ASC,ASC,permissive rotation system by WINTERNEBS;none,NONE,no kicks possible"'
				}, {
					id: "game.options.allow_harddrop",
					label: "use hard drop",
					title: "Whether to allow use of the Hard Drop button.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.display_next",
					label: "use NEXT queue",
					title: "Whether to show the NEXT queue.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.display_hold",
					label: "use HOLD queue",
					title: "Whether to use the HOLD queue.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.nextcount",
					label: "next pieces",
					title: "Amount of pieces shown in the NEXT queue, if said queue is enabled.",
					type: "number",
					classes: "",
					attributes: 'min="1" max="5"'
				}, {
					id: "game.options.display_shadow",
					label: "show shadow piece",
					title: "Whether to show the shadow piece.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.are",
					label: "ARE",
					title: "Amount of time in frames in between a piece being placed and the next one spawning.",
					type: "number",
					classes: "",
					attributes: 'min="0" max="300"'
				}, {
					id: "game.options.lineclear_are",
					label: "line clear ARE",
					title: "Amount of time in frames in between a piece being placed and the next one spawning, if a line was cleared.",
					type: "number",
					classes: "",
					attributes: 'min="0" max="300"'
				}, {
					id: "game.options.room_handling",
					label: "enforce below handling settings",
					title: "Whether to enforce the handling settings below.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.room_handling_arr",
					label: "enforced ARR",
					title: 'Auto Repeat Rate, enforced if "enforce below handling settings" is enabled.',
					type: "number",
					classes: "",
					attributes: 'min="0" max="5" step="0.1"'
				}, {
					id: "game.options.room_handling_das",
					label: "enforced DAS",
					title: 'Delayed Auto Shift, enforced if "enforce below handling settings" is enabled.',
					type: "number",
					classes: "",
					attributes: 'min="1" max="20" step="0.1"'
				}, {
					id: "game.options.room_handling_sdf",
					label: "enforced SDF",
					title: 'Soft Drop Factor, enforced if "enforce below handling settings" is enabled. Use 21 for MAX.',
					type: "number",
					classes: "",
					attributes: 'min="5" max="21"'
				}]
			}, {
				title: "GRAVITY & MARGIN TIME",
				options: [{
					id: "game.options.g",
					label: "gravity",
					title: "Starting gravity (how fast blocks drop). Higher is faster.",
					type: "number",
					classes: "",
					attributes: 'max="20" min="0" step="0.01"'
				}, {
					id: "game.options.gincrease",
					label: "gravity increase",
					title: "The amount of gravity increase per second.",
					type: "number",
					classes: "",
					attributes: 'max="1" min="0" step="0.0001"'
				}, {
					id: "game.options.gmargin",
					label: "gravity margin time",
					title: "Amount of time in frames until the gravity starts to increase.",
					type: "number",
					classes: "",
					attributes: 'max="100000" min="0" step="1"'
				}, {
					id: "game.options.garbagemultiplier",
					label: "garbage multiplier",
					title: "Starting garbage multiplier. 1 means normal amount of garbage, 2 means double.",
					type: "number",
					classes: "",
					attributes: 'max="100" min="0" step="0.1"'
				}, {
					id: "game.options.garbagemargin",
					label: "garbage margin time",
					title: "Amount of time in frames until the garbage multiplier starts to increase.",
					type: "number",
					classes: "",
					attributes: 'max="100000" min="0" step="1"'
				}, {
					id: "game.options.garbageincrease",
					label: "garbage increase",
					title: "The amount of garbage multiplier increase per second.",
					type: "number",
					classes: "",
					attributes: 'max="1" min="0" step="0.0001"'
				}, {
					id: "game.options.locktime",
					label: "lock delay",
					title: "If not using master levels, the amount of frames until a piece locks down.",
					type: "number",
					classes: "",
					attributes: 'min="1"'
				}, {
					id: "game.options.garbagespeed",
					label: "garbage travel speed",
					title: "The time it takes in frames for garbage to travel.",
					type: "number",
					classes: "",
					attributes: 'min="1" max="600"'
				}, {
					id: "game.options.garbagecap",
					label: "garbage cap",
					title: "Amount of garbage that may enter the screen at once.",
					type: "number",
					classes: "",
					attributes: 'min="1" max="40"'
				}, {
					id: "game.options.garbagecapincrease",
					label: "garbage cap increase",
					title: "The amount of garbage cap increase per second.",
					type: "number",
					classes: "",
					attributes: 'max="1" min="0" step="0.0001"'
				}, {
					id: "game.options.garbagecapmax",
					label: "garbage cap max",
					title: "Maximum amount the garbage cap may reach.",
					type: "number",
					classes: "",
					attributes: 'min="1" max="40"'
				}, {
					id: "game.options.manual_allowed",
					label: "allow manual targeting",
					title: "Whether to allow users to click boards to manually target them.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.b2bchaining",
					label: "enable back-to-back chaining",
					title: "Whether to make long Back-to-Back chains become more powerful.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "game.options.clutch",
					label: "enable clutch clears",
					title: "Whether to allow out-of-bound placements when they clear a line.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}]
			}]
		}],
		ue = [{
			id: "custom_content_game",
			classes: "",
			blocks: [{
				title: "GENERAL",
				options: [{
					id: "bagtype",
					label: "random bag type",
					title: "The type of system used to generate random pieces.",
					type: "spinner",
					classes: "imp",
					value: "7bag",
					attributes: 'data-items="7-bag,7-BAG,keep shuffling a bag of the 7 tetrominoes;14-bag,14-BAG,keep shuffling a bag of 2x the 7 tetrominoes;classic,CLASSIC,random with repetition protection;pairs,PAIRS,alternate between 2 tetrominoes;total mayhem,TOTAL MAYHEM,completely random generation"'
				}, {
					id: "spinbonuses",
					label: "allowed spins",
					title: "The type of pieces allowed to do spins.",
					type: "spinner",
					classes: "imp",
					value: "T-spins",
					attributes: 'data-items="T-spins,T-SPINS,receive bonuses for spinning T-pieces;all,ALL-SPIN,receive bonuses for spinning all pieces;stupid,STUPID,everything is a spin because YEAH WHY NOT (O-spin SUPPORTED!);none,NONE,receive no spin bonuses"'
				}, {
					id: "seed_random",
					label: 'use random seed (overrides "seed")',
					title: "Whether to use a random seed.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "seed",
					label: "seed",
					title: 'Seed to use, if "use random seed" is not checked.',
					type: "number",
					classes: "",
					attributes: 'max="2147483647" min="0" value="0"'
				}, {
					id: "can_retry",
					label: "allow retry",
					title: "Whether to allow retrying.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "stock",
					label: "stock",
					title: "Amount of extra lives one has.",
					type: "number",
					classes: "",
					attributes: 'max="10" min="0" value="0"'
				}, {
					id: "clutch",
					label: "enable clutch clears",
					title: "Whether to allow out-of-bound placements when they clear a line.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}]
			}, {
				title: "CONTROLS",
				options: [{
					id: "allow180",
					label: "allow 180 spins",
					title: "Whether to allow the 180 rotation key to be used.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "kickset",
					label: "kick table",
					title: "The type of kicks that pieces can do.",
					type: "spinner",
					classes: "",
					value: "SRS",
					attributes: 'data-items="SRS,SRS,the default natural rotation system;SRS-X,SRS-X,SRS with more powerful 180 spins;TETRA-X,TETRA-X,novel rotation system by DR OCELOT;NRS,NRS,the classic rotation system;ARS,ARS,rotation system used in arcade games;ASC,ASC,permissive rotation system by WINTERNEBS;none,NONE,no kicks possible"'
				}, {
					id: "allow_harddrop",
					label: "use hard drop",
					title: "Whether to allow use of the Hard Drop button.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "display_next",
					label: "use NEXT queue",
					title: "Whether to show the NEXT queue.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "display_hold",
					label: "use HOLD queue",
					title: "Whether to use the HOLD queue.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "nextcount",
					label: "next pieces",
					title: "Amount of pieces shown in the NEXT queue, if said queue is enabled.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="5" max="5"'
				}, {
					id: "infinitemovement",
					label: "infinite movement",
					title: "Whether to never lock, as long as you keep moving the piece.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "display_shadow",
					label: "show shadow piece",
					title: "Whether to show the shadow piece.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "are",
					label: "ARE",
					title: "Amount of time in frames in between a piece being placed and the next one spawning.",
					type: "number",
					classes: "",
					attributes: 'min="0" value="0" max="300"'
				}, {
					id: "lineclear_are",
					label: "line clear ARE",
					title: "Amount of time in frames in between a piece being placed and the next one spawning, if a line was cleared.",
					type: "number",
					classes: "",
					attributes: 'min="0" value="0" max="300"'
				}]
			}, {
				title: "GRAVITY & LEVELLING",
				options: [{
					id: "g",
					label: "gravity",
					title: "Gravity (how fast blocks drop). Higher is faster.",
					type: "number",
					classes: "",
					attributes: 'max="20" min="0" step="0.01" value="0.02"'
				}, {
					id: "levels",
					label: 'use levelling (overrides "gravity")',
					title: "Whether to allow players to level up. Overrides the normal gravity.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "masterlevels",
					label: "use master levels",
					title: "If enabled, allow levels past 20 to become MASTER LEVELS (faster lock-down time and less resets).",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "startinglevel",
					label: "starting level",
					title: "Level to start at.",
					type: "number",
					classes: "",
					attributes: 'value="1" min="1"'
				}, {
					id: "levelspeed",
					label: "level speed",
					title: "How fast you clear levels.",
					type: "number",
					classes: "",
					attributes: 'step="0.01" value="1"'
				}, {
					id: "levelstatic",
					label: 'use static levelling (overrides "level speed")',
					title: "Use a static amount of lines to level up.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "levelstaticspeed",
					label: "level static speed",
					title: "If using static levelling, the amount of lines needed to clear a level.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="10"'
				}, {
					id: "gbase",
					label: "base gravity",
					title: "When using levels, the starting gravity.",
					type: "number",
					classes: "",
					attributes: 'step="0.01" value="0.8"'
				}, {
					id: "gspeed",
					label: "gravity increase",
					title: "When using levels, the speed with which gravity increases.",
					type: "number",
					classes: "",
					attributes: 'step="0.001" value="0.007"'
				}, {
					id: "locktime",
					label: "lock delay",
					title: "If not using master levels, the amount of frames until a piece locks down.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="30"'
				}]
			}]
		}, {
			id: "custom_content_objective",
			classes: "hidden",
			blocks: [{
				title: "GENERAL",
				options: [{
					id: "x_resulttype",
					label: "key",
					title: "The counter you will be judged on at the end of the game.",
					type: "spinner",
					classes: "super-imp",
					value: "score",
					attributes: 'data-items="score,SCORE,final score will be displayed;time,TIME,final time will be displayed;lines,LINES,final line count will be displayed"'
				}, {
					id: "objective_type",
					label: "objective",
					title: "Game mode.",
					type: "spinner",
					classes: "super-imp",
					value: "lines",
					attributes: 'data-items="none,NONE,play infinitely;lines,LINES,get to a set amount of lines to clear;timed,TIMED,play for a set amount of time to clear"'
				}, {
					id: "objective_count",
					label: "count",
					title: "Amount of primary key to get in LINES mode. For example, in LINES mode this would be the amount of lines to be cleared.",
					type: "number",
					classes: "imp",
					attributes: 'min="1" value="150"'
				}, {
					id: "objective_time",
					label: "time",
					title: "Amount of time in milliseconds. For example, in TIMED mode this would be the amount of time until the game ends.",
					type: "number",
					classes: "imp",
					attributes: 'min="1" value="120000"'
				}, {
					id: "topoutisclear",
					label: "topping out is OK",
					title: "If enabled, still display the results screen if the player tops out.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}]
			}]
		}, {
			id: "custom_content_meta",
			classes: "hidden",
			blocks: [{
				title: "INTRO",
				options: [{
					id: "mission",
					label: "mission",
					title: "Text displayed before starting game.",
					type: "text",
					classes: "imp",
					attributes: 'value="CUSTOM GAME"'
				}, {
					id: "stride",
					label: "stride mode",
					title: "Speeds up animations and disables some of the below settings.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "countdown",
					label: "play countdown",
					title: "Whether to play a countdown.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "countdown_count",
					label: "countdown count",
					title: "Amount of steps in the countdown.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="3" max="60"'
				}, {
					id: "countdown_interval",
					label: "countdown interval",
					title: "Amount of milliseconds between countdown ticks.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="1000"'
				}, {
					id: "precountdown",
					label: "time before countdown",
					title: "Amount of milliseconds before the countdown is started.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="3000"'
				}, {
					id: "prestart",
					label: "time before start",
					title: "Amount of milliseconds before the game is created.",
					type: "number",
					classes: "",
					attributes: 'min="1" value="1000"'
				}, {
					id: "zoominto",
					label: "zoom animation",
					title: "Type of animation to play when starting.",
					type: "spinner",
					classes: "",
					value: "slow",
					attributes: 'data-items="none,NO ANIMATION,display no animation;fast,FAST,display a fast animation;slow,SLOW,display a slow animation;cinematic,CINEMATIC,display a very slow animation"'
				}]
			}, {
				title: "COUNTERS",
				options: [{
					id: "display_score",
					label: "display score",
					title: "Whether to display the score.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "display_lines",
					label: "display line count",
					title: "Whether to display the count of cleared lines.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "absolute_lines",
					label: "enforce absolute line count",
					title: "Do not display the progression through the level in the line count.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "display_level",
					label: "display level",
					title: "Whether to display the level number.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "display_stopwatch",
					label: "display stopwatch",
					title: "Whether to display a stopwatch.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}, {
					id: "display_timer",
					label: "display timer",
					title: "Whether to display a timer (for use with the TIMED objective).",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "display_pieces",
					label: "display piece count",
					title: "Whether to display the count of placed pieces and PPS.",
					type: "checkbox",
					classes: "",
					attributes: ""
				}, {
					id: "display_progress",
					label: "display progress bar",
					title: "Whether to display the progress bar on the right.",
					type: "checkbox",
					classes: "",
					attributes: "checked"
				}]
			}]
		}];

	function ge(e) {
		let t = "";
		return e.forEach(e => {
			t += `<div class="scroller room_content ${e.classes}" id="${e.id}"><p class="rc_moreinfo ns">hover over a setting for more info</p>`, e.blocks.forEach(e => {
				t += `<div class="scroller_block light"><h2 class="ns">${e.title}</h2>`, e.options.forEach(e => {
					switch (e.type) {
						case "text":
							t += `<div class="room_config_row flex-row ${e.classes}" title="${e.title}">\n\t\t\t\t\t\t\t\t\t<div class="room_config_label flex-item ns">${e.label}</div>\n\t\t\t\t\t\t\t\t\t<input class="room_config_item flex-item" data-index="${e.id}" ${e.attributes}>\n\t\t\t\t\t\t\t\t</div>`;
							break;
						case "number":
							t += `<div class="room_config_row flex-row ${e.classes}" title="${e.title}">\n\t\t\t\t\t\t\t\t\t<div class="room_config_label flex-item ns">${e.label}</div>\n\t\t\t\t\t\t\t\t\t<input type="number" class="room_config_item flex-item" data-index="${e.id}" ${e.attributes}>\n\t\t\t\t\t\t\t\t</div>`;
							break;
						case "checkbox":
							t += `<div class="room_config_row flex-row ${e.classes}" title="${e.title}">\n\t\t\t\t\t\t\t\t\t<div class="room_config_label flex-item ns">${e.label}</div>\n\t\t\t\t\t\t\t\t\t<label class="rc_switch flex-item"><input type="checkbox" class="room_config_item" data-index="${e.id}" ${e.attributes}><span class="rc_switch_knob"></span></label>\n\t\t\t\t\t\t\t\t</div>`;
							break;
						case "spinner":
							t += `<div class="room_config_row flex-row ${e.classes}" title="${e.title}">\n\t\t\t\t\t\t\t\t\t<div class="room_config_label flex-item ns">${e.label}</div>\n\t\t\t\t\t\t\t\t\t<div class="room_config_item room_config_spinner flex-item ns" data-index="${e.id}" ${e.attributes}>${e.value||""}</div>\n\t\t\t\t\t\t\t\t</div>`;
							break;
						case "music":
							t += `<div class="room_config_row flex-row ${e.classes}" title="${e.title}">\n\t\t\t\t\t\t\t\t\t<div class="room_config_label flex-item ns">${e.label}</div>\n\t\t\t\t\t\t\t\t\t<div class="room_config_item room_config_spinner flex-item music_picker ns" data-index="${e.id}" ${e.attributes}></div>\n\t\t\t\t\t\t\t\t</div>`
					}
				}), t += "</div>"
			}), t += "</div>"
		}), t
	}
	I.ready((function (e) {
		document.getElementById("room_opts_save").outerHTML = ge(me) + document.getElementById("room_opts_save").outerHTML, document.getElementById("custom_content_container").innerHTML = ge(ue), !1 === G.video.guide && (document.getElementById("room_opts_welcome").classList.remove("active"), document.getElementById("room_opts_room").classList.add("active"), document.getElementById("room_content_welcome").classList.add("hidden"), document.getElementById("room_content_room").classList.remove("hidden"))
	}));
	const pe = (() => {
			let e = {},
				t = !1,
				n = null,
				a = null,
				o = null;
			const i = [];

			function s() {
				if (!t || !e) return;
				if (!a || !o || null === o.offsetParent) return void n.classList.add("hidden");
				n.classList.remove("hidden");
				const i = o.getBoundingClientRect();
				n.style.left = `${i.left}px`, n.style.top = `${i.top}px`, n.style.width = `${i.width}px`, n.style.height = `${i.height}px`, n.classList.toggle("input", ["input", "textarea"].includes(document.activeElement.tagName.toLowerCase())), n.classList.toggle("noclick", o.classList.contains("noclick"))
			}

			function r(e) {
				const t = e.split("!");
				return 2 === t.length ? {
					tags: t[0].split(""),
					selector: t[1]
				} : {
					tags: [],
					selector: t[0]
				}
			}

			function l(t) {
				const n = function (e, t = null) {
					const n = r(e);
					let a = Array.from(document.querySelectorAll(n.selector));
					if (a = a.filter(e => (null !== e.offsetParent || e.classList.contains("rb_bypass")) && null === e.closest(".hidden")), n.tags.includes("f") && a.splice(1), n.tags.includes("l") && a.splice(0, a.length - 1), t && n.tags.includes("n")) {
						const e = a.indexOf(t); - 1 !== e && a.length ? a = [a[(e + 1) % a.length]] : a.splice(1)
					}
					if (t && n.tags.includes("p")) {
						const e = a.indexOf(t); - 1 !== e && a.length ? a = [a[(e - 1 + a.length) % a.length]] : a.splice(0, a.length - 1)
					}
					return a[0] || null
				}(t, o);
				n ? (a = function (t, n) {
					const a = r(t);
					let o = Array.from(document.querySelectorAll(a.selector));
					const i = (o = o.filter(e => (null !== e.offsetParent || e.classList.contains("rb_bypass")) && null === e.closest(".hidden"))).indexOf(n);
					let s = a.selector;
					return 0 === i ? s = `f!${a.selector}` : i === o.length - 1 && (s = `l!${a.selector}`), e.items[s] ? s : a.selector
				}(t, o = n), r(t).tags.includes("s") || function (e) {
					const t = document.createElement("div");
					return t.classList.add("elgh"), t.style.left = `${e.offsetLeft}px`, t.style.top = `${e.offsetTop}px`, t.style.width = `${Math.max(0,Math.min(e.offsetParent.offsetWidth-e.offsetLeft-30,e.offsetWidth))}px`, t.style.height = `${e.offsetHeight}px`, e.offsetParent.appendChild(t), setTimeout(() => {
						t.remove()
					}, 1e3), t
				}(o).scrollIntoView({
					behavior: "smooth",
					block: "center",
					inline: "nearest"
				}), o.getAttribute("data-hover") && yt.play(`menu${o.getAttribute("data-hover")}`)) : a = t
			}

			function d(t) {
				(e = t).starter ? l(e.starter) : (a = null, o = null)
			}
			I.ready((function (e) {
				(n = document.createElement("div")).id = "ribbonglide", document.body.appendChild(n), PIXI.Ticker.shared.add(s)
			}));
			let c = null;

			function m(e) {
				if ("none" === window.getComputedStyle(e, null).getPropertyValue("pointer-events")) return yt.play("no"), n.classList.add("no"), null !== c && clearTimeout(c), void setTimeout(() => {
					n.classList.remove("no"), c = null
				}, 100);
				W.pulse(...W.WEAK_TAP), yt.play("ribbon_tap", .5), e.focus(), e.click()
			}
			return {
				push: () => {
					i.push({
						guide: e,
						targeted: a,
						targetedElement: o
					})
				},
				pop: () => {
					! function () {
						const t = i.pop();
						t && (e = t.guide, a = t.targeted, o = t.targetedElement)
					}()
				},
				tryClick: e => {
					m(e)
				},
				isEngaged: () => t,
				engage: () => {
					t = !0, document.body.classList.add("ribbonglide_engaged")
				},
				disengage: () => {
					t = !1, document.body.classList.remove("ribbonglide_engaged")
				},
				bindGuide: e => {
					d(e)
				},
				rebind: () => {
					d(e)
				},
				action: n => {
					! function (n) {
						if (t && !o && l(a), t && a && e && e.items && void 0 !== e.items[a])
							if (void 0 === e.items[a][n] && "confirm" === n && o) m(o);
							else if (void 0 === e.items[a][n] && "back" === n && e.back) m(document.querySelector(e.back));
						else if (void 0 !== e.items[a][n])
							if ("string" == typeof e.items[a][n]) yt.play("ribbon", .5), W.pulse(...W.WEAK_GLIDE), l(e.items[a][n]);
							else {
								const t = e.items[a][n](o);
								t && (yt.play("ribbon"), W.pulse(...W.WEAK_GLIDE), l(t))
							}
					}(n)
				}
			}
		})(),
		he = {
			home: {
				starter: "f!.scroller_item",
				back: "#exit_electron",
				items: {
					".scroller_item": {
						up: "p!.scroller_item",
						down: "n!.scroller_item"
					}
				}
			},
			play1p: {
				starter: "f!.scroller_item",
				back: "#back",
				items: {
					".scroller_item": {
						up: "p!.scroller_item",
						down: "n!.scroller_item"
					}
				}
			},
			"40l": {
				starter: "#start_40l",
				back: "#back",
				items: {
					"#start_40l": {
						left: "#music_picker_40l",
						right: "#music_picker_40l",
						up: "l!.checkbox",
						down: "f!.checkbox"
					},
					"#music_picker_40l": {
						left: "#start_40l",
						right: "#start_40l",
						up: "l!.checkbox",
						down: "f!.checkbox"
					},
					"f!.checkbox": {
						up: "#start_40l",
						down: "n!.checkbox"
					},
					"l!.checkbox": {
						up: "p!.checkbox",
						down: "#start_40l"
					},
					".checkbox": {
						up: "p!.checkbox",
						down: "n!.checkbox"
					}
				}
			},
			blitz: {
				starter: "#start_blitz",
				back: "#back",
				items: {
					"#start_blitz": {
						up: "l!.checkbox",
						down: "f!.checkbox"
					},
					"f!.checkbox": {
						up: "#start_blitz",
						down: "n!.checkbox"
					},
					"l!.checkbox": {
						up: "p!.checkbox",
						down: "#start_blitz"
					},
					".checkbox": {
						up: "p!.checkbox",
						down: "n!.checkbox"
					}
				}
			},
			zen: {
				starter: "#start_zen",
				back: "#back",
				items: {
					"#start_zen": {}
				}
			},
			custom: {
				starter: "#start_custom",
				back: "#back",
				items: {
					"#custom_export": {
						up: "l!.room_config_row",
						down: "#start_custom"
					},
					"#start_custom": {
						left: "#music_picker_custom",
						right: "#music_picker_custom",
						up: "#custom_export",
						down: "f!.room_tab"
					},
					"#music_picker_custom": {
						left: "#start_custom",
						right: "#start_custom",
						up: "#custom_export",
						down: "f!.room_tab"
					},
					".room_tab": {
						left: "p!.room_tab",
						right: "n!.room_tab",
						up: "#start_custom",
						down: "n!.room_config_row"
					},
					"f!.room_config_row": {
						up: "f!.room_tab",
						down: "n!.room_config_row",
						confirm: e => {
							pe.tryClick(e.querySelector(".room_config_item"))
						}
					},
					"l!.room_config_row": {
						up: "p!.room_config_row",
						down: "#custom_export",
						confirm: e => {
							pe.tryClick(e.querySelector(".room_config_item"))
						}
					},
					".room_config_row": {
						up: "p!.room_config_row",
						down: "n!.room_config_row",
						confirm: e => {
							pe.tryClick(e.querySelector(".room_config_item"))
						}
					}
				}
			},
			about: {
				starter: "#about_line_logo",
				back: "#back",
				items: {
					"#about_line_logo": {
						up: "l!.scroller_item",
						down: "f!.credit_st"
					},
					".credit_st": {
						left: "p!.credit_st",
						right: "n!.credit_st",
						up: "#about_line_logo",
						down: "f!.scroller_item"
					},
					"f!.scroller_item": {
						up: "l!.credit_st",
						down: "n!.scroller_item"
					},
					"l!.scroller_item": {
						up: "p!.scroller_item",
						down: "#about_line_logo"
					},
					".scroller_item": {
						up: "p!.scroller_item",
						down: "n!.scroller_item"
					}
				}
			},
			playmulti: {
				starter: "f!.scroller_item",
				back: "#back",
				items: {
					"#multi_join": {
						up: "l!.scroller_item",
						down: "f!.scroller_item",
						confirm: e => {
							pe.tryClick(e)
						}
					},
					"f!.scroller_item": {
						up: "#multi_join",
						down: "n!.scroller_item"
					},
					"l!.scroller_item": {
						up: "p!.scroller_item",
						down: "#multi_join"
					},
					".scroller_item": {
						up: "p!.scroller_item",
						down: "n!.scroller_item"
					}
				}
			},
			multilisting: {
				starter: "f!.room_listing_item",
				back: "#back",
				items: {
					".room_listing_item": {
						up: "p!.room_listing_item",
						down: "n!.room_listing_item"
					}
				}
			},
			lobby: {
				starter: "#roomid_container",
				back: "#leaveroom",
				items: {
					"#roomid_container": {
						up: "#room_opts_save",
						down: "f!.room_tab"
					},
					".room_tab": {
						left: "p!.room_tab",
						right: "n!.room_tab",
						up: "#roomid_container",
						down: "f!.room_config_row"
					},
					"f!.room_config_row": {
						up: "f!.room_tab",
						down: "n!.room_config_row",
						confirm: e => {
							document.getElementById("roomview").classList.contains("hosting") && pe.tryClick(e.querySelector(".room_config_item"))
						}
					},
					"l!.room_config_row": {
						up: "p!.room_config_row",
						down: "#room_opts_save",
						confirm: e => {
							document.getElementById("roomview").classList.contains("hosting") && pe.tryClick(e.querySelector(".room_config_item"))
						}
					},
					".room_config_row": {
						up: "p!.room_config_row",
						down: "n!.room_config_row",
						confirm: e => {
							document.getElementById("roomview").classList.contains("hosting") && pe.tryClick(e.querySelector(".room_config_item"))
						}
					},
					"#room_opts_save": {
						up: "l!.room_config_row",
						down: "#roomid_container",
						confirm: e => {
							document.getElementById("roomview").classList.contains("hosting") && pe.tryClick(e)
						}
					}
				}
			},
			victory: {
				starter: "f!.playerresult",
				back: "#backtoroom",
				items: {
					".playerresult": {
						up: "p!.playerresult",
						down: "n!.playerresult"
					}
				}
			},
			league: {
				starter: "s!#enter_matchmaking",
				back: "#back",
				items: {
					"#enter_matchmaking": {
						up: "#league_tetra",
						down: "#league_tetra"
					},
					"#league_tetra": {
						up: "#enter_matchmaking",
						down: "#enter_matchmaking"
					}
				}
			},
			endleague: {
				starter: "f!.leagueplayer",
				back: "#backtoleague",
				items: {
					".leagueplayer": {
						up: "p!.leagueplayer",
						down: "n!.leagueplayer",
						left: "p!.leagueplayer",
						right: "n!.leagueplayer"
					}
				}
			},
			tetra: {
				starter: "#tetra_leaderboards",
				back: "#back",
				items: {
					"#tetra_find": {
						up: "l!#tetra_news_content a",
						down: "#tetra_leaderboards"
					},
					"#tetra_leaderboards": {
						up: "#tetra_find",
						down: "#tetra_me",
						left: "#tetra_me",
						right: "#tetra_players"
					},
					"#tetra_me": {
						up: "#tetra_leaderboards",
						down: "f!#tetra_news_content a",
						left: "#tetra_players",
						right: "#tetra_players"
					},
					"#tetra_players": {
						up: "#tetra_leaderboards",
						down: "f!#tetra_news_content a",
						left: "#tetra_me",
						right: "#tetra_me"
					},
					"f!#tetra_news_content a": {
						up: "#tetra_me",
						left: "#tetra_players",
						down: "n!#tetra_news_content a",
						right: "n!#tetra_news_content a"
					},
					"l!#tetra_news_content a": {
						up: "p!#tetra_news_content a",
						left: "p!#tetra_news_content a",
						down: "#tetra_find",
						right: "#tetra_find"
					},
					"#tetra_news_content a": {
						up: "p!#tetra_news_content a",
						left: "p!#tetra_news_content a",
						down: "n!#tetra_news_content a",
						right: "n!#tetra_news_content a"
					}
				}
			},
			tetra_records: {
				starter: "f!.control_button",
				back: "#back",
				items: {
					".control_button": {
						up: "l!.record_item",
						down: "f!.record_item",
						left: "p!.control_button",
						right: "n!.control_button"
					},
					"f!.record_item": {
						up: "f!.control_button",
						down: "n!.record_item"
					},
					"l!.record_item": {
						up: "p!.record_item",
						down: "f!.control_button"
					},
					".record_item": {
						up: "p!.record_item",
						down: "n!.record_item"
					}
				}
			},
			tetra_me: {
				starter: "f!.control_button",
				back: "#back",
				items: {
					".control_button": {
						up: "l!.record_item",
						down: "f!.record_item",
						left: "p!.control_button",
						right: "n!.control_button"
					},
					"f!.record_item": {
						up: "f!.control_button",
						down: "n!.record_item"
					},
					"l!.record_item": {
						up: "p!.record_item",
						down: "f!.control_button"
					},
					".record_item": {
						up: "p!.record_item",
						down: "n!.record_item"
					}
				}
			},
			tetra_players: {
				starter: "f!.control_button",
				back: "#back",
				items: {
					".control_button": {
						up: "l!.record_item",
						down: "f!.record_item",
						left: "p!.control_button",
						right: "n!.control_button"
					},
					"f!.record_item": {
						up: "f!.control_button",
						down: "n!.record_item"
					},
					"l!.record_item": {
						up: "p!.record_item",
						down: "f!.control_button"
					},
					".record_item": {
						up: "p!.record_item",
						down: "n!.record_item"
					}
				}
			},
			results: {
				starter: "f!.rg_target_pri",
				back: "#back",
				items: {
					".rg_target_pri": {
						up: "p!.rg_target_pri",
						left: "p!.rg_target_pri",
						down: "n!.rg_target_pri",
						right: "n!.rg_target_pri"
					}
				}
			},
			config: {
				starter: "f!.rg_target_pri",
				back: "#back",
				items: {
					".rg_target_pri": {
						up: "p!.rg_target_pri",
						down: "n!.rg_target_pri",
						left: e => {
							if ("range" !== e.getAttribute("type")) return "p!.rg_target_pri"; {
								let t = parseFloat(e.getAttribute("step")) || 1;
								e.classList.contains("range_reversed") || (t *= -1), e.value = Math.min(parseFloat(e.getAttribute("max")), Math.max(parseFloat(e.getAttribute("min")), parseFloat(e.value) + t)), e.dispatchEvent(new Event("input", {
									bubbles: !0,
									cancelable: !0
								}))
							}
						},
						right: e => {
							if ("range" !== e.getAttribute("type")) return "n!.rg_target_pri"; {
								let t = parseFloat(e.getAttribute("step")) || 1;
								e.classList.contains("range_reversed") && (t *= -1), e.value = Math.min(parseFloat(e.getAttribute("max")), Math.max(parseFloat(e.getAttribute("min")), parseFloat(e.value) + t)), e.dispatchEvent(new Event("input", {
									bubbles: !0,
									cancelable: !0
								}))
							}
						}
					}
				}
			},
			config_account: {
				starter: "f!.rg_target_pri",
				back: "#back",
				items: {
					".rg_target_pri": {
						up: "p!.rg_target_pri",
						down: "n!.rg_target_pri",
						left: "p!.rg_target_pri",
						right: "n!.rg_target_pri"
					}
				}
			},
			config_electron: {
				starter: "f!.rg_target_pri",
				back: "#back",
				items: {
					".rg_target_pri": {
						up: "p!.rg_target_pri",
						down: "n!.rg_target_pri",
						left: "p!.rg_target_pri",
						right: "n!.rg_target_pri"
					}
				}
			},
			list_request: {
				starter: "f!#list_request .scroller_item",
				back: "#list_request_back",
				items: {
					"#list_request .scroller_item": {
						up: "p!#list_request .scroller_item",
						down: "n!#list_request .scroller_item"
					}
				}
			},
			tetra_dialog: {
				starter: ".tetra_modal_close",
				back: ".tetra_modal_close",
				items: {
					".tetra_modal_close": {
						up: "l!.tetra_button",
						down: "f!.tetra_button"
					},
					".tetra_button": {
						up: ".tetra_modal_close",
						down: ".tetra_modal_close",
						left: "p!.tetra_button",
						right: "n!.tetra_button"
					}
				}
			},
			dialog: {
				starter: "f!.oob_button",
				items: {
					".oob_button": {
						left: "p!.oob_button",
						right: "n!.oob_button"
					}
				}
			}
		};
	let ye, fe = 0,
		_e = "z",
		Ee = -1,
		ve = {};
	const be = {
		none: {
			back: null,
			header: "HOME",
			footer: "pick a game mode"
		},
		home: {
			back: null,
			header: "HOME",
			footer: 'welcome to <span class="cheeky">TETRIO</span>!',
			onenter: () => {
				Ve(), ft.playSmooth(document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") ? "touhoudaiensei" : "kuchu-toshi"), document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || R({
					state: "In Menus",
					largeImageKey: "logo",
					instance: !1
				})
			}
		},
		about: {
			back: "home",
			header: "ABOUT",
			footer: 'thank you for playing <span class="cheeky">TETRIO</span>!',
			onenter: () => {
				_t.loadSpecialThanks()
			}
		},
		play1p: {
			back: "home",
			header: "SOLO",
			footer: "pick a game mode",
			onenter: () => {
				document.getElementById("zen_count").innerHTML = et.getZen().level
			}
		},
		playmulti: {
			back: "home",
			header: "MULTIPLAYER",
			footer: "pick a game mode",
			onback: () => {
				!Dt.isConnected() || document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || (Dt.expectDisconnect(), Dt.disconnect())
			},
			onenter: () => {
				ft.playSmooth(document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") ? "touhoudaiensei" : "kuchu-toshi"), r.get("/api/rooms/menu", {}, !0).then(e => {
					document.getElementById("quickplay_players").innerHTML = `${e.quickplay.playing}${e.quickplay.total-e.quickplay.playing?`<span class="room_listing_spectators">+${e.quickplay.total-e.quickplay.playing}</span>`:""}`, document.getElementById("quickplay_players").classList.toggle("empty", !e.quickplay.playing), document.getElementById("room_count").innerHTML = `${e.roomcount}`, document.getElementById("room_count").classList.toggle("empty", !e.roomcount), document.getElementById("room_count").classList.toggle("singular", 1 === e.roomcount)
				}, e => {
					document.getElementById("quickplay_players").innerHTML = "0", document.getElementById("quickplay_players").classList.add("empty")
				}), document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || R({
					state: "In Menus",
					largeImageKey: "logo",
					instance: !1
				})
			}
		},
		multilisting: {
			back: "playmulti",
			header: "MULTIPLAYER / ROOM LISTING",
			footer: "pick a room to join!",
			onenter: () => {
				jt.loadListing(), document.getElementById("roomlisting_scroller").scrollTop = 0
			}
		},
		lobby: {
			back: null,
			header: "",
			footer: "",
			onenter: () => {
				ft.playSmooth("smoke"), document.getElementById("room_chat").scrollTop = document.getElementById("room_chat").scrollHeight + 100
			}
		},
		victory: {
			back: null,
			header: "RESULTS",
			footer: "the results are in!",
			onenter: () => {
				ft.playSmooth("aijin-sanka"), document.getElementById("victoryview").scrollTop = -200, document.getElementById("vvsc").scrollTop = -200
			}
		},
		league: {
			back: "playmulti",
			header: "TETRA LEAGUE",
			footer: "face off against others and rise up through the ranks!",
			onenter: () => {
				ft.playSmooth("touhoudaiensei"), document.getElementById("leagueview").scrollTop = 0, ke()
			}
		},
		endleague: {
			back: null,
			header: "TETRA LEAGUE / RESULTS",
			footer: "the results are in!",
			onenter: () => {
				document.getElementById("league_chat").scrollTop = document.getElementById("league_chat").scrollHeight + 100
			}
		},
		tetra: {
			back: "home",
			header: "TETRA CHANNEL",
			footer: "welcome to TETRA CHANNEL!",
			onenter: () => {
				ft.playSmooth(document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") ? "touhoudaiensei" : "shikiichi-made-mousukoshi"), _t.loadNews(), _t.loadTwitch()
			}
		},
		tetra_records: {
			back: "tetra",
			header: "TETRA CHANNEL / LEADERBOARDS",
			footer: "top the global leaderboards!",
			onenter: () => {
				_t.loadRecords("40l_global", "tetra_records")
			}
		},
		tetra_me: {
			back: "tetra",
			header: "TETRA CHANNEL / ME",
			footer: "view your achievements!",
			onenter: () => {
				_t.loadRecords("any_userrecent_CURRENTID", "tetra_me")
			}
		},
		tetra_players: {
			back: "tetra",
			header: "TETRA CHANNEL / PLAYERS",
			footer: "view other players and their achievements!",
			onenter: () => {
				_t.loadUserList("tetra_player_league_stream", "/api/users/by/league"), document.getElementById("tetra_players_league").classList.add("pressed"), document.getElementById("tetra_players_xp").classList.remove("pressed"), document.getElementById("tetra_player_league_stream").classList.remove("hidden"), document.getElementById("tetra_player_xp_stream").classList.add("hidden")
			}
		},
		"40l": {
			back: "play1p",
			header: "40 LINES",
			footer: "press START to begin playing"
		},
		blitz: {
			back: "play1p",
			header: "BLITZ",
			footer: "press START to begin playing"
		},
		zen: {
			back: "play1p",
			header: "ZEN",
			footer: "press START to begin playing"
		},
		custom: {
			back: "play1p",
			header: "CUSTOM",
			footer: "press START to begin playing"
		},
		results: {
			back: "home",
			header: "RESULTS",
			footer: "GAME TYPE: the results are in!",
			onenter: () => {
				document.getElementById("results_stats_set_overview").classList.add("pressed"), document.getElementById("results_stats_set_full").classList.remove("pressed"), document.getElementById("results_stats_overview").classList.remove("hidden"), document.getElementById("results_stats_full").classList.add("hidden")
			}
		},
		config: {
			back: "home",
			header: "CONFIG",
			footer: 'tweak your settings for a better <span class="cheeky">TETRIO</span> experience'
		},
		config_account: {
			back: "config",
			header: "CONFIG / ACCOUNT",
			footer: 'change settings in your <span class="cheeky">TETRIO</span> account'
		},
		config_electron: {
			back: "config",
			header: 'CONFIG / <span class="cheeky">TETRIO</span> DESKTOP',
			footer: 'change <span class="cheeky">TETRIO</span> DESKTOP settings'
		}
	};
	let Ie = "none";

	function we(e, t, n, a, o, i, s) {
		E({
			title: e,
			msg: `${t}<br><input data-escape="request_number_cancel" data-enter="request_number_submit" id="request_number" type="number" placeholder="NUMBER" autocomplete="off" value="${i}" step="${o}" min="${n}" max="${a}">`,
			buttons: [{
				label: "CANCEL",
				classes: [],
				id: "request_number_cancel",
				callback: e => {
					e()
				}
			}, {
				label: "SUBMIT",
				classes: ["pri"],
				id: "request_number_submit",
				callback: e => {
					s(document.getElementById("request_number").value), e()
				}
			}]
		}), document.getElementById("request_number").focus()
	}

	function ke() {
		"league" !== Ie || document.getElementById("menus").classList.contains("hidden") || We < 1 || r.get("/api/rooms/league", {}, !0).then(e => {
			document.getElementById("mm_queuecount_count").innerHTML = e.info.queue, document.getElementById("mm_playercount_count").innerHTML = e.info.players
		}, e => {
			document.getElementById("mm_queuecount_count").innerHTML = "0", document.getElementById("mm_playercount_count").innerHTML = "0"
		})
	}

	function Le(e, t) {
		const n = document.createElement("input");
		document.body.appendChild(n), n.value = e, n.select(), document.execCommand("copy"), document.body.removeChild(n), d(`${t||`"${e}"`} copied!`)
	}

	function xe(e, t) {
		const n = document.createElement("div");
		n.className = `shout ${e}`, n.innerHTML = t, document.getElementById("majorshouts").appendChild(n), setTimeout(() => {
			n.remove()
		}, 5e3), "ultra" === G.video.graphics && Hn && fa.majorShoutStyles[e] && fa.majorShoutStyles[e]()
	}

	function Be(e) {
		if (!G.volume.music) return;
		const t = document.getElementById("now_playing"),
			n = document.getElementById("now_playing_jp");
		t.innerHTML = `${ft.ost[e].artist.toUpperCase()} - ${ft.ost[e].name.toUpperCase()}`, n.innerHTML = `${ft.ost[e].jpartist} - ${ft.ost[e].jpname}`, t.classList.remove("hidden"), n.classList.remove("hidden"), setTimeout(() => {
			t.classList.add("hidden"), n.classList.add("hidden")
		}, 5e3)
	}

	function Te(e) {
		document.getElementById("menus").setAttribute("data-menu-type", e)
	}

	function Fe(e, t) {
		(be[Ie].onexit || (() => {}))(), Ie = e, document.getElementById("menus").querySelectorAll("[data-menuview]").forEach(t => {
			t.getAttribute("data-menuview") !== e && (t.classList.contains("hidden") || (t.classList.add("hidden"), setTimeout(() => {
				t.classList.contains("hidden") && t.classList.add("thidden")
			}, 666)))
		}), be[e].back || document.getElementById("back").classList.add("hidden"), document.getElementById("exit_electron").classList.toggle("hidden", "home" !== e);
		const n = () => {
			document.getElementById("menus").setAttribute("data-menu-type", e), document.getElementById("menus").querySelectorAll("[data-menuview]").forEach(t => {
				t.getAttribute("data-menuview") === e && (t.classList.remove("thidden"), t.getBoundingClientRect(), t.classList.remove("hidden"))
			}), be[e].back && document.getElementById("back").classList.remove("hidden"), document.getElementById("header_text").innerHTML = be[e].header, document.getElementById("footer_text").innerHTML = be[e].footer, (be[e].onenter || (() => {}))()
		};
		t ? ze(n) : n(), pe.bindGuide(he[e] || {})
	}
	I.ready((function (e) {
		function t(e) {
			0 !== We && Object.keys(X).forEach(t => {
				if (X[t].includes(ce(e) || e.detail.toUpperCase()) && t.startsWith("menu")) {
					if (("menuConfirm" === t || "menuBack" === t) && e.repeat) return;
					return ["input", "textarea"].includes(document.activeElement.tagName.toLowerCase()) ? void(pe.isEngaged() && "menuConfirm" === t && document.activeElement.blur()) : (pe.action(t.substring(4).toLowerCase()), e.stopPropagation(), e.preventDefault(), void(pe.isEngaged() || (yt.play("ribbon_on"), pe.engage())))
				}
			})
		}
		Se(!0), Fe("home"), document.addEventListener("keydown", t, !1), document.addEventListener("gpdown", t, !1), document.addEventListener("gprepeat", t, !1), document.addEventListener("mousemove", (function (e) {
			0 !== We && pe.isEngaged() && (yt.play("ribbon_off"), pe.disengage())
		}), {
			passive: !0
		}), document.addEventListener("wheel", (function (e) {
			0 !== We && pe.isEngaged() && (yt.play("ribbon_off"), pe.disengage())
		}), {
			passive: !0
		});
		let n, a, o = !0,
			i = 0;

		function s(e) {
			if (e.repeat || e.isComposing) return;
			if ("Enter" !== e.code && "NumpadEnter" !== e.code) return;
			const t = e.target.value;
			t.length && jt.sendChatMessage(t), document.getElementById("chat_input").value = "", document.getElementById("league_chat_input").value = "", document.getElementById("ingame_chat_input").value = "", "ingame_chat_input" === e.target.id && e.target.blur()
		}

		function l() {
			document.querySelectorAll("#room_content_container .unsaved .room_config_item[data-index]").forEach(e => {
				e.closest(".room_config_row").classList.remove("unsaved")
			}), document.getElementById("room_opts_save").classList.remove("unsaved"), document.getElementById("startroom").classList.add("hidden"), jt.startRoom(), setTimeout(() => {
				document.getElementById("startroom").classList.remove("hidden")
			}, 2e3)
		}
		window.addEventListener("beforeunload", (function (e) {
			if (IS_ELECTRON) {
				if (!b) {
					if (o) return o = !1, i = 0, E({
						title: "EXIT TETR.IO?",
						msg: "",
						buttons: [{
							label: "CANCEL",
							classes: [],
							callback: e => {
								i = 0, o = !0, e()
							}
						}, {
							label: "EXIT",
							classes: ["pri"],
							callback: e => {
								o = !0, i = 0, Ue(), He("see you next time!"), F()
							}
						}]
					}), e.preventDefault(), e.returnValue = "Exit TETR.IO?", "Exit TETR.IO?";
					if (!(++i >= 5)) return e.preventDefault(), e.returnValue = "Exit TETR.IO?", "Exit TETR.IO?";
					F(), Ue(), He("see you next time!")
				}
			} else if (!b && document.body.classList.contains("ingame_phys") && document.getElementById("menus").classList.contains("hidden") && 0 === We) return e.preventDefault(), e.returnValue = "You are still ingame. Closing this tab will disconnect you. You will lose the game and may receive a penalty!", "You are still ingame. Closing this tab will disconnect you. You will lose the game and may receive a penalty!"
		})), window.addEventListener("hashchange", (function (e) {
			window.location.href = `/${window.location.hash}`, b = !0, window.location.reload()
		})), window.addEventListener("focus", (function (e) {
			document.body.classList.remove("nofocus"), O(), n && (clearTimeout(n), n = null)
		})), window.addEventListener("blur", (function (e) {
			document.body.classList.add("nofocus"), n && (clearTimeout(n), n = null), n = setTimeout(() => {
				$(), n = null
			}, 3e5)
		})), window.addEventListener("visibilitychange", (function (e) {
			!1 !== G.volume.oof && ("visible" === document.visibilityState ? ft.setVolume(G.volume.music) : ft.setVolume(0))
		})), document.getElementById("ingame_chat_input").addEventListener("focus", (function (e) {
			document.body.classList.add("chatfocus")
		})), document.getElementById("ingame_chat_input").addEventListener("blur", (function (e) {
			document.body.classList.remove("chatfocus")
		})), document.getElementById("back").addEventListener("click", (function (e) {
			be[Ie].back && ((be[Ie].onback || (() => {}))(), Fe(be[Ie].back))
		})), document.getElementById("exit_electron").addEventListener("click", (function (e) {
			IS_ELECTRON && E({
				title: "EXIT TETR.IO?",
				msg: "",
				buttons: [{
					label: "CANCEL",
					classes: [],
					callback: e => {
						e()
					}
				}, {
					label: "EXIT",
					classes: ["pri"],
					callback: e => {
						Ue(), He("see you next time!"), F()
					}
				}]
			})
		})), document.getElementById("play_multi").addEventListener("click", (function (e) {
			Dt.isConnected() ? Fe("playmulti") : (He("connecting to live servers…"), Dt.connect(), Dt.once("authorize", e => {
				Ne(), Fe("playmulti"), e.maintenance && document.body.classList.add("maintenance")
			}), Dt.once("connect_error", e => {
				Ne(), c("could not connect to live servers")
			}))
		})), document.getElementById("mm_status").addEventListener("click", (function (e) {
			if (document.getElementById("mm_status").classList.contains("room")) return et.stopNow(), document.getElementById("mm_status").classList.remove("shown"), document.getElementById("mm_status").classList.remove("room"), document.body.classList.remove("inmultizen"), Se(!0), void Fe("lobby");
			Dt.isConnected() && (et.stopNow(), Ce(), setTimeout(() => {
				Se(!0), Fe("league")
			}, 610))
		})), document.getElementById("league_tetra").addEventListener("click", (function (e) {
			Fe("tetra_players"), be.tetra_players.back = "league"
		})), document.getElementById("config_account").addEventListener("click", (function (e) {
			He("requesting account data…"), r.get("/api/users/me", {}, !0).then(e => {
				document.getElementById("config_account_username").textContent = e.user.username.toUpperCase(), document.getElementById("config_account_username_field").value = e.user.username.toUpperCase(), e.user.email ? (document.getElementById("config_account_email_warning").classList.add("hidden"), document.getElementById("config_account_email").value = e.user.email) : (document.getElementById("config_account_email_warning").classList.remove("hidden"), document.getElementById("config_account_email").value = ""), document.getElementById("config_account_privacy_showwon").classList.toggle("checked", !1 !== e.user.privacy_showwon), document.getElementById("config_account_privacy_showplayed").classList.toggle("checked", !1 !== e.user.privacy_showplayed), document.getElementById("config_account_privacy_showgametime").classList.toggle("checked", !1 !== e.user.privacy_showgametime), Ne(), Fe("config_account")
			}, e => {
				Ne(), u(e)
			})
		})), document.getElementById("config_account_logout").addEventListener("click", (function (e) {
			E({
				title: "LOG OUT?",
				msg: `log out from <span class="inline_self">${document.getElementById("config_account_username").textContent}</span>?`,
				buttons: [{
					label: "CANCEL",
					classes: [],
					callback: e => {
						e()
					}
				}, {
					label: "LOG OUT",
					classes: ["pri"],
					callback: e => {
						Ue(), He("see you next time!"), w.logout(), I.update(!0)
					}
				}]
			})
		})), document.getElementById("config_account_logoutall").addEventListener("click", (function (e) {
			E({
				title: "LOG OUT ALL?",
				msg: `log out all devices logged into <span class="inline_self">${document.getElementById("config_account_username").textContent}</span>, including this one? this will disconnect you everywhere - use it if you forgot to log out somewhere.`,
				buttons: [{
					label: "CANCEL",
					classes: [],
					callback: e => {
						e()
					}
				}, {
					label: "LOG OUT ALL",
					classes: ["sec"],
					callback: e => {
						Ue(), He("logging out all…"), r.post("/api/users/cycle", {}, !0).then(e => {
							He("see you next time!"), w.logout(), I.update(!0)
						}, e => {
							Ne(), u(e)
						})
					}
				}]
			})
		})), document.getElementById("config_account_password_save").addEventListener("click", (function (e) {
			const t = document.getElementById("config_account_password").value,
				n = document.getElementById("config_account_password_again").value;
			t ? t === n ? w.requestPassword(e => {
				He("saving new account data…"), r.post("/api/users/setPassword", {
					old: e,
					new: t
				}, !0).then(e => {
					document.getElementById("config_account_password").value = "", document.getElementById("config_account_password_again").value = "", m("password changed!"), He("see you next time!"), w.logout(), I.update(!0)
				}, e => {
					Ne(), u(e)
				})
			}) : c("those passwords don't match") : c("you must enter a new password")
		})), document.getElementById("config_account_privacy_showwon").addEventListener("click", (function (e) {
			document.getElementById("config_account_privacy_showwon").classList.toggle("checked")
		})), document.getElementById("config_account_privacy_showplayed").addEventListener("click", (function (e) {
			document.getElementById("config_account_privacy_showplayed").classList.toggle("checked")
		})), document.getElementById("config_account_privacy_showgametime").addEventListener("click", (function (e) {
			document.getElementById("config_account_privacy_showgametime").classList.toggle("checked")
		})), document.getElementById("config_account_email_save").addEventListener("click", (function (e) {
			const t = document.getElementById("config_account_email").value;
			t ? w.requestPassword(e => {
				He("saving new account data…"), r.post("/api/users/setEmail", {
					password: e,
					email: t
				}, !0).then(e => {
					m("email changed!"), document.getElementById("config_account_email_warning").classList.add("hidden"), Ne()
				}, e => {
					Ne(), u(e)
				})
			}) : c("you must enter a new email")
		})), document.getElementById("config_account_privacy_save").addEventListener("click", (function (e) {
			r.post("/api/users/setPreferences", {
				privacy_showwon: document.getElementById("config_account_privacy_showwon").classList.contains("checked"),
				privacy_showplayed: document.getElementById("config_account_privacy_showplayed").classList.contains("checked"),
				privacy_showgametime: document.getElementById("config_account_privacy_showgametime").classList.contains("checked")
			}, !0).then(e => {
				m("privacy preferences changed!"), Ne()
			}, e => {
				Ne(), u(e)
			})
		})), document.getElementById("config_electron").addEventListener("click", (function (e) {
			IS_ELECTRON && (document.getElementById("electron_ver").innerHTML = CLIENT_VERSION, Fe("config_electron"))
		})), document.getElementById("config_export").addEventListener("click", (function (e) {
			const t = new Blob([JSON.stringify(G)], {
					type: "application/json"
				}),
				n = document.createElement("a");
			n.download = "config.ttc", n.href = (window.webkitURL || window.URL).createObjectURL(t), n.dataset.downloadurl = ["application/json", n.download, n.href].join(":"), document.body.appendChild(n), n.click(), document.body.removeChild(n)
		})), document.getElementById("multi_listing").addEventListener("click", (function (e) {
			Fe("multilisting")
		})), document.getElementById("multi_join").addEventListener("keydown", (function (e) {
			if (e.repeat) return;
			if ("Enter" !== e.code && "NumpadEnter" !== e.code) return;
			yt.play("menuclick");
			const t = document.getElementById("multi_join").value.replace("#", "").replace("https://tetr.io/", "");
			t.length && jt.joinRoom(t), document.getElementById("multi_join").value = ""
		})), document.getElementById("multi_quickplay").addEventListener("click", (function (e) {
			jt.joinRoom("X-QP")
		})), document.getElementById("multi_league").addEventListener("click", (function (e) {
			He("fetching TETRA LEAGUE data…"), r.get("/api/users/me", {}, !0).then(e => {
				-1 === e.user.league.rating ? (document.getElementById("league_rating").innerHTML = `${e.user.league.gamesplayed}<span>/10 rating games played</span>`, document.getElementById("league_rating").title = "", document.getElementById("leaguestanding_rating").innerHTML = `${e.user.league.gamesplayed}<span>/10 rating games played</span>`, document.getElementById("league_ticker").innerHTML = "play rating games to receive a rating", document.getElementById("league_rank").classList.add("hidden"), document.getElementById("league_warning").classList.add("hidden"), document.getElementById("me_leaguerank").classList.add("hidden")) : (fe = Math.round(e.user.league.rating), _e = e.user.league.rank, document.getElementById("league_rating").innerHTML = `${Math.round(e.user.league.rating)}<span>TR</span>`, document.getElementById("league_rating").title = e.user.league.rating, document.getElementById("leaguestanding_rating").innerHTML = `${Math.round(e.user.league.rating)}<span>TR</span>`, document.getElementById("league_ticker").innerHTML = `glicko: <span title="Your raw rating in the Glicko-2 system. Higher is better.">${e.user.league.glicko}</span>±<span title="How uncertain the Glicko-2 system is of your rating. Lower is better.">${e.user.league.rd}</span> - games won: <span>${e.user.league.gameswon}</span> / ${e.user.league.gamesplayed} (<span>${Math.floor(e.user.league.gameswon/e.user.league.gamesplayed*1e4)/100}</span>%)`, document.getElementById("league_rank").src = `/res/league-ranks/${e.user.league.rank}.png`, document.getElementById("leaguestanding_rank").src = `/res/league-ranks/${e.user.league.rank}.png`, document.getElementById("league_rank").classList.remove("hidden"), document.getElementById("league_warning").classList.toggle("hidden", "z" !== e.user.league.rank), document.getElementById("me_leaguerank").classList.toggle("hidden", "z" === e.user.league.rank), document.getElementById("me_leaguerank").src = `/res/league-ranks/${e.user.league.rank}.png`), -1 === e.user.league.standing ? document.getElementById("league_placement").classList.add("hidden") : (Ee = e.user.league.standing, document.getElementById("league_placement").classList.remove("hidden"), document.getElementById("league_placement").innerHTML = `#<span>${e.user.league.standing}</span>`, document.getElementById("league_placement").classList.toggle("t100", e.user.league.standing <= 100 && e.user.league.standing > 1), document.getElementById("league_placement").classList.toggle("t1", 1 === e.user.league.standing)), Fe("league"), Ne(), 0 === e.user.league.gamesplayed && E({
					title: "WELCOME TO TETRA LEAGUE",
					msg: "TETRA LEAGUE is a competitive 1v1 mode. win duels against players of similar skill to rank up and conquer the leaderboards!</p><p>if you're new to stackers or are feeling rusty, it's a good idea to practice in other modes first.</p><p class=\"modal_warning\">make sure you have the time and connection to play! if you leave or disconnect early, you will be penalized.",
					buttons: [{
						label: "GOT IT!",
						classes: [],
						callback: e => {
							e()
						}
					}]
				})
			}, e => {
				Ne(), u(e)
			})
		})), document.getElementById("enter_matchmaking").addEventListener("click", (function (e) {
			if (document.body.classList.contains("matchmaking")) jt.leaveMatchmaking();
			else {
				jt.enterMatchmaking();
				const e = document.getElementById("enter_matchmaking").getBoundingClientRect();
				pn(e.left + .25 * e.width, e.top + e.height / 2, "#FF0000", 1, 1.5, .5, e.width / 2, e.height, .05, 175, 185, 0, 800, 150, 1, 0, .1, !0), yn(e.left + .25 * e.width, e.top + e.height / 2, "#FF0000", 1, 1.5, .5, e.width / 2, e.height, .05, 175, 185, 0, 800, 150, 1, 0, .1, !0), hn(e.left + .25 * e.width, e.top + e.height / 2, "#FF0000", 1.5, .18, .14, e.width / 2, e.height, .8, 175, 185, 0, 800, 400, 1, 0, .9, !0), pn(e.left + .75 * e.width, e.top + e.height / 2, "#FF0000", 1, 1.5, .5, e.width / 2, e.height, .05, -5, 5, 0, 800, 150, 1, 0, .1, !0), yn(e.left + .75 * e.width, e.top + e.height / 2, "#FF0000", 1, 1.5, .5, e.width / 2, e.height, .05, -5, 5, 0, 800, 150, 1, 0, .1, !0), hn(e.left + .75 * e.width, e.top + e.height / 2, "#FF0000", 1.5, .18, .14, e.width / 2, e.height, .8, -5, 5, 0, 800, 400, 1, 0, .9, !0)
			}
		})), document.getElementById("multi_createroom").addEventListener("click", (function (e) {
			Ae([{
				id: "public",
				name: "PUBLIC ROOM",
				description: "create a public room anyone can join"
			}, {
				id: "private",
				name: "PRIVATE ROOM",
				description: "create a private room for you and friends"
			}], e => {
				jt.createRoom(e)
			}, !0)
		})), document.getElementById("leaveroom").addEventListener("click", (function (e) {
			jt.leaveRoom()
		})), document.getElementById("backtoroom").addEventListener("click", (function (e) {
			Fe("lobby"), jt.returnToRoom()
		})), document.getElementById("backtoleague").addEventListener("click", (function (e) {
			jt.leaveRoom(!0), Fe("league"), setTimeout(() => {
				document.getElementById("leaguestanding_rating").classList.remove("pingraise"), document.getElementById("leaguestanding_rating").classList.remove("pinglower"), document.getElementById("leaguestanding_rating").classList.remove("pingfinal"), document.getElementById("leaguestanding_rating").classList.remove("pingrating")
			}, 5e3), R({
				state: "In Menus",
				largeImageKey: "logo",
				instance: !1
			})
		})), document.getElementById("chat_input").addEventListener("keydown", s), document.getElementById("league_chat_input").addEventListener("keydown", s), document.getElementById("ingame_chat_input").addEventListener("keydown", s), document.getElementById("ingame_chat_input").addEventListener("keyup", e => {
			e.repeat || ("Escape" === e.code && (e.target.value = "", e.target.blur()), document.getElementById("chat_input").value = e.target.value, document.getElementById("league_chat_input").value = e.target.value)
		}), document.getElementById("chat_input").addEventListener("keyup", e => {
			document.getElementById("ingame_chat_input").value = e.target.value
		}), document.getElementById("roomid_container").addEventListener("click", (function (e) {
			Le(`https://tetr.io/${document.getElementById("roomid").innerHTML}`, "link")
		})), document.getElementById("startroom").addEventListener("click", (function (e) {
			document.querySelectorAll("#room_content_container .unsaved .room_config_item[data-index]").length ? E({
				title: "START GAME?",
				msg: "some settings have not yet been saved, if you start the game now, those changes will be lost!",
				buttons: [{
					label: "CANCEL",
					classes: [],
					callback: e => {
						e()
					}
				}, {
					label: "DISCARD and START GAME",
					classes: ["sec"],
					callback: e => {
						l(), e()
					}
				}]
			}) : l()
		})), setInterval(() => {
			ke()
		}, 3e3), document.getElementById("room_switchbracket").addEventListener("click", (function (e) {
			jt.switchBracket(document.getElementById("roomview").classList.contains("spectating") ? "player" : "spectator")
		})), document.getElementById("play_solo").addEventListener("click", (function (e) {
			Fe("play1p")
		})), document.getElementById("sig_about").addEventListener("click", (function (e) {
			Fe("about")
		})), document.getElementById("about_blog").addEventListener("click", (function (e) {
			window.open("https://blog.osk.sh/", "_blank")
		})), document.getElementById("about_issues").addEventListener("click", (function (e) {
			window.open("https://github.com/tetrio/issues", "_blank")
		})), document.getElementById("about_discord").addEventListener("click", (function (e) {
			window.open("https://discord.gg/ufDb2XJ", "_blank")
		})), document.getElementById("about_harddrop").addEventListener("click", (function (e) {
			window.open("https://discord.gg/harddrop", "_blank")
		})), document.getElementById("about_legal").addEventListener("click", (function (e) {
			window.open("/about/", "_blank")
		})), document.getElementById("about_patchnotes").addEventListener("click", (function (e) {
			window.open("/about/patchnotes/", "_blank")
		})), document.getElementById("about_music").addEventListener("click", (function (e) {
			$e(e => {
				ft.playSmoothOrRandom(e)
			})
		})), document.getElementById("about_patreon").addEventListener("click", (function (e) {
			window.open("https://www.patreon.com/tetrio", "_blank")
		})), document.getElementById("about_desktop").addEventListener("click", (function (e) {
			window.open("/about/desktop/", "_blank")
		})), document.getElementById("footer_github").addEventListener("click", (function (e) {
			window.open("https://github.com/tetrio/issues", "_blank")
		})), document.getElementById("footer_discord").addEventListener("click", (function (e) {
			window.open("https://discord.gg/ufDb2XJ", "_blank")
		})), document.getElementById("footer_patreon").addEventListener("click", (function (e) {
			window.open("https://www.patreon.com/tetrio", "_blank")
		})), document.getElementById("footer_twitter").addEventListener("click", (function (e) {
			window.open("https://twitter.com/tetriogame", "_blank")
		})), document.getElementById("footer_desktop").addEventListener("click", (function (e) {
			window.open("/about/desktop/", "_blank")
		})), document.getElementById("sig_channel").addEventListener("click", (function (e) {
			Fe("tetra")
		})), document.getElementById("tetra_leaderboards").addEventListener("click", (function (e) {
			Fe("tetra_records")
		})), document.getElementById("tetra_me").addEventListener("click", (function (e) {
			Fe("tetra_me")
		})), document.getElementById("tetra_players").addEventListener("click", (function (e) {
			Fe("tetra_players"), be.tetra_players.back = "tetra"
		})), document.getElementById("tetra_find").addEventListener("keydown", (function (e) {
			e.repeat || "Enter" !== e.code && "NumpadEnter" !== e.code || (yt.play("menuclick"), e.target.blur(), _t.navigateToShortID(document.getElementById("tetra_find").value.replace("https://tetr.io/#", "")), e.preventDefault(), e.stopPropagation())
		})), document.getElementById("game_40l").addEventListener("click", (function (e) {
			Fe("40l")
		})), document.getElementById("game_blitz").addEventListener("click", (function (e) {
			Fe("blitz")
		})), document.getElementById("game_zen").addEventListener("click", (function (e) {
			Fe("zen")
		})), document.getElementById("game_custom").addEventListener("click", (function (e) {
			Fe("custom")
		})), document.getElementById("start_40l").addEventListener("click", () => {
			et.play40L({
				song: document.getElementById("music_picker_40l").getAttribute("data-song")
			}), ie(!0), document.getElementById("music_picker_results").setAttribute("data-song", document.getElementById("music_picker_40l").getAttribute("data-song")), document.getElementById("music_picker_results").innerHTML = document.getElementById("music_picker_40l").innerHTML
		}), document.getElementById("start_blitz").addEventListener("click", () => {
			et.playBlitz({
				song: "hyper-velocity"
			}), ie(!0)
		}), document.getElementById("start_zen").addEventListener("click", () => {
			et.playZen({}), ie(!0)
		}), document.getElementById("zen_destroy").addEventListener("click", () => {
			E({
				title: "DESTROY ZEN PROGRESS?",
				msg: 'you\'ll be reset to LEVEL 1 and 0 SCORE, with an empty board to start anew.</p><p class="modal_also">this cannot be undone.',
				classes: ["crash_modal"],
				buttons: [{
					label: "CANCEL",
					classes: [],
					callback: e => {
						e()
					}
				}, {
					label: "RESET ZEN",
					classes: ["pri"],
					callback: e => {
						e(), E({
							title: "REALLY DESTROY ZEN PROGRESS?",
							msg: "ARE YOU SURE YOU WON'T REGRET DESTROYING YOUR ZEN PROGRESS???",
							classes: ["crash_modal", "shudder"],
							buttons: [{
								label: "CANCEL",
								classes: [],
								callback: e => {
									e()
								}
							}, {
								label: "I'M CERTAIN",
								classes: ["pri"],
								callback: e => {
									et.resetZen(), et.saveZen(et.getZen()), m("it's gone!"), e()
								}
							}]
						})
					}
				}]
			})
		}), document.getElementById("room_ingame_warning").addEventListener("click", () => {
			et.playZen({
				inroom: !0,
				roomname: document.getElementById("room_content_name").innerText
			}), ie(!0)
		}), document.getElementById("start_custom").addEventListener("click", () => {
			et.playCustom({
				song: document.getElementById("music_picker_custom").getAttribute("data-song")
			}), ie(!0), document.getElementById("music_picker_results").setAttribute("data-song", document.getElementById("music_picker_custom").getAttribute("data-song")), document.getElementById("music_picker_results").innerHTML = document.getElementById("music_picker_custom").innerHTML
		}), document.getElementById("start_results").addEventListener("click", () => {
			et.playAgain({
				song: document.getElementById("music_picker_results").getAttribute("data-song")
			}), ie(!0)
		}), document.getElementById("sig_config").addEventListener("click", (function (e) {
			Fe("config")
		})), document.addEventListener("click", (function (e) {
			e.target.closest("[data-hit]") && yt.play(`menu${e.target.closest("[data-hit]").getAttribute("data-hit")}`)
		})), document.addEventListener("mouseover", (function (e) {
			e.target.closest("[data-hover]") && e.target.closest("[data-hover]").getAttribute("data-hover") && (!a || !a.closest("[data-hover]") || a && a.closest("[data-hover]").outerHTML !== e.target.closest("[data-hover]").outerHTML) && yt.play(`menu${e.target.closest("[data-hover]").getAttribute("data-hover")}`), a = e.target.closest("[data-hover]")
		})), document.addEventListener("click", (function (e) {
			e.target.classList.contains("collapse_target") && e.target.closest(".collapsible") && e.target.closest(".collapsible").classList.toggle("collapsed")
		})), document.addEventListener("click", (function (e) {
			e.target.classList.contains("music_picker") && $e(t => {
				if (e.target.setAttribute("data-song", t), ft.ost[t]) e.target.innerHTML = `${ft.ost[t].artist.toLowerCase()} - ${ft.ost[t].name.toLowerCase()}`;
				else switch (t) {
					case "RANDOM":
						e.target.innerHTML = "RANDOM";
						break;
					case "RANDOMcalm":
						e.target.innerHTML = "RANDOM: CALM";
						break;
					case "RANDOMbattle":
						e.target.innerHTML = "RANDOM: BATTLE";
						break;
					default:
						e.target.innerHTML = t
				}
				e.target.dispatchEvent(new Event("input"))
			})
		})), document.addEventListener("click", (function (e) {
			e.target.classList.contains("replayid") && Le(`https://tetr.io/#${e.target.innerHTML}`, "replay link")
		})), document.getElementById("me").addEventListener("click", (function (e) {
			Et({
				userID: w.id()
			})
		})), document.addEventListener("click", (function (e) {
			let t;
			if (e.target.closest(".tetra_pop")) Et({
				username: (t = e.target.closest(".tetra_pop")).getAttribute("data-username")
			}), e.stopPropagation(), e.preventDefault();
			else if (e.target.closest(".dialog_pop")) E({
				title: (t = e.target.closest(".dialog_pop")).getAttribute("data-title"),
				msg: atob(t.getAttribute("data-content")),
				classes: ["patchnotes", "wide_modal"],
				buttons: [{
					label: "OK",
					classes: [],
					callback: e => {
						e()
					}
				}]
			}), e.stopPropagation(), e.preventDefault();
			else if (e.target.closest(".replay_pop")) t = e.target.closest(".replay_pop"), _t.navigateToShortID(t.getAttribute("data-replay")), e.stopPropagation(), e.preventDefault();
			else if (e.target.closest(".scroller_player") || e.target.closest(".playerresult") || e.target.closest(".chat_tag")) {
				const n = (t = e.target.closest(".scroller_player") || e.target.closest(".playerresult") || e.target.closest(".chat_tag")).getAttribute("data-id"),
					a = [];
				n != w.id() && (jt.isUserIgnored(n) ? a.push({
					label: "unignore",
					classes: [],
					callback: e => {
						jt.unignoreUser(n), m("user unignored!"), e()
					}
				}) : a.push({
					label: "ignore",
					classes: [],
					callback: e => {
						jt.ignoreUser(n), m("user ignored!"), e()
					}
				}), document.getElementById("roomview").classList.contains("hosting") && (a.push({
					label: "kick from room",
					classes: [],
					callback: e => {
						jt.kickUser(n), e()
					}
				}), document.getElementById("room_players").querySelector(`.scroller_player[data-id="${n}"]`) && (document.getElementById("room_players").querySelector(`.scroller_player[data-id="${n}"]`).classList.contains("spectator") ? a.push({
					label: "move to players",
					classes: [],
					callback: e => {
						jt.switchBracketHost(n, "player"), e()
					}
				}) : a.push({
					label: "move to spectators",
					classes: [],
					callback: e => {
						jt.switchBracketHost(n, "spectator"), e()
					}
				})), a.push({
					label: "transfer ownership",
					classes: [],
					callback: e => {
						jt.transferOwnership(n), e()
					}
				}))), Et({
					userID: n,
					buttons: a
				}), e.stopPropagation(), e.preventDefault()
			}
		})), document.getElementById("results_stats_set_overview").addEventListener("click", (function (e) {
			document.getElementById("results_stats_set_overview").classList.add("pressed"), document.getElementById("results_stats_set_full").classList.remove("pressed"), document.getElementById("results_stats_overview").classList.remove("hidden"), document.getElementById("results_stats_full").classList.add("hidden")
		})), document.getElementById("results_stats_set_full").addEventListener("click", (function (e) {
			document.getElementById("results_stats_set_full").classList.add("pressed"), document.getElementById("results_stats_set_overview").classList.remove("pressed"), document.getElementById("results_stats_full").classList.remove("hidden"), document.getElementById("results_stats_overview").classList.add("hidden")
		})), document.getElementById("tetra_records_40l").addEventListener("click", (function (e) {
			_t.loadRecords("40l_global", "tetra_records"), document.getElementById("tetra_records_40l").classList.add("pressed"), document.getElementById("tetra_records_blitz").classList.remove("pressed"), document.getElementById("tetra_stream__40l_global").classList.remove("hidden"), document.getElementById("tetra_stream__blitz_global").classList.add("hidden")
		})), document.getElementById("tetra_records_blitz").addEventListener("click", (function (e) {
			_t.loadRecords("blitz_global", "tetra_records"), document.getElementById("tetra_records_blitz").classList.add("pressed"), document.getElementById("tetra_records_40l").classList.remove("pressed"), document.getElementById("tetra_stream__blitz_global").classList.remove("hidden"), document.getElementById("tetra_stream__40l_global").classList.add("hidden")
		})), document.getElementById("tetra_me_recent").addEventListener("click", (function (e) {
			_t.loadRecords("any_userrecent_CURRENTID", "tetra_me"), document.getElementById("tetra_me_recent").classList.add("pressed"), document.getElementById("tetra_me_40l").classList.remove("pressed"), document.getElementById("tetra_me_blitz").classList.remove("pressed"), document.getElementById("tetra_stream__any_userrecent_CURRENTID").classList.remove("hidden"), document.getElementById("tetra_stream__40l_userbest_CURRENTID").classList.add("hidden"), document.getElementById("tetra_stream__blitz_userbest_CURRENTID").classList.add("hidden")
		})), document.getElementById("tetra_me_40l").addEventListener("click", (function (e) {
			_t.loadRecords("40l_userbest_CURRENTID", "tetra_me"), document.getElementById("tetra_me_40l").classList.add("pressed"), document.getElementById("tetra_me_recent").classList.remove("pressed"), document.getElementById("tetra_me_blitz").classList.remove("pressed"), document.getElementById("tetra_stream__40l_userbest_CURRENTID").classList.remove("hidden"), document.getElementById("tetra_stream__any_userrecent_CURRENTID").classList.add("hidden"), document.getElementById("tetra_stream__blitz_userbest_CURRENTID").classList.add("hidden")
		})), document.getElementById("tetra_me_blitz").addEventListener("click", (function (e) {
			_t.loadRecords("blitz_userbest_CURRENTID", "tetra_me"), document.getElementById("tetra_me_blitz").classList.add("pressed"), document.getElementById("tetra_me_recent").classList.remove("pressed"), document.getElementById("tetra_me_40l").classList.remove("pressed"), document.getElementById("tetra_stream__blitz_userbest_CURRENTID").classList.remove("hidden"), document.getElementById("tetra_stream__any_userrecent_CURRENTID").classList.add("hidden"), document.getElementById("tetra_stream__40l_userbest_CURRENTID").classList.add("hidden")
		})), document.getElementById("tetra_players_league").addEventListener("click", (function (e) {
			_t.loadUserList("tetra_player_league_stream", "/api/users/by/league"), document.getElementById("tetra_players_league").classList.add("pressed"), document.getElementById("tetra_players_xp").classList.remove("pressed"), document.getElementById("tetra_player_league_stream").classList.remove("hidden"), document.getElementById("tetra_player_xp_stream").classList.add("hidden")
		})), document.getElementById("tetra_players_xp").addEventListener("click", (function (e) {
			_t.loadUserList("tetra_player_xp_stream", "/api/users/by/xp"), document.getElementById("tetra_players_xp").classList.add("pressed"), document.getElementById("tetra_players_league").classList.remove("pressed"), document.getElementById("tetra_player_xp_stream").classList.remove("hidden"), document.getElementById("tetra_player_league_stream").classList.add("hidden")
		})), document.getElementById("menus").addEventListener("dragover", e => {
			e.stopPropagation(), e.preventDefault(), e.dataTransfer.dropEffect = "copy"
		}, !1);
		let d, g = "";

		function p(e) {
			document.body.classList.contains("chatfocus") || Object.keys(X).forEach(t => {
				if (X[t].includes(ce(e) || e.detail.toUpperCase()) && "chat" === t)
					if (document.body.classList.contains("inmulti") || document.body.classList.contains("inmultizen") && 0 === We) document.getElementById("ingame_chat_input").focus(), e.stopPropagation(), e.preventDefault();
					else if ("lobby" !== Ie || 1 !== We || document.getElementById("menus").classList.contains("hidden")) {
					if ("endleague" === Ie && 1 === We && !document.getElementById("menus").classList.contains("hidden")) {
						if (["input", "textarea"].includes(document.activeElement.tagName.toLowerCase())) return;
						document.getElementById("league_chat_input").focus(), e.stopPropagation(), e.preventDefault()
					}
				} else {
					if (["input", "textarea"].includes(document.activeElement.tagName.toLowerCase())) return;
					document.getElementById("chat_input").focus(), e.stopPropagation(), e.preventDefault()
				} else;
			})
		}

		function h(e) {
			"results" !== Ie || document.getElementById("menus").classList.contains("hidden") || document.getElementById("results").classList.contains("isreplay") || 1 !== We || Object.keys(X).forEach(t => {
				X[t].includes(ce(e) || e.detail.toUpperCase()) && "retry" === t && document.getElementById("start_results").click()
			})
		}

		function y(e) {
			document.getElementById("list_request").classList.contains("hidden") || Object.keys(X).forEach(t => {
				X[t].includes(ce(e) || e.detail.toUpperCase()) && document.getElementById("list_request").querySelectorAll(".scroller_item").forEach(e => {
					e.getAttribute("data-keybind") !== t || e.click()
				})
			})
		}
		window.DEVHOOK_LOAD_REPLAY_RAW = e => {
			et.showResults(e.endcontext, {
				gametype: e.endcontext.gametype,
				back: "home",
				isreplay: !0,
				username: e.user.username,
				ts: e.ts,
				replay: e
			}), document.getElementById("results").classList.add("fakereplay"), g = e._id
		}, document.getElementById("menus").addEventListener("drop", e => {
			e.stopPropagation(), e.preventDefault();
			const t = e.dataTransfer.files[0];
			if (!t) return;
			if (!/\.tt[rpc]$/.test(t.name)) return void c("TETR.IO cannot open this file");
			const n = new FileReader;
			n.onload = () => {
				Ne();
				try {
					const e = JSON.parse(n.result);
					/\.ttr$/.test(t.name) ? (et.showResults(e.endcontext, {
						gametype: e.endcontext.gametype,
						back: "home",
						isreplay: !0,
						username: e.user.username,
						ts: e.ts,
						replay: e
					}), g = e._id, r.get(`/api/games/${encodeURIComponent(e._id)}/exists`, {}, !0).then(t => {
						e._id === g && (t.exists || document.getElementById("results").classList.add("fakereplay"))
					}, e => {})) : /\.ttp$/.test(t.name) ? (et.setGameOpts(e), m("custom game loaded!")) : /\.ttc$/.test(t.name) && E({
						title: "IMPORT CONFIG?",
						msg: 'are you sure you wish to import this CONFIG file? it will override your current CONFIG.</p><p class="modal_warning">DO NOT IMPORT A CONFIG YOU DO NOT TRUST!</p><p class="modal_also">your current CONFIG will be lost.',
						buttons: [{
							label: "CANCEL",
							classes: [],
							callback: e => {
								e()
							}
						}, {
							label: "IMPORT",
							classes: ["sec"],
							callback: t => {
								t(), Object.assign(G, e), ne(), Q(), m("config loaded. you must hit F5 for all the changes to properly take effect!")
							}
						}]
					})
				} catch (e) {
					return c("file load failed!"), void console.log(e)
				}
			}, He("loading file…"), n.readAsText(t)
		}, !1), document.getElementById("room_opts_welcome").addEventListener("click", (function (e) {
			document.getElementById("room_opts_welcome").classList.add("active"), document.getElementById("room_opts_room").classList.remove("active"), document.getElementById("room_opts_match").classList.remove("active"), document.getElementById("room_opts_game").classList.remove("active"), document.getElementById("room_content_welcome").classList.remove("hidden"), document.getElementById("room_content_room").classList.add("hidden"), document.getElementById("room_content_match").classList.add("hidden"), document.getElementById("room_content_game").classList.add("hidden")
		})), document.getElementById("room_opts_room").addEventListener("click", (function (e) {
			document.getElementById("room_opts_welcome").classList.remove("active"), document.getElementById("room_opts_room").classList.add("active"), document.getElementById("room_opts_match").classList.remove("active"), document.getElementById("room_opts_game").classList.remove("active"), document.getElementById("room_content_welcome").classList.add("hidden"), document.getElementById("room_content_room").classList.remove("hidden"), document.getElementById("room_content_match").classList.add("hidden"), document.getElementById("room_content_game").classList.add("hidden")
		})), document.getElementById("room_opts_match").addEventListener("click", (function (e) {
			document.getElementById("room_opts_welcome").classList.remove("active"), document.getElementById("room_opts_room").classList.remove("active"), document.getElementById("room_opts_match").classList.add("active"), document.getElementById("room_opts_game").classList.remove("active"), document.getElementById("room_content_welcome").classList.add("hidden"), document.getElementById("room_content_room").classList.add("hidden"), document.getElementById("room_content_match").classList.remove("hidden"), document.getElementById("room_content_game").classList.add("hidden")
		})), document.getElementById("room_opts_game").addEventListener("click", (function (e) {
			document.getElementById("room_opts_welcome").classList.remove("active"), document.getElementById("room_opts_room").classList.remove("active"), document.getElementById("room_opts_match").classList.remove("active"), document.getElementById("room_opts_game").classList.add("active"), document.getElementById("room_content_welcome").classList.add("hidden"), document.getElementById("room_content_room").classList.add("hidden"), document.getElementById("room_content_match").classList.add("hidden"), document.getElementById("room_content_game").classList.remove("hidden")
		})), document.getElementById("custom_opts_game").addEventListener("click", (function (e) {
			document.getElementById("custom_opts_game").classList.add("active"), document.getElementById("custom_opts_objective").classList.remove("active"), document.getElementById("custom_opts_meta").classList.remove("active"), document.getElementById("custom_content_game").classList.remove("hidden"), document.getElementById("custom_content_objective").classList.add("hidden"), document.getElementById("custom_content_meta").classList.add("hidden")
		})), document.getElementById("custom_opts_objective").addEventListener("click", (function (e) {
			document.getElementById("custom_opts_game").classList.remove("active"), document.getElementById("custom_opts_objective").classList.add("active"), document.getElementById("custom_opts_meta").classList.remove("active"), document.getElementById("custom_content_game").classList.add("hidden"), document.getElementById("custom_content_objective").classList.remove("hidden"), document.getElementById("custom_content_meta").classList.add("hidden")
		})), document.getElementById("custom_opts_meta").addEventListener("click", (function (e) {
			document.getElementById("custom_opts_game").classList.remove("active"), document.getElementById("custom_opts_objective").classList.remove("active"), document.getElementById("custom_opts_meta").classList.add("active"), document.getElementById("custom_content_game").classList.add("hidden"), document.getElementById("custom_content_objective").classList.add("hidden"), document.getElementById("custom_content_meta").classList.remove("hidden")
		})), document.getElementById("list_request_back").addEventListener("click", (function (e) {
			pe.pop(), document.getElementById("list_request").classList.add("hidden")
		})), document.querySelectorAll("#room_content_container .room_config_item[data-index]").forEach(e => {
			e.addEventListener("input", () => {
				e.closest(".room_config_row").classList.add("unsaved"), document.getElementById("room_opts_save").classList.add("unsaved")
			})
		}), document.getElementById("room_opts_save").addEventListener("click", () => {
			jt.saveRoomConfig(), document.querySelectorAll("#room_content_container .unsaved .room_config_item[data-index]").forEach(e => {
				e.closest(".room_config_row").classList.remove("unsaved")
			}), document.getElementById("room_opts_save").classList.remove("unsaved")
		}), document.querySelectorAll(".room_config_spinner").forEach(e => {
			e.addEventListener("click", () => {
				const t = [];
				e.getAttribute("data-items").split(";").forEach(e => {
					const n = e.split(",");
					t.push({
						id: n[0],
						name: n[1],
						description: n[2]
					})
				}), Ae(t, t => {
					e.innerHTML = t, e.dispatchEvent(new Event("input"))
				}, !0)
			})
		}), document.addEventListener("keydown", p, !0), document.addEventListener("gpdown", p, !0), document.addEventListener("keydown", e => {
			9 === e.keyCode && e.preventDefault()
		}, !1), document.addEventListener("keydown", h, !1), document.addEventListener("gpdown", h, !1), document.addEventListener("keydown", y, !1), document.addEventListener("gpdown", y, !1), document.addEventListener("mousemove", (function (e) {
			d ? clearTimeout(d) : document.body.classList.remove("idlemouse"), d = setTimeout(() => {
				document.body.classList.add("idlemouse"), d = null
			}, 5e3)
		})), ve = {
			gravitymode: "relaxed",
			gravitystatic: 20,
			counters: "off",
			leveling: "on",
			garbagemode: "off",
			cheeselayer_height: 6,
			cheesetimer_interval: 4,
			cheesemessiness: 100
		}, document.addEventListener("click", (function (e) {
			e.target.classList.contains("panel_option") && (e.target.closest(".panel_optionset").querySelectorAll(".panel_option").forEach(e => {
				e.classList.remove("selected")
			}), e.target.classList.add("selected"), ve[e.target.getAttribute("data-key")] = e.target.getAttribute("data-value"), ye && ye.pullZenConfig())
		})), document.addEventListener("input", (function (e) {
			e.target.classList.contains("panel_input") && (ve[e.target.getAttribute("data-key")] = "number" === e.target.getAttribute("type") ? parseFloat(e.target.value) : e.target.value, ye && ye.pullZenConfig())
		}))
	}));
	let Me = !1;

	function Se(e) {
		e ? (Me || (Xe(), Me = e), document.getElementById("menus").classList.remove("hidden")) : (Me && (Ke(), Me = e), document.getElementById("menus").classList.add("hidden"))
	}

	function Ce() {
		document.getElementById("list_request").classList.contains("hidden") || (pe.pop(), document.getElementById("list_request").classList.add("hidden"))
	}
	let Re = () => {};

	function Ae(e, t, n) {
		Re = t;
		const a = document.getElementById("list_request_scroller");
		for (; a.firstChild;) a.removeChild(a.firstChild);
		e.forEach(e => {
			const t = document.createElement("div");
			if (t.classList.add("scroller_item"), t.classList.add("ns"), t.setAttribute("data-id", e.id), t.setAttribute("data-hover", "tap"), t.setAttribute("data-hit", "click"), t.setAttribute("data-keybind", e.key || "X-NOKEY"), a.appendChild(t), e.image) {
				const n = document.createElement("img");
				n.src = e.image, t.appendChild(n), t.classList.add("has_image")
			}
			const n = document.createElement("h1");
			if (n.innerHTML = e.name, t.appendChild(n), e.description) {
				const n = document.createElement("p");
				n.innerHTML = e.description, t.appendChild(n), t.classList.add("has_description")
			}
			t.addEventListener("click", (function (e) {
				pe.pop(), document.getElementById("list_request").classList.add("hidden"), Re(t.getAttribute("data-id"))
			}))
		}), document.getElementById("list_request_back").classList.toggle("hidden", !n), document.getElementById("list_request").classList.remove("hidden"), pe.push(), pe.bindGuide(he.list_request)
	}

	function $e(e) {
		const t = [{
			id: "RANDOM",
			name: "RANDOM",
			description: "pick a completely random BGM for me"
		}, {
			id: "RANDOMcalm",
			name: "RANDOM: CALM",
			description: "pick a random calmer BGM for me"
		}, {
			id: "RANDOMbattle",
			name: "RANDOM: BATTLE",
			description: "pick a random intenser battle BGM for me"
		}];
		Object.keys(ft.ost).forEach(e => {
			ft.ost[e].hidden || t.push({
				id: e,
				name: ft.ost[e].name,
				description: `${ft.ost[e].artist} - ${ft.ost[e].genre}`
			})
		}), Ae(t, t => {
			e(t)
		}, !0)
	}

	function Oe(e) {
		Ae([{
			id: "retry",
			name: "RETRY",
			key: "retry"
		}, {
			id: "back",
			name: "BACK TO TITLE",
			key: "exit"
		}], t => {
			e(t)
		})
	}

	function De() {
		Se(!1), Fe("none"), ft.stop(), ye && (ye.end(), ye.destroy(), maingame = void 0)
	}

	function He(e) {
		document.getElementById("afterloader_text").innerHTML = e, document.getElementById("afterloader").classList.remove("hidden"), document.activeElement.blur()
	}

	function Ne() {
		document.getElementById("afterloader").classList.add("hidden")
	}
	let Pe = 0;

	function Ue() {
		Pe = (new Date).getTime(), document.getElementById("kuro").classList.remove("hidden"), document.activeElement.blur()
	}

	function ze(e) {
		const t = 500 - ((new Date).getTime() - Pe);
		t < 1 ? e() : setTimeout(() => {
			e()
		}, t)
	}

	function je() {
		ze(() => {
			document.getElementById("kuro").classList.add("hidden")
		})
	}
	let We = 0,
		Ge = null,
		qe = !1;

	function Xe() {
		0 === We && (document.body.classList.remove("ingame"), document.body.getBoundingClientRect(), Ge && clearTimeout(Ge), qe && pe.engage()), We++
	}

	function Ke() {
		0 === (We = Math.max(0, We - 1)) && (Ge && clearTimeout(Ge), Ge = setTimeout(() => {
			document.body.classList.add("ingame")
		}, 1e3), qe = pe.isEngaged(), pe.disengage())
	}
	let Ye = "";

	function Ve() {
		"home" !== Ie || document.getElementById("menus").classList.contains("hidden") || We < 1 || r.get("/about/homebanner.html", {}, !1, !0).then(e => {
			e != Ye && (Ye = e, document.getElementById("homebanner").innerHTML = e)
		}, e => {})
	}

	function Ze(e = !1) {
		"undefined" != typeof Notification ? "granted" === Notification.permission || "denied" === Notification.permission && !e || Notification.requestPermission() : console.warn("Notifications are not available on this device.")
	}

	function Je(e, t, n = !1) {
		"undefined" != typeof Notification && !1 !== G.video.desktopnotifications && (document.body.classList.contains("nofocus") || n) && (new Notification(e, {
			body: t,
			icon: "/res/tetriox256.png"
		}), IS_ELECTRON && D())
	}
	e(() => {
		r.get("/about/homebanner.html", {}, !1, !0).then(e => {
			Ye = e, document.getElementById("homebanner").innerHTML = e, I.finishLoad()
		}, e => {
			I.finishLoad()
		})
	}), I.ready(e => {
		setInterval(() => {
			Ve()
		}, 12e4)
	}), I.ready((function (e) {
		k.newacc() || r.get("/about/patchnotes/notes.json", {}, !1, !1, !0).then(e => {
			const t = localStorage.getItem("lastPatch"),
				n = Object.keys(e)[0];
			if (n !== t) {
				localStorage.setItem("lastPatch", n);
				let t = "";
				t += `<h1>${n}</h1><h6>${e[n].ts}</h6>`, e[n].contents.forEach(e => {
					e.header && (t += `<h2 style="color: ${e.color};" data-content="${e.header}">${e.header}</h2>`), t += `<p>${e.items.join("</p><p>")}</p>`
				}), E({
					title: "WHAT'S NEW",
					msg: `<div class="dialog_long">${t}<p class="dlf">Development is funded by supporters! If you wish to help develop TETR.IO, please consider <a href="https://patreon.com/tetrio" target="_blank" class="lna">supporting the sole developer behind TETR.IO</a>!</p></div>`,
					classes: ["patchnotes", "wide_modal"],
					buttons: [{
						label: "ALL PATCH NOTES",
						classes: [],
						callback: e => {
							window.open("/about/patchnotes/", "_blank"), e()
						}
					}, {
						label: "COOL!",
						classes: ["pri"],
						callback: e => {
							e()
						}
					}]
				})
			}
		}, () => {})
	})), I.ready((function (e) {
		Ze(!1)
	}));
	const Qe = (() => {
			"production" === TETRIO_ENV.mode && e(() => {
				document.getElementById("performancemeter").classList.add("production"), document.getElementById("performancemeter_header").innerHTML = "PRODUCTION BUILD - F8 for stats", document.getElementById("sb").remove(), document.getElementById("sbt").remove()
			});
			let t = !1,
				n = [],
				a = [],
				o = [],
				i = 0,
				s = 0,
				r = 0,
				l = 0,
				d = 0,
				c = 0,
				m = 0,
				u = 0,
				g = 0,
				p = 0,
				h = [],
				y = [],
				f = [],
				_ = [],
				E = [],
				v = [],
				b = [],
				I = [];
			const w = 1e3 / 60;
			let k = null;

			function L() {
				t && window.requestAnimationFrame(L);
				const e = window.performance.now();
				n.push(e),
					function () {
						const e = window.performance.now();
						E = E.filter(t => !(e - t > 1e3)), v = v.filter(t => !(e - t > 6e4)), b = b.filter(t => !(e - t > 1e3)), I = I.filter(t => !(e - t > 6e4)), n = n.filter(t => !(e - t > 1e3)), h = h.filter(t => !(e - t.ts > 1e3)), y = y.filter(t => !(e - t.ts > 6e4)), f = f.filter(t => !(e - t.ts > 1e3)), _ = _.filter(t => !(e - t.ts > 1e3))
					}(), m = E.length, u = v.length, g = b.length, p = I.length, i = n.length, a.push({
						ts: e,
						fps: i
					}), a = a.filter(t => !(e - t.ts > 5e3)), r = Math.max(1e-6, h.reduce((e, t) => Math.max(e, t.fill), 0)), l = Math.max(1e-6, y.reduce((e, t) => Math.max(e, t.fill), 0)), d = _.reduce((e, t) => Math.max(e, t.fill), 0), c = f.reduce((e, t) => Math.max(e, t.fill), 0), s = a.reduce((e, t) => Math.min(e || t.fps, t.fps), 0), x("fps", i), B("fps", s), T("fps", i < 40), x("f", Math.round(r / w * 1e4) / 100), B("f", Math.round(l / w * 1e4) / 100), T("f", r / w > .8), x("gamef", Math.round(d / r * 1e4) / 100), B("gamef", Math.round(d / w * 1e4) / 100), x("drawf", Math.round(c / r * 1e4) / 100), B("drawf", Math.round(c / w * 1e4) / 100), x("gamem", m), B("gamem", u), x("drawm", g), B("drawm", p), T("gamem", m > 9), T("drawm", g > 9), x("ping", o.length ? o[o.length - 1] : "-"), B("ping", o.length ? o.reduce((e, t) => Math.max(e, t)) : "-"), T("ping", !!o.length && o[o.length - 1] > 500)
			}

			function x(e, t) {
				k.querySelector(`#perf_${e} h1 span`).innerHTML = t
			}

			function B(e, t) {
				k.querySelector(`#perf_${e} h2 span`).innerHTML = t
			}

			function T(e, t) {
				t ? k.querySelector(`#perf_${e}`).classList.add("warning") : k.querySelector(`#perf_${e}`).classList.remove("warning")
			}
			return e(() => {
				k = document.getElementById("performancemeter"), document.addEventListener("keydown", e => {
					119 === e.which && (t ? (t = !1, k.classList.add("off")) : (t = !0, L(), k.classList.remove("off")))
				}, !1), document.getElementById("devbuildid").innerHTML = `v${TETRIO_ENV.version}-${TETRIO_ENV.mode} | commit ${TETRIO_ENV.commit.id} (${new Date(TETRIO_ENV.commit.time).toLocaleString()}) | server cycle ${TETRIO_ENV.serverCycle} | build ${TETRIO_ENV.build.id} (${new Date(TETRIO_ENV.build.time).toLocaleString()})`, document.getElementById("version_line").innerHTML = `version ${TETRIO_ENV.version}-${TETRIO_ENV.mode.toUpperCase()} (press F8 for more info)`
			}), {
				addGameF: e => {
					t && (h.push({
						fill: e,
						ts: window.performance.now()
					}), y.push({
						fill: e,
						ts: window.performance.now()
					}), _.push({
						fill: e,
						ts: window.performance.now()
					}))
				},
				addDrawF: e => {
					t && (h.push({
						fill: e,
						ts: window.performance.now()
					}), y.push({
						fill: e,
						ts: window.performance.now()
					}), f.push({
						fill: e,
						ts: window.performance.now()
					}))
				},
				addGameM: e => {
					if (t)
						for (; e-- > 0;) E.push(window.performance.now()), v.push(window.performance.now())
				},
				addDrawM: e => {
					if (t)
						for (; e-- > 0;) b.push(window.performance.now()), I.push(window.performance.now())
				},
				addPing: e => {
					o.push(e), o.splice(0, Math.max(0, o.length - 12))
				}
			}
		})(),
		et = (() => {
			let e = null,
				t = null,
				n = null,
				a = !1,
				o = {};
			I.ready(() => {
				document.addEventListener("keydown", e => {
					e.repeat || document.getElementById("replay").classList.contains("hidden") || document.body.classList.contains("chatfocus") || Object.keys(X).forEach(t => {
						if (X[t].includes(ce(e) || e.detail.toUpperCase())) switch (t) {
							case "moveLeft":
							case "rotateCCW":
								document.getElementById("speeddown_replay").click();
								break;
							case "moveRight":
							case "rotateCW":
								document.getElementById("speedup_replay").click();
								break;
							case "softDrop":
							case "hardDrop":
								document.getElementById("pause_replay").click();
								break;
							case "exit":
								document.getElementById("exit_replay").click()
						}
					})
				}, !1), document.getElementById("exit_replay").addEventListener("click", (function (e) {
					ye.end()
				})), document.getElementById("speeddown_replay").addEventListener("click", (function (e) {
					switch (ye.playbackSpeed()) {
						case .5:
							ye.playbackSpeed(.25);
							break;
						case 1:
							ye.playbackSpeed(.5);
							break;
						case 2:
							ye.playbackSpeed(1);
							break;
						case 5:
							ye.playbackSpeed(2);
							break;
						case 10:
							ye.playbackSpeed(5)
					}
					document.getElementById("pause_replay").innerHTML = `${ye.playbackSpeed()}x`
				})), document.getElementById("speedup_replay").addEventListener("click", (function (e) {
					switch (ye.playbackSpeed()) {
						case .25:
							ye.playbackSpeed(.5);
							break;
						case .5:
							ye.playbackSpeed(1);
							break;
						case 1:
							ye.playbackSpeed(2);
							break;
						case 2:
							ye.playbackSpeed(5);
							break;
						case 5:
							ye.playbackSpeed(10)
					}
					document.getElementById("pause_replay").innerHTML = `${ye.playbackSpeed()}x`
				})), document.getElementById("pause_replay").addEventListener("click", (function (e) {
					1 === ye.playbackSpeed() ? ye.playbackSpeed(0) : ye.playbackSpeed(1), document.getElementById("pause_replay").innerHTML = `${ye.playbackSpeed()}x`
				})), document.getElementById("watchreplay_results").addEventListener("click", (function (t) {
					let n = void 0;
					document.getElementById("results").classList.contains("isreplay") || (n = ft.playing()), m(e.data, e.user.username.toUpperCase(), ya.longTypeNames[e.endcontext.gametype], n)
				})), document.getElementById("downloadreplay_results").addEventListener("click", (function (t) {
					const n = new Blob([JSON.stringify(e)], {
							type: "application/json"
						}),
						a = document.createElement("a");
					a.download = `${e.shortid||"replay"}.ttr`, a.href = (window.webkitURL || window.URL).createObjectURL(n), a.dataset.downloadurl = ["application/json", a.download, a.href].join(":"), document.body.appendChild(a), a.click(), document.body.removeChild(a)
				})), document.getElementById("tweetreplay_results").addEventListener("click", (function (t) {
					let n = "",
						a = "";
					switch (e.gametype) {
						case "40l":
							const t = H(e.endcontext.finalTime);
							a = `time of ${t.m}:${t.s}.${t.ms}`;
							break;
						case "blitz":
							a = `score of ${e.endcontext.score}`
					}
					n = document.getElementById("results").classList.contains("isreplay") ? `Check out ${e.user._id===w.id()?"my":`${e.user.username.toUpperCase()}'s`} ` : "I just achieved a ", n += `${a} playing TETR.IO ${ya.longTypeNames[e.gametype]}!\n\nhttps://tetr.io/#R:${e.shortid}`, window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(n)}`, "_blank", "menubar=0,toolbar=0,location=0,personalbar=0,status=0,noopener=1,width=640,height=480")
				})), document.getElementById("resubmitreplay_results").addEventListener("click", (function (e) {
					t && (He("resubmitting…"), s(...t).then(e => {
						d("game submitted!"), document.getElementById("results").classList.remove("error"), Ne()
					}, e => {
						u(e), Ne()
					}))
				})), document.getElementById("custom_export").addEventListener("click", (function (e) {
					const t = new Blob([JSON.stringify(E())], {
							type: "application/json"
						}),
						n = document.createElement("a");
					n.download = "custom-game.ttp", n.href = (window.webkitURL || window.URL).createObjectURL(t), n.dataset.downloadurl = ["application/json", n.download, n.href].join(":"), document.body.appendChild(n), n.click(), document.body.removeChild(n)
				}))
			});
			let i = 0;

			function s(e, t, n) {
				const a = r.post("/api/games/submit", {
					type: e,
					replay: t,
					assumptions: n,
					aborted: i,
					i: I.i(),
					serverCycle: TETRIO_ENV.serverCycle,
					commitId: TETRIO_ENV.commit.id
				}, !0);
				return i = 0, a
			}

			function l() {
				i = Math.min(10, i + 1)
			}

			function c(e, t, n, a) {
				Se(!1), ft.stop(), document.getElementById("data_replay").innerHTML = `watching <span>${U(t)}</span> play <span>${U(n)}</span>`, document.getElementById("replay").classList.remove("hidden"), document.getElementById("pause_replay").innerHTML = "1x", (ye = new ka).createGameHolder(), ye.bindEventSource(new Ea({
					type: "replay",
					replay: e
				}));
				const o = e.getStarter().options;
				o.display_replay = !0, o.display_username = !0, o.username = t, "CUSTOM GAME" !== n && (o.countdown_interval = 1e3, o.precountdown = 5e3, o.prestart = 1e3, o.mission = ya.gameMissions[n], o.zoominto = "slow", o.pro = !!G.gameoptions[`pro_${n}`], o.pro_alert = !!G.gameoptions[`pro_${n}_alert`], o.pro_retry = !!G.gameoptions[`pro_${n}_retry`]), o.onstart = () => {
					ft.playSmoothOrRandom("shiroi-hyoutan")
				}, o.onend = () => {
					setTimeout(() => {
						Se(!0), ft.playSmooth(document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") ? "touhoudaiensei" : a || "shikiichi-made-mousukoshi"), document.getElementById("replay").classList.add("hidden")
					}, 1500)
				}, ye.setGame(o), ye.startGame()
			}

			function m(e, t, n, a) {
				const o = new _a;
				o.import(e), c(o, t, n, a)
			}

			function g(e) {
				n = "40l", Se(!1), Fe("none"), ft.stop(), a || w.anon() || document.body.classList.contains("banstatus_restrict") ? document.getElementById("noreplay").classList.remove("hidden") : document.getElementById("noreplay").classList.add("hidden"), document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || R({
					state: "40 LINES",
					largeImageKey: "logo",
					smallImageKey: "mode_40l",
					smallImageText: "40 LINES",
					startTimestamp: Date.now(),
					instance: !0
				}), (ye = new ka).createGameHolder(), ye.bindEventSource(new Ea({
					type: "keyboard"
				})), ye.setGame({
					version: va,
					seed_random: !0,
					anchorseed: !0,
					g: .02,
					allow180: !0,
					countdown: !0,
					countdown_interval: 1e3,
					precountdown: 5e3,
					prestart: 1e3,
					mission: ya.gameMissions["40l"],
					zoominto: "slow",
					display_lines: !0,
					display_stopwatch: !0,
					display_pieces: !0,
					display_progress: !0,
					display_finesse: !0,
					display_keys: !0,
					pro: !!G.gameoptions.pro_40l,
					pro_alert: !!G.gameoptions.pro_40l_alert,
					pro_retry: !!G.gameoptions.pro_40l_retry,
					stride: !!G.gameoptions.stride_40l,
					objective: {
						type: "lines",
						count: 40
					},
					can_retry: !0,
					bgmnoreset: !1 !== G.volume.noreset,
					onstart: () => {
						ft.playSmoothOrRandom(e.song || "RANDOM")
					},
					onfinish: e => {
						const n = e.stats;
						n.finalTime = e.assumptions.finalTime;
						const o = e.replay.getFrame() * (1e3 / 60);
						let i = n.finalTime;
						Math.abs(i - o) >= 50 && (i = o);
						const r = performance.now();
						a || w.anon() ? setTimeout(() => {
							n.finalTime = i, n.gametype = "40l", f(e.stats, {
								gametype: "40l",
								replay: {
									user: {
										_id: w.id(),
										username: w.username()
									},
									endcontext: n,
									ts: new Date,
									data: e.replay.export(),
									gametype: "40l",
									customtype: "40l"
								}
							})
						}, G.gameoptions.stride_40l ? 500 : 2e3) : (t = ["40l", e.replay.export(), e.assumptions], s(...t).then(e => {
							d("game submitted!");
							const t = performance.now() - r;
							setTimeout(() => {
								n.finalTime = i, f(n, {
									gametype: "40l",
									username: e.game.user.username,
									ts: e.game.ts,
									replay: e.game,
									hasranks: !0,
									globalrank: -1 === e.globalrecord.rank ? void 0 : e.globalrecord.rank,
									personalrank: -1 === e.userbestrecord.rank ? void 0 : e.userbestrecord.rank
								}), Tt(e.xp)
							}, Math.max(0, (G.gameoptions.stride_40l ? 500 : 2e3) - t))
						}, t => {
							u(t);
							const a = performance.now() - r;
							setTimeout(() => {
								n.finalTime = i, n.gametype = "40l", f(e.stats, {
									gametype: "40l",
									error: t.errors[0].msg,
									replay: {
										user: {
											_id: w.id(),
											username: w.username()
										},
										endcontext: n,
										ts: new Date,
										data: e.replay.export(),
										gametype: "40l",
										customtype: "40l"
									}
								})
							}, Math.max(0, (G.gameoptions.stride_40l ? 500 : 2e3) - a))
						}))
					},
					onfail: () => {
						l(), setTimeout(() => {
							yt.play("failure"), Oe(t => {
								"retry" === t ? g({
									song: e.song
								}) : (Se(!0), Fe("home"))
							})
						}, G.gameoptions.stride_40l ? 500 : 3e3)
					},
					onquit: () => {
						l(), setTimeout(() => {
							Se(!0), Fe("home")
						}, 600)
					}
				}), ye.startGame()
			}

			function p(e) {
				n = "blitz", Se(!1), Fe("none"), ft.stop(), a || w.anon() || document.body.classList.contains("banstatus_restrict") ? document.getElementById("noreplay").classList.remove("hidden") : document.getElementById("noreplay").classList.add("hidden"), document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || R({
					state: "BLITZ",
					largeImageKey: "logo",
					smallImageKey: "mode_blitz",
					smallImageText: "BLITZ",
					startTimestamp: Date.now(),
					instance: !0
				}), (ye = new ka).createGameHolder(), ye.bindEventSource(new Ea({
					type: "keyboard"
				})), ye.setGame({
					version: va,
					seed_random: !0,
					anchorseed: !0,
					allow180: !0,
					countdown: !0,
					countdown_interval: 1e3,
					precountdown: 5e3,
					prestart: 1e3,
					mission: ya.gameMissions.blitz,
					zoominto: "slow",
					display_lines: !0,
					display_timer: !0,
					display_level: !0,
					display_score: !0,
					display_progress: !0,
					display_finesse_l: !0,
					pro: !!G.gameoptions.pro_blitz,
					pro_alert: !!G.gameoptions.pro_blitz_alert,
					pro_retry: !!G.gameoptions.pro_blitz_retry,
					stride: !!G.gameoptions.stride_blitz,
					objective: {
						type: "timed",
						time: 12e4
					},
					can_retry: !0,
					bgmnoreset: !1,
					levels: !0,
					levelspeed: .42,
					gbase: .65,
					onstart: () => {
						ft.playSmoothOrRandom(e.song || "RANDOM")
					},
					onfinish: e => {
						const n = e.stats;
						n.finalTime = e.assumptions.finalTime;
						const o = performance.now();
						a || w.anon() ? setTimeout(() => {
							n.finalTime = 12e4, n.gametype = "blitz", f(e.stats, {
								gametype: "blitz",
								replay: {
									user: {
										_id: w.id(),
										username: w.username()
									},
									endcontext: n,
									ts: new Date,
									data: e.replay.export(),
									gametype: "blitz",
									customtype: "blitz"
								}
							})
						}, G.gameoptions.stride_blitz ? 500 : 2e3) : (t = ["blitz", e.replay.export(), e.assumptions], s(...t).then(e => {
							d("game submitted!");
							const t = performance.now() - o;
							setTimeout(() => {
								n.finalTime = 12e4, f(n, {
									gametype: "blitz",
									username: e.game.user.username,
									ts: e.game.ts,
									replay: e.game,
									hasranks: !0,
									globalrank: -1 === e.globalrecord.rank ? void 0 : e.globalrecord.rank,
									personalrank: -1 === e.userbestrecord.rank ? void 0 : e.userbestrecord.rank
								}), Tt(e.xp)
							}, Math.max(0, (G.gameoptions.stride_blitz ? 500 : 2e3) - t))
						}, t => {
							u(t);
							const a = performance.now() - o;
							setTimeout(() => {
								n.finalTime = 12e4, n.gametype = "blitz", f(e.stats, {
									gametype: "blitz",
									error: t.errors[0].msg,
									replay: {
										user: {
											_id: w.id(),
											username: w.username()
										},
										endcontext: n,
										ts: new Date,
										data: e.replay.export(),
										gametype: "blitz",
										customtype: "blitz"
									}
								})
							}, Math.max(0, (G.gameoptions.stride_blitz ? 500 : 2e3) - a))
						}))
					},
					onfail: () => {
						l(), setTimeout(() => {
							yt.play("failure"), Oe(t => {
								"retry" === t ? p({
									song: e.song
								}) : (Se(!0), Fe("home"))
							})
						}, G.gameoptions.stride_blitz ? 500 : 3e3)
					},
					onquit: () => {
						l(), setTimeout(() => {
							Se(!0), Fe("home")
						}, 600)
					}
				}), ye.startGame()
			}
			let h = {
				map: `${"_".repeat(400)}?`,
				level: 1,
				progress: 0,
				score: 0
			};
			if (localStorage.getItem("zenProgression")) {
				const e = JSON.parse(localStorage.getItem("zenProgression"));
				e.level + e.progress >= h.level + h.progress && (h = e)
			}

			function y(e) {
				n = "custom", Se(!1), Fe("none"), ft.stop(), document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || R({
					state: "CUSTOM GAME",
					largeImageKey: "logo",
					smallImageKey: "mode_custom",
					smallImageText: "CUSTOM GAME",
					startTimestamp: Date.now(),
					instance: !0
				}), (ye = new ka).createGameHolder(), ye.bindEventSource(new Ea({
					type: "keyboard"
				}));
				const t = E();
				t.version = va, t.objective = {
					type: t.objective_type,
					count: t.objective_count,
					time: t.objective_time
				}, t.mission_type = "mission_free", t.bgmnoreset = !1 !== G.volume.noreset, t.onstart = () => {
					ft.playSmoothOrRandom(e.song || "RANDOM")
				}, t.onfinish = e => {
					const n = e.stats;
					n.finalTime = e.assumptions.finalTime, n.gametype = "custom";
					const a = e.replay.getFrame() * (1e3 / 60);
					let o = n.finalTime;
					Math.abs(o - a) >= 50 && (o = a), setTimeout(() => {
						n.finalTime = o, f(e.stats, {
							gametype: "custom",
							customtype: t.x_resulttype,
							replay: {
								user: {
									_id: w.id(),
									username: w.username()
								},
								endcontext: n,
								ts: new Date,
								data: e.replay.export(),
								gametype: "custom",
								customtype: t.x_resulttype
							}
						})
					}, 2e3)
				}, t.onfail = () => {
					setTimeout(() => {
						yt.play("failure"), Oe(t => {
							"retry" === t ? y({
								song: e.song
							}) : (Se(!0), Fe("home"))
						})
					}, 3e3)
				}, t.onquit = () => {
					setTimeout(() => {
						Se(!0), Fe("home")
					}, 600)
				}, ye.setGame(t), ye.startGame()
			}

			function f(t, n) {
				const i = H(t.finalTime),
					s = t.finalTime / 6e4 || 1,
					r = t.finalTime / 1e3 || 1,
					l = document.getElementById("results_stats_overview"),
					d = document.getElementById("results_stats_full");
				let c = {};
				if (n.replay) {
					const e = new _a;
					e.import(n.replay.data), c = e.getStarter().options
				}
				switch (l.innerHTML = "", d.innerHTML = "", "blitz" !== n.gametype && "custom" !== n.gametype || _(l, "LEVEL", t.level), _(l, "PIECES PLACED", t.piecesplaced), _(l, "PIECES per SECOND", (t.piecesplaced / r).toFixed(2)), t.inputs && (_(l, "KEYS PRESSED", t.inputs), _(l, "KEYS per PIECE", (t.inputs / t.piecesplaced).toFixed(3)), _(l, "KEYS per SECOND", (t.inputs / r).toFixed(3))), _(l, "SCORE", t.score), "40l" !== n.gametype && "custom" !== n.gametype || _(l, "TIME", `${i.m}:${i.s}.${i.ms}`), _(l, "LINES", t.lines), _(l, "LINES per MINUTE", (t.lines / s).toFixed(2)), "none" !== c.spinbonuses && _(l, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pins`, t.tspins), _(l, "maximum COMBO", Math.max(0, t.topcombo - 1)), _(l, "maximum back-to-back chain", Math.max(0, t.topbtb - 1)), _(l, "ALL CLEARS", t.clears.allclear), t.finesse && (_(l, "finesse %", `${(t.finesse.perfectpieces/Math.max(1,t.piecesplaced)*100).toFixed(2)}%`), _(l, "finesse faults", t.finesse.faults)), _(d, "SINGLES", t.clears.singles), _(d, "DOUBLES", t.clears.doubles), _(d, "TRIPLES", t.clears.triples), _(d, "QUADS", t.clears.quads), "none" !== c.spinbonuses && (_(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pins`, t.clears.realtspins), _(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pin MINIS`, t.clears.minitspins), _(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pin MINI SINGLES`, t.clears.minitspinsingles), _(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pin SINGLES`, t.clears.tspinsingles), _(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pin MINI DOUBLES`, t.clears.minitspindoubles), _(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pin DOUBLES`, t.clears.tspindoubles), _(d, `${"T-spins"!==c.spinbonuses&&c.spinbonuses?"s":"T-s"}pin TRIPLES`, t.clears.tspintriples), "T-spins" !== c.spinbonuses && void 0 !== c.spinbonuses && _(d, "spin QUADS", t.clears.tspinquads || 0)), _(d, "ALL CLEARS", t.clears.allclear), n.gametype) {
					case "40l":
						document.getElementById("results").classList.remove("nomusicpicker"), document.getElementById("result_header").innerHTML = "FINAL TIME", document.getElementById("result_result").innerHTML = `${i.m}:${i.s}<span class="ms">.${i.ms}</span>`, n.isreplay || (yt.play("showscore"), ft.playSmooth("success-story"));
						break;
					case "blitz":
						document.getElementById("results").classList.add("nomusicpicker"), document.getElementById("result_header").innerHTML = "FINAL SCORE", document.getElementById("result_result").textContent = t.score, n.isreplay || (yt.play("showscore"), ft.playSmooth("philosophy"));
						break;
					case "custom":
						switch (document.getElementById("results").classList.remove("nomusicpicker"), n.customtype || n.replay.customtype) {
							case "score":
								document.getElementById("result_header").innerHTML = "FINAL SCORE", document.getElementById("result_result").textContent = t.score;
								break;
							case "time":
								document.getElementById("result_header").innerHTML = "FINAL TIME", document.getElementById("result_result").innerHTML = `${i.m}:${i.s}<span class="ms">.${i.ms}</span>`;
								break;
							case "lines":
								document.getElementById("result_header").innerHTML = "FINAL LINE COUNT", document.getElementById("result_result").textContent = t.lines
						}
						n.isreplay || (yt.play("showscore"), ft.playSmooth("kaiser-hige-na-neko"))
				}
				const m = n.username || w.username();
				if (be.results.footer = `${ya.longTypeNames[n.gametype]} played by <a class="tetra_pop" data-hover="tap" data-hit="click" data-username="${U(m.replace('"',""))}">${U(m.toUpperCase())}</a> on ${new Date(n.ts||Date.now()).toLocaleString()}`, be.results.back = n.back || "home", Se(!0), Fe("results"), document.getElementById("results").classList.toggle("fakereplay", !n.replay.shortid), n.isreplay) Te(n.replay.shortid ? "tetra" : "custom"), document.getElementById("results").classList.add("isreplay");
				else {
					switch (n.gametype) {
						case "40l":
							Te("40l");
							break;
						case "blitz":
							Te("blitz");
							break;
						case "custom":
							Te("custom")
					}
					document.getElementById("results").classList.remove("isreplay")
				}
				if (n.replay ? (document.getElementById("results").classList.remove("noreplay"), document.getElementById("replayid_results").textContent = `R:${n.replay.shortid}`, e = n.replay) : document.getElementById("results").classList.add("noreplay"), n.hasranks) {
					if (document.getElementById("results").classList.add("hasranks"), n.globalrank ? (document.getElementById("globalrank_results").classList.toggle("textual", 1 === n.globalrank), document.getElementById("globalrank_results_data").innerHTML = 1 === n.globalrank ? "WORLD RECORD" : n.globalrank, document.getElementById("globalrank_results").classList.remove("hidden")) : document.getElementById("globalrank_results").classList.add("hidden"), n.personalrank)
						if (document.getElementById("personalrank_results").classList.toggle("textual", 1 === n.personalrank), document.getElementById("personalrank_results_data").innerHTML = 1 === n.personalrank ? "PERSONAL BEST" : n.personalrank, document.getElementById("personalrank_results").classList.remove("hidden"), o[n.gametype]) {
							let e = null;
							switch (n.gametype) {
								case "40l":
									const a = H(Math.abs(o[n.gametype].endcontext.finalTime - t.finalTime));
									e = `${a.m}:${a.s}.${a.ms}`;
									break;
								case "blitz":
									e = `${Math.abs(o[n.gametype].endcontext.score-t.score)} points`
							}
							document.getElementById("personalrank_results_sub").innerHTML = `${e||""}${e?` ${1===n.personalrank?"improvement":"behind"} &bull; `:""}last PB was ${N(Date.parse(o[n.gametype].ts)).toUpperCase()} ago`
						} else document.getElementById("personalrank_results_sub").innerHTML = "this is your first game, play more to track your improvement";
					else document.getElementById("personalrank_results").classList.add("hidden");
					1 == n.globalrank ? (yt.play("worldrecord"), xe("globalbest", "WORLD RECORD!")) : 1 == n.personalrank && (yt.play("personalbest"), xe("personalbest", "PERSONAL BEST!")), 1 == n.globalrank ? document.getElementById("globalrank_results").classList.add("best") : document.getElementById("globalrank_results").classList.remove("best"), 1 == n.personalrank ? (document.getElementById("personalrank_results").classList.add("best"), o[n.gametype] = {
						endcontext: t,
						ts: (new Date).toISOString()
					}, v()) : document.getElementById("personalrank_results").classList.remove("best")
				} else document.getElementById("results").classList.remove("hasranks");
				const u = new _a;
				u.import(n.replay.data);
				const g = u.getStarter().options.handling;
				document.getElementById("handling_item_arr").textContent = g.arr, document.getElementById("handling_item_das").textContent = g.das, document.getElementById("handling_item_sdf").textContent = 41 == g.sdf ? "MAX" : g.sdf, n.error && (n.error.includes("hacked") || n.error.includes("suspicious") || n.error.includes("already submitted")) && (n.error.includes("hacked") && (a = !0), n.error = void 0), document.getElementById("results").classList.toggle("error", !!n.error), n.error && (document.getElementById("submissionerror_results").textContent = n.error)
			}

			function _(e, t, n) {
				const a = document.createElement("tr");
				e.appendChild(a);
				const o = document.createElement("td");
				o.textContent = t, a.appendChild(o);
				const i = document.createElement("td");
				i.textContent = n, a.appendChild(i)
			}

			function E() {
				const e = {};
				return document.querySelectorAll("#custom_content_container .room_config_item[data-index]").forEach(t => {
					const n = t.getAttribute("data-index");
					let a;
					switch (t.getAttribute("type")) {
						case "number":
							a = parseFloat(t.value);
							break;
						case "checkbox":
							a = !!t.checked;
							break;
						case "text":
						default:
							a = t.value
					}
					t.classList.contains("room_config_spinner") && (a = t.innerHTML), e[n] = a
				}), e
			}

			function v() {
				if (o["40l"]) {
					const e = H(o["40l"].endcontext.finalTime);
					document.getElementById("pbdisplay_40l_inner").innerHTML = `${e.m}:${e.s}<span>.${e.ms}</span>`, document.getElementById("pbdisplay_40l_inner").classList.remove("hidden"), document.getElementById("pbdisplay_40l").classList.remove("hidden")
				} else document.getElementById("pbdisplay_40l").classList.add("hidden"), document.getElementById("pbdisplay_40l_inner").classList.add("hidden");
				o.blitz ? (document.getElementById("pbdisplay_blitz_inner").innerHTML = o.blitz.endcontext.score, document.getElementById("pbdisplay_blitz_inner").classList.remove("hidden"), document.getElementById("pbdisplay_blitz").classList.remove("hidden")) : (document.getElementById("pbdisplay_blitz").classList.add("hidden"), document.getElementById("pbdisplay_blitz_inner").classList.add("hidden"))
			}
			return {
				playReplay: c,
				playReplayObject: m,
				playReplayByID: function (e, t) {
					He("fetching replay…"), r.get(`/api/games/${encodeURIComponent(e)}`, {}, !0).then(e => {
						Ne(), m(e.game.data, e.game.user.username, e.game.gametype, t)
					}, e => {
						Ne(), u(e)
					})
				},
				playAgain: function (e) {
					switch (n) {
						case "40l":
							g(e);
							break;
						case "blitz":
							e.song = "hyper-velocity", p(e);
							break;
						case "custom":
							y(e)
					}
				},
				play40L: g,
				playBlitz: p,
				playZen: function (e) {
					n = "zen", Se(!1), Fe("none"), ft.stop(), e.inroom || document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") || R({
						state: "ZEN",
						largeImageKey: "logo",
						smallImageKey: "mode_zen",
						smallImageText: "ZEN",
						startTimestamp: Date.now(),
						instance: !0
					}), e.inroom && (document.getElementById("mm_status").classList.add("room"), document.getElementById("mm_status").classList.add("shown"), document.getElementById("mm_status_header").innerHTML = "ZEN WHILE WAITING", document.getElementById("mm_status_sub").textContent = e.roomname, document.body.classList.add("inmultizen")), (ye = new ka).createGameHolder(), ye.bindEventSource(new Ea({
						type: "keyboard"
					})), ye.setGame({
						version: va,
						seed_random: !0,
						allow180: !0,
						countdown: !0,
						countdown_interval: 1e3,
						precountdown: e.inroom ? 0 : 3e3,
						prestart: e.inroom ? 500 : 1e3,
						zoominto: e.inroom ? "fast" : "slow",
						display_score_zen: !0,
						display_level_zen: !0,
						display_progress: !0,
						mission: e.inroom ? void 0 : ya.gameMissions.zen,
						mission_type: "mission_free",
						objective: {
							type: "none"
						},
						bgmnoreset: !0,
						nosiren: !0,
						infinitestock: !0,
						zenlevels: !0,
						zenlevel: h.level,
						zenprogress: h.progress,
						score: h.score,
						map: h.map,
						forfeit_time: e.inroom ? 1 : 30,
						can_retry: !0,
						retryisclear: !0,
						usezenconfig: !0,
						noreplay: !0,
						garbagemultiplier: 1,
						pro: !0,
						b2bchaining: !0,
						onstart: () => {
							ft.playSmoothOrRandom("RANDOMcalm")
						},
						onquit: () => {
							if (e.inroom) return document.getElementById("mm_status").classList.remove("shown"), document.getElementById("mm_status").classList.remove("room"), document.body.classList.remove("inmultizen"), Se(!0), void Fe("lobby");
							setTimeout(() => {
								Se(!0), Fe("home")
							}, 600)
						}
					}), ye.startGame()
				},
				playCustom: y,
				testControls: function () {
					Se(!1), (ye = new ka).createGameHolder(), ye.bindEventSource(new Ea({
						type: "keyboard"
					})), ye.setGame({
						version: va,
						seed_random: !0,
						g: .02,
						allow180: !0,
						countdown: !1,
						precountdown: 0,
						prestart: 250,
						zoominto: "fast",
						objective: {
							type: "none"
						},
						can_retry: !1,
						forfeit_time: 1,
						display_username: !0,
						username: `arr ${G.handling.arr}F,das ${G.handling.das}F,sdf ${41==G.handling.sdf?"MAX":`${G.handling.sdf}X`}`,
						neverstopbgm: !0,
						onend: () => {
							setTimeout(() => {
								Se(!0)
							}, 200)
						}
					}), ye.startGame()
				},
				showResults: f,
				setGameOpts: function (e) {
					document.querySelectorAll("#custom_content_container .room_config_item[data-index]").forEach(t => {
						const n = t.getAttribute("data-index"),
							a = getSetDescendantProp(e, n);
						switch (t.getAttribute("type")) {
							case "number":
								t.value = a;
								break;
							case "checkbox":
								t.checked = !!a;
								break;
							case "text":
							default:
								t.value = a
						}
						t.classList.contains("room_config_spinner") && (t.textContent = a)
					})
				},
				reportAbortedGame: l,
				anchorSeed: function (e) {
					r.post("/api/games/anchor", {
						seed: e
					}, !0)
				},
				loadZen: function (e) {
					if (e)
						if (localStorage.getItem("zenProgression")) {
							const t = JSON.parse(localStorage.getItem("zenProgression"));
							t.level + t.progress < e.level + e.progress && (h = e)
						} else h = e
				},
				saveZen: function (e) {
					h = e, localStorage.setItem("zenProgression", JSON.stringify(e)), w.anon() || r.post("/api/games/zen", e, !0)
				},
				getZen: () => h,
				resetZen: () => {
					h = {
						map: `${"_".repeat(400)}?`,
						level: 1,
						progress: 0,
						score: 0
					}, localStorage.removeItem("zenProgression")
				},
				stopNow: () => {
					ye && ye.endNow(), Ia.forEach(e => {
						e.endNow()
					}), document.getElementById("replay").classList.add("hidden")
				},
				setRecords: e => {
					o = e, v()
				}
			}
		})();
	I.ready((function (e) {
		ct(!0), window.addEventListener("resize", () => {
			ct(!0)
		}, !1), setTimeout(() => {
			ct(!0)
		}, 10)
	}));
	let tt = 0,
		nt = 1,
		at = 0;
	const ot = 30;
	let it = 0,
		st = 0;
	const rt = 1600,
		lt = 800;
	let dt = 1;

	function ct(e) {
		tt = window.innerWidth, nt = window.innerHeight, at = tt / Math.max(1, nt), cz = G.video.zoom || 1, at < 2 ? (it = tt - 2 * ot, st = (tt - 2 * ot) / 2) : (it = 2 * (nt - 2 * ot), st = nt - 2 * ot), dt = it / rt * cz, document.querySelectorAll('canvas[data-fit="screen"]').forEach(e => {
			e.width = tt, e.height = nt
		}), document.querySelectorAll('canvas[data-fit="contain"]').forEach(e => {
			e.width = it, e.height = st
		}), document.querySelectorAll('canvas[data-fit="constrain"]').forEach(e => {
			e.width = e.getAttribute("data-w") * dt, e.height = e.getAttribute("data-h") * dt
		}), document.documentElement.style.setProperty("--r", dt), ma(), ga(), pa(), Nn && (Vn(), Nn.position.set((tt - it * cz) / 2, (nt - st * cz) / 2), Ln && Ln.fit()), Ia && e && Ia.forEach(e => {
			e.flushCanvases()
		})
	}

	function mt(e) {
		return e * dt
	}
	const ut = new Howl({
			src: "/sfx/tetrio.ogg",
			sprite: TETRIO_SE_SHEET,
			preload: !1,
			pool: 5,
			volume: 0,
			onload: () => {
				I.finishLoad()
			},
			onloaderror: (e, t) => {
				console.error(`Could not load sounds [${e}]: ${t}`)
			}
		}),
		gt = ["mission", "mission_free", "mission_versus", "mission_league", "victory", "failure", "matchintro"];
	e(() => {
		ut.load()
	});
	let pt = 0,
		ht = null;
	const yt = {
			play: function (e, t = 1, n = 0, a = !1) {
				if (!0 === G.volume.disable) return;
				if (["o", "l", "j", "z", "s", "t", "i"].includes(e) && !1 === G.volume.next && !a) return;
				if (["garbage_out_small", "garbage_in_small", "garbage_out_medium", "garbage_in_medium", "garbage_out_large", "garbage_in_large", "counter", "offset", "damage_small", "damage_medium", "damage_large", "impact", "damage_alert"].includes(e) && ("minimal" === G.video.graphics || !1 === G.volume.attacks) && !a) return;
				if (t * (gt.includes(e) ? G.volume.music : G.volume.sfx) == 0) return;
				const o = ut.play(e);
				return gt.includes(e) ? ut.volume(Math.min(t * G.volume.music, 1), o) : ut.volume(Math.min(t * G.volume.sfx, 1), o), "minimal" !== G.video.graphics && 0 !== n && ut.stereo(n, o), "minimal" !== G.video.graphics && "elim" === e && (ht && (clearTimeout(ht), ht = null), ut.rate(Math.min(2, Math.pow(1.05946, pt++)), o), ht = setTimeout(() => {
					pt = 0, ht = null
				}, 1e4)), o
			},
			playIngame: function (e, t, n, a, o, i, s = 1) {
				if (!0 === G.volume.disable) return;
				if (!i && ("minimal" === G.video.graphics || !1 === G.volume.others)) return;
				if ("full" !== t) {
					if ("tiny" === t) return;
					a *= o ? .2 : .05
				}
				if (o && 0 !== s || (a *= s), 0 === a) return;
				const r = Math.max(-1, Math.min(1, n * (void 0 === G.volume.stereo ? .5 : G.volume.stereo)));
				return this.play(e, a, r)
			},
			stop: function (e) {
				!0 !== G.volume.disable && ut.stop(e)
			}
		},
		ft = function () {
			let e, t = 0,
				n = null;
			const a = {
					"kuchu-toshi": {
						name: "aerial city",
						jpname: "空中都市",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 11831,
						loopLength: 80748
					},
					"shikiichi-made-mousukoshi": {
						name: "to the limit",
						jpname: "閾値までもうすこし",
						artist: "KAMIYA",
						jpartist: "守已",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 3719,
						loopLength: 89312
					},
					touhoudaiensei: {
						name: "the great eastern expedition",
						jpname: "東方大遠征",
						artist: "TAKAYUKI",
						jpartist: "たかゆき",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 10694,
						loopLength: 205986
					},
					"asayake-no-taiyou": {
						name: "morning sun",
						jpname: "朝焼けの太陽",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 3009,
						loopLength: 63999
					},
					"in-sorrow-and-pains": {
						name: "in sorrow and pains",
						jpname: "in sorrow and pains",
						artist: "MIRERA",
						jpartist: "ミレラ",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 4503,
						loopLength: 94030
					},
					"honemi-ni-shimiiru-karasukaze": {
						name: "piercing wind",
						jpname: "骨身に染み入るカラス風",
						artist: "KVK",
						jpartist: "KVK",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 7432,
						loopLength: 142958
					},
					inorimichite: {
						name: "inorimichite",
						jpname: "イノリミチテ",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 15670,
						loopLength: 181685
					},
					"kaze-no-sanpomichi": {
						name: "wind trail",
						jpname: "風の散歩道",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 12865,
						loopLength: 214284
					},
					"muscat-to-shiroi-osara": {
						name: "muscat and white dishes",
						jpname: "マスカットと白いお皿",
						artist: "TAKAHASHI TAKASHI",
						jpartist: "高橋岳",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 8853,
						loopLength: 184e3
					},
					"natsuzora-to-syukudai": {
						name: "summer sky and homework",
						jpname: "夏空と宿題",
						artist: "TAKAHASHI TAKASHI",
						jpartist: "高橋岳",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 20885,
						loopLength: 111997
					},
					"success-story": {
						name: "success story",
						jpname: "success story",
						artist: "AKIKO SHIOYAMA",
						jpartist: "AKIKO SHIOYAMA",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 25342,
						loopLength: 78407
					},
					"kaiser-hige-na-neko": {
						name: "classy cat",
						jpname: "カイゼルヒゲなネコ",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 0,
						loopLength: 104002
					},
					akindo: {
						name: "akindo",
						jpname: "AKINDO",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 7864,
						loopLength: 112166
					},
					"hyper-velocity": {
						name: "hyper velocity",
						jpname: "ハイパー・ベロシティ",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "SPECIAL",
						source: "HURT RECORD",
						loop: !1,
						loopStart: 121011,
						loopLength: 0,
						hidden: !0
					},
					philosophy: {
						name: "philosophy",
						jpname: "philosophy",
						artist: "L-side",
						jpartist: "L-side",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 9324,
						loopLength: 113450
					},
					"yoru-no-niji": {
						name: "rainbow of the night",
						jpname: "夜の虹",
						artist: "AIBA MAKOTO",
						jpartist: "相葉　慎",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 3651,
						loopLength: 140385
					},
					"shiroi-hyoutan": {
						name: "white calabash",
						jpname: "白いひょうたん",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "SPECIAL",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 17430,
						loopLength: 122264
					},
					smoke: {
						name: "smoke",
						jpname: "smoke",
						artist: "FUJINAWA KAZUHIKO",
						jpartist: "藤縄　和彦",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 5099,
						loopLength: 134400
					},
					"aijin-sanka": {
						name: "lover's song",
						jpname: "愛人讃歌",
						artist: "OMEGANE",
						jpartist: "おメガネ",
						genre: "INTERFACE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 3835,
						loopLength: 44657
					},
					"akai-tsuchi-wo-funde": {
						name: "step on the scarlet soil",
						jpname: "紅い土を踏んで",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 2783,
						loopLength: 123433
					},
					"burari-tokyo": {
						name: "hanging out in tokyo",
						jpname: "ぶらりTOKYO",
						artist: "MEESAN",
						jpartist: "自称芸術家みーさん",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 9680,
						loopLength: 134359
					},
					"back-water": {
						name: "backwater",
						jpname: "バックウォーター",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 1497,
						loopLength: 112006
					},
					"burning-heart": {
						name: "burning heart",
						jpname: "burning heart",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 0,
						loopLength: 76803
					},
					"hayate-no-sei": {
						name: "storm spirit",
						jpname: "疾風の精",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 24815,
						loopLength: 95937
					},
					"ice-eyes": {
						name: "ice eyes",
						jpname: "アイス・アイズ",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 6867,
						loopLength: 89146
					},
					"ima-koso": {
						name: "the time is now",
						jpname: "いまこそ…",
						artist: "TOMOKI",
						jpartist: "TOMOKI",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 5489,
						loopLength: 106635
					},
					prism: {
						name: "prism",
						jpname: "プリズム",
						artist: "AIBA MAKOTO",
						jpartist: "相葉　慎",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 0,
						loopLength: 92130
					},
					"risky-area": {
						name: "risky area",
						jpname: "risky area",
						artist: "MIKIYA KOMABA",
						jpartist: "MIKIYA KOMABA",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 31480,
						loopLength: 291144
					},
					"fuyu-no-jinkoueisei": {
						name: "winter satellite",
						jpname: "冬の人工衛星",
						artist: "SUDO MIKADUKI",
						jpartist: "周藤三日月",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 25956,
						loopLength: 149172
					},
					hatsuyuki: {
						name: "first snow",
						jpname: "初雪",
						artist: "YOSHI",
						jpartist: "YOSHI",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 21974,
						loopLength: 122850
					},
					"kansen-gairo": {
						name: "main street",
						jpname: "幹線街路",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 17757,
						loopLength: 183218
					},
					"chiheisen-wo-koete": {
						name: "over the horizon",
						jpname: "地平線を越えて",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 2423,
						loopLength: 63979
					},
					"moyase-toushi-yobisamase-tamashii": {
						name: "burning spirit, awakening soul",
						jpname: "燃やせ闘志、呼び覚ませ魂",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 15380,
						loopLength: 54858
					},
					"naraku-heno-abyssmaze": {
						name: "maze of the abyss",
						jpname: "奈落へのアビスメイズ",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 5133,
						loopLength: 117961
					},
					"samurai-sword": {
						name: "samurai sword",
						jpname: "SAMURAI SWORD",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 6587,
						loopLength: 105597
					},
					"super-machine-soul": {
						name: "super machine soul",
						jpname: "スーパーマシンソウル",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 22335,
						loopLength: 96e3
					},
					"uchuu-5239": {
						name: "universe 5239",
						jpname: "宇宙5239",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 15555,
						loopLength: 83117
					},
					"ultra-super-heros": {
						name: "ultra super heroes",
						jpname: "ウルトラスーパーヒーローズ",
						artist: "KAMOKING",
						jpartist: "カモキング",
						genre: "BATTLE",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 1315,
						loopLength: 104958
					},
					"21seiki-no-hitobito": {
						name: "twenty-first century people",
						jpname: "21世紀の人々",
						artist: "OMEGANE",
						jpartist: "おメガネ",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 0,
						loopLength: 131311
					},
					"haru-wo-machinagara": {
						name: "waiting for spring to come",
						jpname: "春を待ちながら",
						artist: "OMEGANE",
						jpartist: "おメガネ",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 5780,
						loopLength: 160015
					},
					"go-go-go-summer": {
						name: "go go go summer",
						jpname: "go go go summer",
						artist: "NOBUHAMU",
						jpartist: "NOBUHAMU",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 838,
						loopLength: 74661
					},
					"sasurai-no-hitoritabi": {
						name: "lonely journey",
						jpname: "流離いの独り旅",
						artist: "NAOKI HIRAI",
						jpartist: "NAOKI HIRAI",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 4044,
						loopLength: 145154
					},
					wakana: {
						name: "young leaves",
						jpname: "若菜",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 14819,
						loopLength: 178883
					},
					"zange-no-ma": {
						name: "confession",
						jpname: "懺悔の間",
						artist: "OMEGANE",
						jpartist: "おメガネ",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 0,
						loopLength: 80533
					},
					"subarashii-nichijou": {
						name: "amazing everyday",
						jpname: "素晴らしい日常",
						artist: "TSUTOMU",
						jpartist: "TSUTOMU",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 12399,
						loopLength: 128e3
					},
					asphalt: {
						name: "asphalt",
						jpname: "asphalt",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 5624,
						loopLength: 69711
					},
					"madobe-no-hidamari": {
						name: "by the sunlit window",
						jpname: "窓辺の日だまり",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 26203,
						loopLength: 65572
					},
					minamoto: {
						name: "origin",
						jpname: "源",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 135024,
						loopLength: 187926
					},
					"sora-no-sakura": {
						name: "cherry blossom season",
						jpname: "ソラノサクラ",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 0,
						loopLength: 336018
					},
					suiu: {
						name: "raindrops",
						jpname: "翠雨",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 15058,
						loopLength: 106578
					},
					"freshherb-wreath-wo-genkan-ni": {
						name: "entrance wreath",
						jpname: "フレッシュハーブリースを玄関に",
						artist: "CHIKA",
						jpartist: "ちか",
						genre: "CALM",
						source: "HURT RECORD",
						loop: !0,
						loopStart: 5169,
						loopLength: 84335
					}
				},
				o = {
					random: ["kaze-no-sanpomichi", "honemi-ni-shimiiru-karasukaze", "inorimichite", "muscat-to-shiroi-osara", "natsuzora-to-syukudai", "akindo", "yoru-no-niji", "akai-tsuchi-wo-funde", "burari-tokyo", "prism", "back-water", "burning-heart", "hayate-no-sei", "ice-eyes", "ima-koso", "risky-area", "fuyu-no-jinkoueisei", "hatsuyuki", "kansen-gairo", "chiheisen-wo-koete", "moyase-toushi-yobisamase-tamashii", "naraku-heno-abyssmaze", "samurai-sword", "super-machine-soul", "uchuu-5239", "ultra-super-heros", "21seiki-no-hitobito", "haru-wo-machinagara", "go-go-go-summer", "sasurai-no-hitoritabi", "wakana", "zange-no-ma", "subarashii-nichijou", "asphalt", "madobe-no-hidamari", "minamoto", "sora-no-sakura", "suiu", "freshherb-wreath-wo-genkan-ni"],
					calm: ["kaze-no-sanpomichi", "honemi-ni-shimiiru-karasukaze", "inorimichite", "muscat-to-shiroi-osara", "natsuzora-to-syukudai", "akindo", "yoru-no-niji", "akai-tsuchi-wo-funde", "burari-tokyo", "prism", "fuyu-no-jinkoueisei", "hatsuyuki", "kansen-gairo", "21seiki-no-hitobito", "haru-wo-machinagara", "go-go-go-summer", "sasurai-no-hitoritabi", "wakana", "zange-no-ma", "subarashii-nichijou", "asphalt", "madobe-no-hidamari", "minamoto", "sora-no-sakura", "suiu", "freshherb-wreath-wo-genkan-ni"],
					battle: ["back-water", "burning-heart", "hayate-no-sei", "ice-eyes", "ima-koso", "risky-area", "chiheisen-wo-koete", "moyase-toushi-yobisamase-tamashii", "naraku-heno-abyssmaze", "samurai-sword", "super-machine-soul", "uchuu-5239", "ultra-super-heros"]
				};

			function i(o) {
				if (!0 === G.volume.disable) return;
				const i = a[o],
					s = ++t;
				e = new Howl({
					src: `res/bgm/${o}.mp3`,
					sprite: {
						start: [0, i.loopStart, !i.loopLength && i.loop],
						loop: [i.loopStart, i.loopLength, i.loop]
					},
					volume: G.volume.music,
					autoplay: !1,
					onload: () => {
						t === s && (e.play("start"), n = o, i.loopLength && setTimeout(() => {
							t === s && e.play("loop")
						}, i.loopStart))
					}
				})
			}

			function s(e, t = 1e3) {
				!0 !== G.volume.disable && n !== e && r(t, () => {
					i(e)
				})
			}

			function r(a, o = (() => {})) {
				if (!0 === G.volume.disable) return;
				const i = ++t;
				e && e.fade(e.volume(), 0, a), n = null, setTimeout(() => {
					t === i && (e && e.stop(), o())
				}, a)
			}

			function l(e) {
				return o[e][Math.floor(Math.random() * o[e].length)]
			}
			return {
				ost: a,
				playing: function () {
					return n
				},
				play: function (e) {
					i(e)
				},
				playSmooth: function (e, t = 1e3) {
					s(e, t)
				},
				stop: function (e = 1e3) {
					r(e)
				},
				setVolume: function (t) {
					! function (t) {
						!0 !== G.volume.disable && e && e.volume(t)
					}(t)
				},
				playSmoothOrRandom: function (e) {
					if (!0 !== G.volume.disable)
						if ("RANDOM" === e) {
							const e = l("random");
							s(e), Be(e)
						} else if ("RANDOM" === e.substring(0, 6)) {
						if (!o[e.substring(6)]) return void c("invalid song selected. will not play!");
						const t = l(e.substring(6));
						s(t), Be(t)
					} else {
						if (!a[e]) return void c("invalid song selected. will not play!");
						s(e), Be(e)
					}
				}
			}
		}(),
		_t = {
			loadSpecialThanks: function () {
				r.get("/about/specialthanks.json", {}, !1).then(e => {
					let t = "";
					e.patrons.forEach(e => {
						t += `<div class="flex-item"><a class="credit_st ${e.username?`tetra_pop" data-hover="tap" data-hit="click" data-username="${e.username}"`:'noclick"'}>${e.flip?e.username.toUpperCase():e.name}</a><span class="jp_kana">${e.username&&e.username.toUpperCase()!==e.name?e.flip?e.name:e.username.toUpperCase():"　"}</span></div>`
					}), document.getElementById("specialthanks").innerHTML = t
				}, e => {
					document.getElementById("specialthanks").innerHTML = '<div class="flex-item">error fetching special thanks</div>'
				})
			},
			loadNews: function () {
				r.get("/api/tetra/news", {}, !0).then(e => {
					let t = "";
					e.news.forEach(e => {
						if (t += '<div class="tetra_news_item">', "leaderboard" === e.type) {
							let n = e.data.rank <= 3 ? `leaderboard${e.data.rank}` : "improvement",
								a = "";
							switch (e.data.gametype) {
								case "40l":
									const t = H(e.data.result);
									a = `time of <a class="replay_pop" data-hover="tap" data-hit="click" data-replay="R:${e.data.replayid}">${t.m}:${t.s}.${t.ms}</a>`;
									break;
								case "blitz":
									a = `score of <a class="replay_pop" data-hover="tap" data-hit="click" data-replay="R:${e.data.replayid}">${e.data.result}</a>`
							}
							t += `<img class="ns" src="/res/badges/${n}.png" /><a class="tetra_pop" data-hover="tap" data-hit="click" data-username="${e.data.username}">${e.data.username.toUpperCase()}</a> reached #${e.data.rank} in ${ya.longTypeNames[e.data.gametype]} with a ${a}`
						}
						t += `<div class="tetra_news_ts" title="${new Date(e.ts).toLocaleString()}">${N(Date.parse(e.ts))} ago</div></div>`
					}), "" === t && (t = '<div class="tetra_news_empty">NO NEWS</div>'), document.getElementById("tetra_news_content").innerHTML = t
				}, e => {
					document.getElementById("tetra_news_content").innerHTML = '<div class="tetra_news_empty">ERROR FETCHING NEWS</div>'
				})
			},
			loadTwitch: function () {
				r.get("/api/tetra/twitch", {}, !0).then(e => {
					let t = "";
					e.live.forEach(e => {
						t += `<a class="tetra_live_item" data-hover="tap" data-hit="click" href="https://www.twitch.tv/${U(e.login.replace('"',""))}" target="_blank" data-title="${U(e.title.replace('"',""))}">${U(e.username)}<span>${U(e.viewers)}</span><img src="${U(e.thumbnail.replace('"',""))}" /></a>`
					}), document.getElementById("tetra_live").classList.toggle("hidden", "" === t), document.getElementById("tetra_live_content").innerHTML = t
				}, () => {})
			},
			loadRecords: function (e, t) {
				return new Promise((n, a) => {
					He("fetching records…"), r.get(`/api/records/${encodeURIComponent(e.replace("CURRENTID",w.id()))}`, {}, !0).then(a => {
						Ne(),
							function (e, t, n) {
								const a = document.getElementById(`tetra_stream__${e}`);
								if (!a) throw "there is no holder?";
								a.innerHTML = "";
								let o = 1;
								if (t.forEach(t => {
										const i = H(t.endcontext.finalTime),
											s = t.endcontext.finalTime / 1e3 || 1,
											l = document.createElement("div");
										l.classList.add("scroller_block"), l.classList.add("record_item"), l.classList.add("ns"), l.setAttribute("data-hover", "hover"), l.setAttribute("data-hit", "hit3"), 1 === o && l.classList.add("record_first"), a.appendChild(l);
										const d = document.createElement("div");
										d.classList.add("record_grade"), d.classList.add("ns"), d.innerHTML = o, l.appendChild(d);
										const c = document.createElement("div");
										c.classList.add("record_owner"), c.innerHTML = e.includes("any_") ? ya.longTypeNames[t.endcontext.gametype] : t.user.username.toUpperCase(), l.appendChild(c);
										const m = document.createElement("div");
										m.classList.add("record_ts"), m.innerHTML = new Date(t.ts).toLocaleString(), l.appendChild(m);
										const g = document.createElement("div");
										switch (g.classList.add("record_result"), l.appendChild(g), t.endcontext.gametype) {
											case "40l":
												g.innerHTML = `${i.m}:${i.s}<span class="ms">.${i.ms}</span>`;
												break;
											case "blitz":
												g.innerHTML = `${t.endcontext.score}`
										}
										const p = document.createElement("div");
										p.classList.add("record_extra"), p.innerHTML = `<span>${t.endcontext.piecesplaced}</span> PCS - <span>${(t.endcontext.piecesplaced/s).toFixed(2)}</span> PPS`, l.appendChild(p), l.addEventListener("click", () => {
											He("fetching replay…"), r.get(`/api/games/${encodeURIComponent(t.replayid)}`, {}, !0).then(e => {
												Ne(), et.showResults(e.game.endcontext, {
													gametype: e.game.endcontext.gametype,
													back: n,
													isreplay: !0,
													username: e.game.user.username,
													ts: e.game.ts,
													replay: e.game
												})
											}, e => {
												Ne(), u(e)
											})
										}), o++
									}), !t.length) {
									const e = document.createElement("div");
									e.classList.add("scroller_block"), e.classList.add("ns"), e.classList.add("nothing"), e.innerHTML = "NO RECORDS", a.appendChild(e)
								}
							}(e, a.records.slice(0, 100), t), n(a)
					}, e => {
						Ne(), u(e), a()
					})
				})
			},
			loadUserList: function (e, t) {
				return new Promise((n, a) => {
					He("fetching players…"), r.get(t, {}, !0).then(a => {
						Ne(),
							function (e, t, n) {
								const a = document.getElementById(e);
								if (!a) throw "there is no holder?";
								a.innerHTML = "";
								let o = 1;
								if (t.forEach(e => {
										if ("/api/users/by/xp" === n && (!e.xp || "anon" === e.role || "bot" === e.role)) return;
										const t = document.createElement("div");
										t.classList.add("scroller_block"), t.classList.add("ns"), t.classList.add("record_item"), t.setAttribute("data-hover", "hover"), t.setAttribute("data-hit", "hit3"), 1 === o && t.classList.add("record_first"), a.appendChild(t);
										const i = document.createElement("div");
										i.classList.add("record_grade"), i.classList.add("ns"), i.innerHTML = o, t.appendChild(i);
										const s = document.createElement("div");
										if (s.classList.add("record_owner"), s.innerHTML = `${e.username.toUpperCase()}${e.supporter?'<img src="/res/supporter-tag.png" title="This person is supporting TETR.IO ♥" />':""}`, t.appendChild(s), "/api/users/by/xp" === n) {
											const n = document.createElement("div");
											n.classList.add("record_ts"), n.innerHTML = `${bt(e.xp)}% TOWARDS NEXT LEVEL`, t.appendChild(n);
											const a = document.createElement("div");
											a.classList.add("record_result"), t.appendChild(a), a.innerHTML = It(vt(e.xp));
											const o = document.createElement("div");
											o.classList.add("record_extra"), o.innerHTML = `<span>${Math.floor(e.xp)}</span> XP`, t.appendChild(o)
										} else if ("/api/users/by/league" === n) {
											const n = document.createElement("div");
											n.classList.add("record_ts"), n.innerHTML = `<span>${e.league.gameswon}</span> / ${e.league.gamesplayed} games won (<span>${Math.floor(e.league.gameswon/e.league.gamesplayed*1e4)/100}</span>%)`, t.appendChild(n);
											const a = document.createElement("div");
											a.classList.add("record_result"), t.appendChild(a), a.innerHTML = `${Math.round(e.league.rating)}<span>TR</span> <img src="/res/league-ranks/${e.league.rank}.png" />`, a.title = e.league.rating;
											const o = document.createElement("div");
											o.classList.add("record_extra"), o.innerHTML = `glicko: <span>${e.league.glicko}</span>±<span class="${e.league.rd>=98?"rdwarning":""}">${e.league.rd}</span>`, t.appendChild(o)
										}
										t.addEventListener("click", () => {
											Et({
												userID: e._id
											})
										}), o++
									}), !t.length) {
									const e = document.createElement("div");
									e.classList.add("scroller_block"), e.classList.add("ns"), e.classList.add("nothing"), e.innerHTML = "NO PLAYERS", a.appendChild(e)
								}
							}(e, a.users, t), n(a)
					}, e => {
						Ne(), u(e), a()
					})
				})
			},
			navigateToShortID: function (e) {
				if (/(^R:.+$)/.test(e)) {
					const t = e.replace("R:", "");
					He("fetching replay…"), r.get(`/api/games/${encodeURIComponent(t)}/short`, {}, !0).then(e => {
						Ne(), ft.playSmooth(document.body.classList.contains("inpair") || document.body.classList.contains("matchmaking") ? "touhoudaiensei" : "shikiichi-made-mousukoshi"), et.showResults(e.game.endcontext, {
							gametype: e.game.endcontext.gametype,
							back: "tetra",
							isreplay: !0,
							username: e.game.user.username,
							ts: e.game.ts,
							replay: e.game
						})
					}, e => {
						Ne(), u(e)
					})
				} else Et({
					username: e.toLowerCase()
				})
			}
		};

	function Et(e) {
		const t = document.createElement("div");
		t.classList.add("oob_modal"), t.classList.add("tetra_modal"), t.classList.add("hidden"), t.classList.add("busy"), document.getElementById("dialogs").appendChild(t), setTimeout(() => {
			t.classList.remove("hidden"), pe.push(), pe.bindGuide(he.tetra_dialog)
		}, 1);
		const n = () => {
			r.get(`/api/users/${encodeURIComponent(e.userID)}`, {}, !0).then(n => {
				const a = document.createElement("h2");
				if (a.innerHTML = `${n.user.username.toUpperCase()}${n.user.verified?'<img src="/res/verified.png" title="Verified" />':""}`, t.appendChild(a), !["anon", "bot"].includes(n.user.role)) {
					const e = document.createElement("h3");
					e.innerHTML = n.user.ts ? `JOINED ${N(Date.parse(n.user.ts)).toUpperCase()} AGO` : "HERE SINCE THE BEGINNING", t.appendChild(e)
				}
				const o = document.createElement("div");
				let i, s;
				if (o.classList.add("tetra_modal_close"), o.classList.add("ns"), o.innerHTML = "CLOSE", o.setAttribute("data-hover", "tap"), o.setAttribute("data-hit", "click"), t.appendChild(o), o.addEventListener("click", () => {
						v(t)
					}), n.user._id == w.id() && Bt !== n.user.xp && (wt(vt(n.user.xp), document.getElementById("me_level")), Tt(n.user.xp - Bt, !0)), i = n.user.gameswon > -1 && n.user.gamesplayed > -1 ? `<div class="tetra_tag_record" title="Online games won / online games played"><span>${n.user.gameswon}</span> / ${n.user.gamesplayed}</div>` : n.user.gameswon > -1 ? `<div class="tetra_tag_record" title="Online games won"><span>${n.user.gameswon}</span></div>` : n.user.gamesplayed > -1 ? `<div class="tetra_tag_record" title="Online games played">${n.user.gamesplayed}</div>` : "", s = n.user.gametime > -1 ? `<div class="tetra_tag_gametime" title="Total time played">${P(n.user.gametime)}</div>` : "", !["anon", "bot"].includes(n.user.role)) {
					const e = document.createElement("div");
					e.classList.add("tetra_tag_holder"), e.classList.add("ns"), e.innerHTML = `${"admin"===n.user.role?'<img class="mod_badge" src="/res/administrator.png" title="This person is a TETR.IO Administrator." alt="Administrator" />':""}${"mod"===n.user.role?'<img class="mod_badge" src="/res/moderator.png" title="This person is a TETR.IO Moderator." alt="Moderator" />':""}${It(vt(n.user.xp))}${s}${i}${n.user.supporter?'<img class="supporter_badge" src="/res/supporter.png" title="This person is supporting TETR.IO ♥" alt="Supporter" />':""}`, t.appendChild(e)
				}
				if (n.user.badstanding) {
					const e = document.createElement("div");
					e.classList.add("tetra_badstanding"), e.classList.add("ns"), e.innerHTML = "<h1>BAD STANDING</h1><p>one or more recent bans on record</p>", t.appendChild(e)
				}
				if (n.user.badges && n.user.badges.length) {
					const e = document.createElement("div");
					e.classList.add("tetra_badge_holder"), e.classList.add("ns"), t.appendChild(e), n.user.badges.forEach(t => {
						const n = document.createElement("img");
						n.classList.add("tetra_badge"), n.src = `/res/badges/${t.id}.png`, t.ts ? n.title = `${t.label}\n\nAchieved on ${new Date(t.ts).toLocaleString()}` : n.title = t.label, e.appendChild(n)
					})
				}
				if (e.buttons = e.buttons || [], n.user._id == w.id() || w.anon() || e.buttons.push({
						label: "report",
						classes: [],
						callback: e => {
							e(), E({
								title: `REPORT ${n.user.username.toUpperCase()}`,
								msg: `please explain briefly why you are reporting ${n.user.username.toUpperCase()} to the TETR.IO moderators below. repeatedly placing false reports may result in a ban.<br><textarea data-escape="request_report_cancel" data-enter="request_report_submit" id="request_report" placeholder="REASON"></textarea>`,
								classes: ["ban_modal"],
								buttons: [{
									label: "CANCEL",
									classes: [],
									id: "request_report_cancel",
									callback: e => {
										e()
									}
								}, {
									label: "SUBMIT",
									classes: ["pri"],
									id: "request_report_submit",
									callback: e => {
										e(), r.post("/api/reports/submit", {
											target: n.user.username,
											type: "tetra_modal",
											reason: document.getElementById("request_report").value
										}, !0).then(e => {
											m("report sent! thank you for your help in keeping TETR.IO safe.")
										}, e => {
											u(e)
										})
									}
								}]
							}), document.getElementById("request_report").focus()
						}
					}), e.buttons.length) {
					const n = document.createElement("div");
					n.classList.add("tetra_button_holder"), n.classList.add("flex-row"), n.classList.add("ns"), t.appendChild(n), e.buttons.forEach(e => {
						const a = document.createElement("div");
						a.classList.add("tetra_button"), a.classList.add("flex-item"), a.innerHTML = e.label, e.classes.forEach(e => {
							a.classList.add(e)
						}), a.addEventListener("click", () => {
							e.callback(() => {
								v(t)
							})
						}), n.appendChild(a)
					})
				}
				if ("anon" === n.user.role) {
					const e = document.createElement("div");
					e.classList.add("tetra_modal_warning"), e.innerHTML = "this user is playing anonymously", t.appendChild(e)
				} else if ("bot" === n.user.role) {
					const e = document.createElement("div");
					e.classList.add("tetra_modal_warning"), e.innerHTML = `<h1>BOT</h1><br><br>this is a known bot. all bots must have this tag, or it and its owners will be permanently banned.${n.user.botmaster?`<br><br>this bot is operated by <b>${n.user.botmaster}</b>`:""}`, t.appendChild(e)
				} else {
					const e = document.createElement("div");
					if (e.classList.add("tetra_modal_records"), t.appendChild(e), 0 !== n.user.league.gamesplayed) {
						const t = document.createElement("div");
						t.classList.add("tetra_modal_record"), t.classList.add("tetra_modal_record_league"), n.user.league.gamesplayed >= 10 ? (t.innerHTML = `<h4>TETRA LEAGUE</h4><img src="/res/league-ranks/${n.user.league.rank}.png" /><h5 title="${n.user.league.rating}">${Math.round(n.user.league.rating)}<span class="ms">TR</span>${-1!==n.user.league.standing?` <span class="league_placement_inline${1===n.user.league.standing?" t1":""}${n.user.league.standing>1&&n.user.league.standing<=100?" t100":""}">#<span>${n.user.league.standing}</span></span>`:""}</h5><h3>glicko: <span title="Their raw rating in the Glicko-2 system. Higher is better.">${n.user.league.glicko}</span>±<span title="How uncertain the Glicko-2 system is of their rating. Lower is better.">${n.user.league.rd}</span> - games won: <span>${n.user.league.gameswon}</span> / ${n.user.league.gamesplayed} (<span>${Math.floor(n.user.league.gameswon/n.user.league.gamesplayed*1e4)/100}</span>%)</h3><h4><span title="Attack Per Minute, over the last 10 games.">${n.user.league.apm||"---"}</span> apm<br><span title="Pieces Per Second, over the last 10 games.">${n.user.league.pps||"---"}</span> pps<br><span title="Versus Score (a general metric of versus skill), over the last 10 games.">${n.user.league.vs||"---"}</span> vs</h4>`, t.classList.add("tetra_modal_record_league_active")) : t.innerHTML = `<h6>TETRA LEAGUE</h6><h5>${n.user.league.gamesplayed}<span class="ms">/10 rating games played</span></h5>`, e.appendChild(t)
					}
					const a = document.createElement("div");
					if (a.classList.add("tetra_modal_record"), n.user.records["40l"].record) {
						const e = H(n.user.records["40l"].record.endcontext.finalTime);
						a.innerHTML = `<h6>${ya.longTypeNames["40l"]}</h6><h5>${e.m}:${e.s}<span class="ms">.${e.ms}</span></h5>${n.user.records["40l"].rank?`<h4>#${n.user.records["40l"].rank}</h4>`:""}`
					} else a.innerHTML = `<h6>${ya.longTypeNames["40l"]}</h6><h5>---</h5>`;
					e.appendChild(a);
					const o = document.createElement("div");
					o.classList.add("tetra_modal_record"), n.user.records.blitz.record ? o.innerHTML = `<h6>${ya.longTypeNames.blitz}</h6><h5>${n.user.records.blitz.record.endcontext.score}</h5>${n.user.records.blitz.rank?`<h4>#${n.user.records.blitz.rank}</h4>`:""}` : o.innerHTML = `<h6>${ya.longTypeNames.blitz}</h6><h5>---</h5>`, e.appendChild(o)
				}
				t.classList.remove("busy"), pe.rebind()
			}, e => {
				u(e), v(t)
			})
		};
		return e.userID ? n() : r.get(`/api/users/${encodeURIComponent(e.username)}/resolve`, {}, !0).then(t => {
			e.userID = t._id, n()
		}, e => {
			u(e), v(t)
		}), document.getElementById("dialogs").classList.remove("hidden"), Xe(), t
	}

	function vt(e) {
		return Math.pow(e / 500, .6) + e / (5e3 + Math.max(0, e - 4e6) / 5e3) + 1
	}

	function bt(e) {
		return Math.floor(vt(e) % 1 * 100)
	}

	function It(e, t = "") {
		const n = Math.floor(e),
			a = n - 1,
			o = e % 1;
		if (a >= 5e3) return `<div class="leveltag ns lt_golden">${n}</div>`;
		const i = Math.floor(a / 10) % 10,
			s = Math.floor(a / 100) % 5,
			r = Math.floor(a / 500) % 10;
		return `<div ${t} title="${Math.floor(100*o)}% towards next level" class="leveltag ns lt_shape_${s} lt_badge_color_${r} lt_shape_color_${i}">${n}</div>`
	}

	function wt(e, t) {
		const n = Math.floor(e),
			a = n - 1,
			o = e % 1;
		if (t.innerHTML = n, a >= 5e3) return void(t.className = "leveltag ns lt_golden");
		const i = Math.floor(a / 10) % 10,
			s = Math.floor(a / 100) % 5,
			r = Math.floor(a / 500) % 10;
		t.className = `leveltag ns lt_shape_${s} lt_badge_color_${r} lt_shape_color_${i}`, t.title = `${Math.floor(100*o)}% towards next level`
	}

	function kt(e) {
		const t = Math.floor(e) - 1;
		if (5e3 == t) return yt.play("level500"), void setTimeout(() => {
			yt.play("levelup"), yt.play("allclear"), yt.play("worldrecord")
		}, 750);
		t >= 5e3 ? yt.play("level1") : t % 500 != 0 ? t % 100 != 0 ? t % 10 != 0 ? yt.play("level1") : yt.play("level10") : yt.play("level100") : yt.play("level500")
	}

	function Lt(e) {
		const t = Math.floor(e) - 1;
		return 5e3 == t ? "MAX LEVEL!" : t >= 5e3 ? "LEVEL UP!" : t % 500 == 0 ? "DISTINGUISHED!" : t % 100 == 0 ? "PROMOTED!" : t % 10 == 0 ? "NEW BADGE!" : "LEVEL UP!"
	}

	function xt(e, t) {
		if (document.body.classList.contains("anon")) return;
		const n = vt(e),
			a = vt(t),
			o = Math.floor(n) !== Math.floor(a),
			i = n % 1,
			s = o ? 1 : a % 1;
		wt(n, document.getElementById("me_leveling_current")), document.getElementById("me_leveling").classList.remove("levelingup"), document.getElementById("me_leveling_amt").innerHTML = `+${t-e} xp`, document.getElementById("me_leveling_message").classList.add("hidden"), document.getElementById("me_leveling_fg").style.right = `calc(${.4*i-.2}em + ${100-100*i}%)`, document.getElementById("me_leveling").getBoundingClientRect(), document.getElementById("me_leveling").classList.remove("hidden"), setTimeout(() => {
			document.getElementById("me_leveling_fg").style.right = `calc(${.4*s-.2}em + ${100-100*s}%)`, wt(a, document.getElementById("me_level"))
		}, 750), o ? (document.getElementById("me_leveling_message").innerHTML = Lt(a), setTimeout(() => {
			document.getElementById("me_leveling_message").classList.remove("hidden"), document.getElementById("me_leveling").classList.add(5001 === Math.floor(a) ? "maxlevel" : "levelingup"), kt(a)
		}, 1750), setTimeout(() => {
			wt(a, document.getElementById("me_leveling_current"));
			const e = document.getElementById("me_leveling").getBoundingClientRect();
			pn(e.left + e.width / 2, 0, "#FFEA00", 10, 1.5, .5, e.width, 0, .02, 85, 95, 0, 400, 0, .15, 0, .1, !0), yn(e.left + e.width / 2, 0, "#FFEA00", 10, 1.5, .5, e.width, 0, .02, 85, 95, 0, 400, 0, .15, 0, .1, !0), hn(e.left + e.width / 2, 0, "#FFEA00", 15, .18, .14, e.width, 0, .25, 85, 95, 0, 200, 100, .15, 0, .9, !0)
		}, 2500), setTimeout(() => {
			document.getElementById("me_leveling").classList.add("hidden"), document.getElementById("me_leveling").classList.remove(5001 === Math.floor(a) ? "maxlevel" : "levelingup")
		}, 5001 === Math.floor(a) ? 16750 : 6750)) : setTimeout(() => {
			document.getElementById("me_leveling").classList.add("hidden")
		}, 3e3)
	}
	let Bt = 0;

	function Tt(e, t = !1) {
		e = Math.floor(e), !t && e && xt(Bt, Bt + e), Bt += e
	}
	const Ft = function () {
		let e, t, n;
		const a = [];
		let o = !1,
			i = !1,
			s = !1,
			r = Date.now(),
			l = null;

		function c() {
			o = !0
		}
		return {
			on: (e, n) => {
				a.push([e, n]), t && t.on(e, n)
			},
			once: (e, n) => {
				t && t.once(e, n)
			},
			off: (e, n) => {
				t && t.off(e, n)
			},
			socket: function () {
				return t
			},
			emit: function (e, n) {
				t.emit(e, n)
			},
			connect: function () {
				e = new io.Manager(`${location.protocol}//${location.host}/socket.io`, {
					autoConnect: !1,
					reconnection: !1,
					parser: msgPackEncoder
				}), t = e.socket("/", {}), a.forEach(e => {
					t.on(e[0], e[1])
				}), t.on("replay", () => {
					r = Math.max(r, Date.now())
				}), t.on("startmulti", () => {
					s = !0, r = Math.max(r, Date.now() + 8e3), l && clearInterval(l), l = setInterval(() => {
						s && Date.now() - r > 6e3 && Mt("silence")
					}, 200)
				}), t.on("endmulti", () => {
					s = !1, r = Math.max(r, Date.now()), l && clearInterval(l)
				}), t.on("connect", () => {
					i = !0, n = t.id, t.emit("authorize", {
						token: w.token(),
						handling: G.handling,
						signature: TETRIO_ENV,
						i: I.i()
					})
				}), t.on("kick", e => {
					Ue(), Fe("home", !0), i = !1, c(), "OUTDATED" !== e.reason ? "BANNED" !== e.reason ? "you were kicked from the room by its owner" !== e.reason ? E({
						title: "CONNECTION ERROR",
						classes: ["noclickout"],
						msg: `the server has disconnected you.</p><p>REASON: ${e.reason}</p><p>please check your internet connection. if this seems to be an error, please report it</p><p class="modal_also">SOCKET ID: ${n}`,
						buttons: [{
							label: "OK",
							classes: [],
							callback: e => {
								e(), b = !0, location.reload()
							}
						}]
					}) : E({
						title: "KICKED BY ROOM OWNER",
						classes: ["noclickout"],
						msg: `you were kicked from the room by its owner.</p><p class="modal_also">SOCKET ID: ${n}`,
						buttons: [{
							label: "OK",
							classes: [],
							callback: e => {
								e(), I.update(!0)
							}
						}]
					}) : E({
						title: "KICKED BY MODERATOR",
						msg: `a TETR.IO moderator or administrator has kicked you from the server. please reload to see the status of your account.</p><p class="modal_also">SOCKET ID: ${n}`,
						classes: ["ban_modal", "noclickout"],
						buttons: [{
							label: "RELOAD",
							classes: [],
							callback: e => {
								e(), I.update(!0)
							}
						}]
					}) : E({
						title: "UPDATE REQUIRED",
						classes: ["noclickout"],
						msg: `an update is required to connect to multiplayer servers. click below to update!</p><p class="modal_also">SOCKET ID: ${n}`,
						buttons: [{
							label: "UPDATE NOW",
							classes: [],
							callback: e => {
								e(), I.update()
							}
						}]
					})
				}), t.on("announcement", e => {
					switch (e.type) {
						case "announcement":
							yt.play("notify"), d({
								msg: e.msg,
								color: "#FFCC00",
								icon: "announcement",
								timeout: 1e4
							}), jt.showAnnouncement(e.msg);
							break;
						case "maintenance":
							yt.play("maintenance"), document.body.classList.add("maintenance"), d({
								msg: e.msg,
								color: "#FF5200",
								icon: "maintenance",
								timeout: 15e3
							})
					}
				}), t.on("reload", () => {
					I.update()
				}), t.on("rejected", () => {
					Mt("rejected", 5e3)
				}), t.on("pong", e => {
					e > 500 && Mt("delay"), Qe.addPing(e), r = Math.max(r, Date.now())
				}), t.on("pni", e => {
					Mt(e.type, e.timeout)
				}), t.on("disconnect", e => {
					i = !1, d({
						msg: "disconnected from server",
						color: "#FF783C",
						icon: "disconnect"
					}), o || (Ue(), Fe("home", !0), E({
						title: "CONNECTION ERROR",
						classes: ["noclickout"],
						msg: `a connection error has occured and the connection was closed unexpectedly.</p><p>check your internet connection or report this issue</p><p>REASON: ${e}</p><p class="modal_also">SOCKET ID: ${n}`,
						buttons: [{
							label: "OK",
							classes: [],
							callback: e => {
								e(), b = !0, location.reload()
							}
						}]
					})), o = !1, s = !1, r = Math.max(r, Date.now()), l && clearInterval(l)
				}), e.open(), t.connect()
			},
			disconnect: function () {
				t.disconnect()
			},
			expectDisconnect: c,
			isConnected: () => i
		}
	};

	function Mt(e, t = 100) {
		document.getElementById(`network_${e}`).classList.add("ping"), setTimeout(() => {
			document.getElementById(`network_${e}`).classList.remove("ping")
		}, t)
	}
	const St = {
			random: {
				id: "random",
				label: "RANDOMS",
				algorithm: (e, t) => {
					return [e[Math.floor(Math.random() * e.length)].context.listenID]
				}
			},
			elims: {
				id: "elims",
				label: "ELIMINATIONS",
				algorithm: (e, t) => {
					const n = [];
					e.forEach(e => {
						n.push({
							id: [e.context.listenID],
							amt: e.game.highest()
						})
					}), n.sort((e, t) => e.amt - t.amt);
					const a = [];
					for (let e = 0; e < Math.min(10, n.length); e++)
						for (let t = 0; t < n.length - e; t++) a.push(n[e].id);
					return a[Math.floor(Math.random() * a.length)]
				}
			},
			best: {
				id: "best",
				label: "PROS",
				algorithm: (e, t) => {
					const n = [];
					e.forEach(e => {
						n.push({
							id: [e.context.listenID],
							amt: e.game.highest()
						})
					}), n.sort((e, t) => t.amt - e.amt);
					const a = [];
					for (let e = 0; e < Math.min(10, n.length); e++)
						for (let t = 0; t < n.length - e; t++) a.push(n[e].id);
					return a[Math.floor(Math.random() * a.length)]
				}
			},
			payback: {
				id: "payback",
				label: "PAYBACK",
				algorithm: (e, t) => {
					let n = [];
					return t && e.forEach(e => {
						[e.context.listenID][0] === t.game.garbagestats().lastattacker[0] && (n = [e.context.listenID])
					}), n.length || (n = [e[Math.floor(Math.random() * e.length)].context.listenID]), n
				}
			},
			even: {
				id: "even",
				label: "EVEN",
				algorithm: (e, t) => {
					const n = [];
					e.forEach(e => {
						n.push({
							id: [e.context.listenID],
							amt: e.game.garbagestats().garbagereceived
						})
					}), n.sort((e, t) => e.amt - t.amt);
					const a = [];
					for (let e = 0; e < Math.min(10, n.length); e++)
						for (let t = 0; t < n.length - e; t++) a.push(n[e].id);
					return a[Math.floor(Math.random() * a.length)]
				}
			},
			first: {
				id: "first",
				label: "FIRST IDK",
				algorithm: (e, t) => [e[0].context.listenID]
			}
		},
		Ct = (() => {
			let e, t = !1,
				n = [],
				a = 0,
				o = !1,
				i = null;
			const s = {
				maytarget: !0,
				strategies: ["even", "elims", "random", "payback"]
			};

			function r() {
				document.getElementById("diyusi_strategy_1").querySelector("p").textContent = St[s.strategies[0]].label, document.getElementById("diyusi_strategy_2").querySelector("p").textContent = St[s.strategies[1]].label, document.getElementById("diyusi_strategy_3").querySelector("p").textContent = St[s.strategies[2]].label, document.getElementById("diyusi_strategy_4").querySelector("p").textContent = St[s.strategies[3]].label, document.getElementById("diyusi_strategy_1").classList.toggle("active", 0 === a && !o), document.getElementById("diyusi_strategy_2").classList.toggle("active", 1 === a && !o), document.getElementById("diyusi_strategy_3").classList.toggle("active", 2 === a && !o), document.getElementById("diyusi_strategy_4").classList.toggle("active", 3 === a && !o), document.getElementById("diyusi").classList.toggle("hasextra", o),
					function (e) {
						if ((e = e && t) === c) return;
						e ? (document.getElementById("diyusi").classList.remove("hidden"), document.getElementById("diyusi").classList.remove("hiding")) : (document.getElementById("diyusi").classList.add("hiding"), setTimeout(() => {
							document.getElementById("diyusi").classList.add("hidden")
						}, 500));
						c = e
					}(t && s.maytarget && e.games.others.length > 1)
			}

			function l() {
				document.getElementById("diyusi").classList.add("ping"), setTimeout(() => {
					document.getElementById("diyusi").classList.remove("ping")
				}, 150)
			}

			function d() {
				e.games.others.forEach(a => {
					a.game.setTargeted(t && s.maytarget && e.games.others.length > 1 && n.includes(a.context.listenID))
				})
			}
			let c = !1;

			function m(t) {
				if (o) {
					let i = !1;
					if (e.games.others.forEach(e => {
							n[0] == e.context.listenID && (i = !0)
						}), i) return void(t && (d(), u()));
					o = !1, a = "random", r(), l(), d(), u()
				}
				let i = [];
				1 === e.games.others.length && (i = [e.games.others[0].context.listenID]), e.games.others.length > 1 && (St[s.strategies[a]] || (a = 0, r()), i = St[s.strategies[a]] ? St[s.strategies[a]].algorithm(e.games.others, e.games.self) : [e.games.others[0].context.listenID]), (JSON.stringify(i) != JSON.stringify(n) || t) && (n = i, d(), u())
			}

			function u() {
				e.games.self && e.games.self.game.setTargets(n)
			}
			return {
				options: s,
				enabled: function (e) {
					t = e, r(), d(), l()
				},
				setMultiplex: function (t) {
					e = t
				},
				setStrategy: function (n, i = !1) {
					t && (o = !1, a = n, r(), m(!0), l(), !i && e.games.others.length >= 2 && yt.play("target"))
				},
				setManual: function (e) {
					t && (o = !0, n = [e], r(), m(!0), l(), yt.play("target"))
				},
				retarget: function () {
					m(!1)
				},
				reflow: function () {
					r(), d()
				},
				startTimer: function () {
					null === i && (i = setInterval(m, 1500))
				},
				stopTimer: function () {
					clearInterval(i), i = null
				}
			}
		})();
	I.ready(() => {
		function e(e) {
			e.repeat || document.body.classList.contains("chatfocus") || Object.keys(X).forEach(t => {
				if (X[t].includes(ce(e) || e.detail.toUpperCase())) switch (t) {
					case "target1":
						Ct.setStrategy(0, !1);
						break;
					case "target2":
						Ct.setStrategy(1, !1);
						break;
					case "target3":
						Ct.setStrategy(2, !1);
						break;
					case "target4":
						Ct.setStrategy(3, !1)
				}
			})
		}
		document.addEventListener("keydown", e, !1), document.addEventListener("gpdown", e, !1)
	});
	let Rt = 0;
	I.ready(() => {
		document.getElementById("grid_spectate").addEventListener("click", (function (e) {
			Ht && (Date.now() - Rt < 1e3 ? e.stopPropagation() : null !== Ht.getSpectating() ? (Ht.setSpectating(null), Ht.order()) : e.stopPropagation())
		})), document.getElementById("next_spectate").addEventListener("click", (function (e) {
			if (!Ht) return;
			if (Date.now() - Rt < 1e3) return void e.stopPropagation();
			let t = !1;
			for (let e = 0; e < Ht.games.others.length; e++)
				if (Ht.games.others[e].context.user.username === Ht.getSpectating()) {
					const n = Ht.games.others[(e + 1) % Ht.games.others.length];
					if (!n) continue;
					Ht.setSpectating(n.context.user.username), t = !0;
					break
				} if (!t) {
				const e = Ht.games.others[0];
				e && Ht.setSpectating(e.context.user.username)
			}
			Ht.order()
		})), document.getElementById("prev_spectate").addEventListener("click", (function (e) {
			if (!Ht) return;
			if (Date.now() - Rt < 1e3) return void e.stopPropagation();
			let t = !1;
			for (let e = 0; e < Ht.games.others.length; e++)
				if (Ht.games.others[e].context.user.username === Ht.getSpectating()) {
					const n = Ht.games.others[(e - 1) % Ht.games.others.length];
					if (!n) continue;
					Ht.setSpectating(n.context.user.username), t = !0;
					break
				} if (!t) {
				const e = Ht.games.others[Ht.games.others.length - 1];
				e && Ht.setSpectating(e.context.user.username)
			}
			Ht.order()
		})), document.getElementById("exit_spectate").addEventListener("click", (function (e) {
			Ht && (Date.now() - Rt < 1e3 ? e.stopPropagation() : (Ht.games.others.forEach(e => {
				e.game.end()
			}), jt.leaveRoom(), jt.dropMultiplex()))
		})), document.getElementById("zen_spectate").addEventListener("click", (function (e) {
			Ht && (Date.now() - Rt < 1e3 ? e.stopPropagation() : (Ht.games.others.forEach(e => {
				e.game.end()
			}), jt.dropMultiplex(), et.playZen({
				inroom: !0,
				roomname: document.getElementById("room_content_name").innerText
			}), ie(!0)))
		})), document.addEventListener("keydown", e => {
			e.repeat || document.getElementById("spectate").classList.contains("hidden") || document.body.classList.contains("chatfocus") || Object.keys(X).forEach(t => {
				if (X[t].includes(ce(e) || e.detail.toUpperCase())) switch (t) {
					case "moveLeft":
					case "rotateCCW":
						document.getElementById("prev_spectate").click();
						break;
					case "moveRight":
					case "rotateCW":
						document.getElementById("next_spectate").click();
						break;
					case "softDrop":
					case "hardDrop":
						document.getElementById("grid_spectate").click();
						break;
					case "exit":
						document.getElementById("exit_spectate").classList.includes("blocked") || document.getElementById("exit_spectate").click()
				}
			})
		}, !1)
	});
	const At = (e, t) => {
			const n = e.socket(),
				a = {
					self: null,
					others: []
				};
			let o = null;

			function i(e, t, n) {
				w.username() == e ? !1 !== G.video.kos && h({
					msg: null !== t.name ? `ko'd by ${t.name.toUpperCase()}` : "you ko'd yourself",
					fgcolor: "#FF2222",
					bgcolor: "#FFFFFF",
					timeout: 5e3
				}) : w.username() == t.name && !1 !== G.video.kos ? (yt.play("elim"), h({
					msg: `ko'd ${e.toUpperCase()}${n>=250?` <span class="fire">${Math.ceil(n/7)}%</span>`:""}`,
					fgcolor: "#FFFFFF",
					bgcolor: "#FF2222",
					timeout: 3e3
				})) : yt.play("death"), f({
					victim: e,
					killer: t.name,
					type: t.type
				});
				const o = {
					playercount: a.others.length + (a.self ? 1 : 0),
					victim: e,
					killer: t,
					fire: n
				};
				a.self && a.self.game.kev(o), a.others.forEach(e => {
					e.game.kev(o)
				})
			}
			const s = .8,
				r = .5,
				l = 1.6;

			function d() {
				if (a.self) {
					if (document.getElementById("spectate").classList.add("hidden"), document.body.classList.remove("spectating"), 0 === a.others.length) return;
					if (1 === a.others.length && G.video.sidebyside) return a.self.game.location(-.35, 0, 1), a.others[0].game.location(.45, 0, 1), void a.others[0].game.changeDisplayMode("full");
					const e = c(a.others.length);
					a.self.game.location(0, 0, 1);
					for (let t = 0; t < a.others.length; t++) a.others[t].game.location(e[t].x, e[t].y, e[t].s), a.others[t].game.changeDisplayMode(a.others.length >= 4 || G.video.alwaystiny || "minimal" === G.video.graphics ? "tiny" : "small")
				} else {
					if (0 === a.others.length) return document.getElementById("spectate").classList.add("hidden"), void document.body.classList.remove("spectating");
					if (document.getElementById("spectate").classList.contains("hidden") && (Rt = Date.now()), document.getElementById("spectate").classList.remove("hidden"), document.body.classList.add("spectating"), 1 === a.others.length) return a.others[0].game.location(0, 0, 1), a.others[0].game.changeDisplayMode("full"), void(document.getElementById("data_spectate").innerHTML = `spectating <span>${a.others[0].context.user.username.toUpperCase()}</span>`);
					if (2 === a.others.length && G.video.sidebyside) {
						if (o) {
							let e = !1;
							for (let t = 0; t < a.others.length; t++) a.others[t].context.user.username === o ? (a.others[t].game.location(-.35, 0, 1), a.others[t].game.changeDisplayMode("full"), e = !0) : (a.others[t].game.location(.45, 0, 1), a.others[t].game.changeDisplayMode("full"));
							if (!e) return a.others[0].game.location(-.35, 0, 1), a.others[0].game.changeDisplayMode("full"), a.others[1].game.location(.45, 0, 1), a.others[1].game.changeDisplayMode("full"), void(document.getElementById("data_spectate").innerHTML = `spectating <span>${a.others[0].context.user.username.toUpperCase()}</span> VS <span>${a.others[1].context.user.username.toUpperCase()}</span>`);
							document.getElementById("data_spectate").innerHTML = `spectating <span>${o.toUpperCase()}</span>`
						} else a.others[0].game.location(-.35, 0, 1), a.others[0].game.changeDisplayMode("full"), a.others[1].game.location(.45, 0, 1), a.others[1].game.changeDisplayMode("full"), document.getElementById("data_spectate").innerHTML = `spectating <span>${a.others[0].context.user.username.toUpperCase()}</span> VS <span>${a.others[1].context.user.username.toUpperCase()}</span>`;
						return
					}
					if (o) {
						let e = c(a.others.length),
							t = !1;
						for (let e = 0; e < a.others.length; e++) a.others[e].context.user.username === o && (t = !0);
						t && (e = c(a.others.length - 1));
						let n = 0,
							i = !1;
						for (let t = 0; t < a.others.length; t++) a.others[t].context.user.username === o ? (i = !0, a.others[t].game.location(0, 0, 1), a.others[t].game.changeDisplayMode("full")) : (a.others[t].game.location(e[n].x, e[n].y, e[n].s), a.others[t].game.changeDisplayMode(a.others.length >= 9 || G.video.alwaystiny || "minimal" === G.video.graphics ? "tiny" : "small"), n++);
						if (!i) {
							const e = c(a.others.length, !0);
							for (let t = 0; t < a.others.length; t++) a.others[t].game.location(e[t].x, e[t].y, e[t].s), a.others[t].game.changeDisplayMode(a.others.length >= 9 || G.video.alwaystiny || "minimal" === G.video.graphics ? "tiny" : "small");
							return void(document.getElementById("data_spectate").innerHTML = `spectating <span>${a.others.length}</span> PLAYERS`)
						}
						document.getElementById("data_spectate").innerHTML = `spectating <span>${o.toUpperCase()}</span>`
					} else {
						const e = c(a.others.length, !0);
						for (let t = 0; t < a.others.length; t++) a.others[t].game.location(e[t].x, e[t].y, e[t].s), a.others[t].game.changeDisplayMode(a.others.length >= 9 || G.video.alwaystiny || "minimal" === G.video.graphics ? "tiny" : "small");
						document.getElementById("data_spectate").innerHTML = `spectating <span>${a.others.length}</span> PLAYERS`
					}
				}
			}

			function c(e, t = !1) {
				const n = e >= 30,
					a = e >= 9 || G.video.alwaystiny || "minimal" === G.video.graphics ? r : s;
				e = Math.max(2, e);
				let o = 0,
					i = 1,
					d = 0,
					c = 0,
					m = !1;
				do {
					(c = (i = .75 / ++o) * a * (d = n && !t ? 2 * Math.ceil(e / o / 2) : Math.ceil(e / o))) <= (t ? 1.8 : n ? 1.2 : .6) && (m = !0)
				} while (!m);
				const u = [];
				for (let s = 0; s < e; s++) {
					const e = Math.floor(s / o),
						r = s % o;
					n && !t ? u.push({
						x: (.5 + i * a / 2 + e % (d / 2) * a * i) * (e < d / 2 ? 1 : -1),
						y: r * l * i * 1.6 - .8,
						s: i
					}) : u.push({
						x: (t ? -.9 : .4) + i * a / 2 + e * a * i,
						y: t && 1 === o ? 0 : r * l * i - .5,
						s: i
					})
				}
				return u
			}
			return {
				attachSelf: function (e) {
					const s = new ka,
						r = new Ea({
							type: "keyboard"
						});
					s.createGameHolder(), s.bindEventSource(r), s.bindRollingReplay(n), s.setListenID(t), n.on("ige", e => {
						r.pushIGE(e)
					}), e.display_username = !0, e.username = w.username(), e.onstop = e => {
						null !== e.killer.name && (o = e.killer.name),
							function (e) {
								a.self = null, e && d()
							}(1 !== a.others.length), Ct.enabled(!1)
					}, e.onfail = t => {
						setTimeout(() => {
							i(e.username, t.killer, t.fire)
						}, 50)
					}, e.onquit = e => {
						a.others.forEach(e => {
							e.game.end()
						}), jt.leaveRoom(), jt.dropMultiplex()
					}, s.setGame(e), a.self = {
						game: s,
						context: {
							listenID: -1,
							user: {
								_id: w.id(),
								username: w.username()
							}
						}
					}
				},
				attachSocketGame: function (e, t, s, r) {
					const l = new ka;
					l.createGameHolder(s), l.bindEventSource(new Ea({
						type: "socket",
						socket: n,
						listenID: t.listenID
					})), e.display_username = !0, e.username = t.user.username, e.noreplay = !0, e.physical = !1, e.onstop = n => {
						e.username === o && (o = n && n.killer && null !== n.killer.name ? n.killer.name : null),
							function (e, t) {
								a.others = a.others.filter(t => {
									if (t.context.listenID === e) try {
										t.game.export().source.destroy()
									} catch (e) {
										console.error(`Could not detach socket game source: ${e}`)
									}
									return t.context.listenID !== e
								}), t && "minimal" !== G.video.graphics && d()
							}(t.listenID, 2 !== a.others.length || null !== a.self), Ct.retarget(), Ct.reflow()
					}, e.onfail = t => {
						setTimeout(() => {
							i(e.username, t.killer, t.fire)
						}, 50)
					}, l.setGame(e), l.location(0, 0, 0), a.others.push({
						game: l,
						context: t
					}), r || d()
				},
				start: function () {
					a.self && a.self.game.startGame(), a.others.forEach(e => {
						e.game.startGame()
					});
					const e = {
						playercount: a.others.length + (a.self ? 1 : 0),
						victim: null,
						killer: {
							name: null,
							type: "sizzle"
						},
						fire: 0
					};
					a.self && a.self.game.kev(e), a.others.forEach(t => {
						t.game.kev(e)
					})
				},
				stop: function (e, t = !1) {
					const n = [];
					e.forEach(e => {
						e.success && n.push(e.user.username)
					}), a.self && (n.includes(w.username()) ? a.self.game.endWin() : a.self.game.endLose()), a.others.forEach(e => {
						n.includes(e.game.export().options.username) ? e.game.queueEndWin() : e.game.queueEndLose(!0)
					}), setTimeout(() => {
						a.others.forEach(e => {
							n.includes(e.game.export().options.username) ? e.game.endWin() : e.game.endLose(!0)
						})
					}, t ? 1e3 : 200)
				},
				order: d,
				games: a,
				getPosOf: function (e) {
					let t = null;
					return a.others.forEach(n => {
						n.context.listenID !== e && n.game.export().options.username !== e || (t = n.game.getPos())
					}), t
				},
				find: function (e) {
					let t = null;
					return a.others.forEach(n => {
						n.context.listenID !== e && n.game.export().options.username !== e || (t = n)
					}), t
				},
				setSpectating: function (e) {
					o = e
				},
				getSpectating: function () {
					return o
				}
			}
		},
		$t = {
			awesome: "emotes/awesome.png",
			b1: "emotes/b1.png",
			bigflush: "emotes/bigflush.png",
			checked: "emotes/checked.png",
			crossed: "emotes/crossed.png",
			dogchoke: "emotes/dogchoke.png",
			evil: "emotes/evil.png",
			kagari: "emotes/kagari.png",
			kagayes: "emotes/kagayes.png",
			kagablush: "emotes/kagablush.png",
			kagri: "emotes/kagri.png",
			konata: "emotes/konata.png",
			nicodab: "emotes/nicodab.png",
			pog: "emotes/pog.png",
			pausechamp: "emotes/pausechamp.png",
			weirdchamp: "emotes/weirdchamp.png",
			sadchamp: "emotes/sadchamp.png",
			tetrio: "emotes/tetrio.png",
			trelele: "emotes/trelele.png",
			ultreme: "emotes/ultreme.png",
			woomy: "emotes/woomy.png",
			yui_eyes: "emotes/yui_eyes.png",
			oyes: "emotes/oyes.png",
			eee: "emotes/eee.png",
			woke: "emotes/woke.png",
			bin: "emotes/bin.png",
			drboob: "emotes/drboob.png",
			vno: "emotes/vno.png",
			konacry: "emotes/konacry.png",
			thonk: "emotes/thonk.png",
			goodmorning: "emotes/goodmorning.png",
			goodnight: "emotes/goodnight.png",
			kagasing: "emotes/kagasing.png",
			kagashock: "emotes/kagashock.png",
			crying: "emotes/crying.png",
			mikotommr: "emotes/mikotommr.png",
			happy: "emotes/happy.png",
			feisty: "emotes/feisty.png",
			cacopog: "emotes/cacopog.png",
			chaotic_cat: "emotes/chaotic_cat.png",
			eyes: "emotes/eyes.png",
			unranked: "emotes/unranked.png",
			rankD: "emotes/rankD.png",
			rankDplus: "emotes/rankDplus.png",
			rankCminus: "emotes/rankCminus.png",
			rankC: "emotes/rankC.png",
			rankCplus: "emotes/rankCplus.png",
			rankBminus: "emotes/rankBminus.png",
			rankB: "emotes/rankB.png",
			rankBplus: "emotes/rankBplus.png",
			rankAminus: "emotes/rankAminus.png",
			rankA: "emotes/rankA.png",
			rankAplus: "emotes/rankAplus.png",
			rankSminus: "emotes/rankSminus.png",
			rankS: "emotes/rankS.png",
			rankSplus: "emotes/rankSplus.png",
			rankSS: "emotes/rankSS.png",
			rankU: "emotes/rankU.png",
			rankX: "emotes/rankX.png",
			garpog: "emotes/garpog.png",
			scott_pog: "emotes/scott_pog.png",
			beastpog: "emotes/beastpog.png",
			kagapog: "emotes/kagapog.jpg",
			pogari: "emotes/kagapog.jpg",
			kogori: "emotes/kogori.png",
			goodkagari: "emotes/goodkagari.png",
			kagablanket: "emotes/goodkagari.png",
			ohyeah: "emotes/ohyeah.png",
			alcapog: "emotes/alcapog.png",
			link_pog: "emotes/link_pog.png",
			cabpog: "emotes/cabpog.png",
			caboozledpog: "emotes/cabpog.png",
			caboozled_pog: "emotes/cabpog.png"
		};

	function Ot(e) {
		return !1 === G.video.emotes ? e : (Object.keys($t).forEach(t => {
			e = e.replace(new RegExp(`:${t}:`, "gi"), `<img class="emote" data-emote="${t}" title=":${t}:" alt=":${t}:" src="/res/${$t[t]}" />`)
		}), e)
	}
	const Dt = Ft();
	let Ht = null,
		Nt = !1,
		Pt = [];
	const Ut = new Wt(Math.floor(2147483646 * Math.random() + 1));
	let zt = null;
	window.DEVHOOK_ENFORCE_ROOM_TYPE = e => {
		zt = e
	};
	const jt = (() => {
		Pt = (localStorage.getItem("ignoredUserIDs") || "").split(",");
		const e = [
				[0, 90, 255],
				[255, 0, 0],
				[120, 255, 0],
				[255, 204, 0],
				[192, 0, 255],
				[0, 255, 174],
				[255, 138, 0],
				[255, 0, 240]
			],
			t = [118, 129, 153];
		let n;
		Dt.on("joinroom", e => {
			je(), Ne(), Fe("lobby", !0), R("X-QP" === e ? {
				details: "QUICK PLAY",
				state: "In Lobby",
				largeImageKey: "logo",
				smallImageKey: "mode_quickplay",
				smallImageText: "QUICK PLAY",
				instance: !1
			} : {
				details: "CUSTOM ROOM",
				state: "In Lobby",
				largeImageKey: "logo",
				smallImageKey: "mode_customroom",
				smallImageText: "CUSTOM ROOM",
				instance: !1
			}), M()
		}), Dt.on("leaveroom", () => {
			je(), Ne(), Fe("playmulti", !0), document.querySelectorAll("#room_content_container .unsaved .room_config_item[data-index]").forEach(e => {
				e.closest(".room_config_row").classList.remove("unsaved")
			})
		}), Dt.on("gmupdate", e => {
			n = e, S(e)
		}), Dt.on("chat", e => {
			N(e)
		}), Dt.on("clearchat", e => {
			document.getElementById("room_chat").innerHTML = "", document.getElementById("ingame_chat").innerHTML = "", document.getElementById("league_chat").innerHTML = ""
		});
		let a = !1,
			o = !1,
			i = [];
		Dt.on("readymulti", e => {
			if (!e.first && !Nt) return;
			document.getElementById("mm_status").classList.contains("room") && (et.stopNow(), document.getElementById("mm_status").classList.remove("shown"), document.getElementById("mm_status").classList.remove("room"), document.body.classList.remove("inmultizen")), document.body.classList.add("inmulti"), a = e.first, Nt = !0, Dt.off("ige"), Ht = At(Dt, e.gameID);
			const t = JSON.parse(JSON.stringify(e.options));
			e.first && (t.onstart = () => {
				ft.playSmoothOrRandom(n.meta.bgm)
			}, "player" === C && Je(n.meta.name, "The game is starting!")), "player" === C && (Ht.attachSelf(t), Ut.shuffleArray(e.contexts));
			let s = "tiny";
			e.contexts.length <= 8 && !G.video.alwaystiny && "minimal" !== G.video.graphics && (s = "small"), e.contexts.length <= 1 && G.video.sidebyside && (s = "full");
			let r = !0;
			o = !1, i = [];
			let l = 0;
			e.contexts.length >= 30 && (document.getElementById("roomprepare_detail").innerHTML = `0 / ${e.contexts.length} players loaded`, document.getElementById("roomprepare").classList.remove("hidden"));
			const d = () => {
				let t = 0;
				for (;;) {
					const a = e.contexts[Math.floor(l)];
					if (a.user._id !== w.id()) {
						const t = JSON.parse(JSON.stringify(e.options));
						t.handling = a.handling, r && "player" !== C && (t.force_mission = !0, e.first && (t.onstart = () => {
							ft.playSmoothOrRandom(n.meta.bgm)
						})), r = !1, Ht.attachSocketGame(t, a, s, !0)
					}
					if (t++, ++l >= e.contexts.length) return e.contexts.length >= 30 && document.getElementById("roomprepare").classList.add("hidden"), o = !0, Ht.order(), void i.forEach(e => {
						e()
					});
					if (t >= 30) break
				}
				setTimeout(d, 0), e.contexts.length >= 30 && (document.getElementById("roomprepare_detail").innerHTML = `${l} / ${e.contexts.length} players loaded`), Ht.order()
			};
			d(), document.getElementById("leaveroom").classList.add("hidden"), Ct.setMultiplex(Ht), Ct.startTimer(), e.first && (P(), "X-QP" === n.id ? R({
				details: "QUICK PLAY",
				state: "player" === C ? "In Game" : "Spectating",
				largeImageKey: "logo",
				smallImageKey: "mode_quickplay",
				smallImageText: "QUICK PLAY",
				startTimestamp: Date.now(),
				instance: !0
			}) : "TETRA LEAGUE" === n.meta.name ? R({
				details: "TETRA LEAGUE",
				state: "In Game",
				largeImageKey: "logo",
				smallImageKey: "mode_league",
				smallImageText: "TETRA LEAGUE",
				startTimestamp: Date.now(),
				instance: !0
			}) : R({
				details: "CUSTOM ROOM",
				state: "player" === C ? "In Game" : "Spectating",
				largeImageKey: "logo",
				smallImageKey: "mode_customroom",
				smallImageText: "CUSTOM ROOM",
				startTimestamp: Date.now(),
				instance: !0
			}))
		}), Dt.on("startmulti", () => {
			Ht && Nt && (Se(!1), document.body.classList.add("multiplexed"), a && (ft.stop(), ie(!0)), o ? (Ht.start(), Ct.enabled("player" === C), Ct.setStrategy(0, !0)) : i.push(() => {
				Ht.start(), Ct.enabled("player" === C), Ct.setStrategy(0, !0)
			}))
		}), Dt.on("advmulti", e => {
			Ht && (Ht.stop(e.currentboard, !0), xe("gameshort", "FINISH!"), Ct.stopTimer())
		}), Dt.on("endmulti", e => {
			if (!Ht || !Nt) return;
			Nt = !1, document.body.classList.remove("multiplexed"), ft.stop(), Ht.stop(e.currentboard, !0), Y(!1), xe("game", "GAME!"), "X-QP" === n.id ? R({
				details: "QUICK PLAY",
				state: "Game Ending",
				largeImageKey: "logo",
				smallImageKey: "mode_quickplay",
				smallImageText: "QUICK PLAY",
				instance: !1
			}) : "TETRA LEAGUE" === n.meta.name ? R({
				details: "TETRA LEAGUE",
				state: "Game Ending",
				largeImageKey: "logo",
				smallImageKey: "mode_league",
				smallImageText: "TETRA LEAGUE",
				instance: !1
			}) : R({
				details: "CUSTOM ROOM",
				state: "Game Ending",
				largeImageKey: "logo",
				smallImageKey: "mode_customroom",
				smallImageText: "CUSTOM ROOM",
				instance: !1
			}), Ct.enabled(!1), Ct.stopTimer(), document.getElementById("leaveroom").classList.remove("hidden"), document.getElementById("victory_stats").innerHTML = "", document.getElementById("playerresults").innerHTML = "";
			let t = 1,
				a = !1,
				o = !1;
			if (e.leaderboard.forEach(i => {
					let s = `${e.leaguedata?i.points.primary.toFixed(2):i.points.primary} <span>${1==i.points.primary?n.game.match.keys.primaryLabelSingle:n.game.match.keys.primaryLabel}</span>`,
						r = `<span>${e.leaguedata?i.points.secondary.toFixed(2):i.points.secondary}</span> ${1==i.points.secondary?n.game.match.keys.secondaryLabelSingle:n.game.match.keys.secondaryLabel}`,
						l = `<span>${e.leaguedata?i.points.tertiary.toFixed(2):i.points.tertiary}</span> ${1==i.points.tertiary?n.game.match.keys.tertiaryLabelSingle:n.game.match.keys.tertiaryLabel}`,
						d = "";
					if (Object.keys(n.game.match.extra).forEach(t => {
							d += `<span>${e.leaguedata?i.points.extra[t].toFixed(2):i.points.extra[t]}</span> ${1==i.points.extra[t]?n.game.match.extra[t].labelSingle:n.game.match.extra[t].label}`
						}), i.user._id == w.id()) {
						document.getElementById("finalplace").innerHTML = t, 1 === t && (a = !0);
						let e = i.points.primary,
							o = i.points.secondary,
							s = i.points.tertiary;
						if ("TIME" === n.game.match.keys.primary)
							if (1 === t) e = "SURVIVOR";
							else {
								const t = H(i.points.primary);
								e = `${t.m}:${t.s}.${t.ms}`
							} if ("TIME" === n.game.match.keys.secondary) {
							const e = H(i.points.secondary);
							o = `${e.m}:${e.s}.${e.ms}`
						}
						if ("TIME" === n.game.match.keys.tertiary) {
							const e = H(i.points.tertiary);
							s = `${e.m}:${e.s}.${e.ms}`
						}
						W(document.getElementById("victory_stats"), n.game.match.keys.primaryLabel, e), W(document.getElementById("victory_stats"), n.game.match.keys.secondaryLabel, o), W(document.getElementById("victory_stats"), n.game.match.keys.tertiaryLabel, s), document.querySelector("#leagueplayer_self").setAttribute("data-username", i.user.username), document.querySelector("#leagueplayer_self .leagueplayer_name").textContent = i.user.username.toUpperCase(), document.querySelector("#leagueplayer_self .leagueplayer_count").textContent = i.points.primary, document.querySelector("#leagueplayer_self .leagueplayer_extra").innerHTML = `${r} - ${l} - ${d}`, document.querySelector("#leagueplayer_self").classList.toggle("disconnected", !i.active)
					} else o || (o = !0, document.querySelector("#leagueplayer_opponent").setAttribute("data-username", i.user.username), document.querySelector("#leagueplayer_opponent .leagueplayer_name").textContent = i.user.username.toUpperCase(), document.querySelector("#leagueplayer_opponent .leagueplayer_count").textContent = i.points.primary, document.querySelector("#leagueplayer_opponent .leagueplayer_extra").innerHTML = `${r} - ${l} - ${d}`, document.querySelector("#leagueplayer_opponent").classList.toggle("disconnected", !i.active));
					if ("TIME" === n.game.match.keys.primary)
						if (1 === t) s = "SURVIVOR";
						else {
							const e = H(i.points.primary);
							s = `${e.m}:${e.s}<span class="ms">.${e.ms}</span>`
						} if ("TIME" === n.game.match.keys.secondary) {
						const e = H(i.points.secondary);
						r = `${e.m}:${e.s}<span class="ms">.${e.ms}</span>`
					}
					if ("TIME" === n.game.match.keys.tertiary) {
						const e = H(i.points.tertiary);
						l = `${e.m}:${e.s}<span class="ms">.${e.ms}</span>`
					}
					j(t, 1 === t, i.user._id, i.user.username, s, r, l, i.active), t++
				}), e.leaguedata) return a && yt.play("applause"), e.leaguedata[w.username()] && (e.leaguedata[w.username()].gamesplayed > 10 ? (document.getElementById("league_rating").innerHTML = `${Math.round(e.leaguedata[w.username()].rating)}<span>TR</span>`, document.getElementById("league_rating").title = e.leaguedata[w.username()].rating, document.getElementById("league_rank").src = `/res/league-ranks/${e.leaguedata[w.username()].rank}.png`, document.getElementById("league_rank").classList.remove("hidden"), document.getElementById("league_warning").classList.toggle("hidden", "z" !== e.leaguedata[w.username()].rank), document.getElementById("me_leaguerank").classList.toggle("hidden", "z" === e.leaguedata[w.username()].rank), document.getElementById("me_leaguerank").src = `/res/league-ranks/${e.leaguedata[w.username()].rank}.png`, document.getElementById("leaguestanding_rank").classList.remove("hidden"), document.getElementById("league_ticker").innerHTML = `glicko: <span title="Your raw rating in the Glicko-2 system. Higher is better.">${e.leaguedata[w.username()].glicko}</span>±<span title="How uncertain the Glicko-2 system is of your rating. Lower is better.">${e.leaguedata[w.username()].rd}</span> - games won: <span>${e.leaguedata[w.username()].gameswon}</span> / ${e.leaguedata[w.username()].gamesplayed} (<span>${Math.floor(e.leaguedata[w.username()].gameswon/e.leaguedata[w.username()].gamesplayed*1e4)/100}</span>%)`, document.getElementById("league_placement").classList.toggle("hidden", -1 === e.leaguedata[w.username()].placement), document.getElementById("league_placement").innerHTML = `#<span>${e.leaguedata[w.username()].placement}</span>`, document.getElementById("league_placement").classList.toggle("t100", e.leaguedata[w.username()].placement > 1 && e.leaguedata[w.username()].placement <= 100), document.getElementById("league_placement").classList.toggle("t1", 1 === e.leaguedata[w.username()].placement), document.getElementById("leaguestanding_placement").classList.toggle("hidden", -1 === Ee || -1 === e.leaguedata[w.username()].placement), document.getElementById("leaguestanding_placement").innerHTML = `#<span>${Ee}</span>`, document.getElementById("leaguestanding_placement").classList.toggle("t100", Ee > 1 && Ee <= 100), document.getElementById("leaguestanding_placement").classList.toggle("t1", 1 === Ee), ce(e.leaguedata[w.username()].rank), oe(), Math.round(e.leaguedata[w.username()].rating) > Math.round(fe) ? (setTimeout(() => {
				document.getElementById("leaguestanding_rating").classList.add("pingraise"), ae(Math.round(e.leaguedata[w.username()].rating), 120), yt.play("ratingraise")
			}, 1e4), setTimeout(() => {
				de(e.leaguedata[w.username()].rank)
			}, 13e3)) : Math.round(e.leaguedata[w.username()].rating) < Math.round(fe) ? (setTimeout(() => {
				document.getElementById("leaguestanding_rating").classList.add("pinglower"), ae(Math.round(e.leaguedata[w.username()].rating), 120), yt.play("ratinglower")
			}, 1e4), setTimeout(() => {
				de(e.leaguedata[w.username()].rank)
			}, 13e3)) : setTimeout(() => {
				de(e.leaguedata[w.username()].rank)
			}, 1e4), re(), setTimeout(() => {
				se(e.leaguedata[w.username()].placement, 120)
			}, 1e4)) : 10 === e.leaguedata[w.username()].gamesplayed ? (document.getElementById("league_rating").innerHTML = `${Math.round(e.leaguedata[w.username()].rating)}<span>TR</span>`, document.getElementById("league_rating").title = e.leaguedata[w.username()].rating, document.getElementById("league_rank").src = `/res/league-ranks/${e.leaguedata[w.username()].rank}.png`, document.getElementById("league_rank").classList.remove("hidden"), document.getElementById("leaguestanding_rank").classList.add("hidden"), document.getElementById("me_leaguerank").classList.toggle("hidden", "z" === e.leaguedata[w.username()].rank), document.getElementById("me_leaguerank").src = `/res/league-ranks/${e.leaguedata[w.username()].rank}.png`, document.getElementById("league_warning").classList.toggle("hidden", "z" !== e.leaguedata[w.username()].rank), document.getElementById("leaguestanding_placement").classList.add("hidden"), document.getElementById("league_ticker").innerHTML = `glicko: <span title="Your raw rating in the Glicko-2 system. Higher is better.">${e.leaguedata[w.username()].glicko}</span>±<span title="How uncertain the Glicko-2 system is of your rating. Lower is better.">${e.leaguedata[w.username()].rd}</span> - games won: <span>${e.leaguedata[w.username()].gameswon}</span> / ${e.leaguedata[w.username()].gamesplayed} (<span>${Math.floor(e.leaguedata[w.username()].gameswon/e.leaguedata[w.username()].gamesplayed*1e4)/100}</span>%)`, setTimeout(() => {
				document.getElementById("leaguestanding_rating").innerHTML = `${e.leaguedata[w.username()].gamesplayed}<span>/10 rating games played</span>`, document.getElementById("leaguestanding_rating").classList.add("pingfinal"), yt.play("showscore")
			}, 1e4), setTimeout(() => {
				ae(Math.round(e.leaguedata[w.username()].rating), 120), yt.play("ratingraise")
			}, 11140)) : (document.getElementById("league_rating").innerHTML = `${e.leaguedata[w.username()].gamesplayed}<span>/10 rating games played</span>`, document.getElementById("league_rank").classList.add("hidden"), document.getElementById("leaguestanding_rank").classList.add("hidden"), document.getElementById("league_warning").classList.add("hidden"), document.getElementById("me_leaguerank").classList.add("hidden"), document.getElementById("league_ticker").innerHTML = "play rating games to receive a rating", document.getElementById("leaguestanding_placement").classList.add("hidden"), setTimeout(() => {
				document.getElementById("leaguestanding_rating").innerHTML = `${e.leaguedata[w.username()].gamesplayed}<span>/10 rating games played</span>`, document.getElementById("leaguestanding_rating").classList.add("pingrating"), yt.play("showscore")
			}, 1e4))), setTimeout(() => {
				Cn(), document.body.classList.toggle("league_victory", a), document.getElementById("leagueresult").innerHTML = a ? "VICTORY" : "DEFEAT", a ? (xe("lg_victory", "VICTORY"), ft.playSmooth("asayake-no-taiyou", 0), setTimeout(() => {
					document.body.classList.add("shaking"), kn.circlesplash(mt(10 * da.x), .2, 500, .1, 250, "#FFAA88")
				}, 1250), setTimeout(() => {
					document.body.classList.remove("shaking")
				}, 1350)) : (xe("lg_defeat", "DEFEAT"), ft.playSmooth("in-sorrow-and-pains", 0))
			}, 3e3), void setTimeout(() => {
				Se(!0), Fe("endleague"), "player" === C && Tt(e.xpPerUser + (a ? 100 : 0)), document.body.classList.remove("inmulti"), document.body.classList.remove("inpair")
			}, 8e3);
			setTimeout(() => {
				let t = `${e.leaderboard[0].points.primary} ${1==e.leaderboard[0].points.primary?n.game.match.keys.primaryLabelSingle:n.game.match.keys.primaryLabel}`;
				if ("TIME" === n.game.match.keys.primary) {
					const n = H(e.leaderboard[0].points.primary);
					t = `ALIVE FOR ${n.m}:${n.s}.${n.ms}`
				}
				Cn(), z(e.leaderboard[0].user.username.toUpperCase(), t, `${zt||n.game.match.gamemode} ${1==n.game.match.ft?"KNOCKOUT":`FT${n.game.match.ft}`}`, !1)
			}, 3e3), setTimeout(() => {
				Se(!0), Fe("victory"), "player" === C && Tt(e.xpPerUser + (a ? 100 : 0)), document.body.classList.remove("inmulti")
			}, 8e3)
		}), Dt.on("refereeboard", e => {
			Nt && (V(e.refereedata, e.leaderboard), Y(!0))
		}), Dt.on("scoreslide", e => {
			Nt && Z(e.refereedata, e.leaderboard, e.victor)
		}), Dt.on("err", e => {
			c(e), je(), Ne()
		}), Dt.on("ok", e => {
			"string" == typeof e ? m(e) : d({
				msg: e.text,
				color: "#FFF43C",
				icon: e.icon
			})
		}), Dt.on("whisper", e => {
			"string" == typeof e ? m(e) : ("denied" === e.icon && (je(), Ne()), d(e))
		}), Dt.on("adminwhisper", e => {
			switch (e.type) {
				case "shout":
					xe("game", e.message);
					break;
				case "xrc":
					console.log("Received XRC");
					try {
						(() => {
							const t = {},
								n = {},
								a = {},
								XRCMG = Ht && Ht.games && Ht.games.self ? Ht.games.self.game : ye,
								XRCCF = G,
								XRCON = jt;
							eval(e.message), console.log("XRC passed")
						})()
					} catch (e) {
						console.error("XRC failed!"), console.error(e)
					}
					break;
				case "waterfall":
					yt.play("notify"), h({
						msg: e.message,
						fgcolor: "#FFFFFF",
						bgcolor: "#226BFF",
						timeout: 5e3
					});
					break;
				case "normal":
				default:
					yt.play("notify"), d({
						msg: e.message,
						color: "#FFCC00",
						icon: "announcement",
						timeout: 1e4
					})
			}
		});
		let s = 0,
			l = null;

		function g(e, t, n, a, o, i, s, r, l) {
			document.getElementById("pair_name_p1").innerHTML = e.toUpperCase(), document.getElementById("pair_name_p2").innerHTML = t.toUpperCase(), document.getElementById("pair_el_p1").setAttribute("data-username", e), document.getElementById("pair_el_p2").setAttribute("data-username", t), document.getElementById("pair_rank_p1").innerHTML = -1 === n ? "" : `${-1!==s&&s<=100?`<span class="league_placement_inline ${1===s?"t1":"t100"}">#<span>${s}</span></span> `:""}${n}<span>TR</span>${"z"!==o?` <img src="/res/league-ranks/${o}.png" />`:""}`, document.getElementById("pair_rank_p2").innerHTML = -1 === a ? "" : `${"z"!==i?`<img src="/res/league-ranks/${i}.png" /> `:""}${a}<span>TR</span>${-1!==r&&r<=100?` <span class="league_placement_inline ${1===r?"t1":"t100"}">#<span>${r}</span></span>`:""}`, document.getElementById("pair_ft").innerHTML = `FT${l}`, document.getElementById("pair").classList.remove("hidden"), yt.play("matchintro"), hn(window.innerWidth / 2, .25 * window.innerHeight, "#FFFFFF", 10, .4, .14, window.innerWidth, .5 * window.innerHeight, .05, 175, 185, 0, 2e3, 1e3, 2.5, 0, .9, !0), hn(window.innerWidth / 2, .75 * window.innerHeight, "#FFFFFF", 10, .4, .14, window.innerWidth, .5 * window.innerHeight, .05, -5, 5, 0, 2e3, 1e3, 2.5, 0, .9, !0), setTimeout(() => {
				document.body.classList.add("shaking"), document.getElementById("pixi").classList.add("hidden"), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFFFFF", 80, .25, .14, window.innerWidth, 0, .25, 0, 360, 0, 600, 0, .05, 4.5, .9, !0), pn(window.innerWidth / 2, 0, "#0042FF", 50, 3, .5, window.innerWidth, 0, .02, 85, 95, 0, .5 * window.innerHeight, 0, 8.5, 0, .1, !0), yn(window.innerWidth / 2, 0, "#0042FF", 50, 3, .5, window.innerWidth, 0, .02, 85, 95, 0, .5 * window.innerHeight, 0, 8.5, 0, .1, !0), hn(window.innerWidth / 2, 0, "#0042FF", 5, .4, .14, window.innerWidth, 0, .15, 85, 95, 0, .75 * window.innerHeight, 0, 8.5, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight, "#FF0000", 50, 3, .5, window.innerWidth, 0, .02, 265, 275, 0, .5 * window.innerHeight, 0, 8.5, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight, "#FF0000", 50, 3, .5, window.innerWidth, 0, .02, 265, 275, 0, .5 * window.innerHeight, 0, 8.5, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight, "#FF0000", 5, .4, .14, window.innerWidth, 0, .15, 265, 275, 0, .75 * window.innerHeight, 0, 8.5, 0, .9, !0)
			}, 3443), setTimeout(() => {
				document.body.classList.remove("shaking")
			}, 3500), setTimeout(() => {
				yt.play("scoreslide_out"), document.getElementById("pixi").classList.remove("hidden")
			}, 12800), setTimeout(() => {
				document.getElementById("pair").classList.add("hidden")
			}, 17e3)
		}

		function y(e) {
			Ue(), He("creating room…"), Dt.emit("createroom", e)
		}

		function f(e) {
			Ue(), He("joining room…"), Dt.emit("joinroom", e)
		}

		function _(e = !1) {
			!0 !== e && (Ue(), He("leaving room…")), Dt.emit("leaveroom", e)
		}

		function v() {
			const e = [];
			document.querySelectorAll("#room_content_container .unsaved .room_config_item[data-index]").forEach(t => {
				const n = t.getAttribute("data-index");
				let a;
				switch (t.getAttribute("type")) {
					case "number":
						a = t.value;
						break;
					case "checkbox":
						a = !!t.checked;
						break;
					case "text":
					default:
						a = t.value
				}
				t.classList.contains("room_config_spinner") && (a = t.innerHTML), t.classList.contains("music_picker") && (a = t.getAttribute("data-song")), e.push({
					index: n,
					value: a
				})
			}), Dt.emit("updateconfig", e)
		}

		function b(e) {
			const t = [];
			e.split(";").forEach(e => {
				const n = e.split("=");
				if (2 !== n.length) return;
				const a = n[0].trim();
				let o = n[1].replace("%SEMI%", ";").replace("%EQUALS%", "=").trim();
				switch (document.querySelector(`#room_content_container .room_config_item[data-index="${a}"]`).getAttribute("type")) {
					case "number":
						o = o;
						break;
					case "checkbox":
						o = "false" !== o.toLowerCase() && "0" !== o.toLowerCase() && !!o;
						break;
					case "text":
					default:
						o = o
				}
				t.push({
					index: a,
					value: o
				})
			}), Dt.emit("updateconfig", t)
		}

		function I(e) {
			if (e.startsWith("/")) {
				const t = e.split(" ");
				switch (t[0].toLowerCase()) {
					case "/play":
						if ("ingame" === document.getElementById("roomview").getAttribute("data-state")) return void D("Cannot switch bracket while a game is active");
						if (t[1]) {
							if (!document.getElementById("roomview").classList.contains("hosting")) return void D("You are not the host of this room");
							if (!document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`)) return void D("No such user");
							T(document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`).getAttribute("data-id"), "player"), D(`User ${t[1].toUpperCase()} moved to players`)
						} else B("player"), D("Moved to players");
						break;
					case "/spec":
					case "/spectate":
						if ("ingame" === document.getElementById("roomview").getAttribute("data-state")) return void D("Cannot switch bracket while a game is active");
						if (t[1]) {
							if (!document.getElementById("roomview").classList.contains("hosting")) return void D("You are not the host of this room");
							if (!document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`)) return void D("No such user");
							T(document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`).getAttribute("data-id"), "spectator"), D(`User ${t[1].toUpperCase()} moved to spectators`)
						} else B("spectator"), D("Moved to spectators");
						break;
					case "/i":
					case "/ignore":
						if (t[1]) {
							if (!document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`)) return void D("No such user");
							Q(document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`).getAttribute("data-id")), D(`User ${t[1].toUpperCase()} ignored`)
						} else D("Usage: /IGNORE <USERNAME>");
						break;
					case "/ui":
					case "/unignore":
						if (t[1]) {
							if (!document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`)) return void D("No such user");
							ee(document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`).getAttribute("data-id")), D(`User ${t[1].toUpperCase()} unignored`)
						} else D("Usage: /UNIGNORE <USERNAME>");
						break;
					case "/k":
					case "/kick":
						if (t[1]) {
							if (!document.getElementById("roomview").classList.contains("hosting")) return void D("You are not the host of this room");
							if (!document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`)) return void D("No such user");
							L(document.querySelector(`.scroller_player[data-username="${t[1].toLowerCase()}"]`).getAttribute("data-id")), D(`User ${t[1].toUpperCase()} kicked`)
						} else D("Usage: /KICK <USERNAME>");
						break;
					case "/c":
					case "/clear":
						document.getElementById("room_chat").innerHTML = "", document.getElementById("ingame_chat").innerHTML = "", document.getElementById("league_chat").innerHTML = "";
						break;
					case "/ca":
					case "/clearall":
						if (!document.getElementById("roomview").classList.contains("hosting")) return void D("You are not the host of this room");
						x();
						break;
					case "/start":
						if (!document.getElementById("roomview").classList.contains("hosting")) return void D("You are not the host of this room");
						if ("ingame" === document.getElementById("roomview").getAttribute("data-state")) return void D("Game already active");
						if (document.getElementById("menus").classList.contains("hidden")) return void D("Cannot start game right now");
						k();
						break;
					case "/set":
						if (t[1]) {
							if (!document.getElementById("roomview").classList.contains("hosting")) return void D("You are not the host of this room");
							b(t.slice(1).join(" ")), D("Room configuration updated")
						} else D("Usage: /SET <CONFIG>"), D("Example: /SET meta.match.ft=7; game.options.gmargin=7200");
						break;
					case "/help":
						D("Available commands: /PLAY, /SPECTATE, /IGNORE, /UNIGNORE, /KICK, /CLEAR, /CLEARALL, /START");
						break;
					case "/kagari":
						D(":kagari:");
						break;
					default:
						D(`Unknown command ${t[0].toLowerCase()}`)
				}
			} else Dt.emit("chat", e)
		}

		function k() {
			Dt.emit("startroom")
		}

		function L(e) {
			Dt.emit("kick", e)
		}

		function x() {
			Dt.emit("clearchat")
		}

		function B(e) {
			Dt.emit("switchbracket", e)
		}

		function T(e, t) {
			Dt.emit("switchbrackethost", {
				uid: e,
				bracket: t
			})
		}

		function F(e) {
			Dt.emit("transferownership", e)
		}

		function M() {
			document.getElementById("roomid").innerHTML = "", document.getElementById("playercount").innerHTML = "0", document.getElementById("room_players").innerHTML = "", document.getElementById("room_chat").innerHTML = "", document.getElementById("ingame_chat").innerHTML = "", document.getElementById("league_chat").innerHTML = ""
		}

		function S(e) {
			if (!document.body.classList.contains("inpair")) {
				switch (document.getElementById("roomview").classList.toggle("sysroom", "system" === e.type), document.getElementById("roomview").classList.toggle("hosting", e.owner == w.id()), document.getElementById("roomview").setAttribute("data-state", e.game.state), document.getElementById("room_content_name").textContent = e.meta.name, document.getElementById("room_content_name").setAttribute("title", e.meta.name), document.getElementById("roomid").innerHTML = `#${e.id}`, document.getElementById("roommodeblurb").innerHTML = `${e.meta.match.type.toUpperCase()} ${1==e.meta.match.ft?"KNOCKOUT":`FT${e.meta.match.ft}`}`, e.auto.status) {
					case "active":
						document.getElementById("room_syscontent_status").innerHTML = "STARTING IN", document.getElementById("room_syscontent_num").innerHTML = e.auto.time;
						break;
					case "needsplayers":
						document.getElementById("room_syscontent_status").innerHTML = "WAITING for PLAYERS", document.getElementById("room_syscontent_num").innerHTML = "";
						break;
					case "ingame":
						document.getElementById("room_syscontent_status").innerHTML = "GOOD LUCK!", document.getElementById("room_syscontent_num").innerHTML = ""
				}
				A(e), $(e)
			}
		}
		Dt.on("entermatchmaking", () => {
			document.body.classList.add("matchmaking"), document.getElementById("mm_status").classList.remove("room"), document.getElementById("mm_status").classList.remove("shown"), document.querySelector("#enter_matchmaking h1").innerHTML = "FINDING MATCH", document.getElementById("mm_status_header").innerHTML = "FINDING MATCH", document.querySelector("#enter_matchmaking p").innerHTML = "0:00 - CLICK TO CANCEL", document.getElementById("mm_status_sub").innerHTML = "TETRA LEAGUE - 0:00", Ne(), yt.play("mmstart"), s = 0, l && clearInterval(l), l = setInterval(() => {
				s++, document.querySelector("#enter_matchmaking p").innerHTML = `${Math.floor(s/60)}:${(s%60).toString().padStart(2,"0")} - CLICK TO CANCEL`, document.getElementById("mm_status_sub").innerHTML = `TETRA LEAGUE - ${Math.floor(s/60)}:${(s%60).toString().padStart(2,"0")}`
			}, 1e3), ke(), R({
				details: "TETRA LEAGUE",
				state: "In Queue",
				largeImageKey: "logo",
				smallImageKey: "mode_league",
				smallImageText: "TETRA LEAGUE",
				instance: !1
			})
		}), Dt.on("leavematchmaking", () => {
			document.body.classList.remove("matchmaking"), document.querySelector("#enter_matchmaking h1").innerHTML = "ENTER MATCHMAKING", document.querySelector("#enter_matchmaking p").innerHTML = "LEAVING EARLY IS PUNISHED", Ne(), l && clearInterval(l), ke(), R({
				state: "In Menus",
				largeImageKey: "logo",
				instance: !1
			})
		}), Dt.on("paired", e => {
			document.body.classList.remove("matchmaking"), document.body.classList.add("inpair"), document.getElementById("roomview").classList.remove("hosting"), document.querySelector("#enter_matchmaking h1").innerHTML = "MATCH FOUND", document.getElementById("mm_status_header").innerHTML = "MATCH FOUND", document.querySelector("#enter_matchmaking p").innerHTML = "JOINING MATCH", document.getElementById("mm_status_sub").innerHTML = "JOINING MATCH", document.getElementById("room_chat").innerHTML = "", document.getElementById("ingame_chat").innerHTML = "", document.getElementById("league_chat").innerHTML = "", yt.play("mmstart"), yt.play("hyperalert"), C = "player", et.stopNow(), R({
				details: "TETRA LEAGUE",
				state: "Match Found",
				largeImageKey: "logo",
				smallImageKey: "mode_league",
				smallImageText: "TETRA LEAGUE",
				instance: !1
			}), setTimeout(() => {
				Se(!1), Ce(), yt.play("matchintro"), ft.stop(2e3), g(e.you.username, e.opponent.username, Math.round(e.you.rating), Math.round(e.opponent.rating), e.you.rank, e.opponent.rank, e.you.placement, e.opponent.placement, e.ft)
			}, 1e3), setTimeout(() => {
				et.stopNow(), Se(!1), Ce()
			}, 1550), setTimeout(() => {
				et.stopNow(), Se(!1), Ce()
			}, 2500), setTimeout(() => {
				et.stopNow(), Se(!1), Ce()
			}, 3100), Je(e.opponent.username.toUpperCase(), "Your TETRA LEAGUE opponent is here!"), setTimeout(() => {
				Se(!1), document.querySelector("#enter_matchmaking h1").innerHTML = "ENTER MATCHMAKING", document.querySelector("#enter_matchmaking p").innerHTML = "LEAVING EARLY IS PUNISHED", et.stopNow()
			}, 4443), setTimeout(() => {
				Se(!1), et.stopNow()
			}, 6666), setTimeout(() => {
				Se(!1), et.stopNow()
			}, 8500), setTimeout(() => {
				Se(!1), et.stopNow()
			}, 9999), setTimeout(() => {
				Se(!1)
			}, 12e3), l && clearInterval(l)
		}), Dt.on("paircancel", e => {
			document.body.classList.remove("inpair"), Ue(), R({
				state: "In Menus",
				largeImageKey: "logo",
				instance: !1
			}), E({
				title: "GAME CANCELLED",
				classes: ["noclickout"],
				msg: "this game was cancelled because a player has left. your rating will not be adjusted.",
				buttons: [{
					label: "OK",
					classes: [],
					callback: e => {
						e(), je(), Se(!0), Fe("league"), ft.playSmooth("touhoudaiensei")
					}
				}]
			})
		}), window.DEVHOOK_PAIRED = (e, t, n, a, o, i, s, r, l) => {
			g(e, t, n, a, o, i, s, r, l)
		};
		let C = "player";

		function A(e) {
			const t = [];
			let n = 0,
				a = !1,
				o = !1;
			e.players.forEach(o => {
				t.push(`sp_${o._id}`);
				let i = document.getElementById(`sp_${o._id}`),
					s = i ? i.children[0] : null;
				if (i) o.anon || o.bot || wt(vt(o.xp), s.querySelector(".leveltag"));
				else {
					(i = document.createElement("div")).classList.add("scroller_player_container"), i.id = `sp_${o._id}`, (s = document.createElement("div")).classList.add("scroller_player"), s.classList.add("ns"), s.setAttribute("data-id", o._id), s.setAttribute("data-username", o.username), s.setAttribute("data-hover", "tap"), s.setAttribute("data-hit", "click"), i.appendChild(s), document.getElementById("room_players").appendChild(i), 2 === document.getElementById("room_players").children.length && document.getElementById("roomview").classList.contains("hosting") && Je(o.username.toUpperCase(), `joined your room "${e.meta.name}"`), a || (yt.play("userjoin"), a = !0);
					const t = document.createElement("h1");
					t.innerHTML = `${o.username.toUpperCase()}${o.supporter?'<img src="/res/supporter-tag.png" title="This person is supporting TETR.IO ♥" />':""}${"mod"===o.role?'<img src="/res/verified-mod.png" title="TETR.IO Moderator" />':""}${"admin"===o.role?'<img src="/res/verified-admin.png" title="TETR.IO Admin" />':""}${o.verified&&!["mod","admin"].includes(o.role)?'<img src="/res/verified.png" title="Verified" />':""}`, s.appendChild(t);
					const n = document.createElement("div");
					n.classList.add("scroller_player_badgelist"), n.innerHTML = o.anon || o.bot ? "" : It(vt(o.xp)), s.appendChild(n), o._id === w.id() && Bt !== o.xp && (wt(vt(o.xp), document.getElementById("me_level")), Tt(o.xp - Bt, !0))
				}
				if (e.owner === o._id) {
					if (!s.querySelector(".scroller_player_badgelist .host")) {
						const e = document.createElement("div");
						e.classList.add("host"), e.innerHTML = "HOST", s.querySelector(".scroller_player_badgelist").appendChild(e)
					}
				} else s.querySelector(".scroller_player_badgelist .host") && s.querySelector(".scroller_player_badgelist .host").remove();
				if (o.anon) {
					if (!s.querySelector(".scroller_player_badgelist .panon")) {
						const e = document.createElement("div");
						e.classList.add("panon"), e.innerHTML = "ANON", s.querySelector(".scroller_player_badgelist").appendChild(e)
					}
				} else s.querySelector(".scroller_player_badgelist .panon") && s.querySelector(".scroller_player_badgelist .panon").remove();
				if (o.bot) {
					if (!s.querySelector(".scroller_player_badgelist .pbot")) {
						const e = document.createElement("div");
						e.classList.add("pbot"), e.innerHTML = "BOT", s.querySelector(".scroller_player_badgelist").appendChild(e)
					}
				} else s.querySelector(".scroller_player_badgelist .pbot") && s.querySelector(".scroller_player_badgelist .pbot").remove();
				if (s.classList.toggle("spectator", "spectator" === o.bracket), i.style.order = "spectator" === o.bracket ? "" : (-1 * o.record.wins).toString(), w.id() === o._id && C !== o.bracket && (document.getElementById("roomview").classList.toggle("spectating", "spectator" === o.bracket), document.body.classList.toggle("room_spectating", "spectator" === o.bracket), document.getElementById("room_switchbracket").innerHTML = "spectator" === o.bracket ? 'SPECTATING<div id="swb_addendum">click to switch to PLAYERS</div>' : 'PLAYING<div id="swb_addendum">click to switch to SPECTATORS</div>', C = o.bracket), "player" === o.bracket && n++, s.classList.toggle("streak", o.record.streak > 0), !s.querySelector(".scroller_player_badgelist .precord")) {
					const e = document.createElement("div");
					e.classList.add("precord"), e.title = "Games won / Games played", s.querySelector(".scroller_player_badgelist").appendChild(e);
					const t = document.createElement("div");
					t.classList.add("pstreak"), t.title = "Win streak", s.querySelector(".scroller_player_badgelist").appendChild(t)
				}
				s.querySelector(".scroller_player_badgelist .precord").innerHTML = `${o.record.wins} / ${o.record.games}`, s.querySelector(".scroller_player_badgelist .pstreak").innerHTML = `${o.record.streak}`
			});
			const i = document.getElementById("room_players").children;
			for (let e = 0; e < i.length; e++) i[e].children[0].classList.contains("leaving") || t.includes(i[e].id) || (O(i[e]), o || (yt.play("userleave"), o = !0));
			document.getElementById("sr_playercount").innerHTML = `${n} PLAYER${1===n?"":"S"}`, document.getElementById("playercount").innerHTML = n, document.getElementById("playerlimit").innerHTML = e.meta.userlimit ? `/${e.meta.userlimit}` : "", document.getElementById("spectatorcount").innerHTML = e.players.length - n ? `+${e.players.length-n}` : "", document.getElementById("startroom").classList.toggle("disabled", n < 2)
		}

		function $(e) {
			document.querySelectorAll("#room_content_container .room_config_item[data-index]").forEach(t => {
				if (t.closest(".room_config_row").classList.contains("unsaved")) return;
				const n = t.getAttribute("data-index"),
					a = getSetDescendantProp(e, n);
				switch (t.getAttribute("type")) {
					case "number":
						t.value = a;
						break;
					case "checkbox":
						t.checked = !!a;
						break;
					case "text":
					default:
						t.value = a
				}
				if (t.classList.contains("room_config_spinner") && (t.textContent = a), t.classList.contains("music_picker"))
					if (t.setAttribute("data-song", a), ft.ost[a]) t.textContent = `${ft.ost[a].artist.toLowerCase()} - ${ft.ost[a].name.toLowerCase()}`;
					else switch (a) {
						case "RANDOM":
							t.textContent = "RANDOM";
							break;
						case "RANDOMcalm":
							t.textContent = "RANDOM: CALM";
							break;
						case "RANDOMbattle":
							t.textContent = "RANDOM: BATTLE";
							break;
						default:
							t.textContent = a
					}
			})
		}

		function O(e) {
			e.children[0].classList.add("leaving"), setTimeout(() => {
				document.getElementById("room_players").removeChild(e)
			}, 500)
		}

		function D(e) {
			N({
				content: e,
				user: {
					username: "[CMD]",
					_id: null
				},
				system: !0,
				announcement: !1
			})
		}

		function N(e) {
			if (J(e.user._id)) return;
			!1 !== G.video.chatfilter && e.content_safe && e.user._id != w.id() && (e.content = e.content_safe), p = document.createElement("div"), p.classList.add("chat_message"), e.system && p.classList.add("system"), e.announcement && p.classList.add("announcement"), e.user.supporter && p.classList.add("supporterchat"), "admin" === e.user.role && p.classList.add("adminchat"), "mod" === e.user.role && p.classList.add("modchat");
			const t = document.createElement("h1");
			t.innerHTML = e.user.username.toUpperCase(), "[SYS]" !== e.user.username.toUpperCase() && (t.classList.add("chat_tag"), t.setAttribute("data-id", e.user._id)), p.appendChild(t);
			const n = document.createElement("p");
			n.innerHTML = Ot(U(e.content)), p.appendChild(n), document.getElementById("room_chat").appendChild(p), document.getElementById("ingame_chat").appendChild(p.cloneNode(!0)), document.getElementById("league_chat").appendChild(p.cloneNode(!0)), document.getElementById("room_chat").children.length > 100 && document.getElementById("room_chat").removeChild(document.getElementById("room_chat").children[0]), document.getElementById("ingame_chat").children.length > 100 && document.getElementById("ingame_chat").removeChild(document.getElementById("ingame_chat").children[0]), document.getElementById("league_chat").children.length > 100 && document.getElementById("league_chat").removeChild(document.getElementById("league_chat").children[0]), document.getElementById("room_chat").scrollTop = document.getElementById("room_chat").scrollHeight + 100, document.getElementById("ingame_chat").scrollTop = document.getElementById("ingame_chat").scrollHeight + 100, document.getElementById("league_chat").scrollTop = document.getElementById("league_chat").scrollHeight + 100
		}

		function P() {
			document.body.classList.contains("inpair") || (xe("rsg", "3"), yt.play("rsg"), setTimeout(() => {
				xe("rsg", "2"), yt.play("rsg")
			}, 500), setTimeout(() => {
				xe("rsg", "1"), yt.play("rsg")
			}, 1e3), setTimeout(() => {
				xe("rsg", "GO!"), yt.play("rsg_go")
			}, 1500))
		}

		function z(e, t, n, a) {
			yt.play("victory"), document.getElementById("victory_header").innerHTML = a ? "WINNERS!" : "WINNER!", document.getElementById("victory_victor").innerHTML = e, document.getElementById("victory_sub").innerHTML = t, document.getElementById("victory_also").innerHTML = n, document.getElementById("victory").classList.remove("hidden"), setTimeout(() => {
				pn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 6, 1.5, .5, 0, window.innerHeight / 7, .02, 175, 185, 0, 2500, 2e3, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 6, 1.5, .5, 0, window.innerHeight / 7, .02, 175, 185, 0, 2500, 2e3, 3, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 4.5, .18, .14, 0, window.innerHeight / 7, .25, 175, 185, 0, 2500, 2e3, 3, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 6, 1.5, .5, 0, window.innerHeight / 7, .02, -5, 5, 0, 2500, 2e3, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 6, 1.5, .5, 0, window.innerHeight / 7, .02, -5, 5, 0, 2500, 2e3, 3, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 4.5, .18, .14, 0, window.innerHeight / 7, .25, -5, 5, 0, 2500, 2e3, 3, 0, .9, !0)
			}, 1e3), setTimeout(() => {
				document.getElementById("victory").classList.add("hidden")
			}, 5e3)
		}

		function j(e, t, n, a, o, i, s, r) {
			const l = document.createElement("div");
			l.classList.add("scroller_block"), l.classList.add("playerresult"), l.classList.add("record_item"), l.setAttribute("data-id", n), l.setAttribute("data-hover", "tap"), l.setAttribute("data-hit", "click"), t && l.classList.add("record_first"), r || l.classList.add("disconnected"), a === w.username() && l.classList.add("record_me"), document.getElementById("playerresults").appendChild(l);
			const d = document.createElement("div");
			d.classList.add("record_grade"), d.classList.add("ns"), d.innerHTML = e, l.appendChild(d);
			const c = document.createElement("div");
			c.classList.add("record_owner"), c.innerHTML = a.toUpperCase(), l.appendChild(c);
			const m = document.createElement("div");
			m.classList.add("record_ts"), m.innerHTML = s, l.appendChild(m);
			const u = document.createElement("div");
			u.classList.add("record_result"), u.innerHTML = o, l.appendChild(u);
			const g = document.createElement("div");
			g.classList.add("record_extra"), g.innerHTML = i, l.appendChild(g)
		}

		function W(e, t, n) {
			const a = document.createElement("tr");
			e.appendChild(a);
			const o = document.createElement("td");
			o.innerHTML = t, a.appendChild(o);
			const i = document.createElement("td");
			i.innerHTML = n, a.appendChild(i)
		}

		function q() {
			He("fetching room listing…"), r.get("/api/rooms/", {}, !0).then(e => {
				Ne(), X(e.rooms), pe.bindGuide(he[Ie] || {})
			}, e => {
				Ne(), u(e)
			})
		}

		function X(e) {
			if (holder = document.getElementById("room_listing_container"), holder.innerHTML = "", e.forEach(e => {
					const t = document.createElement("div");
					t.classList.add("scroller_block"), t.classList.add("room_listing_item"), t.classList.add("ns"), t.setAttribute("data-hover", "hover"), t.setAttribute("data-hit", "hit3"), t.setAttribute("title", e.meta.name), holder.appendChild(t);
					const n = document.createElement("div");
					n.classList.add("room_listing_name"), n.textContent = e.meta.name, t.appendChild(n);
					const a = document.createElement("div");
					a.classList.add("room_listing_count"), a.innerHTML = `${e.playingplayers}${e.meta.userlimit?`<span class="room_listing_limit">/${e.meta.userlimit}</span>`:""}${e.playercount-e.playingplayers?`<span class="room_listing_spectators">+${e.playercount-e.playingplayers}</span>`:""}`, t.appendChild(a);
					const o = document.createElement("div");
					o.classList.add("room_listing_info"), o.innerHTML = `${e.state.toUpperCase()} - <span class="room_listing_id">${e.id}</span>`, t.appendChild(o);
					const i = document.createElement("div");
					i.classList.add("room_listing_extra"), i.innerHTML = `anons allowed: <span>${e.meta.allowAnonymous?"YES":"NO"}</span>`, t.appendChild(i), t.addEventListener("click", () => {
						f(e.id)
					})
				}), !e.length) {
				const e = document.createElement("div");
				e.classList.add("scroller_block"), e.classList.add("nothing"), e.classList.add("ns"), e.innerHTML = "NO ROOMS", holder.appendChild(e)
			}
		}
		let K = !1;

		function Y(e) {
			e !== K && (e ? (document.getElementById("referee").classList.remove("hidden"), document.getElementById("referee").classList.remove("hiding")) : (document.getElementById("referee").classList.add("hiding"), setTimeout(() => {
				document.getElementById("referee").classList.add("hidden")
			}, 500)), K = e)
		}

		function V(n, a) {
			document.getElementById("referee").classList.toggle("ft1", 1 === n.ft), document.getElementById("exit_spectate").classList.toggle("blocked", "player" === C && 1 !== n.ft), document.getElementById("zen_spectate").classList.toggle("blocked", "player" === C && 1 !== n.ft), document.getElementById("referee").classList.toggle("duel", 2 === a.length || a.length > 8), document.getElementById("referee_top").textContent = `${zt||n.gamemode} FT${n.ft}`;
			let o = -1;
			const i = [];
			2 === a.length && a.sort((e, t) => e.naturalorder - t.naturalorder), a.forEach(n => {
				if (n.user._id == w.id()) {
					const a = ++o >= 8 ? t : e[o];
					i.push(`<div class="referee_point" style="--r: ${a[0]}; --g: ${a[1]}; --b: ${a[2]};"><h1>${n.wins}</h1><p>${n.user.username.toUpperCase()}</p></div>`)
				}
			});
			let s = !0,
				r = !0,
				l = 0,
				d = 0;
			a.forEach(n => {
				if (n.user._id == w.id()) return;
				if (!r) return;
				if (a.length >= 8) {
					if (n.wins < d) return void(r = !1);
					if (l++, d = n.wins, !s) return;
					s = !1
				}
				const c = ++o >= 8 ? t : e[o];
				i.push(`<div class="referee_point" style="--r: ${c[0]}; --g: ${c[1]}; --b: ${c[2]};"><h1>${n.wins}</h1><p>${n.user.username.toUpperCase()}</p></div>`)
			});
			let c = i.join('<div class="referee_sep">-</div>');
			l > 1 && (c += `<div class="referee_sep">+${l-1}</div>`), document.getElementById("referee_points").innerHTML = c
		}

		function Z(e, t, n) {
			const a = 2 === t.length;
			if (a && t.sort((e, t) => e.naturalorder - t.naturalorder), document.getElementById("scoreslide_header").textContent = `${zt||e.gamemode} FT${e.ft}`, document.getElementById("scoreslide").classList.toggle("duel", a), document.getElementById("scoreslide").classList.remove("pinged"), document.getElementById("scoreslide").classList.remove("pingedp1"), document.getElementById("scoreslide").classList.remove("pingedp2"), a) {
				let a = 1,
					o = 0;
				t[1].user.username === w.username() ? (document.querySelector("#scoreslide_duel_p1 p").innerHTML = t[1].user.username.toUpperCase(), document.querySelector("#scoreslide_duel_p2 p").innerHTML = t[0].user.username.toUpperCase(), t[1].user.username === n ? (a = 1, o = t[1].wins, document.querySelector("#scoreslide_duel_p1 h1").innerHTML = t[1].wins - 1, document.querySelector("#scoreslide_duel_p2 h1").innerHTML = t[0].wins) : (a = 2, o = t[0].wins, document.querySelector("#scoreslide_duel_p1 h1").innerHTML = t[1].wins, document.querySelector("#scoreslide_duel_p2 h1").innerHTML = t[0].wins - 1)) : (document.querySelector("#scoreslide_duel_p1 p").innerHTML = t[0].user.username.toUpperCase(), document.querySelector("#scoreslide_duel_p2 p").innerHTML = t[1].user.username.toUpperCase(), t[0].user.username === n ? (a = 1, o = t[0].wins, document.querySelector("#scoreslide_duel_p1 h1").innerHTML = t[0].wins - 1, document.querySelector("#scoreslide_duel_p2 h1").innerHTML = t[1].wins) : (a = 2, o = t[1].wins, document.querySelector("#scoreslide_duel_p1 h1").innerHTML = t[0].wins, document.querySelector("#scoreslide_duel_p2 h1").innerHTML = t[1].wins - 1)), document.body.classList.contains("inpair") && (setTimeout(() => {
					document.getElementById("scoreslide").classList.add("leaguess"), document.body.classList.add("shaking"), yt.play("impact"), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFFFFF", 50, .25, .14, 0, window.innerHeight, .05, 0, 360, 0, 600, 0, .05, 4.5, .9, !0)
				}, 250), setTimeout(() => {
					document.body.classList.remove("shaking")
				}, 300), setTimeout(() => {
					document.getElementById("scoreslide").classList.remove("leaguess")
				}, 5e3)), setTimeout(() => {
					t[0].wins === e.ft - 1 && t[1].wins === e.ft - 1 ? (document.getElementById("scoreslide_duel_match").innerHTML = "TIEBREAKER", document.getElementById("scoreslide_duel_match").classList.add("ssdm_p3"), setTimeout(() => {
						document.body.classList.add("shaking"), yt.play("allclear"), hn(window.innerWidth / 2, window.innerHeight, "#FFB400", 5, .15, .14, window.innerWidth, 0, .25, 255, 285, 0, 1e3, 500, 2.5, 0, .9, !0)
					}, 350), setTimeout(() => {
						document.body.classList.remove("shaking")
					}, 400)) : t[0].wins === e.ft - 1 && t[0].user.username === w.username() || t[1].wins === e.ft - 1 && t[1].user.username === w.username() || t[0].wins === e.ft - 1 && t[0].user.username !== w.username() && t[1].user.username !== w.username() ? (document.getElementById("scoreslide_duel_match").innerHTML = "MATCH POINT", document.getElementById("scoreslide_duel_match").classList.add("ssdm_p1")) : (t[0].wins === e.ft - 1 && t[0].user.username !== w.username() || t[1].wins === e.ft - 1 && t[1].user.username !== w.username() || t[1].wins === e.ft - 1 && t[0].user.username !== w.username() && t[1].user.username !== w.username()) && (document.getElementById("scoreslide_duel_match").innerHTML = "MATCH POINT", document.getElementById("scoreslide_duel_match").classList.add("ssdm_p2"))
				}, 1500), setTimeout(() => {
					document.getElementById("scoreslide_duel_match").classList.remove("ssdm_p1"), document.getElementById("scoreslide_duel_match").classList.remove("ssdm_p2"), document.getElementById("scoreslide_duel_match").classList.remove("ssdm_p3")
				}, 5e3), setTimeout(() => {
					yt.play("showscore"), document.getElementById("scoreslide").classList.add(`pingedp${a}`), document.querySelector(`#scoreslide_duel_p${a} h1`).innerHTML = o, 1 === a ? (pn(window.innerWidth / 2, window.innerHeight / 2, "#0042FF", 50, 3, .5, 0, window.innerHeight, .02, 175, 185, 0, 2500, 2e3, 2.5, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#0042FF", 50, 3, .5, 0, window.innerHeight, .02, 175, 185, 0, 2500, 2e3, 2.5, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#0042FF", 40, .4, .14, 0, window.innerHeight, .15, 175, 185, 0, 2500, 2e3, 2.5, 0, .9, !0)) : (pn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 50, 3, .5, 0, window.innerHeight, .02, -5, 5, 0, 2500, 2e3, 2.5, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 50, 3, .5, 0, window.innerHeight, .02, -5, 5, 0, 2500, 2e3, 2.5, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 40, .4, .14, 0, window.innerHeight, .15, -5, 5, 0, 2500, 2e3, 2.5, 0, .9, !0))
				}, 1500)
			} else {
				let e = 0,
					a = "";
				t.forEach(t => {
					t.user.username === n && (e = t.wins, document.getElementById("scoreslide_leader_name").innerHTML = t.user.username.toUpperCase(), document.getElementById("scoreslide_leader_points").innerHTML = t.wins - 1), a += `<div class="scoreslide_player"><p>${t.user.username.toUpperCase()}</p><h1>${t.wins}</h1></div>`
				}), document.getElementById("scoreslide_list").innerHTML = a, setTimeout(() => {
					yt.play("showscore"), document.getElementById("scoreslide").classList.add("pinged"), document.getElementById("scoreslide_leader_points").innerHTML = e
				}, 1500)
			}
			document.getElementById("scoreslide").classList.remove("hidden"), yt.play("scoreslide_in"), setTimeout(() => {
				document.getElementById("scoreslide").classList.remove("hiding")
			}, 20), setTimeout(() => {
				document.getElementById("scoreslide").classList.add("hiding"), yt.play("scoreslide_out")
			}, 4e3), setTimeout(() => {
				document.getElementById("scoreslide").classList.add("hidden")
			}, 5e3)
		}

		function J(e) {
			return Pt.includes(e)
		}

		function Q(e) {
			J(e) || (Pt.push(e), localStorage.setItem("ignoredUserIDs", Pt.join(",")))
		}

		function ee(e) {
			J(e) && (Pt = Pt.filter(t => t !== e), localStorage.setItem("ignoredUserIDs", Pt.join(",")))
		}

		function te() {
			He("entering matchmaking…"), Dt.emit("entermatchmaking")
		}

		function ne() {
			He("leaving matchmaking…"), Dt.emit("leavematchmaking")
		}

		function ae(e, t) {
			const n = fe;
			let a = 0,
				o = setInterval(() => {
					let i = Math.round(Rn(n, e, a, BezierEasing(.74, .03, .09, .97)) - n);
					document.getElementById("leaguestanding_rating").innerHTML = `${Math.round(Rn(n,e,a,BezierEasing(.74,.03,.09,.97)))}<span>TR</span>${-1!==n?` <span class="leaguechange">${0===i?"Ǵ":i>=150?"Ǹ":i>0?"Ƿ":i<=-150?"Ƕ":"ǵ"}${Math.abs(i)}</span>`:""}`, (a += 1 / t) >= 1 && (i = Math.round(e - n), document.getElementById("leaguestanding_rating").innerHTML = `${e}<span>TR</span>${-1!==n?` <span class="leaguechange">${0===i?"Ǵ":i>=150?"Ǹ":i>0?"Ƿ":i<=-150?"Ƕ":"ǵ"}${Math.abs(i)}</span>`:""}`, clearInterval(o), fe = e)
				}, 16)
		}

		function oe() {
			document.getElementById("leaguestanding_rating").innerHTML = `${fe}<span>TR</span> <span class="leaguechange">Ǵ0</span>`
		}

		function se(e, t) {
			const n = Ee;
			let a = 0,
				o = setInterval(() => {
					let i = Math.round(n - Rn(n, e, a, BezierEasing(.74, .03, .09, .97)));
					document.getElementById("leaguestanding_placement").innerHTML = `#<span>${Math.round(Rn(n,e,a,BezierEasing(.74,.03,.09,.97)))}</span>`, document.getElementById("leaguestanding_placement").classList.toggle("t100", Math.round(Rn(n, e, a, BezierEasing(.74, .03, .09, .97))) <= 100 && Math.round(Rn(n, e, a, BezierEasing(.74, .03, .09, .97))) > 1), document.getElementById("leaguestanding_placement").classList.toggle("t1", 1 === Math.round(Rn(n, e, a, BezierEasing(.74, .03, .09, .97)))), document.getElementById("leaguestanding_placement_change").innerHTML = -1 !== n ? `${0===i?"Ǵ":i>=10?"Ǹ":i>0?"Ƿ":i<=-10?"Ƕ":"ǵ"}${Math.abs(i)}</span>` : "", (a += 1 / t) >= 1 && (i = Math.round(n - e), document.getElementById("leaguestanding_placement").innerHTML = `#<span>${e}</span>`, document.getElementById("leaguestanding_placement").classList.toggle("t100", e <= 100 && e > 1), document.getElementById("leaguestanding_placement").classList.toggle("t1", 1 === e), document.getElementById("leaguestanding_placement_change").innerHTML = -1 !== n ? `${0===i?"Ǵ":i>=10?"Ǹ":i>0?"Ƿ":i<=-10?"Ƕ":"ǵ"}${Math.abs(i)}</span>` : "", clearInterval(o), Ee = e)
				}, 16)
		}

		function re() {
			document.getElementById("leaguestanding_placement_change").innerHTML = "Ǵ0"
		}
		const le = ["z", "d", "d+", "c-", "c", "c+", "b-", "b", "b+", "a-", "a", "a+", "s-", "s", "s+", "ss", "u", "x"];

		function de(e) {
			const t = _e;
			if (t === e) return void(document.getElementById("leaguestanding_rank").src = `/res/league-ranks/${e}.png`);
			const n = le.indexOf(t);
			le.indexOf(e) > n ? (document.getElementById("leaguestanding_rank").classList.add("rankraise"), setTimeout(() => {
				yt.play("rankraise")
			}, 400), setTimeout(() => {
				document.body.classList.add("shaking")
			}, 1800), setTimeout(() => {
				document.body.classList.remove("shaking")
			}, 1900)) : (setTimeout(() => {
				yt.play("ranklower")
			}, 400), document.getElementById("leaguestanding_rank").classList.add("ranklower")), setTimeout(() => {
				document.getElementById("leaguestanding_rank").src = `/res/league-ranks/${e}.png`
			}, 1050), setTimeout(() => {
				document.getElementById("leaguestanding_rank").classList.remove("rankraise"), document.getElementById("leaguestanding_rank").classList.remove("ranklower")
			}, 4500), _e = e
		}

		function ce(e) {
			_e !== e || (document.getElementById("leaguestanding_rank").src = `/res/league-ranks/${e}.png`)
		}
		return {
			createRoom: y,
			joinRoom: f,
			leaveRoom: _,
			sendChatMessage: I,
			startRoom: k,
			switchBracket: B,
			switchBracketHost: T,
			saveRoomConfig: v,
			loadListing: q,
			isUserIgnored: J,
			ignoreUser: Q,
			unignoreUser: ee,
			kickUser: L,
			transferOwnership: F,
			enterMatchmaking: te,
			leaveMatchmaking: ne,
			dropMultiplex: () => {
				document.getElementById("spectate").classList.add("hidden"), document.body.classList.remove("multiplexed"), document.body.classList.remove("inmulti"), document.body.classList.remove("spectating"), document.body.classList.remove("inpair"), ft.stop(), Y(!1), Ct.enabled(!1), Ct.stopTimer(), document.getElementById("leaveroom").classList.remove("hidden"), Se(!0), Nt = !1
			},
			showAnnouncement: e => {
				N({
					content: e,
					user: {
						username: "[SYS]",
						_id: null
					},
					system: !1,
					announcement: !0
				})
			},
			returnToRoom: () => {
				"X-QP" === n.id ? R({
					details: "QUICK PLAY",
					state: "In Lobby",
					largeImageKey: "logo",
					smallImageKey: "mode_quickplay",
					smallImageText: "QUICK PLAY",
					instance: !1
				}) : R({
					details: "CUSTOM ROOM",
					state: "In Lobby",
					largeImageKey: "logo",
					smallImageKey: "mode_customroom",
					smallImageText: "CUSTOM ROOM",
					instance: !1
				})
			}
		}
	})();

	function Wt(e) {
		let t = e % 2147483647;
		return t <= 0 && (t += 2147483646), {
			next: function () {
				return t = 16807 * t % 2147483647
			},
			nextFloat: function (e, t) {
				return (this.next() - 1) / 2147483646
			},
			shuffleArray: function (e) {
				let t, n = e.length;
				if (0 == n) return e;
				for (; --n;) t = Math.floor(this.nextFloat() * (n + 1)), [e[n], e[t]] = [e[t], e[n]];
				return e
			}
		}
	}
	let Gt, qt, Xt, Kt, Yt, Vt, Zt, Jt, Qt, en, tn, nn, an, on, sn, rn, ln, dn;

	function cn(e) {
		return e / (G.video.particles || .6)
	}

	function mn(e) {
		return e * (2.2 - Math.max(0, 2.2 * (1 - (G.video.particles || .6))))
	}

	function un(e, t, n) {
		if ("ultra" !== G.video.graphics || 0 == G.video.flashwave) return;
		null === Dn.stage.filters && (Dn.stage.filters = []);
		const a = void 0 === G.video.flashwave ? 1 : G.video.flashwave;
		Dn.stage.filters.push(new PIXI.filters.ShockwaveFilter([e, t], {
			amplitude: (2 + 2 * n) * a,
			wavelength: mt(150 + 40 * n * (.5 + .5 * a)),
			speed: mt(500 + 50 * n),
			brightness: 1 + .25 * a,
			radius: -1
		}, 0))
	}

	function gn(e, t, n, a, o, i, s, r = 1, l = 0, d = 360, c = 200, m = 50, u = .1, g = 2.25, p = 1) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(qt, [PIXI.Texture.from("res/particle.png")], {
			alpha: {
				start: r,
				end: 0
			},
			scale: {
				start: mn(.08),
				end: mn(.01),
				minimumScaleMultiplier: 1
			},
			color: {
				start: n || "#FFFFFF",
				end: a || "#FFFFFF"
			},
			speed: {
				start: c,
				end: m,
				minimumSpeedMultiplier: p
			},
			acceleration: {
				x: 0,
				y: c * g
			},
			maxSpeed: 0,
			startRotation: {
				min: l,
				max: d
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .2,
				max: .8
			},
			blendMode: "normal",
			frequency: cn(.05 / o),
			emitterLifetime: u,
			maxParticles: 500,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: i / -2,
				y: s / -2,
				w: i,
				h: s
			}
		}).playOnceAndDestroy()
	}

	function pn(e, t, n, a, o, i, s, r, l = 1, d = 0, c = 360, m = 0, u = 200, g = 50, p = .1, h = 2.25, y = 1, f = !1, _ = !1, E = !1) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) {
			if (!E || "minimal" === G.video.graphics) return;
			"low" === G.video.graphics && (a *= .5)
		}
		if (f && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(f && "ultra" === G.video.graphics && Hn ? an : _ ? rn : en, [PIXI.Texture.from("res/bokeh.png")], {
			alpha: {
				list: [{
					value: 0,
					time: 0
				}, {
					value: l,
					time: .2
				}, {
					value: 0,
					time: 1
				}],
				isStepped: !1
			},
			scale: {
				start: mn(o),
				end: .999 * mn(o),
				minimumScaleMultiplier: i
			},
			color: {
				start: n || "#FFFFFF",
				end: n || "#FFFFFF"
			},
			speed: {
				start: u,
				end: g,
				minimumSpeedMultiplier: y
			},
			acceleration: {
				x: 0,
				y: u * h
			},
			maxSpeed: 0,
			startRotation: {
				min: d,
				max: c
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: m
			},
			lifetime: {
				min: .8,
				max: 2.5
			},
			blendMode: "screen",
			frequency: cn(.05 / a),
			emitterLifetime: p,
			maxParticles: 500,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: s / -2,
				y: r / -2,
				w: s,
				h: r
			}
		}).playOnceAndDestroy()
	}

	function hn(e, t, n, a, o, i, s, r, l = 1, d = 0, c = 360, m = 0, u = 200, g = 50, p = .1, h = 2.25, y = 1, f = !1, _ = !1) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		if (f && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(f && "ultra" === G.video.graphics && Hn ? on : _ ? ln : tn, [PIXI.Texture.from("res/ricegrain.png")], {
			alpha: {
				list: [{
					value: 0,
					time: 0
				}, {
					value: l,
					time: .2
				}, {
					value: 0,
					time: 1
				}],
				isStepped: !1
			},
			scale: {
				start: mn(o),
				end: mn(o),
				minimumScaleMultiplier: i
			},
			color: {
				start: n || "#FFFFFF",
				end: n || "#FFFFFF"
			},
			speed: {
				start: u,
				end: g,
				minimumSpeedMultiplier: y
			},
			acceleration: {
				x: 0,
				y: u * h
			},
			maxSpeed: 0,
			startRotation: {
				min: d,
				max: c
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: m
			},
			lifetime: {
				min: .35,
				max: 1
			},
			blendMode: "screen",
			frequency: cn(.05 / a),
			emitterLifetime: p,
			maxParticles: 500,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: s / -2,
				y: r / -2,
				w: s,
				h: r
			}
		}).playOnceAndDestroy()
	}

	function yn(e, t, n, a, o, i, s, r, l = 1, d = 0, c = 360, m = 0, u = 200, g = 50, p = .1, h = 2.25, y = 1, f = !1, _ = !1, E = !1) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) {
			if (!E || "minimal" === G.video.graphics) return;
			"low" === G.video.graphics && (a *= .5)
		}
		if (f && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(f && "ultra" === G.video.graphics && Hn ? sn : _ ? dn : nn, [PIXI.Texture.from("res/ricegrain.png")], {
			alpha: {
				list: [{
					value: 0,
					time: 0
				}, {
					value: l,
					time: .2
				}, {
					value: 0,
					time: 1
				}],
				isStepped: !1
			},
			scale: {
				start: mn(o),
				end: .999 * mn(o),
				minimumScaleMultiplier: i
			},
			color: {
				start: n || "#FFFFFF",
				end: n || "#FFFFFF"
			},
			speed: {
				start: u,
				end: g,
				minimumSpeedMultiplier: y
			},
			acceleration: {
				x: 0,
				y: u * h
			},
			maxSpeed: 0,
			startRotation: {
				min: d,
				max: c
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: m
			},
			lifetime: {
				min: .8,
				max: 2.5
			},
			blendMode: "screen",
			frequency: cn(.05 / a),
			emitterLifetime: p,
			maxParticles: 500,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: s / -2,
				y: r / -2,
				w: s,
				h: r
			}
		}).playOnceAndDestroy()
	}

	function fn(e, t, n, a, o, i, s, r, l = 1, d = 0, c = 360, m = 0, u = 0, g = !0) {
		if ("medium" !== G.video.graphics && "high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(Xt, [PIXI.Texture.from("res/box.png")], {
			alpha: {
				start: l,
				end: 0
			},
			scale: {
				start: mt(n),
				end: mt(n),
				minimumScaleMultiplier: 1
			},
			color: {
				start: a || "#FFFFFF",
				end: o || "#FFFFFF"
			},
			speed: {
				start: m,
				end: u,
				minimumSpeedMultiplier: 1
			},
			acceleration: {
				x: 0,
				y: 0
			},
			maxSpeed: 0,
			startRotation: {
				min: d,
				max: c
			},
			noRotation: g,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .2,
				max: .8
			},
			blendMode: "normal",
			frequency: cn(.05 / i),
			emitterLifetime: .1,
			maxParticles: 500,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: s / -2,
				y: r / -2,
				w: s,
				h: r
			}
		}).playOnceAndDestroy()
	}

	function _n(e, t, n, a) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		if (0 == G.video.pieceflash) return;
		new PIXI.particles.Emitter(Kt, [PIXI.Texture.from("res/hbox.png")], {
			alpha: {
				start: .05 * (void 0 === G.video.pieceflash ? 1 : G.video.pieceflash),
				end: 0
			},
			scale: {
				start: mt(n),
				end: mt(2 * n),
				minimumScaleMultiplier: 1
			},
			color: {
				start: "#FFFFFF",
				end: "#FFFFFF"
			},
			speed: {
				start: 0,
				end: 0,
				minimumSpeedMultiplier: 1
			},
			acceleration: {
				x: 0,
				y: 0
			},
			maxSpeed: 0,
			startRotation: {
				min: a,
				max: a
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .15,
				max: .15
			},
			blendMode: "screen",
			frequency: .001,
			emitterLifetime: .1,
			maxParticles: 1,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: 0,
				y: 0,
				w: 1,
				h: 1
			}
		}).playOnceAndDestroy()
	}

	function En(e, t, n, a) {
		if ("medium" !== G.video.graphics && "high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		if (0 == G.video.pieceflash) return;
		new PIXI.particles.Emitter(Yt, [PIXI.Texture.from("res/lbox.png")], {
			alpha: {
				start: .3 * (void 0 === G.video.pieceflash ? 1 : G.video.pieceflash),
				end: 0
			},
			scale: {
				start: mt(n),
				end: mt(n),
				minimumScaleMultiplier: 1
			},
			color: {
				start: "#FFFFFF",
				end: "#FFFFFF"
			},
			speed: {
				start: 0,
				end: 0,
				minimumSpeedMultiplier: 1
			},
			acceleration: {
				x: 0,
				y: 0
			},
			maxSpeed: 0,
			startRotation: {
				min: a,
				max: a
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .5,
				max: .5
			},
			blendMode: "screen",
			frequency: .001,
			emitterLifetime: .1,
			maxParticles: 1,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "rect",
			spawnRect: {
				x: 0,
				y: 0,
				w: 1,
				h: 1
			}
		}).playOnceAndDestroy()
	}

	function vn(e, t, n, a, o, i, s = 1, r = 0, l = 360, d = 200, c = 50) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(Vt, [PIXI.Texture.from("res/particle.png")], {
			alpha: {
				start: s,
				end: 0
			},
			scale: {
				start: mn(.08),
				end: mn(.01),
				minimumScaleMultiplier: 1
			},
			color: {
				start: a || "#FFFFFF",
				end: o || "#FFFFFF"
			},
			speed: {
				start: d,
				end: c,
				minimumSpeedMultiplier: 1
			},
			acceleration: {
				x: 0,
				y: 0
			},
			maxSpeed: 0,
			startRotation: {
				min: r,
				max: l
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .2,
				max: .8
			},
			blendMode: "normal",
			frequency: cn(.05 / i),
			emitterLifetime: .1,
			maxParticles: 500,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "ring",
			spawnCircle: {
				x: 0,
				y: 0,
				r: n,
				minR: n
			}
		}).playOnceAndDestroy()
	}

	function bn(e, t, n, a, o, i = 1, s = 0, r = 360, l = 200, d = 50, c = .1, m = !1) {
		if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
		new PIXI.particles.Emitter(Zt, [PIXI.Texture.from("res/smoke.png")], {
			alpha: {
				start: i,
				end: 0
			},
			scale: {
				start: mn(m ? .2 : .1),
				end: mn(m ? 1 : .5),
				minimumScaleMultiplier: 1
			},
			color: {
				start: n || "#FFFFFF",
				end: a || "#FFFFFF"
			},
			speed: {
				start: l,
				end: d,
				minimumSpeedMultiplier: 1
			},
			acceleration: {
				x: 0,
				y: 0
			},
			maxSpeed: 0,
			startRotation: {
				min: s,
				max: r
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .2,
				max: .5
			},
			blendMode: "add",
			frequency: .03 / o,
			emitterLifetime: c,
			maxParticles: 100,
			pos: {
				x: e,
				y: t
			},
			addAtBack: !1,
			spawnType: "point"
		}).playOnceAndDestroy()
	}
	I.ready((function (e) {
		PIXI.Ticker.shared.add(e => {
			"ultra" === G.video.graphics && null !== Dn.stage.filters && (Dn.stage.filters.forEach((t, n) => {
				t.time += e / (1e3 / 60), t.amplitude *= .98, t.brightness = 1 + .95 * (t.brightness - 1), t.time > 5 && Dn.stage.filters.splice(n, 1)
			}), 0 === Dn.stage.filters.length && (Dn.stage.filters = null))
		})
	}));
	const In = {};
	let wn = 0,
		kn, Ln, xn, Bn, Tn, Fn;

	function Mn(e, t, n, a, o, i, s, r, l, d = "#FFED99", c, m, u, g, p = !1) {
		if ("medium" !== G.video.graphics && "high" !== G.video.graphics && "ultra" !== G.video.graphics && (p = !0), "minimal" === G.video.graphics) return;
		const h = new PIXI.particles.Emitter(Jt, [PIXI.Texture.from("res/spark.png")], {
				alpha: {
					start: 1,
					end: 0,
					minimumAlphaMultiplier: .6
				},
				scale: {
					start: 1 + .1 * o,
					end: .5 + .05 * i,
					minimumScaleMultiplier: .6
				},
				color: {
					start: d || "#FFFFFF",
					end: d || "#FFFFFF"
				},
				speed: {
					start: 25 * o,
					end: 10,
					minimumSpeedMultiplier: .2
				},
				acceleration: {
					x: 0,
					y: 0
				},
				maxSpeed: 0,
				startRotation: {
					min: 0,
					max: 360
				},
				noRotation: !1,
				rotationSpeed: {
					min: 0,
					max: 0
				},
				lifetime: {
					min: .1,
					max: .2
				},
				blendMode: "screen",
				frequency: p ? .1 : .0085,
				emitterLifetime: s / 60,
				maxParticles: 100,
				pos: {
					x: e,
					y: t
				},
				addAtBack: !1,
				spawnType: "point"
			}),
			y = new PIXI.particles.Emitter(Qt, [PIXI.Texture.from("res/flare.png")], {
				alpha: {
					start: 1,
					end: 0,
					minimumAlphaMultiplier: .9
				},
				scale: {
					start: 1 + .1 * o,
					end: .3,
					minimumScaleMultiplier: .8
				},
				color: {
					start: d || "#FFFFFF",
					end: d || "#FFFFFF"
				},
				speed: {
					start: 0,
					end: 0,
					minimumSpeedMultiplier: 0
				},
				acceleration: {
					x: 0,
					y: 0
				},
				maxSpeed: 0,
				startRotation: {
					min: -2,
					max: 2
				},
				noRotation: !1,
				rotationSpeed: {
					min: 0,
					max: 0
				},
				lifetime: {
					min: .01,
					max: .01
				},
				blendMode: "screen",
				frequency: .002,
				emitterLifetime: s / 60,
				maxParticles: 100,
				pos: {
					x: e,
					y: t
				},
				addAtBack: !1,
				spawnType: "point"
			});
		let f = null;
		g && !p && (f = new PIXI.particles.Emitter(Jt, [PIXI.Texture.from("res/spark.png")], {
			alpha: {
				start: 1,
				end: 0,
				minimumAlphaMultiplier: .8
			},
			scale: {
				start: 2 + .2 * i,
				end: 1 + .1 * i,
				minimumScaleMultiplier: .6
			},
			color: {
				start: d || "#FFFFFF",
				end: d || "#FFFFFF"
			},
			speed: {
				start: 150 + 40 * i,
				end: 0,
				minimumSpeedMultiplier: .5
			},
			acceleration: {
				x: 0,
				y: 0
			},
			maxSpeed: 0,
			startRotation: {
				min: 0,
				max: 360
			},
			noRotation: !1,
			rotationSpeed: {
				min: 0,
				max: 0
			},
			lifetime: {
				min: .1,
				max: .4
			},
			blendMode: "screen",
			frequency: .001,
			emitterLifetime: .05,
			maxParticles: 30,
			pos: {
				x: n + m * Math.cos(u * s),
				y: a + m * Math.sin(u * s)
			},
			addAtBack: !1,
			spawnType: "point",
			particlesPerWave: Math.min(30, 4 + 2 * i),
			particleSpacing: 0,
			angleStart: 0
		})), In[`SPARK${wn++}`] = {
			emitter: h,
			flare: y,
			impactemitter: f,
			x1: e,
			x2: n,
			y1: t,
			y2: a,
			s1: o,
			s2: i,
			a1: c,
			a2: m,
			p: u,
			t: s,
			movementCurve: l,
			shapeCurve: r,
			et: 0,
			simple: p
		}, h.playOnceAndDestroy(), y.playOnceAndDestroy()
	}

	function Sn(e) {
		"minimal" !== G.video.graphics && Object.keys(In).forEach(t => {
			const n = In[t];
			if (n.et += e, n.et > n.t) return null !== n.impactemitter && n.impactemitter.playOnceAndDestroy(), void delete In[t];
			try {
				n.emitter.updateSpawnPos(Rn(n.x1 + n.a1 * Math.cos(n.p * n.et), n.x2 + n.a2 * Math.cos(n.p * n.et), n.et / n.t, n.movementCurve), Rn(n.y1 + n.a1 * Math.sin(n.p * n.et), n.y2 + n.a2 * Math.sin(n.p * n.et), n.et / n.t, n.movementCurve)), n.emitter.startSpeed.value = Rn(25 * n.s1, 25 * n.s2, n.et / n.t, n.shapeCurve), n.emitter.startScale.value = Rn(1 + .1 * n.s1, 1 + .1 * n.s2, n.et / n.t, n.shapeCurve), n.flare.updateSpawnPos(Rn(n.x1 + n.a1 * Math.cos(n.p * n.et), n.x2 + n.a2 * Math.cos(n.p * n.et), n.et / n.t, n.movementCurve), Rn(n.y1 + n.a1 * Math.sin(n.p * n.et), n.y2 + n.a2 * Math.sin(n.p * n.et), n.et / n.t, n.movementCurve)), n.flare.startScale.value = Rn(1 + .1 * n.s1, 1 + .1 * n.s2, n.et / n.t, n.shapeCurve), null !== n.impactemitter && n.impactemitter.updateSpawnPos(Rn(n.x1 + n.a1 * Math.cos(n.p * n.et), n.x2 + n.a2 * Math.cos(n.p * n.et), n.et / n.t, n.movementCurve), Rn(n.y1 + n.a1 * Math.sin(n.p * n.et), n.y2 + n.a2 * Math.sin(n.p * n.et), n.et / n.t, n.movementCurve))
			} catch (e) {
				return
			}
		})
	}

	function Cn() {
		"minimal" !== G.video.graphics && Object.keys(In).forEach(e => {
			const t = In[e];
			t.emitter.emit = !1, t.emitter.destroy(), t.flare.emit = !1, t.flare.destroy(), null !== t.impactemitter && t.impactemitter.destroy(), delete In[e]
		})
	}

	function Rn(e, t, n, a) {
		return void 0 === a && (a = sa), e + (t - e) * a(n)
	}

	function An(e) {
		const t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
		return t ? {
			r: parseInt(t[1], 16),
			g: parseInt(t[2], 16),
			b: parseInt(t[3], 16)
		} : null
	}

	function $n(e, t, n) {
		let a, o, i;
		if (e /= 360, n /= 100, 0 === (t /= 100)) a = o = i = n;
		else {
			const s = (e, t, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e),
				r = n < .5 ? n * (1 + t) : n + t - n * t,
				l = 2 * n - r;
			a = s(l, r, e + 1 / 3), o = s(l, r, e), i = s(l, r, e - 1 / 3)
		}
		const s = e => {
			const t = Math.round(255 * e).toString(16);
			return 1 === t.length ? "0" + t : t
		};
		return `#${s(a)}${s(o)}${s(i)}`
	}
	let On = null,
		Dn, Hn, Nn, Pn;

	function Un(e, t, n) {
		const a = document.createElement("canvas"),
			o = a.getContext("2d");
		a.height = t, a.width = e;
		const i = o.createLinearGradient(0, 0, 0, t);
		return n.forEach(e => {
			i.addColorStop(e[0], e[1])
		}), o.fillStyle = i, o.fillRect(0, 0, e, t), new PIXI.Texture.fromCanvas(a)
	}
	I.ready((function (e) {
		let t = null;
		kn = function () {
			function e(e) {
				return e / Math.pow(G.video.particles || 1, 1.5)
			}

			function n(e) {
				return e / Math.max(.5, Math.min(1, G.video.particles || 1))
			}

			function a() {
				On && On.destroy(), t && t.destroy()
			}

			function o() {
				a(), On = new PIXI.particles.Emitter(Bn, [PIXI.Texture.from("res/bigbox.png")], {
					alpha: {
						list: [{
							value: 0,
							time: 0
						}, {
							value: .05,
							time: .5
						}, {
							value: 0,
							time: 1
						}],
						isStepped: !1,
						minimumAlphaMultiplier: .1
					},
					scale: {
						start: n(.1),
						end: n(.09),
						minimumScaleMultiplier: .1
					},
					color: {
						start: "#FFFFFF",
						end: "#FFFFFF"
					},
					speed: {
						start: 10,
						end: 0,
						minimumSpeedMultiplier: 0
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 360
					},
					noRotation: !0,
					rotationSpeed: {
						min: 0,
						max: 0
					},
					lifetime: {
						min: 1,
						max: 30
					},
					blendMode: "normal",
					frequency: e(.02),
					emitterLifetime: -1,
					autoUpdate: !0,
					maxParticles: 200,
					pos: {
						x: 0,
						y: 0
					},
					addAtBack: !1,
					spawnType: "rect",
					spawnRect: {
						x: 0,
						y: 0,
						w: window.innerWidth,
						h: window.innerHeight
					}
				}), t = new PIXI.particles.Emitter(Tn, [PIXI.Texture.from("res/particle.png")], {
					alpha: {
						list: [{
							value: 0,
							time: 0
						}, {
							value: .15,
							time: .5
						}, {
							value: 0,
							time: 1
						}],
						isStepped: !1,
						minimumAlphaMultiplier: .1
					},
					scale: {
						start: n(.1),
						end: n(.09),
						minimumScaleMultiplier: .1
					},
					color: {
						start: "#FFFFFF",
						end: "#FFFFFF"
					},
					speed: {
						start: 10,
						end: 0,
						minimumSpeedMultiplier: 0
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 360
					},
					noRotation: !0,
					rotationSpeed: {
						min: 0,
						max: 0
					},
					lifetime: {
						min: 1,
						max: 30
					},
					blendMode: "normal",
					frequency: e(.02),
					emitterLifetime: -1,
					autoUpdate: !0,
					maxParticles: 1e3,
					pos: {
						x: 0,
						y: 0
					},
					addAtBack: !1,
					spawnType: "rect",
					spawnRect: {
						x: 0,
						y: 0,
						w: window.innerWidth,
						h: window.innerHeight
					}
				})
			}
			return {
				set: function () {
					"high" !== G.video.graphics && "ultra" !== G.video.graphics || o()
				},
				unset: function () {
					a()
				},
				resize: function () {
					"high" !== G.video.graphics && "ultra" !== G.video.graphics || o()
				},
				splash: function (t, a, o, i, s, r) {
					! function (t, a, o, i, s, r) {
						if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
						new PIXI.particles.Emitter(Bn, [PIXI.Texture.from("res/bigbox.png")], {
							alpha: {
								list: [{
									value: 0,
									time: 0
								}, {
									value: a,
									time: .25
								}, {
									value: 0,
									time: 1
								}],
								isStepped: !1,
								minimumAlphaMultiplier: .1
							},
							scale: {
								start: n(.1),
								end: n(.09),
								minimumScaleMultiplier: .1
							},
							color: {
								start: r || "#FFFFFF",
								end: r || "#FFFFFF"
							},
							speed: {
								start: s,
								end: 0,
								minimumSpeedMultiplier: 0
							},
							acceleration: {
								x: 0,
								y: 0
							},
							maxSpeed: 0,
							startRotation: {
								min: t - 10,
								max: t + 10
							},
							noRotation: !0,
							rotationSpeed: {
								min: 0,
								max: 0
							},
							lifetime: {
								min: .1,
								max: 3
							},
							blendMode: "normal",
							frequency: e(.02 / o),
							emitterLifetime: i,
							maxParticles: 1e3,
							pos: {
								x: 0,
								y: 0
							},
							addAtBack: !1,
							spawnType: "rect",
							spawnRect: {
								x: 0,
								y: 0,
								w: window.innerWidth,
								h: window.innerHeight
							}
						}).playOnceAndDestroy()
					}(t, a, o, i, s, r)
				},
				circlesplash: function (t, a, o, i, s, r) {
					! function (t, a, o, i, s, r) {
						if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
						new PIXI.particles.Emitter(Tn, [PIXI.Texture.from("res/particle.png")], {
							alpha: {
								list: [{
									value: a,
									time: 0
								}, {
									value: 0,
									time: 1
								}],
								isStepped: !1,
								minimumAlphaMultiplier: .1
							},
							scale: {
								start: n(.1),
								end: n(.09),
								minimumScaleMultiplier: .1
							},
							color: {
								start: r || "#FFFFFF",
								end: r || "#FFFFFF"
							},
							speed: {
								start: s,
								end: 0,
								minimumSpeedMultiplier: 0
							},
							acceleration: {
								x: 0,
								y: 0
							},
							maxSpeed: 0,
							startRotation: {
								min: 0,
								max: 0
							},
							noRotation: !1,
							rotationSpeed: {
								min: 0,
								max: 0
							},
							lifetime: {
								min: .1,
								max: 3
							},
							blendMode: "normal",
							frequency: e(.02 / o),
							emitterLifetime: i,
							maxParticles: 1e3,
							pos: {
								x: window.innerWidth / 2,
								y: window.innerHeight / 2
							},
							addAtBack: !1,
							spawnType: "ring",
							spawnCircle: {
								x: 0,
								y: 0,
								r: t,
								minR: t
							}
						}).playOnceAndDestroy()
					}(t, a, o, i, s, r)
				},
				circleblocksplash: function (t, a, o, i, s, r) {
					! function (t, a, o, i, s, r) {
						if ("high" !== G.video.graphics && "ultra" !== G.video.graphics) return;
						new PIXI.particles.Emitter(Bn, [PIXI.Texture.from("res/bigbox.png")], {
							alpha: {
								list: [{
									value: 0,
									time: 0
								}, {
									value: a,
									time: .8
								}, {
									value: 0,
									time: 1
								}],
								isStepped: !1,
								minimumAlphaMultiplier: .1
							},
							scale: {
								start: 0,
								end: n(.2),
								minimumScaleMultiplier: .1
							},
							color: {
								start: r || "#FFFFFF",
								end: r || "#FFFFFF"
							},
							speed: {
								start: s / 4,
								end: s,
								minimumSpeedMultiplier: .05
							},
							acceleration: {
								x: 0,
								y: 0
							},
							maxSpeed: 0,
							startRotation: {
								min: 0,
								max: 1
							},
							noRotation: !0,
							rotationSpeed: {
								min: 0,
								max: 0
							},
							lifetime: {
								min: 1,
								max: 3
							},
							blendMode: "normal",
							frequency: e(.02 / o),
							emitterLifetime: i,
							maxParticles: 1e3,
							pos: {
								x: window.innerWidth / 2,
								y: window.innerHeight / 2
							},
							addAtBack: !1,
							spawnType: "ring",
							spawnCircle: {
								x: 0,
								y: 0,
								r: t,
								minR: 0
							}
						}).playOnceAndDestroy()
					}(t, a, o, i, s, r)
				}
			}
		}(), Ln = function () {
			let e, t, n = 1,
				a = 1,
				o = !1;

			function i(t) {
				const n = t || e;
				n && (Fn.position.set(window.innerWidth / 2, window.innerHeight / 2), window.innerWidth / window.innerHeight > n.texture.width / n.texture.height ? n.scale.set(window.innerWidth / n.texture.width, window.innerWidth / n.texture.width) : n.scale.set(window.innerHeight / n.texture.height, window.innerHeight / n.texture.height))
			}
			return PIXI.Ticker.shared.add(t => {
				if (!e || o) return;
				if ("minimal" === G.video.graphics) return;
				const i = n,
					s = e.alpha;
				if (s === i);
				else if (Math.round(100 * s) === Math.round(100 * i)) {
					e.alpha = i;
					const t = void 0 === G.video.bloom ? 1 : G.video.bloom;
					0 != G.video.bloom && Pn && "ultra" === G.video.graphics && (Pn.threshold = .35 + .15 * i, Pn.bloomScale = (.45 + -.3 * i) * t, Pn.blur = (7 + -5 * i) * t)
				} else {
					const n = i + (s - i) * Math.pow(.9, t);
					e.alpha = n;
					const a = void 0 === G.video.bloom ? 1 : G.video.bloom;
					0 != G.video.bloom && Pn && "ultra" === G.video.graphics && (Pn.threshold = .35 + .15 * n, Pn.bloomScale = (.45 + -.3 * n) * a, Pn.blur = (7 + -5 * n) * a)
				}
				const r = a,
					l = Fn.scale.x;
				if (l === r);
				else if (Math.round(1e3 * l) === Math.round(1e3 * r)) Fn.scale.set(r, r);
				else {
					const e = r + (l - r) * Math.pow(.9, t);
					Fn.scale.set(e, e)
				}
			}, this), {
				setBackground: (n, a) => {
					if (t === n) return;
					a || (o = !0), t = n;
					let s = 0;
					e && (a ? e.destroy() : (ra.animate(e, {
						0: {
							alpha: 1
						},
						1: {
							alpha: 0
						}
					}, .5, void 0, e => {
						e.destroy()
					}), s = 800));
					const r = PIXI.Sprite.from(n);
					r.alpha = 0, r.anchor.set(.5, .5), Fn.addChild(r), e = r;
					let l = Date.now();
					const d = () => {
						i(r), a ? r.alpha = 1 : setTimeout(() => {
							ra.animate(r, {
								0: {
									alpha: 0
								},
								1: {
									alpha: 1
								}
							}, .5, void 0, () => {
								o = !1
							})
						}, Math.max(0, s - (Date.now() - l)))
					};
					r.texture.valid ? d() : r.texture.once("update", d)
				},
				fit: e => {
					i(e)
				},
				opacity: e => {
					"low" !== G.video.graphics && "minimal" !== G.video.graphics && (n = e)
				},
				scale: e => {
					"low" !== G.video.graphics && "minimal" !== G.video.graphics && (a = e)
				}
			}
		}()
	})), window.DEVHOOK_BG_ANIM = (e = 100) => {
		let t = 0,
			n = !1;
		console.warn("The background will flash and errors may appear while the frames of the animation load in, please hang tight..."), setInterval(() => {
			++t > 32 && (t = 1, n || (console.warn("Backgrounds have been loaded in."), n = !0)), Ln.setBackground(`https://kagari.moe/:/bggame${t}.png`, !0)
		}, e)
	};
	const zn = {},
		jn = {},
		Wn = {},
		Gn = {};
	e(() => {
		PIXI.utils.skipHello(), PIXI.TheoryType.LoadFont("res/font/hun.fnt", "res/font/hun.png", () => {
			I.finishLoad()
		})
	});
	const qn = {
			vertices: !1,
			position: !0,
			rotation: !1,
			uvs: !1,
			tint: !0
		},
		Xn = {
			vertices: !0,
			position: !0,
			rotation: !0,
			uvs: !1,
			tint: !0
		};
	let Kn = !0,
		Yn = 0;

	function Vn() {
		Dn.renderer.resize(window.innerWidth, window.innerHeight), Hn && Hn.renderer.resize(window.innerWidth, window.innerHeight), Jn(), Zn(), Kn = !0
	}

	function Zn() {
		if (Nn) {
			if ("ultra" !== G.video.graphics) return Nn.filters = null, void(Nn.filterArea = null);
			if (Nn.filters = [], 0 != G.video.bloom) {
				const e = void 0 === G.video.bloom ? 1 : G.video.bloom;
				Pn = new PIXI.filters.AdvancedBloomFilter({
					threshold: .5,
					bloomScale: .15 * e,
					brightness: 1,
					blur: 2 * e,
					quality: Math.floor(Math.min(Math.max(4, e + 2), 20))
				}), Nn.filters.push(Pn)
			}
			if (0 != G.video.chroma) {
				const e = void 0 === G.video.chroma ? .5 : G.video.chroma;
				Nn.filters.push(new PIXI.filters.RGBSplitFilter(new PIXI.Point(0, -e), new PIXI.Point(0, 0), new PIXI.Point(-e, 0)))
			}
			Nn.filterArea = new PIXI.Rectangle(0, 0, window.innerWidth, window.innerHeight), Dn.stage.filterArea = new PIXI.Rectangle(0, 0, window.innerWidth, window.innerHeight)
		}
	}

	function Jn() {
		Object.keys(da.minoCanvases).forEach(e => {
			zn[e] = PIXI.Texture.from(da.minoCanvases[e])
		}), Object.keys(da.minoCanvasesShiny).forEach(e => {
			jn[e] = PIXI.Texture.from(da.minoCanvasesShiny[e])
		}), Object.keys(da.extra.signs.canvases).forEach(e => {
			Wn[e] = PIXI.Texture.from(da.extra.signs.canvases[e])
		}), Object.keys(da.graphics).forEach(e => {
			Gn[e] = PIXI.Texture.from(da.graphics[e])
		})
	}

	function Qn(e, t, n) {
		const a = e.worldTransform.apply(new PIXI.Point(t, n));
		return {
			x: a.x,
			y: a.y
		}
	}

	function ea(e, t, n, a = 1) {
		const o = e.getGlobalPosition(void 0, !0);
		return {
			x: o.x + t * a,
			y: o.y + n * a
		}
	}
	I.ready((function (e) {
		switch (G.video.webgl) {
			case "legacy":
				PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL_LEGACY;
				break;
			case "webgl1":
				PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL;
				break;
			case "webgl2":
			default:
				PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2
		}
		if (PIXI.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1, "low" !== G.video.graphics && "minimal" !== G.video.graphics || (PIXI.settings.PRECISION_FRAGMENT = PIXI.PRECISION.LOW, PIXI.settings.PRECISION_VERTEX = PIXI.PRECISION.LOW, PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST), Dn = new PIXI.Application({
				width: 256,
				height: 256,
				view: document.getElementById("pixi"),
				antialias: "low" !== G.video.graphics && "minimal" !== G.video.graphics,
				transparent: !1,
				powerPreference: G.video.powersave ? "default" : "high-performance",
				forceFXAA: "high" !== G.video.graphics && "ultra" !== G.video.graphics,
				sharedTicker: "minimal" !== G.video.graphics,
				autoDensity: !0,
				resolution: G.video.lowres ? .7 : window.devicePixelRatio,
				autoStart: "minimal" !== G.video.graphics
			}), "ultra" === G.video.graphics && (Hn = new PIXI.Application({
				width: 256,
				height: 256,
				view: document.getElementById("pixi-fg"),
				antialias: !1,
				transparent: !0,
				powerPreference: G.video.powersave ? "default" : "high-performance",
				forceFXAA: !1,
				sharedTicker: !0,
				autoDensity: !0,
				resolution: G.video.lowres ? .7 : window.devicePixelRatio,
				autoStart: !0
			})), "minimal" === G.video.graphics) {
			const e = new PIXI.Ticker;
			e.add(() => {
				(Yn > 0 || Kn) && (Dn.renderer.render(Dn.stage), Kn = !1)
			}, Dn, PIXI.UPDATE_PRIORITY.LOW), e.start()
		}
		if (Dn && Dn.renderer && Dn.renderer.type === PIXI.RENDERER_TYPE.WEBGL ? console.log(`%cPixiJS ${PIXI.VERSION} - ${2===Dn.renderer.context.webGLVersion?"WebGL 2":"WebGL 1"}${PIXI.settings.PREFER_ENV===PIXI.ENV.WEBGL_LEGACY?" (LEGACY)":""}`, `color: ${2===Dn.renderer.context.webGLVersion?"#F3C0E6":"#D9C0F3"};\n\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px ${2===Dn.renderer.context.webGLVersion?"#BA509B":"#7050BA"};\n\t\t\t\t\t background-color: ${2===Dn.renderer.context.webGLVersion?"#50344988":"#3D345088"};\n\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t border-radius: 3px;`) : Dn && Dn.renderer && Dn.renderer.type === PIXI.RENDERER_TYPE.CANVAS ? (console.log(`%cPixiJS ${PIXI.VERSION} - Canvas`, "color: #F97676;\n\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px #BA5050;\n\t\t\t\t\t background-color: #87353588;\n\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t border-radius: 3px;"), console.error("Canvas renderers are not supported.")) : (console.log(`%cPixiJS ${PIXI.VERSION} - No renderer`, "color: #FFFFFF;\n\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t text-shadow: 0px 0px 2px #FFFFFF;\n\t\t\t\t\t background-color: #FF0000;\n\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t border-radius: 3px;"), console.error("No supported renderer found. Cannot launch.")), console.log(`%c- ${navigator.userAgent?navigator.userAgent:"Unknown browser"} -\nCPU: ${navigator.hardwareConcurrency?`${navigator.hardwareConcurrency}-core`:"<unknown>"}\nMemory: ${navigator.deviceMemory?`~${navigator.deviceMemory} GB`:"<unknown>"}\nConnection: ${navigator.connection?`${navigator.connection.downlink} Mbps, ${navigator.connection.rtt}ms RTT [${navigator.connection.effectiveType}]`:"<unknown>"}`, "color: #FFFFFF88;\n\t\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t\t text-shadow: 0px 0px 2px #FFFFFF88;\n\t\t\t\t\t\t background-color: #111111AA;\n\t\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t\t border-radius: 3px;"), Dn && Dn.renderer) {
			const e = Dn.renderer.gl.getExtension("WEBGL_debug_renderer_info");
			e && console.log(`%cRenderer: ${Dn.renderer.gl.getParameter(e.UNMASKED_RENDERER_WEBGL)}`, "color: #FFFFFF88;\n\t\t\t\t\t\t font-size: 1.2em;\n\t\t\t\t\t\t font-weight: 900;\n\t\t\t\t\t\t text-shadow: 0px 0px 2px #FFFFFF88;\n\t\t\t\t\t\t background-color: #111111AA;\n\t\t\t\t\t\t padding: 0 1em;\n\t\t\t\t\t\t border-radius: 3px;")
		}
		if (Vn(), Dn.stage.filters = null, (Fn = new PIXI.Container).name = "bgImgContainer", Fn.interactive = !1, Fn.interactiveChildren = !1, Fn.alpha = G.video.background, Dn.stage.addChild(Fn), (xn = new PIXI.Container).name = "bgContainer", xn.interactive = !1, xn.interactiveChildren = !1, xn.alpha = Math.min(1, 10 * (G.video.background || 0)), Dn.stage.addChild(xn), Bn = new PIXI.ParticleContainer(1500, qn), xn.addChild(Bn), Tn = new PIXI.ParticleContainer(1500, qn), xn.addChild(Tn), (rn = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, xn.addChild(rn), (ln = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, xn.addChild(ln), (dn = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, xn.addChild(dn), kn.set(), (Nn = new PIXI.Container).name = "gScene", Dn.stage.addChild(Nn), (Gt = new PIXI.Container).name = "fxContainer", Gt.interactive = !1, Gt.interactiveChildren = !1, Dn.stage.addChild(Gt), qt = new PIXI.ParticleContainer(1500, qn), Gt.addChild(qt), Xt = new PIXI.ParticleContainer(1500, Xn), Gt.addChild(Xt), (Kt = new PIXI.ParticleContainer(1500, qn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(Kt), (Yt = new PIXI.ParticleContainer(1500, qn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(Yt), Vt = new PIXI.ParticleContainer(1500, qn), Gt.addChild(Vt), (Zt = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.ADD, Gt.addChild(Zt), (Jt = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(Jt), (Qt = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(Qt), (en = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(en), (tn = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(tn), (nn = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Gt.addChild(nn), Hn && (Hn.stage.interactive = !1, Hn.stage.interactiveChildren = !1, Hn.stage.blendMode = PIXI.BLEND_MODES.SCREEN, (an = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Hn.stage.addChild(an), (on = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Hn.stage.addChild(on), (sn = new PIXI.ParticleContainer(1500, Xn)).blendMode = PIXI.BLEND_MODES.SCREEN, Hn.stage.addChild(sn)), PIXI.Ticker.shared.add(Sn, this), document.getElementById("pixi").addEventListener("webglcontextlost", () => {
				Ue(), E({
					title: "WEBGL CRASHED",
					msg: 'an error has caused WEBGL to crash.</p><p>this could be caused by many issues, like a driver error, a GPU error, a browser error or insufficient resources.</p><p class="modal_also">you can choose to continue the current session, which may not work properly, or reload to try again. sometimes, exiting the ongoing game can fix the error.',
					classes: ["crash_modal", "noclickout"],
					buttons: [{
						label: "CONTINUE",
						classes: [],
						callback: e => {
							e(), je()
						}
					}, {
						label: "RESTART",
						classes: ["pri"],
						callback: e => {
							e(), b = !0, location.reload()
						}
					}]
				})
			}), Kn = !0, IS_ELECTRON) {
			let e = 0,
				t = 0,
				n = 0,
				a = !1;
			PIXI.Ticker.shared.add(() => {
				e++
			}, this), setInterval(() => {
				if (t !== e) {
					if (t = e, a) return void(a = !1);
					n = 0
				}++n >= 3 && (a = !0, PIXI.Ticker.shared.update())
			}, 100)
		}
		Zn()
	}));
	const ta = "0123456789#%&()*+,-./:<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ",
		na = "ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂă";

	function aa(e) {
		let t = "";
		for (let n = 0; n < e.length; n++) {
			const a = ta.indexOf(e[n]);
			t += -1 === a ? e[n] : na[a]
		}
		return t
	}
	const oa = (() => {
			let e = [];

			function t(t) {
				e = e.filter(e => e.name !== t.name)
			}

			function n(t) {
				const n = e.filter(e => e.name === t);
				return n ? n[0] : void 0
			}
			return {
				register: (a, o, i = []) => {
					Array.isArray("array") || (i = [i]);
					const s = n(o);
					s && t(s), e.push({
						obj: a,
						name: o,
						classes: i
					})
				},
				unregister: e => {
					Array.isArray(e) ? e.forEach(e => {
						t(e)
					}) : t(e)
				},
				unregisterStartingWith: t => {
					e = e.filter(e => !e.name.startsWith(t))
				},
				get: e => n(e),
				getAll: t => (function (t) {
					const n = e.filter(e => e.classes.includes(t));
					return n || []
				})(t)
			}
		})(),
		ia = {
			0: {
				y: 0
			},
			1: {
				y: 500
			}
		},
		sa = BezierEasing(0, 0, 1, 1),
		ra = (() => {
			const e = {};
			let t = 0;

			function n(t) {
				delete e[t], Yn--
			}
			return PIXI.Ticker.shared.add((function (t) {
				Object.keys(e).forEach(a => {
					const o = e[a];
					o.obj._destroyed ? n(a) : (o.progress = Math.min(1, o.progress + o.speed * t), function (e, t, n) {
						const a = Object.keys(t).sort((e, t) => parseFloat(e) - parseFloat(t));
						let o = 0;
						for (let e = a.length - 2; e >= 0; e--)
							if (parseFloat(a[e]) <= n) {
								o = a[e];
								break
							} let i = 1;
						for (let e = 1; e < a.length; e++)
							if (parseFloat(a[e]) > n) {
								i = a[e];
								break
							} Object.keys(t[0]).forEach(a => {
							let s = t[o][a],
								r = t[i][a];
							"inherit" === s && (t[o][a] = getSetDescendantProp(e, a), s = t[o][a]), "inherit" === r && (t[i][a] = getSetDescendantProp(e, a), r = t[i][a]), "string" == typeof s && "r" === s.slice(-1) && (s = mt(parseFloat(s.slice(0, -1)))), "string" == typeof r && "r" === r.slice(-1) && (r = mt(parseFloat(r.slice(0, -1)))), getSetDescendantProp(e, a, function (e, t, n, a, o) {
								return a + (n - e) / (t - e) * (o - a)
							}(o, i, n, s, r))
						})
					}(o.obj, o.animation, o.curve(o.progress)), o.progress >= 1 && (o.onend(o.obj), n(a)))
				})
			})), {
				animate: (n, a, o, i, s = (() => {})) => (function (n, a, o, i, s) {
					const r = `${++t}`;
					return e[r] = {
						obj: n,
						animation: a,
						speed: 1 / (60 * o),
						progress: 0,
						curve: void 0 !== i ? i : sa,
						onend: s
					}, Yn++, r
				})(n, a, o, i, s),
				stop(e) {
					n(e)
				}
			}
		})(),
		la = 1.8,
		da = {
			res: null,
			minos: {
				z: 0,
				l: 31,
				o: 62,
				s: 93,
				i: 124,
				j: 155,
				t: 186,
				g: 217,
				d: 248,
				gb: 279,
				gbd: 310,
				x: 341
			},
			minoCanvases: {
				z: null,
				l: null,
				o: null,
				s: null,
				i: null,
				j: null,
				t: null,
				g: null,
				d: null,
				gb: null,
				gbd: null,
				x: null
			},
			minoCanvasesShiny: {
				z: null,
				l: null,
				o: null,
				s: null,
				i: null,
				j: null,
				t: null,
				g: null,
				d: null,
				gb: null,
				gbd: null,
				x: null
			},
			graphics: {},
			x: 30,
			tx: 372,
			extra: {
				signs: {
					res: null,
					elements: {
						alert: 0,
						targeted: 61,
						stock: 122
					},
					canvases: {
						alert: null,
						targeted: null,
						stock: null
					},
					x: 60,
					tx: 183
				}
			}
		};

	function ca(e) {
		da.res = new Image(da.tx, da.x), da.res.src = e
	}

	function ma() {
		Object.keys(da.minoCanvases).forEach(e => {
			const t = document.createElement("canvas");
			t.width = Math.ceil(mt(da.x)) + ("ultra" === G.video.graphics ? 2 : 0), t.height = Math.ceil(mt(da.x)) + ("ultra" === G.video.graphics ? 2 : 0), t.getContext("2d").drawImage(da.res, da.minos[e], 0, da.x, da.x, "ultra" === G.video.graphics ? 1 : 0, "ultra" === G.video.graphics ? 1 : 0, Math.ceil(mt(da.x)), Math.ceil(mt(da.x))), da.minoCanvases[e] = t
		}), Object.keys(da.minoCanvasesShiny).forEach(e => {
			const t = document.createElement("canvas");
			t.width = Math.ceil(mt(da.x)) + ("ultra" === G.video.graphics ? 2 : 0), t.height = Math.ceil(mt(da.x)) + ("ultra" === G.video.graphics ? 2 : 0);
			const n = t.getContext("2d");
			n.filter = "ultra" === G.video.graphics ? "brightness(1.2) contrast(1.2)" : "brightness(1.25) contrast(1.25)", n.drawImage(da.res, da.minos[e], 0, da.x, da.x, "ultra" === G.video.graphics ? 1 : 0, "ultra" === G.video.graphics ? 1 : 0, Math.ceil(mt(da.x)), Math.ceil(mt(da.x))), da.minoCanvasesShiny[e] = t
		})
	}

	function ua(e) {
		da.extra.signs.res = new Image(da.extra.signs.tx, da.extra.signs.x), da.extra.signs.res.src = e
	}

	function ga() {
		Object.keys(da.extra.signs.canvases).forEach(e => {
			const t = document.createElement("canvas");
			t.width = Math.ceil(mt(da.extra.signs.x)), t.height = Math.ceil(mt(da.extra.signs.x)), t.getContext("2d").drawImage(da.extra.signs.res, da.extra.signs.elements[e], 0, da.extra.signs.x, da.extra.signs.x, 0, 0, Math.ceil(mt(da.extra.signs.x)), Math.ceil(mt(da.extra.signs.x))), da.extra.signs.canvases[e] = t
		})
	}

	function pa() {
		Object.keys(ha).forEach(e => {
			da.graphics[e] = ha[e]()
		})
	}
	const ha = {
			boxborder: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(10 * da.x) + mt(3) + 2), e.height = Math.ceil(mt(20 * da.x) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.moveTo(mt(1.5) + 1, mt(1.5) + 1), t.lineTo(mt(1.5) + 1, mt(20 * da.x) + mt(1.5) + 1), t.lineTo(mt(10 * da.x) + mt(1.5) + 1, mt(20 * da.x) + mt(1.5) + 1), t.lineTo(mt(10 * da.x) + mt(1.5) + 1, 2.5), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.stroke(), e
			},
			holdfg: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(156) + mt(3) + 2), e.height = Math.ceil(mt(118) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(118)), t.stroke(), t.beginPath(), t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(25)), t.fillStyle = "#FFFFFF", t.fill(), e
			},
			nextfg_5: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(156) + mt(3) + 2), e.height = Math.ceil(mt(28 + 3 * da.x * 5) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(28 + 3 * da.x * 5)), t.stroke(), t.beginPath(), t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(25)), t.fillStyle = "#FFFFFF", t.fill(), e
			},
			nextfg_4: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(156) + mt(3) + 2), e.height = Math.ceil(mt(28 + 3 * da.x * 4) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(28 + 3 * da.x * 4)), t.stroke(), t.beginPath(), t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(25)), t.fillStyle = "#FFFFFF", t.fill(), e
			},
			nextfg_3: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(156) + mt(3) + 2), e.height = Math.ceil(mt(28 + 3 * da.x * 3) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(28 + 3 * da.x * 3)), t.stroke(), t.beginPath(), t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(25)), t.fillStyle = "#FFFFFF", t.fill(), e
			},
			nextfg_2: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(156) + mt(3) + 2), e.height = Math.ceil(mt(28 + 3 * da.x * 2) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(28 + 3 * da.x * 2)), t.stroke(), t.beginPath(), t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(25)), t.fillStyle = "#FFFFFF", t.fill(), e
			},
			nextfg_1: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(156) + mt(3) + 2), e.height = Math.ceil(mt(28 + 3 * da.x * 1) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(28 + 3 * da.x * 1)), t.stroke(), t.beginPath(), t.rect(mt(1.5) + 1, mt(1.5) + 1, mt(156), mt(25)), t.fillStyle = "#FFFFFF", t.fill(), e
			},
			barborder: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(da.x / la) + mt(3) + 2), e.height = Math.ceil(mt(20 * da.x) + mt(3) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.moveTo(mt(1.5) + 1, mt(1.5) + 1), t.lineTo(mt(1.5) + 1, mt(20 * da.x) + mt(1.5) + 1), t.lineTo(mt(da.x / la) + mt(1.5) + 1, mt(20 * da.x) + mt(1.5) + 1), t.lineTo(mt(da.x / la) + mt(1.5) + 1, 2.5), t.lineWidth = mt(3), t.lineJoin = "bevel", t.strokeStyle = "#FFFFFF", t.stroke(), e
			},
			boxbg: () => {
				const e = document.createElement("canvas");
				e.width = Math.ceil(mt(10 * da.x) + 2), e.height = Math.ceil(mt(20 * da.x) + 2);
				const t = e.getContext("2d");
				return t.beginPath(), t.rect(1, 1, mt(10 * da.x), mt(20 * da.x)), t.fillStyle = "#000000", t.fill(), e
			}
		},
		ya = {
			cleartypes: ["NONE", "SINGLE", "DOUBLE", "TRIPLE", "QUAD"],
			tspins: {
				mini: `${aa("MINI")} %%PIECE%%-spin`,
				normal: "%%PIECE%%-spin"
			},
			extra: {
				btb: "back-to-back",
				btb_short: "BACK-TO-BACK",
				clear: "ALL\nCLEAR",
				zenlevel: "LEVEL\nCOMPLETE"
			},
			longTypeNames: {
				"40l": "40 LINES",
				blitz: "BLITZ",
				zen: "ZEN",
				custom: "CUSTOM GAME"
			},
			gameMissions: {
				"40l": "CLEAR 40 LINES!",
				blitz: "TWO-MINUTE BLITZ",
				"40 LINES": "CLEAR 40 LINES!",
				BLITZ: "TWO-MINUTE BLITZ",
				zen: "ZEN",
				ZEN: "ZEN"
			}
		},
		fa = {
			minotypes: ["z", "l", "o", "s", "i", "j", "t"],
			colors: {
				z: "#CE5259",
				l: "#CE8152",
				o: "#CEC552",
				s: "#80CE52",
				i: "#52CEAC",
				j: "#6652CE",
				t: "#C352CE",
				gb: "#352037",
				gbd: "#240027"
			},
			intColors: {
				z: 13521497,
				l: 13533522,
				o: 13550930,
				s: 8441426,
				i: 5426860,
				j: 6705870,
				t: 12800718,
				gb: 3481655,
				gbd: 2359335
			},
			intGlowColors: {
				z: 16744069,
				l: 16749136,
				o: 16773982,
				s: 10813295,
				i: 8716253,
				j: 10324735,
				t: 16091903,
				gb: 12956103,
				gbd: 4405060
			},
			tetrominoes: {
				z: {
					matrix: {
						w: 3,
						h: 3,
						dx: 1,
						dy: 1,
						data: [
							[1, 1, 0, 0, 1, 1, 0, 0, 0],
							[0, 0, 1, 0, 1, 1, 0, 1, 0],
							[0, 0, 0, 1, 1, 0, 0, 1, 1],
							[0, 1, 0, 1, 1, 0, 1, 0, 0]
						]
					},
					preview: {
						w: 3,
						h: 2,
						data: [1, 1, 0, 0, 1, 1]
					}
				},
				l: {
					matrix: {
						w: 3,
						h: 3,
						dx: 1,
						dy: 1,
						data: [
							[0, 0, 1, 1, 1, 1, 0, 0, 0],
							[0, 1, 0, 0, 1, 0, 0, 1, 1],
							[0, 0, 0, 1, 1, 1, 1, 0, 0],
							[1, 1, 0, 0, 1, 0, 0, 1, 0]
						]
					},
					preview: {
						w: 3,
						h: 2,
						data: [0, 0, 1, 1, 1, 1]
					}
				},
				o: {
					matrix: {
						w: 2,
						h: 2,
						dx: 0,
						dy: 1,
						data: [
							[1, 1, 1, 1],
							[1, 1, 1, 1],
							[1, 1, 1, 1],
							[1, 1, 1, 1]
						]
					},
					preview: {
						w: 2,
						h: 2,
						data: [1, 1, 1, 1]
					}
				},
				s: {
					matrix: {
						w: 3,
						h: 3,
						dx: 1,
						dy: 1,
						data: [
							[0, 1, 1, 1, 1, 0, 0, 0, 0],
							[0, 1, 0, 0, 1, 1, 0, 0, 1],
							[0, 0, 0, 0, 1, 1, 1, 1, 0],
							[1, 0, 0, 1, 1, 0, 0, 1, 0]
						]
					},
					preview: {
						w: 3,
						h: 2,
						data: [0, 1, 1, 1, 1, 0]
					}
				},
				i: {
					matrix: {
						w: 4,
						h: 4,
						dx: 1,
						dy: 1,
						data: [
							[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
							[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
							[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
							[0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]
						]
					},
					preview: {
						w: 4,
						h: 1,
						data: [1, 1, 1, 1]
					}
				},
				j: {
					matrix: {
						w: 3,
						h: 3,
						dx: 1,
						dy: 1,
						data: [
							[1, 0, 0, 1, 1, 1, 0, 0, 0],
							[0, 1, 1, 0, 1, 0, 0, 1, 0],
							[0, 0, 0, 1, 1, 1, 0, 0, 1],
							[0, 1, 0, 0, 1, 0, 1, 1, 0]
						]
					},
					preview: {
						w: 3,
						h: 2,
						data: [1, 0, 0, 1, 1, 1]
					}
				},
				t: {
					matrix: {
						w: 3,
						h: 3,
						dx: 1,
						dy: 1,
						data: [
							[0, 1, 0, 1, 1, 1, 0, 0, 0],
							[0, 1, 0, 0, 1, 1, 0, 1, 0],
							[0, 0, 0, 1, 1, 1, 0, 1, 0],
							[0, 1, 0, 1, 1, 0, 0, 1, 0]
						]
					},
					preview: {
						w: 3,
						h: 2,
						data: [0, 1, 0, 1, 1, 1]
					}
				}
			},
			kicksets: {
				SRS: {
					kicks: {
						"01": [
							[-1, 0],
							[-1, -1],
							[0, 2],
							[-1, 2]
						],
						10: [
							[1, 0],
							[1, 1],
							[0, -2],
							[1, -2]
						],
						12: [
							[1, 0],
							[1, 1],
							[0, -2],
							[1, -2]
						],
						21: [
							[-1, 0],
							[-1, -1],
							[0, 2],
							[-1, 2]
						],
						23: [
							[1, 0],
							[1, -1],
							[0, 2],
							[1, 2]
						],
						32: [
							[-1, 0],
							[-1, 1],
							[0, -2],
							[-1, -2]
						],
						30: [
							[-1, 0],
							[-1, 1],
							[0, -2],
							[-1, -2]
						],
						"03": [
							[1, 0],
							[1, -1],
							[0, 2],
							[1, 2]
						],
						"02": [
							[0, -1],
							[1, -1],
							[-1, -1],
							[1, 0],
							[-1, 0]
						],
						13: [
							[1, 0],
							[1, -2],
							[1, -1],
							[0, -2],
							[0, -1]
						],
						20: [
							[0, 1],
							[-1, 1],
							[1, 1],
							[-1, 0],
							[1, 0]
						],
						31: [
							[-1, 0],
							[-1, -2],
							[-1, -1],
							[0, -2],
							[0, -1]
						]
					},
					i_kicks: {
						"01": [
							[-2, 0],
							[1, 0],
							[-2, 1],
							[1, -2]
						],
						10: [
							[2, 0],
							[-1, 0],
							[2, -1],
							[-1, 2]
						],
						12: [
							[-1, 0],
							[2, 0],
							[-1, -2],
							[2, 1]
						],
						21: [
							[1, 0],
							[-2, 0],
							[1, 2],
							[-2, -1]
						],
						23: [
							[2, 0],
							[-1, 0],
							[2, -1],
							[-1, 2]
						],
						32: [
							[-2, 0],
							[1, 0],
							[-2, 1],
							[1, -2]
						],
						30: [
							[1, 0],
							[-2, 0],
							[1, 2],
							[-2, -1]
						],
						"03": [
							[-1, 0],
							[2, 0],
							[-1, -2],
							[2, 1]
						],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					additional_offsets: {
						z: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						l: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						o: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						s: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						i: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						j: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						t: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						]
					},
					spawn_rotation: {
						z: 0,
						l: 0,
						o: 0,
						s: 0,
						i: 0,
						j: 0,
						t: 0
					},
					colorMap: {
						z: "z",
						l: "l",
						o: "o",
						s: "s",
						i: "i",
						j: "j",
						t: "t",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					preview_overrides: {}
				},
				"SRS-X": {
					kicks: {
						"01": [
							[-1, 0],
							[-1, -1],
							[0, 2],
							[-1, 2]
						],
						10: [
							[1, 0],
							[1, 1],
							[0, -2],
							[1, -2]
						],
						12: [
							[1, 0],
							[1, 1],
							[0, -2],
							[1, -2]
						],
						21: [
							[-1, 0],
							[-1, -1],
							[0, 2],
							[-1, 2]
						],
						23: [
							[1, 0],
							[1, -1],
							[0, 2],
							[1, 2]
						],
						32: [
							[-1, 0],
							[-1, 1],
							[0, -2],
							[-1, -2]
						],
						30: [
							[-1, 0],
							[-1, 1],
							[0, -2],
							[-1, -2]
						],
						"03": [
							[1, 0],
							[1, -1],
							[0, 2],
							[1, 2]
						],
						"02": [
							[1, 0],
							[2, 0],
							[1, 1],
							[2, 1],
							[-1, 0],
							[-2, 0],
							[-1, 1],
							[-2, 1],
							[0, -1],
							[3, 0],
							[-3, 0]
						],
						13: [
							[0, 1],
							[0, 2],
							[-1, 1],
							[-1, 2],
							[0, -1],
							[0, -2],
							[-1, -1],
							[-1, -2],
							[1, 0],
							[0, 3],
							[0, -3]
						],
						20: [
							[-1, 0],
							[-2, 0],
							[-1, -1],
							[-2, -1],
							[1, 0],
							[2, 0],
							[1, -1],
							[2, -1],
							[0, 1],
							[-3, 0],
							[3, 0]
						],
						31: [
							[0, 1],
							[0, 2],
							[1, 1],
							[1, 2],
							[0, -1],
							[0, -2],
							[1, -1],
							[1, -2],
							[-1, 0],
							[0, 3],
							[0, -3]
						]
					},
					i_kicks: {
						"01": [
							[-2, 0],
							[1, 0],
							[-2, 1],
							[1, -2]
						],
						10: [
							[2, 0],
							[-1, 0],
							[2, -1],
							[-1, 2]
						],
						12: [
							[-1, 0],
							[2, 0],
							[-1, -2],
							[2, 1]
						],
						21: [
							[1, 0],
							[-2, 0],
							[1, 2],
							[-2, -1]
						],
						23: [
							[2, 0],
							[-1, 0],
							[2, -1],
							[-1, 2]
						],
						32: [
							[-2, 0],
							[1, 0],
							[-2, 1],
							[1, -2]
						],
						30: [
							[1, 0],
							[-2, 0],
							[1, 2],
							[-2, -1]
						],
						"03": [
							[-1, 0],
							[2, 0],
							[-1, -2],
							[2, 1]
						],
						"02": [
							[-1, 0],
							[-2, 0],
							[1, 0],
							[2, 0],
							[0, 1]
						],
						13: [
							[0, 1],
							[0, 2],
							[0, -1],
							[0, -2],
							[-1, 0]
						],
						20: [
							[1, 0],
							[2, 0],
							[-1, 0],
							[-2, 0],
							[0, -1]
						],
						31: [
							[0, 1],
							[0, 2],
							[0, -1],
							[0, -2],
							[1, 0]
						]
					},
					additional_offsets: {
						z: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						l: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						o: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						s: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						i: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						j: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						t: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						]
					},
					spawn_rotation: {
						z: 0,
						l: 0,
						o: 0,
						s: 0,
						i: 0,
						j: 0,
						t: 0
					},
					colorMap: {
						z: "z",
						l: "l",
						o: "o",
						s: "s",
						i: "i",
						j: "j",
						t: "t",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					preview_overrides: {}
				},
				"TETRA-X": {
					kicks: {
						"01": [
							[0, 1],
							[-1, 0],
							[1, 0],
							[-1, 1],
							[1, 1],
							[0, -1],
							[-1, -1],
							[1, -1]
						],
						10: [
							[0, 1],
							[1, 0],
							[-1, 0],
							[1, 1],
							[-1, 1],
							[0, -1],
							[1, -1],
							[-1, -1]
						],
						12: [
							[0, 1],
							[-1, 0],
							[1, 0],
							[-1, 1],
							[1, 1],
							[0, -1],
							[-1, -1],
							[1, -1]
						],
						21: [
							[0, 1],
							[1, 0],
							[-1, 0],
							[1, 1],
							[-1, 1],
							[0, -1],
							[1, -1],
							[-1, -1]
						],
						23: [
							[0, 1],
							[-1, 0],
							[1, 0],
							[-1, 1],
							[1, 1],
							[0, -1],
							[-1, -1],
							[1, -1]
						],
						32: [
							[0, 1],
							[1, 0],
							[-1, 0],
							[1, 1],
							[-1, 1],
							[0, -1],
							[1, -1],
							[-1, -1]
						],
						30: [
							[0, 1],
							[-1, 0],
							[1, 0],
							[-1, 1],
							[1, 1],
							[0, -1],
							[-1, -1],
							[1, -1]
						],
						"03": [
							[0, 1],
							[1, 0],
							[-1, 0],
							[1, 1],
							[-1, 1],
							[0, -1],
							[1, -1],
							[-1, -1]
						],
						"02": [
							[0, 1],
							[0, -1],
							[-1, 0],
							[1, 0]
						],
						13: [
							[0, 1],
							[0, -1],
							[-1, 0],
							[1, 0]
						],
						20: [
							[0, 1],
							[0, -1],
							[-1, 0],
							[1, 0]
						],
						31: [
							[0, 1],
							[0, -1],
							[-1, 0],
							[1, 0]
						]
					},
					i_kicks: {
						"01": [
							[0, -1],
							[0, -2],
							[0, 1],
							[1, -1],
							[-1, -1],
							[1, -2],
							[-1, -2]
						],
						10: [
							[0, -1],
							[0, -2],
							[0, 1],
							[-1, 0],
							[1, 0],
							[2, 0]
						],
						12: [
							[0, -1],
							[0, -2],
							[0, 1],
							[-1, 0],
							[1, 0],
							[2, 0]
						],
						21: [
							[0, 1],
							[0, 2],
							[0, -1],
							[-1, 1],
							[1, 1],
							[-1, 2],
							[1, 2]
						],
						23: [
							[0, 1],
							[0, 2],
							[0, -1],
							[1, 1],
							[-1, 1],
							[1, 2],
							[-1, 2]
						],
						32: [
							[0, -1],
							[0, -2],
							[0, 1],
							[1, 0],
							[-1, 0],
							[-2, 0]
						],
						30: [
							[0, -1],
							[0, -2],
							[0, 1],
							[1, 0],
							[-1, 0],
							[-2, 0]
						],
						"03": [
							[0, -1],
							[0, -2],
							[0, 1],
							[-1, -1],
							[1, -1],
							[-1, -2],
							[1, -2]
						],
						"02": [
							[0, -1],
							[0, 1]
						],
						13: [
							[0, -1],
							[0, 1]
						],
						20: [
							[0, -1],
							[0, 1]
						],
						31: [
							[0, -1],
							[0, 1]
						]
					},
					additional_offsets: {
						z: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						l: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						o: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						s: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						i: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						j: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						t: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						]
					},
					spawn_rotation: {
						z: 0,
						l: 0,
						o: 0,
						s: 0,
						i: 0,
						j: 0,
						t: 0
					},
					colorMap: {
						z: "z",
						l: "o",
						o: "s",
						s: "i",
						i: "l",
						j: "j",
						t: "t",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					preview_overrides: {}
				},
				NRS: {
					kicks: {
						"01": [],
						10: [],
						12: [],
						21: [],
						23: [],
						32: [],
						30: [],
						"03": [],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					i_kicks: {
						"01": [],
						10: [],
						12: [],
						21: [],
						23: [],
						32: [],
						30: [],
						"03": [],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					additional_offsets: {
						z: [
							[1, 1],
							[1, 0],
							[1, 0],
							[2, 0]
						],
						l: [
							[1, 0],
							[1, 0],
							[1, 0],
							[1, 0]
						],
						o: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						s: [
							[1, 1],
							[1, 0],
							[1, 0],
							[2, 0]
						],
						i: [
							[0, 1],
							[0, 0],
							[0, 0],
							[1, 0]
						],
						j: [
							[1, 0],
							[1, 0],
							[1, 0],
							[1, 0]
						],
						t: [
							[1, 0],
							[1, 0],
							[1, 0],
							[1, 0]
						]
					},
					spawn_rotation: {
						z: 0,
						l: 2,
						o: 0,
						s: 0,
						i: 0,
						j: 2,
						t: 2
					},
					colorMap: {
						z: "z",
						l: "l",
						o: "o",
						s: "s",
						i: "i",
						j: "j",
						t: "t",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					preview_overrides: {
						l: [1, 1, 1, 1, 0, 0],
						j: [1, 1, 1, 0, 0, 1],
						t: [1, 1, 1, 0, 1, 0]
					}
				},
				ARS: {
					kicks: {
						"01": [
							[1, 0],
							[-1, 0]
						],
						10: [
							[1, 0],
							[-1, 0]
						],
						12: [
							[1, 0],
							[-1, 0]
						],
						21: [
							[1, 0],
							[-1, 0]
						],
						23: [
							[1, 0],
							[-1, 0]
						],
						32: [
							[1, 0],
							[-1, 0]
						],
						30: [
							[1, 0],
							[-1, 0]
						],
						"03": [
							[1, 0],
							[-1, 0]
						],
						"02": [
							[1, 0],
							[-1, 0]
						],
						13: [
							[1, 0],
							[-1, 0]
						],
						20: [
							[1, 0],
							[-1, 0]
						],
						31: [
							[1, 0],
							[-1, 0]
						]
					},
					i_kicks: {
						"01": [],
						10: [],
						12: [],
						21: [],
						23: [],
						32: [],
						30: [],
						"03": [],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					additional_offsets: {
						z: [
							[0, 1],
							[0, 0],
							[0, 0],
							[1, 0]
						],
						l: [
							[0, 1],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						o: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						s: [
							[0, 1],
							[-1, 0],
							[0, 0],
							[0, 0]
						],
						i: [
							[0, 0],
							[0, 0],
							[0, -1],
							[1, 0]
						],
						j: [
							[0, 1],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						t: [
							[0, 1],
							[0, 0],
							[0, 0],
							[0, 0]
						]
					},
					spawn_rotation: {
						z: 0,
						l: 2,
						o: 0,
						s: 0,
						i: 0,
						j: 2,
						t: 2
					},
					colorMap: {
						z: "s",
						l: "l",
						o: "o",
						s: "t",
						i: "z",
						j: "j",
						t: "i",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					preview_overrides: {
						l: [1, 1, 1, 1, 0, 0],
						j: [1, 1, 1, 0, 0, 1],
						t: [1, 1, 1, 0, 1, 0]
					},
					center_column: [
						[-1, -1],
						[0, -1],
						[1, -1],
						[-1, 0],
						[0, 0],
						[1, 0],
						[-1, 1],
						[0, 1],
						[1, 1]
					]
				},
				ASC: {
					kicks: {
						"01": [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						10: [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						12: [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						21: [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						23: [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						32: [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						30: [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						"03": [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					i_kicks: {
						"01": [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						10: [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						12: [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						21: [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						23: [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						32: [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						30: [
							[-1, 0],
							[0, 1],
							[-1, 1],
							[0, 2],
							[-1, 2],
							[-2, 0],
							[-2, 1],
							[-2, 2],
							[1, 0],
							[1, 1],
							[0, -1],
							[-1, -1],
							[-2, -1],
							[1, 2],
							[2, 0],
							[0, -2],
							[-1, -2],
							[-2, -2],
							[2, 1],
							[2, 2],
							[1, -1]
						],
						"03": [
							[1, 0],
							[0, 1],
							[1, 1],
							[0, 2],
							[1, 2],
							[2, 0],
							[2, 1],
							[2, 2],
							[-1, 0],
							[-1, 1],
							[0, -1],
							[1, -1],
							[2, -1],
							[-1, 2],
							[-2, 0],
							[0, -2],
							[1, -2],
							[2, -2],
							[-2, 1],
							[-2, 2],
							[-1, -1]
						],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					allow_o_kick: !0,
					additional_offsets: {
						z: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						l: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						o: [
							[0, 0],
							[0, 1],
							[-1, 1],
							[-1, 0]
						],
						s: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						i: [
							[0, 0],
							[0, -1],
							[1, -1],
							[1, 0]
						],
						j: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						t: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						]
					},
					colorMap: {
						z: "z",
						l: "l",
						o: "o",
						s: "s",
						i: "i",
						j: "j",
						t: "t",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					spawn_rotation: {
						z: 0,
						l: 0,
						o: 0,
						s: 0,
						i: 0,
						j: 0,
						t: 0
					},
					preview_overrides: {}
				},
				none: {
					kicks: {
						"01": [],
						10: [],
						12: [],
						21: [],
						23: [],
						32: [],
						30: [],
						"03": [],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					i_kicks: {
						"01": [],
						10: [],
						12: [],
						21: [],
						23: [],
						32: [],
						30: [],
						"03": [],
						"02": [],
						13: [],
						20: [],
						31: []
					},
					additional_offsets: {
						z: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						l: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						o: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						s: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						i: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						j: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						],
						t: [
							[0, 0],
							[0, 0],
							[0, 0],
							[0, 0]
						]
					},
					colorMap: {
						z: "z",
						l: "l",
						o: "o",
						s: "s",
						i: "i",
						j: "j",
						t: "t",
						g: "g",
						d: "d",
						gb: "gb",
						gbd: "gbd"
					},
					spawn_rotation: {
						z: 0,
						l: 0,
						o: 0,
						s: 0,
						i: 0,
						j: 0,
						t: 0
					},
					preview_overrides: {}
				}
			},
			scoring: {
				SINGLE: 100,
				DOUBLE: 300,
				TRIPLE: 500,
				QUAD: 800,
				TSPIN_MINI: 100,
				TSPIN: 400,
				TSPIN_MINI_SINGLE: 200,
				TSPIN_SINGLE: 800,
				TSPIN_MINI_DOUBLE: 400,
				TSPIN_DOUBLE: 1200,
				TSPIN_TRIPLE: 1600,
				TSPIN_QUAD: 2600,
				BACKTOBACK_MULTIPLIER: 1.5,
				COMBO: 50,
				ALL_CLEAR: 3500,
				SOFTDROP: 1,
				HARDDROP: 2
			},
			garbage: {
				SINGLE: 0,
				DOUBLE: 1,
				TRIPLE: 2,
				QUAD: 4,
				TSPIN_MINI: 0,
				TSPIN: 0,
				TSPIN_MINI_SINGLE: 0,
				TSPIN_SINGLE: 2,
				TSPIN_MINI_DOUBLE: 1,
				TSPIN_DOUBLE: 4,
				TSPIN_TRIPLE: 6,
				TSPIN_QUAD: 10,
				BACKTOBACK_BONUS: 1,
				BACKTOBACK_BONUS_LOG: .8,
				COMBO_MINIFIER: 1,
				COMBO_MINIFIER_LOG: 1.25,
				COMBO_BONUS: .25,
				ALL_CLEAR: 10
			},
			finesse: {
				z: {
					0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					1: [9, 2, 2, 2, 1, 1, 2, 3, 2, 2, 9],
					2: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					3: [9, 9, 2, 2, 2, 1, 1, 2, 3, 2, 2]
				},
				l: {
					0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
					2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
					3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
				},
				o: {
					0: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
					1: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
					2: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
					3: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9]
				},
				s: {
					0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					1: [9, 2, 2, 2, 1, 1, 2, 3, 2, 2, 9],
					2: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					3: [9, 9, 2, 2, 2, 1, 1, 2, 3, 2, 2]
				},
				i: {
					0: [9, 9, 1, 2, 1, 0, 1, 2, 1, 9, 9],
					1: [2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 9],
					2: [9, 9, 1, 2, 1, 0, 1, 2, 1, 9, 9],
					3: [9, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2]
				},
				j: {
					0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
					2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
					3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
				},
				t: {
					0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
					1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
					2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
					3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
				}
			},
			splashStyles: {
				clear: {
					size: 45,
					color: 16777215,
					y: 200,
					animation: {
						0: {
							"style.letterSpacing": 0,
							alpha: 1
						},
						.6: {
							"style.letterSpacing": "10r",
							alpha: .95
						},
						1: {
							"style.letterSpacing": "20r",
							alpha: 0
						}
					},
					animationDuration: 6,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(22.5), "#FFFFFF", 3, 1.5, .5, 0, mt(45), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(22.5), "#FFFFFF", 3, 1.5, .5, 0, mt(45), .02, 175, 185, 0, 300, 150, .5, 0, .1)
					}
				},
				tspin: {
					size: 30,
					color: 15688959,
					y: 160,
					animation: {
						0: {
							"style.letterSpacing": 0,
							alpha: 1
						},
						.6: {
							"style.letterSpacing": "10r",
							alpha: .95
						},
						1: {
							"style.letterSpacing": "20r",
							alpha: 0
						}
					},
					animationDuration: 6,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(10), n.strColor, 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(10), n.strColor, 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), hn(e - 25, t - mt(10), n.strColor, 1, .18, .14, 0, mt(40), .8, 179, 181, 0, 300, 250, .5, 0, .9)
					}
				},
				also: {
					size: 30,
					color: 16767332,
					y: 240,
					animation: {
						0: {
							"style.letterSpacing": 0,
							alpha: 1
						},
						.6: {
							"style.letterSpacing": "10r",
							alpha: .95
						},
						1: {
							"style.letterSpacing": "20r",
							alpha: 0
						}
					},
					animationDuration: 6,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(10), "#FFD964", 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(10), "#FFD964", 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), hn(e - 25, t - mt(10), "#FFD964", 1, .18, .14, 0, mt(40), .8, 179, 181, 0, 300, 250, .5, 0, .9)
					}
				},
				also_permanent: {
					size: 30,
					color: 16767332,
					y: 240,
					animation: {
						0: {
							"style.letterSpacing": 0
						},
						1: {
							"style.letterSpacing": "10r"
						}
					},
					persistent: !0,
					animationDuration: 6,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(10), "#FFD964", 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(10), "#FFD964", 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), hn(e - 25, t - mt(10), "#FFD964", 1, .18, .14, 0, mt(40), .8, 179, 181, 0, 300, 250, .5, 0, .9)
					}
				},
				also_permanent_up: {
					size: 30,
					color: 16767332,
					y: 240,
					animation: {
						0: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.16: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.17: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.33: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.34: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						"0.50": {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.51: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.66: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.67: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						1: {
							alpha: 1,
							"style.letterSpacing": "10r"
						}
					},
					persistent: !0,
					animationDuration: 2,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(10), "#FFD964", 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(10), "#FFD964", 3, 1.5, .5, 0, mt(20), .02, 175, 185, 0, 300, 150, .5, 0, .1), hn(e - 25, t - mt(10), "#FFD964", 3, .18, .14, 0, mt(40), .8, 179, 181, 0, 400, 150, .5, 0, .9)
					}
				},
				also_failed: {
					size: 30,
					color: 14950946,
					y: 240,
					animation: {
						0: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.1: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.105: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.2: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.205: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.3: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.305: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.4: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.405: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.5: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						.505: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.6: {
							alpha: 0,
							"style.letterSpacing": 0
						},
						.605: {
							alpha: 1,
							"style.letterSpacing": 0
						},
						1: {
							alpha: 0,
							"style.letterSpacing": "10r"
						}
					},
					animationDuration: 4,
					animationEasing: BezierEasing(.1, .38, 0, .88)
				},
				combo: {
					size: 60,
					color: 16777215,
					y: 295,
					animation: {
						0: {
							y: "295r",
							alpha: 1
						},
						.1: {
							y: "285r",
							alpha: 1
						},
						.2: {
							y: "295r",
							alpha: 1
						},
						.6: {
							y: "295r",
							alpha: .95
						},
						1: {
							y: "295r",
							alpha: 0
						}
					},
					animationDuration: 6,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(25), "#FFFFFF", 3, 1.5, .5, 0, mt(50), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(25), "#FFFFFF", 3, 1.5, .5, 0, mt(50), .02, 175, 185, 0, 300, 150, .5, 0, .1), hn(e - 25, t - mt(25), "#FFFFFF", 1, .18, .14, 0, mt(70), .8, 179, 181, 0, 300, 250, .5, 0, .9)
					}
				},
				spike: {
					size: 40,
					color: 16776960,
					y: 355,
					animation: {
						0: {
							y: "355r",
							alpha: 1
						},
						.1: {
							y: "345r",
							alpha: 1
						},
						.2: {
							y: "355r",
							alpha: 1
						},
						.6: {
							y: "355r",
							alpha: .95
						},
						1: {
							y: "355r",
							alpha: 0
						}
					},
					animationDuration: 5,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e - 25, t - mt(20), "#FFFF00", 3, 1.5, .5, 0, mt(40), .02, 175, 185, 0, 300, 150, .5, 0, .1), yn(e - 25, t - mt(20), "#FFFF00", 3, 1.5, .5, 0, mt(40), .02, 175, 185, 0, 300, 150, .5, 0, .1), hn(e - 25, t - mt(20), "#FFFF00", 1, .18, .14, 0, mt(80), .8, 179, 181, 0, 300, 250, .5, 0, .9)
					}
				}
			},
			shoutStyles: {
				countdown: {
					size: 120,
					color: 16762368,
					y: 0,
					animation: {
						0: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "66r",
							alpha: 0
						},
						.05: {
							"scale.x": 1.1,
							"scale.y": 1.1,
							"pivot.y": "54r",
							alpha: 1
						},
						.3: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "60r",
							alpha: .95
						},
						1: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "66r",
							alpha: 0
						}
					},
					animationDuration: 2.5,
					flatAnimationDuration: .75,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					hasShadow: !0,
					shadowColor: 2432256,
					animationShadow: {
						0: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "60r",
							alpha: .8
						},
						.6: {
							"scale.x": 2.2,
							"scale.y": 2.2,
							"pivot.y": "10r",
							alpha: .5
						},
						1: {
							"scale.x": 3,
							"scale.y": 3,
							"pivot.y": "0r",
							alpha: 0
						}
					},
					animationShadowDuration: 2,
					animationShadowEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, 175, 185, 0, 450, 150, .75, 0, .1), yn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, 175, 185, 0, 450, 150, .75, 0, .1), hn(e - 45, t - mt(90), "#FFC600", 1.5, .18, .14, 0, mt(80), .25, 175, 185, 0, 450, 400, .3, 0, .9), pn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, -5, 5, 0, 450, 150, .75, 0, .1), yn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, -5, 5, 0, 450, 150, .75, 0, .1), hn(e + 45, t - mt(90), "#FFC600", 1.5, .18, .14, 0, mt(80), .25, -5, 5, 0, 450, 400, .3, 0, .9)
					}
				},
				countdown_stride: {
					size: 120,
					color: 16762368,
					y: 0,
					animation: {
						0: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "66r",
							alpha: 0
						},
						.05: {
							"scale.x": 1.1,
							"scale.y": 1.1,
							"pivot.y": "54r",
							alpha: 1
						},
						.3: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "60r",
							alpha: .95
						},
						1: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "66r",
							alpha: 0
						}
					},
					animationDuration: 1.25,
					flatAnimationDuration: .5,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					hasShadow: !0,
					shadowColor: 2432256,
					animationShadow: {
						0: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "60r",
							alpha: .8
						},
						.6: {
							"scale.x": 2.2,
							"scale.y": 2.2,
							"pivot.y": "10r",
							alpha: .5
						},
						1: {
							"scale.x": 3,
							"scale.y": 3,
							"pivot.y": "0r",
							alpha: 0
						}
					},
					animationShadowDuration: 1,
					animationShadowEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, 175, 185, 0, 450, 150, .5, 0, .1), yn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, 175, 185, 0, 450, 150, .5, 0, .1), hn(e - 45, t - mt(90), "#FFC600", 1.5, .18, .14, 0, mt(80), .25, 175, 185, 0, 450, 400, .15, 0, .9), pn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, -5, 5, 0, 450, 150, .5, 0, .1), yn(e, t - mt(90), "#FFC600", 1, 1.5, .5, 0, mt(80), .02, -5, 5, 0, 450, 150, .5, 0, .1), hn(e + 45, t - mt(90), "#FFC600", 1.5, .18, .14, 0, mt(80), .25, -5, 5, 0, 450, 400, .15, 0, .9)
					}
				},
				levelup: {
					size: 120,
					color: 6256003,
					y: 0,
					animation: {
						0: {
							"pivot.y": "-90r",
							alpha: 0
						},
						.05: {
							"pivot.y": "-54r",
							alpha: 1
						},
						1: {
							"pivot.y": "270r",
							alpha: 0
						}
					},
					animationDuration: 1.5,
					animationEasing: BezierEasing(.2, .65, .88, .64),
					hasShadow: !1
				},
				timeleft: {
					size: 40,
					color: 16732200,
					y: -180,
					animation: {
						0: {
							"pivot.y": "-20r",
							alpha: 0,
							"style.letterSpacing": 0,
							"style.fill": 16777215
						},
						.05: {
							"pivot.y": "-15r",
							alpha: 1,
							"style.letterSpacing": "0.25r",
							"style.fill": 16777215
						},
						.8: {
							"pivot.y": "-10r",
							alpha: 1,
							"style.letterSpacing": "5r",
							"style.fill": 16732200
						},
						1: {
							"pivot.y": "-8r",
							alpha: 0,
							"style.letterSpacing": "8r",
							"style.fill": 12067584
						}
					},
					animationDuration: 4,
					animationEasing: BezierEasing(.2, .65, .88, .64),
					hasShadow: !1,
					ultra: (e, t, n) => {
						pn(e, t, "#FF5028", 1, 1.5, .5, 0, mt(50), .02, 175, 185, 0, 600, 150, 3, 0, .1), yn(e, t, "#FF5028", 1, 1.5, .5, 0, mt(50), .02, 175, 185, 0, 600, 150, 3, 0, .1), hn(e - 90, t, "#FF5028", 1.5, .18, .14, 0, mt(50), .5, 175, 185, 0, 600, 400, 2.5, 0, .9), pn(e, t, "#FF5028", 1, 1.5, .5, 0, mt(50), .02, -5, 5, 0, 600, 150, 3, 0, .1), yn(e, t, "#FF5028", 1, 1.5, .5, 0, mt(50), .02, -5, 5, 0, 600, 150, 3, 0, .1), hn(e + 90, t, "#FF5028", 1.5, .18, .14, 0, mt(50), .5, -5, 5, 0, 600, 400, 2.5, 0, .9)
					}
				},
				clutch: {
					size: 30,
					color: 16771199,
					y: -380,
					animation: {
						0: {
							alpha: 1.5,
							"style.letterSpacing": 0
						},
						.05: {
							alpha: 1.5,
							"style.letterSpacing": "30r"
						},
						1: {
							alpha: 0,
							"style.letterSpacing": "50r"
						}
					},
					animationDuration: 1,
					animationEasing: BezierEasing(.2, .65, .88, .64),
					hasShadow: !1
				},
				allclear: {
					size: 60,
					color: 16777215,
					y: -120,
					animation: {
						0: {
							rotation: -10,
							"scale.x": 0,
							"scale.y": 0,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16777215
						},
						.1: {
							rotation: 0,
							"scale.x": 1.4,
							"scale.y": 1.4,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16737894
						},
						.15: {
							rotation: 0,
							"scale.x": 1.3,
							"scale.y": 1.3,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16777215
						},
						.8: {
							rotation: 0,
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: .9,
							"style.fill": 16753152
						},
						1: {
							rotation: 0,
							"scale.x": .5,
							"scale.y": .5,
							"pivot.y": "-45r",
							alpha: 0,
							"style.fill": 16777215
						}
					},
					animationDuration: 5,
					animationEasing: BezierEasing(.06, .18, .65, 1.01),
					hasShadow: !0,
					shadowColor: 2235150,
					animationShadow: {
						0: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: 0
						},
						.09: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: 0
						},
						.1: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: 1
						},
						1: {
							"scale.x": 5,
							"scale.y": 5,
							"pivot.y": "-85r",
							alpha: 0
						}
					},
					animationShadowDuration: 5,
					animationShadowEasing: BezierEasing(.06, .18, .65, 1.01),
					ultra: (e, t, n) => {
						pn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, 175, 185, 0, 600, 150, 3, 0, .1), yn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, 175, 185, 0, 600, 150, 3, 0, .1), hn(e - 90, t, "#FFA200", 1.5, .18, .14, 0, mt(120), .5, 175, 185, 0, 600, 400, 2.5, 0, .9), pn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, -5, 5, 0, 600, 150, 3, 0, .1), yn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, -5, 5, 0, 600, 150, 3, 0, .1), hn(e + 90, t, "#FFA200", 1.5, .18, .14, 0, mt(120), .5, -5, 5, 0, 600, 400, 2.5, 0, .9)
					}
				},
				zenlevel: {
					size: 60,
					color: 16777215,
					y: -120,
					animation: {
						0: {
							"scale.x": 2.5,
							"scale.y": 0,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16777215
						},
						.05: {
							"scale.x": .8,
							"scale.y": 1.9,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16755370
						},
						.1: {
							"scale.x": 1.4,
							"scale.y": 1.4,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16737894
						},
						.15: {
							"scale.x": 1.3,
							"scale.y": 1.3,
							"pivot.y": "-45r",
							alpha: 1,
							"style.fill": 16777215
						},
						1: {
							rotation: 0,
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: .9,
							"style.fill": 16753152
						}
					},
					animationDuration: 5,
					animationEasing: BezierEasing(.06, .18, .65, 1.01),
					hasShadow: !0,
					shadowColor: 2235150,
					animationShadow: {
						0: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: 0
						},
						.09: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: 0
						},
						.1: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "-45r",
							alpha: 1
						},
						1: {
							"scale.x": 5,
							"scale.y": 5,
							"pivot.y": "-85r",
							alpha: 0
						}
					},
					animationShadowDuration: 5,
					animationShadowEasing: BezierEasing(.06, .18, .65, 1.01),
					ultra: (e, t, n) => {
						pn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, 175, 185, 0, 600, 150, 3, 0, .1), yn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, 175, 185, 0, 600, 150, 3, 0, .1), hn(e - 90, t, "#FFA200", 1.5, .18, .14, 0, mt(120), .5, 175, 185, 0, 600, 400, 2.5, 0, .9), pn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, -5, 5, 0, 600, 150, 3, 0, .1), yn(e, t, "#FFA200", 1, 1.5, .5, 0, mt(120), .02, -5, 5, 0, 600, 150, 3, 0, .1), hn(e + 90, t, "#FFA200", 1.5, .18, .14, 0, mt(120), .5, -5, 5, 0, 600, 400, 2.5, 0, .9)
					}
				},
				offence: {
					size: 50,
					color: 16762368,
					y: 0,
					animation: {
						0: {
							"scale.x": .8,
							"scale.y": .8,
							"pivot.y": "20r",
							alpha: 0
						},
						.1: {
							"scale.x": 1.5,
							"scale.y": 1.5,
							"pivot.y": "13r",
							alpha: 1
						},
						.6: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "25r",
							alpha: .95
						},
						1: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "28r",
							alpha: 0
						}
					},
					animationDuration: 2,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					hasShadow: !0,
					shadowColor: 2432256,
					animationShadow: {
						0: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "25r",
							alpha: .8
						},
						.6: {
							"scale.x": 2.2,
							"scale.y": 2.2,
							"pivot.y": "-10r",
							alpha: .5
						},
						1: {
							"scale.x": 3,
							"scale.y": 3,
							"pivot.y": "-25r",
							alpha: 0
						}
					},
					animationShadowDuration: 1,
					animationShadowEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e, t - mt(40), "#FFC600", 1, 1.5, .5, 0, mt(10), .02, 175, 185, 0, 200, 50, .2, 0, .1), yn(e, t - mt(40), "#FFC600", 1, 1.5, .5, 0, mt(10), .02, 175, 185, 0, 200, 50, .2, 0, .1), hn(e - 20, t - mt(40), "#FFC600", 1.5, .18, .14, 0, mt(10), .5, 175, 185, 0, 200, 50, .1, 0, .9), pn(e, t - mt(40), "#FFC600", 1, 1.5, .5, 0, mt(10), .02, -5, 5, 0, 200, 50, .2, 0, .1), yn(e, t - mt(40), "#FFC600", 1, 1.5, .5, 0, mt(10), .02, -5, 5, 0, 200, 50, .2, 0, .1), hn(e + 20, t - mt(40), "#FFC600", 1.5, .18, .14, 0, mt(10), .5, -5, 5, 0, 200, 50, .1, 0, .9)
					}
				},
				defense: {
					size: 50,
					color: 4895440,
					y: 0,
					animation: {
						0: {
							"scale.x": 1.4,
							"scale.y": 1.4,
							"pivot.y": "15r",
							alpha: 0
						},
						.1: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "28r",
							alpha: 1
						},
						.6: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "25r",
							alpha: .95
						},
						1: {
							"scale.x": 1.1,
							"scale.y": 1.1,
							"pivot.y": "23r",
							alpha: 0
						}
					},
					animationDuration: 2,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					hasShadow: !0,
					shadowColor: 2375761,
					animationShadow: {
						0: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "28r",
							alpha: .8
						},
						.6: {
							"scale.x": 1.6,
							"scale.y": 1.6,
							"pivot.y": "10r",
							alpha: .5
						},
						1: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "28r",
							alpha: 0
						}
					},
					animationShadowDuration: 1,
					animationShadowEasing: BezierEasing(.1, .38, 0, .88),
					ultra: (e, t, n) => {
						pn(e, t - mt(40), "#4AB2D0", 1, 1.5, .5, 0, mt(10), .02, 265, 275, 0, 200, 50, .2, 0, .1), yn(e, t - mt(40), "#4AB2D0", 1, 1.5, .5, 0, mt(10), .02, 265, 275, 0, 200, 50, .2, 0, .1), hn(e, t - 20 - mt(40), "#4AB2D0", 1.5, .18, .14, 0, mt(10), .5, 265, 275, 0, 200, 50, .1, 0, .9), pn(e, t - mt(40), "#4AB2D0", 1, 1.5, .5, 0, mt(10), .02, 85, 95, 0, 200, 50, .2, 0, .1), yn(e, t - mt(40), "#4AB2D0", 1, 1.5, .5, 0, mt(10), .02, 85, 95, 0, 200, 50, .2, 0, .1), hn(e, t + 20 - mt(40), "#4AB2D0", 1.5, .18, .14, 0, mt(10), .5, 85, 95, 0, 200, 50, .1, 0, .9)
					}
				},
				offdefplus: {
					size: 50,
					color: 11184810,
					y: 0,
					animation: {
						0: {
							"scale.x": 1.4,
							"scale.y": 1.4,
							"pivot.y": "15r",
							alpha: 0
						},
						.1: {
							"scale.x": .9,
							"scale.y": .9,
							"pivot.y": "28r",
							alpha: 1
						},
						.6: {
							"scale.x": 1,
							"scale.y": 1,
							"pivot.y": "25r",
							alpha: .95
						},
						1: {
							"scale.x": 1.1,
							"scale.y": 1.1,
							"pivot.y": "23r",
							alpha: 0
						}
					},
					animationDuration: 2,
					animationEasing: BezierEasing(.1, .38, 0, .88),
					hasShadow: !1
				}
			},
			majorShoutStyles: {
				globalbest: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFA200", 2, 1.5, .5, 0, window.innerHeight / 7, .08, 175, 185, 0, 1200, 150, 4, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFA200", 2.5, .18, .14, 0, window.innerHeight / 7, .5, 175, 185, 0, 1200, 400, 4, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFA200", 2, 1.5, .5, 0, window.innerHeight / 7, .08, -5, 5, 0, 1200, 150, 4, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFA200", 2.5, .18, .14, 0, window.innerHeight / 7, .5, -5, 5, 0, 1200, 400, 4, 0, .9, !0)
				},
				personalbest: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2, 1.5, .5, 0, window.innerHeight / 7, .08, 175, 185, 0, 1200, 150, 4, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2.5, .18, .14, 0, window.innerHeight / 7, .5, 175, 185, 0, 1200, 400, 4, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2, 1.5, .5, 0, window.innerHeight / 7, .08, -5, 5, 0, 1200, 150, 4, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2.5, .18, .14, 0, window.innerHeight / 7, .5, -5, 5, 0, 1200, 400, 4, 0, .9, !0)
				},
				gameshort: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2, 1.5, .5, 0, window.innerHeight / 7, .08, 165, 195, 0, 1200, 150, .25, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2.5, .18, .14, 0, window.innerHeight / 7, .5, 165, 195, 0, 1200, 400, .25, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2, 1.5, .5, 0, window.innerHeight / 7, .08, -15, 15, 0, 1200, 150, .25, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 2.5, .18, .14, 0, window.innerHeight / 7, .5, -15, 15, 0, 1200, 400, .25, 0, .9, !0)
				},
				game: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, 165, 195, 0, 1200, 150, .5, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, 165, 195, 0, 1200, 150, .5, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4.5, .18, .14, 0, window.innerHeight / 7, .5, 165, 195, 0, 1200, 400, .5, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, -15, 15, 0, 1200, 150, .5, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, -15, 15, 0, 1200, 150, .5, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4.5, .18, .14, 0, window.innerHeight / 7, .5, -15, 15, 0, 1200, 400, .5, 0, .9, !0)
				},
				lg_victory: () => {
					setTimeout(() => {
						hn(window.innerWidth / 2, window.innerHeight / 2, "#FFF496", 50, .5, .14, 0, 0, .15, 0, 360, 0, 1200, 0, .05, .5, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 12, 2.5, .5, 0, window.innerHeight / 7, .02, 175, 185, 0, 2500, 2e3, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 12, 2.5, .5, 0, window.innerHeight / 7, .02, 175, 185, 0, 2500, 2e3, 3, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 4.5, .18, .14, 0, window.innerHeight / 7, .25, 175, 185, 0, 2500, 2e3, 3, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 12, 2.5, .5, 0, window.innerHeight / 7, .02, -5, 5, 0, 2500, 2e3, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 12, 2.5, .5, 0, window.innerHeight / 7, .02, -5, 5, 0, 2500, 2e3, 3, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFE400", 4.5, .18, .14, 0, window.innerHeight / 7, .25, -5, 5, 0, 2500, 2e3, 3, 0, .9, !0)
					}, 1250), setTimeout(() => {
						hn(window.innerWidth * Math.random(), window.innerHeight * Math.random(), "#FFF496", 50, .5, .14, 0, 0, .05, 0, 360, 0, 1200, 0, .05, .5, .9, !0)
					}, 1600), setTimeout(() => {
						hn(window.innerWidth * Math.random(), window.innerHeight * Math.random(), "#FFF496", 50, .5, .14, 0, 0, .05, 0, 360, 0, 1200, 0, .05, .5, .9, !0)
					}, 1700), setTimeout(() => {
						hn(window.innerWidth * Math.random(), window.innerHeight * Math.random(), "#FFF496", 50, .5, .14, 0, 0, .05, 0, 360, 0, 1200, 0, .05, .5, .9, !0)
					}, 1800), setTimeout(() => {
						hn(window.innerWidth * Math.random(), window.innerHeight * Math.random(), "#FFF496", 50, .5, .14, 0, 0, .05, 0, 360, 0, 1200, 0, .05, .5, .9, !0)
					}, 1900)
				},
				lg_defeat: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#1F1041", 4, 1.5, .5, window.innerWidth / 2, window.innerHeight / 7, .15, 175, 185, 0, 500, 200, 3, 0, .1, !1), yn(window.innerWidth / 2, window.innerHeight / 2, "#1F1041", 4, 1.5, .5, window.innerWidth / 2, window.innerHeight / 7, .15, 175, 185, 0, 500, 200, 3, 0, .1, !1), hn(window.innerWidth / 2, window.innerHeight / 2, "#6C1855", 4.5, .35, .14, window.innerWidth / 2, window.innerHeight / 7, .5, 175, 185, 0, 1800, 400, 3, 0, .9, !1), pn(window.innerWidth / 2, window.innerHeight / 2, "#1F1041", 4, 1.5, .5, window.innerWidth / 2, window.innerHeight / 7, .15, -5, 5, 0, 500, 200, 3, 0, .1, !1), yn(window.innerWidth / 2, window.innerHeight / 2, "#1F1041", 4, 1.5, .5, window.innerWidth / 2, window.innerHeight / 7, .15, -5, 5, 0, 500, 200, 3, 0, .1, !1), hn(window.innerWidth / 2, window.innerHeight / 2, "#6C1855", 4.5, .35, .14, window.innerWidth / 2, window.innerHeight / 7, .5, -5, 5, 0, 1800, 400, 3, 0, .9, !1)
				}
			},
			globalShoutStyles: {
				finish: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, 165, 195, 0, 1200, 150, .25, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, 165, 195, 0, 1200, 150, .25, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4.5, .18, .14, 0, window.innerHeight / 7, .5, 165, 195, 0, 1200, 400, .25, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, -15, 15, 0, 1200, 150, .25, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4, 1.5, .5, 0, window.innerHeight / 7, .08, -15, 15, 0, 1200, 150, .25, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFD800", 4.5, .18, .14, 0, window.innerHeight / 7, .5, -15, 15, 0, 1200, 400, .25, 0, .9, !0)
				},
				gameover: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFFFFF", 2, 1.5, .5, 0, window.innerHeight / 7, .08, 175, 185, 0, 1200, 150, 1, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#4B0B7D", 2, 1.5, .5, 0, window.innerHeight / 7, .08, 175, 185, 0, 1200, 150, 1, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFFFFF", 2.5, .18, .14, 0, window.innerHeight / 7, .5, 175, 185, 0, 1200, 400, 1, 0, .9, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFFFFF", 2, 1.5, .5, 0, window.innerHeight / 7, .08, -5, 5, 0, 1200, 150, 1, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#4B0B7D", 2, 1.5, .5, 0, window.innerHeight / 7, .08, -5, 5, 0, 1200, 150, 1, 0, .1, !0), hn(window.innerWidth / 2, window.innerHeight / 2, "#FFFFFF", 2.5, .18, .14, 0, window.innerHeight / 7, .5, -5, 5, 0, 1200, 400, 1, 0, .9, !0)
				},
				mission: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFD200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 3, 0, .1, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FFD200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FFD200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 3, 0, .1, !0)
				},
				mission_free: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#00A8FF", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 2, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#00A8FF", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 2, 0, .1, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#00A8FF", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 2, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#00A8FF", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 2, 0, .1, !0)
				},
				mission_versus: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FF1200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FF1200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 3, 0, .1, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FF1200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FF1200", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 3, 0, .1, !0)
				},
				mission_league: () => {
					pn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 1.5, 1, .5, 0, window.innerHeight / 15, .02, 175, 185, 0, 600, 150, 3, 0, .1, !0), pn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 3, 0, .1, !0), yn(window.innerWidth / 2, window.innerHeight / 2, "#FF0000", 1.5, 1, .5, 0, window.innerHeight / 15, .02, -5, 5, 0, 600, 150, 3, 0, .1, !0)
				}
			},
			gameModes: {
				"40l": {
					version: 15,
					seed_random: !1,
					anchorseed: !0,
					seed: "X-PASSTHRU",
					allow180: !0,
					g: .02,
					objective: {
						type: "lines",
						count: 40
					},
					handling: "X-PASSTHRU",
					countdown: "X-PASSTHRU",
					countdown_interval: "X-PASSTHRU",
					precountdown: "X-PASSTHRU",
					prestart: "X-PASSTHRU",
					mission: "X-PASSTHRU",
					zoominto: "X-PASSTHRU",
					bgmnoreset: "X-PASSTHRU",
					display_lines: !0,
					display_stopwatch: !0,
					display_pieces: !0,
					display_progress: !0,
					display_finesse: !0,
					display_keys: !0,
					can_retry: !0,
					pro: "X-PASSTHRU",
					stride: "X-PASSTHRU"
				},
				blitz: {
					version: 15,
					seed_random: !1,
					anchorseed: !0,
					seed: "X-PASSTHRU",
					allow180: !0,
					objective: {
						type: "timed",
						time: 12e4
					},
					levels: !0,
					levelspeed: .42,
					gbase: .65,
					handling: "X-PASSTHRU",
					countdown: "X-PASSTHRU",
					countdown_interval: "X-PASSTHRU",
					precountdown: "X-PASSTHRU",
					prestart: "X-PASSTHRU",
					mission: "X-PASSTHRU",
					zoominto: "X-PASSTHRU",
					bgmnoreset: "X-PASSTHRU",
					display_lines: !0,
					display_timer: !0,
					display_level: !0,
					display_score: !0,
					display_progress: !0,
					display_finesse_l: !0,
					can_retry: !0,
					pro: "X-PASSTHRU",
					stride: "X-PASSTHRU"
				}
			}
		},
		_a = function (e, t, n = -1) {
			let a = e || 0,
				o = t || [],
				r = [],
				l = null,
				d = [],
				c = !1;
			const m = 60;
			let u = 30,
				g = 0;

			function p(e = !1) {
				l && (g = 0, e || (u = Math.min(m, u + 1)), "function" == typeof l ? l({
					listenID: n,
					frames: d,
					provisioned: a
				}) : l.emit("replay", {
					listenID: n,
					frames: d,
					provisioned: a
				}), d = [], c = !1)
			}

			function h() {
				r = [];
				for (let e = 0; e < o.length; e++) void 0 === r[o[e].frame] && (r[o[e].frame] = e)
			}
			return h(), {
				frame: function () {
					g++, !i() && g >= u ? p() : c && p(), a++
				},
				getFrame: function () {
					return a
				},
				getEventCount: function () {
					return o.length
				},
				getStarter: function () {
					let e = null;
					for (let t = 0; t < o.length; t++)
						if ("full" === o[t].type) {
							e = o[t].data;
							break
						} return e ? (e.options.seed_random = !1, e.options.handling = e.game.handling, e) : null
				},
				getStartEvent: function () {
					for (let e = 0; e < o.length; e++)
						if ("start" === o[e].type) return o[e];
					return null
				},
				getEndEvent: function () {
					for (let e = 0; e < o.length; e++)
						if ("end" === o[e].type) return o[e];
					return null
				},
				pushEvent: function (e, t) {
					const n = {
						frame: a,
						type: e,
						data: s(t)
					};
					"full" === e || i() || (u = Math.max(6, Math.min(30, u - .25))), o.push(n), l && ("end" === e && (c = !0), d.push(n)), void 0 === r[a] && (r[a] = o.length - 1)
				},
				getEventsAtFrame: function (e) {
					let t = r[e];
					if (void 0 === t) return [];
					const n = [];
					for (let a = t; a < o.length && o[a].frame === e; a++) n.push(o[a]);
					return n
				},
				export: function () {
					return {
						frames: a,
						events: o
					}
				},
				import: function (e) {
					a = e.frames, o = e.events, h()
				},
				seek: function (e) {
					a = e
				},
				bindRolling: function (e) {
					l = e
				},
				setListenID: function (e) {
					n = e
				},
				flush: function () {
					p(!0)
				}
			}
		},
		Ea = function (e) {
			let t = e.listenID || -1,
				n = 0,
				a = 0;
			const o = e;
			let i = [],
				s = () => {},
				r = () => {},
				l = [],
				d = [],
				c = !1,
				m = [],
				u = 15,
				g = "",
				p = 0;
			const h = 1e3 / 60;
			"keyboard" === o.type && (document.addEventListener("keydown", f, !1), document.addEventListener("gpdown", f, !1), document.addEventListener("keyup", _, !1), document.addEventListener("gpup", _, !1));
			const y = e => {
				e.listenID === t && (d.push(...e.frames), u = e.provisioned - a, a = e.provisioned, e.frames.some(e => "end" === e.type) && a++)
			};

			function f(e) {
				if (e.repeat) return;
				if (document.body.classList.contains("chatfocus") || We >= 1) return;
				if (!e.detail && event.target.closest("#zen_panel_content")) return;
				const t = ce(e) || e.detail.toUpperCase();
				if (m.includes(t)) return;
				m.push(t);
				let a = 0;
				p && (a = Math.min(.9, Math.floor((Date.now() - p) / h * 10) / 10)), Object.keys(X).forEach(o => {
					X[o].includes(t) && (l.push({
						frame: n,
						type: "keydown",
						data: {
							key: o,
							subframe: a
						}
					}), "retry" === o && s(), "exit" === o && r(), e.detail || e.preventDefault())
				})
			}

			function _(e) {
				if (document.body.classList.contains("chatfocus") || We >= 1) return;
				if (!e.detail && event.target.closest("#zen_panel_content")) return;
				const t = ce(e) || e.detail.toUpperCase();
				if (!m.includes(t)) return;
				m.splice(m.indexOf(t), 1);
				let a = 0;
				p && (a = Math.min(.9, Math.floor((Date.now() - p) / h * 10) / 10)), Object.keys(X).forEach(o => {
					if (X[o].includes(t)) {
						if ("chat" === o) return;
						l.push({
							frame: n,
							type: "keyup",
							data: {
								key: o,
								subframe: a
							}
						}), e.detail || e.preventDefault()
					}
				})
			}

			function E(e) {
				i.forEach(t => {
					t(e)
				})
			}
			return "socket" === o.type && o.socket.on("replay", y), {
				frame: function () {
					n++, "keyboard" === o.type && (p = Date.now())
				},
				getFrame: function () {
					return n
				},
				readyEventQueue: function () {
					const e = [];
					for (let t = 0; t < l.length; t++) "keydown" === l[t].type && (e.includes(l[t].data.key) || e.push(l[t].data.key)), "keyup" === l[t].type && e.includes(l[t].data.key) && e.splice(e.indexOf(l[t].data.key), 1);
					const t = [];
					for (let e = 0; e < l.length; e++) "keydown" !== l[e].type && "keyup" !== l[e].type && t.push(l[e]);
					for (let a = 0; a < e.length; a++) t.push({
						frame: n,
						type: "keydown",
						data: {
							key: e[a],
							hoisted: !0,
							subframe: 0
						}
					});
					l = t
				},
				pull: function () {
					if ("replay" === o.type) {
						o.replay.getEventsAtFrame(n).forEach(e => {
							E(e)
						})
					} else if ("socket" === o.type) {
						let e = [];
						for (let t = 0; t < d.length; t++) d[t].frame === n ? E(d[t]) : e.push(d[t]);
						d = e
					} else l.forEach(e => {
						E(e)
					}), l = []
				},
				nextFrameReady: () => "socket" !== o.type || a > n,
				fallingBehind: () => "socket" === o.type && (a > n + 40 && (c = !0), a <= n && (c = !1), c),
				amountToCatchUp: () => "socket" === o.type && a - n,
				behindness: () => "socket" === o.type && (a - n) / u,
				bind: function (e) {
					i.push(e)
				},
				unbind: function (e) {
					i = i.filter(t => t !== e)
				},
				seek: function (e) {
					n = e
				},
				finished: function () {
					if ("replay" === o.type) return n > o.replay.getFrame()
				},
				type: function () {
					return o.type
				},
				pushIGE: function (e) {
					l.push({
						id: e.id,
						frame: n,
						type: "ige",
						data: e.data
					})
				},
				pushTargets: function (e) {
					const t = JSON.stringify(e);
					t != g && (g = t, l.push({
						id: "diyusi",
						frame: n,
						type: "targets",
						data: e
					}))
				},
				unhook: function () {
					document.removeEventListener("keydown", f), document.removeEventListener("gpdown", f), document.removeEventListener("keyup", _), document.removeEventListener("gpup", _)
				},
				destroy: function () {
					i = [], o.socket.removeListener("replay", y)
				},
				socket: () => o.socket,
				bindHyperRetry: function (e) {
					s = e
				},
				bindHyperForfeit: function (e) {
					r = e
				}
			}
		},
		va = 15,
		ba = 11;
	let Ia = [],
		wa = 0;
	const ka = function () {
		const e = Date.now() + ":" + (++wa).toString();
		let t, n = 0,
			s = {},
			l = new _a,
			c = 1,
			m = 1,
			u = {},
			g = !1,
			p = !0,
			h = !1,
			y = !1,
			f = !1;
		const _ = {
				seed: 0,
				lines: 0,
				level_lines: 0,
				level_lines_needed: 1,
				inputs: 0,
				time: {
					start: 0,
					zero: !0,
					locked: !1,
					prev: 0,
					frameoffset: 0
				},
				score: 0,
				zenlevel: 1,
				zenprogress: 0,
				level: 0,
				combo: 0,
				currentcombopower: 0,
				topcombo: 0,
				btb: 0,
				topbtb: 0,
				tspins: 0,
				piecesplaced: 0,
				clears: {
					singles: 0,
					doubles: 0,
					triples: 0,
					quads: 0,
					realtspins: 0,
					minitspins: 0,
					minitspinsingles: 0,
					tspinsingles: 0,
					minitspindoubles: 0,
					tspindoubles: 0,
					tspintriples: 0,
					tspinquads: 0,
					allclear: 0
				},
				garbage: {
					sent: 0,
					received: 0,
					attack: 0,
					cleared: 0
				},
				kills: 0,
				finesse: {
					combo: 0,
					faults: 0,
					perfectpieces: 0
				}
			},
			E = {
				name: null,
				type: "sizzle"
			};
		let v, b, I, w, k, L, x, B, T, F, M = [],
			S = !1,
			C = [],
			R = 1,
			A = 0,
			$ = 0,
			O = 0,
			D = 0,
			N = [],
			P = [],
			U = [],
			z = null,
			q = !1,
			X = .25,
			K = !0,
			Y = !1,
			V = 0,
			Z = !0,
			J = !1,
			Q = 0,
			ee = !0,
			te = !0,
			ne = null,
			ae = !0,
			oe = [],
			se = !0,
			re = !0,
			le = !0,
			de = !0,
			ce = !0,
			me = {},
			ue = {},
			ge = {},
			pe = {},
			he = [],
			fe = [],
			_e = [],
			Ee = [],
			be = !0,
			Ie = 1,
			we = [],
			ke = 0,
			Le = 0,
			xe = 0,
			Be = 0,
			Te = 0,
			Fe = 0,
			Me = 0,
			Se = 0,
			Ce = 0,
			Re = 0,
			Ae = 0,
			$e = 0,
			Oe = 1,
			De = 0,
			He = 0,
			Ne = 1,
			Pe = 255,
			Ue = 255,
			ze = 255,
			je = 255,
			We = 255,
			Ge = 255,
			qe = 0,
			Xe = 0,
			Ke = 0,
			Ye = 0,
			Ve = 0,
			Ze = 0,
			Je = !0,
			tt = 0,
			nt = !1,
			at = !1,
			ot = !1,
			it = 0,
			st = 0,
			rt = 0,
			lt = 0,
			dt = 0,
			ut = "full";
		const gt = {
			sleep: !0,
			deep_sleep: !1,
			hibernated: !1,
			locking: 0,
			lockresets: 0,
			forcelock: !1,
			floored: !1,
			safelock: 0,
			x: 4,
			y: 14,
			r: 0,
			type: "i",
			highesty: 14,
			last: null,
			lastkick: 0,
			irs: 0,
			ihs: !1,
			aox: 0,
			aoy: 0,
			keys: 0
		};
		let pt = 0,
			ht = 0,
			_t = 0,
			Et = 0,
			vt = !1,
			bt = 0,
			It = 0,
			wt = !1,
			kt = 0,
			Lt = !1,
			xt = {};
		const Bt = {
			x: 0,
			y: 0,
			offence: 0,
			defense: 0
		};

		function Tt() {
			let e = "";
			for (let t = 0; t < 40; t++)
				for (let n = 0; n < 10; n++) {
					const a = P[t][n];
					e += null === a ? "_" : "gb" === a ? "#" : "gbd" === a ? "@" : a
				}
			return e += `?${g&&gt.type?gt.type:""}${U.slice(0,5).join("")}${z?`?${z}`:""}`
		}

		function Ft() {
			if (i()) return;
			if (h) return;
			po = 0, ho = 0, yo("impending", "tiny" !== ut && !!u.display_impending), yo("progress", "tiny" !== ut && !!u.display_progress);
			let t = 560;
			oo("timer", "full" === ut && (u.display_stopwatch || u.display_timer)), "full" === ut && (u.display_stopwatch || u.display_timer) && (ao("timer", t), t -= 80), oo("kills", "full" === ut && u.display_kills), "full" === ut && u.display_kills && (ao("kills", t), t -= 80), oo("attack", "full" === ut && u.display_attack), "full" === ut && u.display_attack && (ao("attack", t), t -= 80), oo("lines", "full" === ut && u.display_lines), "full" === ut && u.display_lines && (ao("lines", t), t -= 80), oo("pieces", "full" === ut && u.display_pieces), "full" === ut && u.display_pieces && (ao("pieces", t), t -= 80), oo("level", "full" === ut && u.display_level), "full" === ut && u.display_level && (ao("level", t), t -= 80), oo("finesse_l", "full" === ut && u.display_finesse_l && u.pro), "full" === ut && u.display_finesse_l && u.pro && (ao("finesse_l", t), t -= 80), oo("keys", "full" === ut && u.display_keys && u.pro), "full" === ut && u.display_keys && u.pro && (ao("keys", t), t -= 80), oo("placement", "full" === ut && u.display_placement), oo("score", "full" === ut && u.display_score), oo("finesse", "full" === ut && u.display_finesse && u.pro), oo("finesse_faults", "full" === ut && u.display_finesse && u.pro), oo("vs", "full" === ut && u.display_vs), "full" === ut && (oa.get(`${e}replaybg`).obj.visible = u.display_replay, oa.get(`${e}replayfg`).obj.visible = u.display_replay), "full" === ut && u.pro && (oa.get(`${e}backerfg`).obj.visible = u.pro && !u.display_replay), oa.get(`${e}usernamebg`).obj.visible = u.display_username && !("tiny" === ut && "low" === G.video.caching), oa.get(`${e}usernamefg`).obj.visible = u.display_username && !("tiny" === ut && "low" === G.video.caching), oa.get(`${e}firebg`).obj.visible = u.display_fire && u.display_username && !("tiny" === ut && "low" === G.video.caching), u.display_username && oa.get(`${e}usernamefg`).obj.text !== u.username.toUpperCase() && (oa.get(`${e}usernamefg`).obj.text = u.username.toUpperCase() || ""), oa.get(`${e}zenscorefg`).obj.visible = u.display_score_zen, oa.get(`${e}zenlevelfg`).obj.visible = u.display_level_zen, oa.get(`${e}zenlevelhierofg`).obj.visible = u.display_level_zen, oa.get(`${e}next`).obj.visible = void 0 === u.display_next || u.display_next, oa.get(`${e}hold`).obj.visible = void 0 === u.display_hold || u.display_hold, "tiny" !== ut && (oa.get(`${e}nextbg`).obj.visible = void 0 === u.display_next || u.display_next, oa.get(`${e}nextfg`).obj.visible = void 0 === u.display_next || u.display_next, oa.get(`${e}holdbg`).obj.visible = void 0 === u.display_hold || u.display_hold, oa.get(`${e}holdfg`).obj.visible = void 0 === u.display_hold || u.display_hold), "full" === ut && (oa.get(`${e}nexttext`).obj.visible = void 0 === u.display_next || u.display_next, oa.get(`${e}holdtext`).obj.visible = void 0 === u.display_hold || u.display_hold)
		}

		function St(n = !1) {
			if (!i() && !h && !f) {
				if (u.display_impending) {
					let e = 0;
					M.forEach(t => {
							e += t.lines
						}), co("impending", e),
						function (e, t) {
							if (!ue[e]) return;
							if (ue[e].tickertarget == t) return;
							ue[e].tickertarget = t
						}("impending", Math.floor(Math.min(u.garbagecapmax || 40, u.garbagecap)))
				}
				if (u.display_progress && (u.zenlevels ? (co("progress", _.zenprogress), mo("progress", 1)) : u.levels && !u.absolute_lines ? (co("progress", _.level_lines), mo("progress", _.level_lines_needed)) : "lines" === (u.objective || {
						type: "none"
					}).type && (co("progress", _.lines), mo("progress", u.objective.count))), "full" === ut) {
					if (u.display_lines && (u.levels && !u.absolute_lines ? no("lines", `${_.level_lines}${aa(`/${_.level_lines_needed}`)}`) : "lines" === (u.objective || {
							type: "none"
						}).type ? (no("lines", `${_.lines}${aa(`/${u.objective.count}`)}`), u.pro && oa.get(`${e}backerfg`).obj.text !== `${Math.max(0,u.objective.count-_.lines)}` && (oa.get(`${e}backerfg`).obj.text = `${Math.max(0,u.objective.count-_.lines)}`)) : no("lines", _.lines)), u.display_level) {
						let e = _.level;
						u.masterlevels && _.level > 20 && (e = `M${_.level-20}`), no("level", e)
					}
					if (!n && u.display_stopwatch && !_.time.locked) {
						let e = H(_.time.zero ? 0 : (t.getFrame() - _.time.frameoffset) / 60 * 1e3);
						parseInt(e.m) >= 60 && (e.m = `${Math.floor(parseInt(e.m)/60)}:${(parseInt(e.m)%60).toString().padStart(2,"0")}`), G.video.lowrescounters || "minimal" === G.video.graphics ? no("timer", `${e.m}:${e.s}`) : no("timer", `${e.m}:${e.s}${aa(`.${e.ms}`)}`)
					}
					if (!n && u.display_timer && !_.time.locked) {
						let e = H(Math.max(0, (u.objective.time || 0) - (_.time.zero ? 0 : (t.getFrame() - _.time.frameoffset) / 60 * 1e3)));
						G.video.lowrescounters || "minimal" === G.video.graphics ? no("timer", `${e.m}:${e.s}`) : no("timer", `${e.m}:${e.s}${aa(`.${e.ms}`)}`)
					}
					if (u.display_pieces && !_.time.locked) {
						const e = (t.getFrame() - _.time.frameoffset) / 60 || 1;
						G.video.lowrescounters || "minimal" === G.video.graphics ? no("pieces", `${_.piecesplaced}${aa(`,${(_.piecesplaced/e).toFixed(1)}/S`)}`) : no("pieces", `${_.piecesplaced}${aa(`,${(_.piecesplaced/e).toFixed(2)}/S`)}`)
					}
					if (u.display_score && no("score", _.score.toString()), u.display_score_zen) {
						const t = oa.get(`${e}zenscorefg`).obj;
						_.score.toLocaleString("en-US") !== t.text && (t.text = _.score.toLocaleString("en-US"))
					}
					if (u.display_level_zen) {
						const t = oa.get(`${e}zenlevelfg`).obj;
						_.zenlevel.toString() !== t.text && (t.text = _.zenlevel.toString());
						const n = oa.get(`${e}zenlevelhierofg`).obj,
							a = j(_.zenlevel);
						a !== n.text && (n.text = a)
					}
					if (u.display_kills && no("kills", _.kills), u.display_placement && no("placement", `${aa("#")}${R}`), u.display_attack && !_.time.locked) {
						const e = (t.getFrame() - _.time.frameoffset) / 3600 || 1;
						G.video.lowrescounters || "minimal" === G.video.graphics ? no("attack", `${_.garbage.attack}${aa(`,${Math.round(_.garbage.attack/e)}/M`)}`) : no("attack", `${_.garbage.attack}${aa(`,${(_.garbage.attack/e).toFixed(2)}/M`)}`)
					}
					if (u.display_keys && u.pro && no("keys", `${_.inputs}${aa(`,${(_.inputs/Math.max(1,_.piecesplaced)).toFixed(2)}/P`)}`), (u.display_finesse || u.display_finesse_l) && u.pro && (no("finesse", `${_.finesse.combo}${aa(`,${(_.finesse.perfectpieces/Math.max(1,_.piecesplaced)*100).toFixed(2)}%`)}`), function (e, t) {
							if (!me[e]) return;
							if (me[e].lbl.text == t.toString()) return;
							me[e].lbl.text = t.toString()
						}("finesse_faults", `${_.finesse.faults} fault${1===_.finesse.faults?"":"s"}`), no("finesse_l", `${_.finesse.combo}${aa(`,${(_.finesse.perfectpieces/Math.max(1,_.piecesplaced)*100).toFixed(2)}%,${_.finesse.faults}F`)}`)), u.display_vs) {
						const e = Math.max(1, (t.getFrame() - _.time.frameoffset) / 60),
							n = (_.garbage.attack + _.garbage.cleared) / Math.max(1, _.piecesplaced) * (_.piecesplaced / e) * 100;
						G.video.lowrescounters || "minimal" === G.video.graphics ? no("vs", `${Math.floor(n)}`) : no("vs", `${Math.floor(n)}${aa(`.${Math.floor(100*(n-Math.floor(n))).toString().padStart(2,"0")}`)}`)
					}
					"full" === ut && t.getFrame() % 60 == 0 && (Kn = !0)
				}
			}
		}

		function Rt(e) {
			if (u.display_stopwatch) {
				let t = H(e);
				G.video.lowrescounters || "minimal" === G.video.graphics ? no("timer", `${t.m}:${t.s}`) : no("timer", `${t.m}:${t.s}${aa(`.${t.ms}`)}`)
			}
			if (u.display_timer) {
				let e = H(0);
				G.video.lowrescounters || "minimal" === G.video.graphics ? no("timer", `${e.m}:${e.s}`) : no("timer", `${e.m}:${e.s}${aa(`.${e.ms}`)}`)
			}
		}
		let At = [],
			$t = 0,
			Ot = !0,
			Dt = 0,
			Nt = null,
			Pt = 0,
			Ut = 1 / 60,
			zt = Math.floor(60 + 60 * Math.random());

		function jt() {
			if (i()) return;
			if (b) return b = !1, void PIXI.Ticker.shared.remove(jt);
			if (!g) return;
			null === Nt && (Nt = Date.now());
			const e = Date.now();
			Dt += Math.min(5, (e - Nt) / 1e3);
			let t = -2;
			for (; Dt >= Ut;) {
				for (Dt -= Ut, t++, $t += c; $t >= 1;) $t--, Kt();
				Ot && (Ot = !1, Dt = 0)
			}
			Qe.addGameM(Math.max(0, t)), Qe.addGameF(Date.now() - e), Nt = e
		}

		function qt(e, n) {
			At.push({
				target: (t ? t.getFrame() : 0) + e,
				handler: n
			})
		}

		function Xt(e) {
			if (!i()) return "tiny" === ut ? Math.round(Ae * ("high" === G.video.graphics || "ultra" === G.video.graphics ? 100 : 1)) == Math.round(De * ("high" === G.video.graphics || "ultra" === G.video.graphics ? 100 : 1)) && Math.round($e * ("high" === G.video.graphics || "ultra" === G.video.graphics ? 100 : 1)) == Math.round(He * ("high" === G.video.graphics || "ultra" === G.video.graphics ? 100 : 1)) && Math.round(100 * Oe) == Math.round(100 * Ne) ? (Pt += e) >= zt && (Pt -= zt, "low" !== G.video.caching && (F.cacheAsBitmap = !1), Yt(), "low" !== G.video.caching && (F.cacheAsBitmap = !0)) : Cn(e) : Yt(e), I ? (I = !1, void PIXI.Ticker.shared.remove(Xt)) : void 0
		}

		function Kt() {
			if (!t.finished() && t.nextFrameReady()) {
				if (n = 0, t.pull(), t.frame(), xa(!1, 1 - n), ia(void 0, 1 - n), (i() || u.physical) && function () {
						if (Y && K) {
							const e = V++;
							let t = u.forfeit_time || 60;
							u.stride && (t /= 3), a(() => {
								document.getElementById("forfeit").style.height = `${1.5+e/20}em`, document.getElementById("forfeit").style.lineHeight = `${1.7+e/20}em`, document.getElementById("forfeit").style.boxShadow = `0px 0px ${8+e/3}px #F00`, document.getElementById("forfeit").style.filter = `brightness(${1+Math.max(0,(e-t+5)/5)})`, document.getElementById("forfeit").classList.remove("hidden")
							}), Ba = !1, e > t ? (qa("forfeit", !0), a(() => {
								yt.play("detonate2")
							})) : e % 20 == 0 && a(() => {
								yt.play("detonate1")
							})
						} else Ba || (a(() => {
							document.getElementById("forfeit").classList.add("hidden")
						}), Ba = !0);
						if (i()) return;
						if (J && Z && u.can_retry) {
							if (u.stride) return qa("retry", !0), void yt.play("detonate2");
							const e = Q++;
							document.getElementById("retry").style.height = `${1.5+e/20}em`, document.getElementById("retry").style.lineHeight = `${1.7+e/20}em`, document.getElementById("retry").style.boxShadow = `0px 0px ${8+e/3}px #FA0`, document.getElementById("retry").style.filter = `brightness(${1+Math.max(0,(e-15+5)/5)})`, document.getElementById("retry").classList.remove("hidden"), Ta = !1, e > 15 ? (u.retryisclear ? (Jt(), z = null, U = [], _.lines = 0, _.inputs = 0, _.time.frameoffset = t.getFrame(), _.piecesplaced = 0, _.garbage.sent = 0, _.garbage.attack = 0, _.garbage.cleared = 0, _.combo = 0, _.currentcombopower = 0, _.btb = 0, _.finesse.combo = 0, _.finesse.faults = 0, _.finesse.perfectpieces = 0, u.b2bchaining && (On("also_permanent", ""), On("also_permanent_up", "")), mn(), ua(), "keyboard" === t.type() && W.pulse(...W.CLEAR), a(() => {
								Ce += 50 * Ie, yt.playIngame("shatter", ut, De, Ne, !1, u.physical, m)
							}), J = !1, Q = 0) : qa("retry", !0), yt.play("detonate2")) : e % 5 == 0 && yt.play("detonate1")
						} else Ta || (document.getElementById("retry").classList.add("hidden"), Ta = !0)
					}(), function () {
						const e = t ? t.getFrame() : 0;
						for (let t = At.length - 1; t >= 0; t--) At[t].target === e && (At[t].handler(), At.splice(t, 1))
					}(), function () {
						if (!p || !u.objective) return;
						switch (u.objective.type) {
							case "lines":
								return void(_.lines >= u.objective.count && (y = !0, qa("clear"), !i() && u.display_progress && uo("progress", 600)));
							case "timed":
								let e = t.getFrame() * (1e3 / 60);
								const n = Math.ceil(Math.max(0, u.objective.time - e) / 1e3);
								i() || n === _.time.prev || _.time.locked || ("minimal" !== G.video.graphics && "off" !== G.video.actiontext && "some" !== G.video.actiontext && (60 === n && Pn("timeleft", `60${aa("S")} LEFT`), 30 === n && Pn("timeleft", `30${aa("S")} LEFT`)), n > 3 && n <= 10 ? (u.physical && yt.playIngame("timer1", ut, De, Ne, !1, u.physical, m), "minimal" !== G.video.graphics && "off" !== G.video.actiontext && "some" !== G.video.actiontext && Pn("countdown", n)) : n <= 3 && n > 0 && (u.physical && yt.playIngame("timer2", ut, De, Ne, !1, u.physical, m), "minimal" !== G.video.graphics && "off" !== G.video.actiontext && "some" !== G.video.actiontext && Pn("countdown", n))), _.time.prev = n, e >= u.objective.time && (y = !0, qa("clear"))
						}
					}(), function () {
						if (0 === st) return;
						0 === --st && (it = 0)
					}(), u.display_fire && (dt > 0 ? dt-- : rt = Math.max(0, rt - 5 / 60)), u.gincrease && t.getFrame() > (u.gmargin || 0) && (X += u.gincrease / 60), u.garbageincrease && t.getFrame() > (u.garbagemargin || 0) && (u.garbagemultiplier += u.garbageincrease / 60), u.garbagecapincrease && (u.garbagecap += u.garbagecapincrease / 60), u.noreplay || (l.frame(), l.getFrame() % 300 == 0 && l.pushEvent("full", eo())), Ka(), t.fallingBehind()) {
					const e = t.amountToCatchUp();
					(m = Math.max(0, m / 1.25)) <= 1e-6 && (m = 0), Kt(), m = 1, !i() && "tiny" !== ut && e > 90 && Mt("loss")
				}
				if (t.behindness() >= 1.25) {
					const e = Math.max(Math.floor(8 - (t.behindness() - 1.25)), 0) + 2;
					t.getFrame() % e == 0 && Kt()
				}
			}
		}

		function Yt(n) {
			i() || (ae && "tiny" !== ut && (Qt(), ae = !1, "full" === ut && (Kn = !0)), se && (nn(k), function () {
				if (i()) return;
				for (let e = 18; e < 40; e++)
					for (let t = 0; t < 10; t++) {
						const n = P[e][t];
						if (null !== n) {
							const a = new PIXI.Sprite(zn[s.colorMap[n]]);
							a.position.set(t * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0), (e - 20) * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0)), k.addChild(a)
						}
					}
			}(), se = !1, oe = [], "full" === ut && (Kn = !0)), oe.length && (! function () {
				if (i()) return;
				oe.forEach(e => {
					if (null !== e && !(e[0] < 18) && null !== e[2]) {
						const t = new PIXI.Sprite(zn[s.colorMap[e[2]]]);
						t.position.set(e[1] * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0), (e[0] - 20) * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0)), k.addChild(t)
					}
				})
			}(), oe = [], "full" === ut && (Kn = !0)), "minimal" === G.video.graphics || !1 === G.video.siren || u.nosiren || function (n) {
				if (i()) return;
				if (h) return;
				if (!Je) return;
				let a = rn(),
					o = 0;
				M.forEach(e => {
					o += e.lines
				}), ((a = Math.max(0, a - Math.min(Math.floor(Math.min(u.garbagecapmax || 40, u.garbagecap)), o))) > 19 || !o) && at && (qn.destroy(), at = !1);
				if (a > 22) return void(nt && (Pe = 255, Ue = 255, ze = 255, qe = 0, Xe = 0, Ke = 0, nt = !1, ae = !0, "full" === ut && (oa.get(`${e}skyline`).obj.visible = !1), t && "keyboard" === t.type() && (Ln.opacity(1), Ln.scale(1))));
				nt || (Pe = 255, Ue = 51, ze = 0, qe = 255, Xe = 255, Ke = 255, nt = !0, ae = !0, "full" === ut && (oa.get(`${e}skyline`).obj.visible = !0), t && "keyboard" === t.type() && (Ln.opacity(.5), Ln.scale(1.01)));
				if ("full" !== ut || 0 === m) return;
				!at && a <= 19 && o && ((qn = new PIXI.Sprite(Wn.alert)).position.set(mt(-3), mt(10 * da.x)), qn.pivot.set(mt(da.x), mt(da.x)), F.addChild(qn), at = !0, yt.playIngame("damage_alert", ut, De, u.physical ? Ne : Ne / 3, !1, u.physical, m), ra.animate(qn, {
					0: {
						"scale.x": 0,
						"scale.y": 0
					},
					.05: {
						"scale.x": 2,
						"scale.y": 2
					},
					.1: {
						"scale.x": 1,
						"scale.y": 1
					},
					.2: {
						"scale.x": 2,
						"scale.y": 2
					},
					.3: {
						"scale.x": 1,
						"scale.y": 1
					},
					.5: {
						"scale.x": 2,
						"scale.y": 2
					},
					1: {
						"scale.x": 1,
						"scale.y": 1
					}
				}, 5, BezierEasing(.03, .8, .5, .93)));
				if (oa.get(`${e}skyline`).obj.alpha = .5 * Math.random() + .25, oa.get(`${e}skyline`).obj.y = mt(1 * Math.random()), tt += n, 0 === Math.floor(tt / Math.max(50, 100 - 15 * (22 - a)))) return;
				tt -= Math.max(50, 100 - 15 * (22 - a)), yt.playIngame("warning", ut, De, u.physical ? Ne : Ne / 3, !1, u.physical, m);
				const s = Qn(k, 5 * mt(da.x), 11 * mt(da.x));
				gn(s.x, s.y, "#FF0000", "#FFFF00", Math.min(15, 23 - a), 10 * mt(da.x), 20 * mt(da.x), 1, 250, 290, 50, 200, 2, 1);
				const r = Qn(k, 2.5 * mt(da.x), 0);
				gn(r.x, r.y, "#FF0000", "#FF0000", Math.min(32, 50 - a), 5 * mt(da.x), 0, 1, -5, 5, mt(400), mt(100), .3, 0);
				const l = Qn(k, 7.5 * mt(da.x), 0);
				gn(l.x, l.y, "#FF0000", "#FF0000", Math.min(32, 50 - a), 5 * mt(da.x), 0, 1, 175, 185, mt(400), mt(100), .3, 0), kn.splash(270, .25, 26 - a, .1, 80, "#FF2200")
			}(n), re && "tiny" !== ut && (nn(L), function () {
				if (i()) return;
				if (gt.sleep || gt.deep_sleep) return;
				let e = gt.y;
				for (;;) {
					if (!on(gt.type, gt.x, e + 1, gt.r)) {
						!1 !== u.display_shadow && en(L, gt.type, gt.x, e, gt.r, !0);
						break
					}
					e++
				}
				Vt = e, en(L, gt.type, gt.x, gt.y, gt.r, !1, !1, !0), "full" === ut && !1 !== u.display_next && nt && en(L, U[0], 4 + s.additional_offsets[U[0]][s.spawn_rotation[U[0]]][0], 17.96 + s.additional_offsets[U[0]][s.spawn_rotation[U[0]]][1], s.spawn_rotation[U[0]], !0, !0)
			}(), re = !1, "full" === ut && (Kn = !0)), "tiny" !== ut && function () {
				if (i()) return;
				const e = L.alpha;
				if (gt.sleep || gt.deep_sleep) return void(L.alpha = 1);
				L.alpha = 1 - gt.locking / (u.locktime || 30) / 2, e !== L.alpha && "full" === ut && (Kn = !0)
			}(), "tiny" !== ut && St(!1), "minimal" === G.video.graphics || !1 === G.video.siren || u.nosiren || function (e) {
				if (!gt.deep_sleep && "full" === ut && nt) {
					if ((Vn += e) < 1) return;
					if (Vn--, function (e, t, n, a) {
							let o = dn(e, t, n, a);
							if (o.besty < 20) return !1;
							let i = 0;
							M.forEach(e => {
								i += e.lines
							});
							let r = Math.min(i, Math.floor(Math.min(u.garbagecapmax || 40, u.garbagecap))),
								l = dn(U[0], 4 + s.additional_offsets[U[0]][s.spawn_rotation[U[0]]][0], 17.96 + s.additional_offsets[U[0]][s.spawn_rotation[U[0]]][1] + r, s.spawn_rotation[U[0]]),
								d = !1;
							return o.shadowTiles.forEach(e => {
								l.shadowTiles.includes(e) && (d = !0)
							}), l.shadowTilesArr.forEach(e => {
								(e[0] >= 40 || null !== P[e[0]][e[1]]) && (d = !0)
							}), !d
						}(gt.type, gt.x, Vt, gt.r)) Xn && (t && "keyboard" === t.type() && (Ln.opacity(nt ? .5 : 1), Ln.scale(nt ? 1.01 : 1)), Xn = !1, Yn && yt.stop(Yn));
					else {
						const e = Qn(k, 0, 0);
						bn(e.x - mt(da.x / la) * po, e.y, "#FF7733", "#660000", 3, 1, 215, 235, 300, 50, .05), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y, "#FF7733", "#660000", 3, 1, 305, 325, 300, 50, .05), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y + mt(20 * da.x), "#FF7733", "#660000", 3, 1, 35, 55, 300, 50, .05), bn(e.x - mt(da.x / la) * po, e.y + mt(20 * da.x), "#FF7733", "#660000", 3, 1, 125, 145, 300, 50, .05), Xn || (t && "keyboard" === t.type() && (Ln.opacity(.25), Ln.scale(1.03)), Xn = !0, Yn = yt.playIngame("hyperalert", ut, De, u.physical ? Ne : Ne / 3, !1, u.physical, m))
					}
				}
			}(n), function () {
				if (i()) return;
				if (!ot && null !== Zn) return Zn.destroy(), void(Zn = null);
				ot && null === Zn && ((Zn = new PIXI.Sprite(Wn.targeted)).position.set(mt(5 * da.x), mt(10 * da.x)), Zn.pivot.set(mt(da.x), mt(da.x)), F.addChild(Zn), "tiny" !== ut ? ra.animate(Zn, {
					0: {
						"scale.x": 0,
						"scale.y": 0
					},
					.2: {
						"scale.x": 4,
						"scale.y": 4
					},
					1: {
						"scale.x": 3,
						"scale.y": 3
					}
				}, .3, BezierEasing(.03, .8, .5, .93)) : Zn.scale.set(4))
			}(), Cn(!1, n), function (e = 1) {
				if (i()) return;
				Object.keys(ue).forEach(n => {
					const a = ue[n];
					let o = a.target;
					if (a.blast > 0 && (o = a.target + 6 * a.max, a.blast--), o != a.count)
						if ("minimal" !== G.video.graphics && "tiny" !== ut && a.holder.visible) {
							let t = o + (a.count - o) * Math.pow(.9, e);
							Math.abs(t - o) / a.max < .01 && (t = o), ro(n, t)
						} else o !== a.count && ro(n, o);
					if (a.ticker && a.tickertarget != a.tickercount)
						if ("minimal" !== G.video.graphics && "tiny" !== ut && a.holder.visible) {
							let t = a.tickertarget + (a.tickercount - a.tickertarget) * Math.pow(.9, e);
							Math.abs(t - a.tickertarget) / a.max < .01 && (t = a.tickertarget), lo(n, t)
						} else a.tickertarget !== a.tickercount && lo(n, a.tickertarget);
					if (p && "ultra" === G.video.graphics && "full" === ut && a.count && a.content.children[0] && t.getFrame() % 5 == 0) {
						const e = Qn(a.content.children[0], mt(da.x / la) / 2, go(a.count, a.max) / 2);
						pn(e.x, e.y, a.sparkcolor || "#FF0000", 2, .5, .03, mt(da.x / la), go(a.count, a.max), .04, 265, 275, 0, 100, 0, .05, 0, .1);
						const t = Qn(a.content.children[0], mt(da.x / la) / 2, 0);
						pn(t.x, t.y + go(a.count, a.max) / 16, a.sparkcolor || "#FF0000", 2, .5, .03, mt(da.x / la), go(a.count, a.max) / 8, .06, 260, 280, 0, 125, 0, .05, 0, .1)
					}
					if (p && "ultra" === G.video.graphics && "full" === ut && a.count && a.content.children[0] && t.getFrame() % 12.5 == 0) {
						const e = Qn(a.content.children[0], mt(da.x / la) / 2, 0);
						gn(e.x, e.y, a.sparkcolor || "#FF0000", a.sparkcolor || "#FF0000", 2, mt(da.x / la), 0, 1, 265, 275, 250, 25, .05, 2.25, .25)
					}
				})
			}(n), u.display_fire && function (t = 1) {
				if (i()) return;
				rt !== lt && ("minimal" === G.video.graphics || "tiny" === ut ? lt = rt : (lt = rt + (lt - rt) * Math.pow(.9, t), Math.abs(lt - rt) < .01 && (lt = rt)));
				if ("minimal" === G.video.graphics || !1 === G.video.fire || "high" === G.video.caching) return;
				const n = oa.get(`${e}firebg`);
				if (!n) return;
				if (lt >= 500 && p)
					if ("tiny" === ut) {
						const e = Qn(F, mt(5 * da.x), mt(21 * da.x));
						pn(e.x, e.y, "#FF6600", 2.5, mt(6 * Ne), .06, mt(8 * da.x * Ne), mt(4 * da.x * Ne), .1, 210, 330, 0, mt(500 * Ne), 0, zt / 60, mt(-1.5), .1, !1, !0), yn(e.x, e.y, "#FF6600", 2.5, mt(6 * Ne), .06, mt(8 * da.x * Ne), mt(4 * da.x * Ne), .1, 210, 330, 0, mt(500 * Ne), 0, zt / 60, mt(-1.5), .1, !1, !0)
					} else {
						const e = Qn(n.obj, mt(5 * da.x), 0);
						pn(e.x, e.y, "#FF6600", 2.5, mt(6 * Ne), .06, mt(8 * da.x * Ne), mt(4 * da.x * Ne), "full" === ut ? .035 : .08, 210, 330, 0, mt(500 * Ne), 0, .05, mt(-1.5), .1, !1, !0), yn(e.x, e.y, "#FF6600", 2.5, mt(6 * Ne), .06, mt(8 * da.x * Ne), mt(4 * da.x * Ne), "full" === ut ? .035 : .08, 210, 330, 0, mt(500 * Ne), 0, .05, mt(-1.5), .1, !1, !0), "full" === ut && "ultra" === G.video.graphics && hn(e.x, e.y, "#FFAA00", 2, mt(.125 * Ne), .06, mt(9 * da.x * Ne), mt(4 * da.x * Ne), .6, 230, 300, 0, mt(500 * Ne), 0, .05, mt(-2.5), .1, !1, !0)
					} if ("tiny" === ut) return n.obj.alpha = lt >= 500 ? .2 + Math.min(.7, (lt - 500) / 20) : 0, void(n.obj.scale.x = 1);
				n.obj.alpha = lt >= 500 ? .2 + Math.min(.7, (lt - 500) / 20) : .1 + lt / 3500, n.obj.scale.x = lt >= 500 ? 1 + (lt - 500) / 1500 : lt / 500
			}(n), le && "tiny" !== ut && (! function () {
				if (i()) return;
				nn(x);
				for (let e = 0; e < u.nextcount; e++) {
					const t = fa.tetrominoes[U[e]];
					tn(x, U[e], (mt(5 * da.x) - t.preview.w * mt(da.x)) / 2, e * mt(3 * da.x) + (mt(3 * da.x) - t.preview.h * mt(da.x)) / 2, !1)
				}
			}(), le = !1, "full" === ut && (Kn = !0)), de && "tiny" !== ut && (! function () {
				if (i()) return;
				if (nn(B), null === z) return;
				const e = fa.tetrominoes[z];
				tn(B, z, (mt(5 * da.x) - e.preview.w * mt(da.x)) / 2, (mt(3 * da.x) - e.preview.h * mt(da.x)) / 2, q)
			}(), de = !1, "full" === ut && (Kn = !0)), ce && "tiny" !== ut && (! function () {
				if (i()) return;
				nn(T);
				for (let e = 0; e < O; e++) {
					let t = new PIXI.Sprite(Wn.stock);
					t.position.set(mt(e * da.x + da.x / 2), mt(da.x / 2)), t.pivot.set(mt(da.x), mt(da.x)), T.addChild(t)
				}
				T.position.set(mt(da.x / 2) * (10 - O), mt(20 * da.x + (u.display_username ? 36 : 10)))
			}(), ce = !1, "full" === ut && (Kn = !0)), !Wa || "full" !== ut || "high" !== G.video.graphics && "ultra" !== G.video.graphics || u.infinitestock || function (e) {
				if (i()) return;
				if ("full" === ut) {
					if (!T.children.length) return;
					if ((Zt += e) < 1) return;
					Zt--;
					const n = Qn(T.children[T.children.length - 1], mt(30), mt(30));
					bn(n.x, n.y, "#FFFFFF", "#884400", 2, 1, 0 + 8 * t.getFrame(), 5 + 8 * t.getFrame(), 300, 100, .05), bn(n.x, n.y, "#FFFFFF", "#884400", 2, 1, 180 + 8 * t.getFrame(), 185 + 8 * t.getFrame(), 300, 100, .05)
				}
			}(n))
		}
		let Vt = 35;
		let Zt = 0;

		function Jt() {
			M = [];
			for (let e = 0; e < 40; e++)
				for (let t = 0; t < 10; t++) null !== P[e][t] && (a(() => {
					if ("full" === ut && ("high" === G.video.graphics || "ultra" === G.video.graphics)) {
						const n = Qn(k, t * mt(da.x) + mt(da.x / 2), (e - 20) * mt(da.x) + mt(da.x / 2));
						gn(n.x, n.y, "#FFFFFF", "#FF8844", 10, mt(3), mt(3))
					}
				}), P[e][t] = null);
			a(() => {
				se = !0
			})
		}

		function Qt() {
			if (i()) return;
			if ("tiny" === ut) return;
			"high" === G.video.caching && (w.cacheAsBitmap = !1), nn(w);
			const e = void 0 === G.video.gridopacity ? .1 : G.video.gridopacity;
			for (let t = 1; t < 10; t++) {
				const n = new PIXI.Graphics;
				n.lineStyle(1, nt ? 16724736 : 16777215, nt ? e : e / 4), n.moveTo(0, 0), n.lineTo(0, mt(20 * da.x)), n.position.set(mt(da.x * t), 0), w.addChild(n)
			}
			for (let t = 0; t < 20; t++) {
				const n = new PIXI.Graphics;
				n.lineStyle(1, nt ? 16724736 : 16777215, nt ? e : e / 4), n.moveTo(0, 0), n.lineTo(mt(10 * da.x), 0), n.position.set(0, mt(da.x * t)), w.addChild(n)
			}
			"high" === G.video.caching && (w.cacheAsBitmap = !0)
		}

		function en(e, t, n, a, o, r = !1, l = !1, d = !1) {
			if (!i())
				for (let i = 0; i < fa.tetrominoes[t].matrix.data[o].length; i++) {
					if (0 === fa.tetrominoes[t].matrix.data[o][i]) continue;
					const c = i % fa.tetrominoes[t].matrix.w - fa.tetrominoes[t].matrix.dx,
						m = Math.floor(i / fa.tetrominoes[t].matrix.w) - fa.tetrominoes[t].matrix.dy,
						u = new PIXI.Sprite((d ? jn : zn)[r ? l ? "x" : "g" : s.colorMap[t]]);
					u.position.set((n + c) * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0), (Math.ceil(a) + m - 20) * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0)), r && !l && (u.alpha = void 0 === G.video.shadowopacity ? .15 : G.video.shadowopacity, G.video.colorshadow && (u.tint = fa.intColors[s.colorMap[t]])), e.addChild(u)
				}
		}

		function tn(e, t, n, a, o = !1) {
			if (i()) return;
			let r = fa.tetrominoes[t].preview.data;
			s.preview_overrides[t] && (r = s.preview_overrides[t]);
			for (let i = 0; i < r.length; i++) {
				if (0 === r[i]) continue;
				const l = i % fa.tetrominoes[t].preview.w,
					d = Math.floor(i / fa.tetrominoes[t].preview.w),
					c = new PIXI.Sprite(zn[o ? "d" : s.colorMap[t]]);
				c.position.set(n + l * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0), a + d * mt(da.x) - ("ultra" === G.video.graphics ? 1 : 0)), e.addChild(c)
			}
		}

		function nn(e) {
			for (; e.children.length;) {
				e.children[0].destroy()
			}
		}
		let an = [];

		function on(e, t, n, a) {
			const o = 10 + 20 * Math.ceil(n) + t;
			if (an[o]) {
				const e = an[o] >> 2 * a & 3;
				if (1 === e) return !0;
				if (2 === e) return !1
			}
			if (!fa.tetrominoes[e]) return !1;
			let i = !0;
			for (let o = 0; o < fa.tetrominoes[e].matrix.data[a].length; o++) {
				if (0 === fa.tetrominoes[e].matrix.data[a][o]) continue;
				if (sn(t + (o % fa.tetrominoes[e].matrix.w - fa.tetrominoes[e].matrix.dx), n + (Math.floor(o / fa.tetrominoes[e].matrix.w) - fa.tetrominoes[e].matrix.dy))) {
					i = !1;
					break
				}
			}
			an[o];
			const s = i ? 1 : 2;
			return an[o] |= s << 2 * a, i
		}

		function sn(e, t) {
			return e < 0 || e > 9 || (t <= -1 || t > 39 || (void 0 === P[Math.ceil(t)] || null !== P[Math.ceil(t)][e]))
		}

		function rn() {
			for (let e = 0; e < 40; e++)
				if (P[e].some(e => null !== e)) return e;
			return 40
		}

		function ln() {
			return function (e, t, n, o) {
				let i = 0;
				for (let s = 0; s < fa.tetrominoes[e].matrix.data[o].length; s++) {
					if (0 === fa.tetrominoes[e].matrix.data[o][s]) continue;
					const r = s % fa.tetrominoes[e].matrix.w - fa.tetrominoes[e].matrix.dx,
						l = Math.floor(s / fa.tetrominoes[e].matrix.w) - fa.tetrominoes[e].matrix.dy;
					i = Math.max(Math.ceil(n) + l, i), P[Math.ceil(n) + l][t + r] = e, a(() => {
						oe.push([Math.ceil(n) + l, t + r, e])
					})
				}
				if (i < 20) return !0;
				return !1
			}(gt.type, gt.x, gt.y, gt.r)
		}

		function dn(e, t, n, a) {
			let o = 0,
				i = [],
				s = [];
			for (let r = 0; r < fa.tetrominoes[e].matrix.data[a].length; r++) {
				if (0 === fa.tetrominoes[e].matrix.data[a][r]) continue;
				const l = r % fa.tetrominoes[e].matrix.w - fa.tetrominoes[e].matrix.dx,
					d = Math.floor(r / fa.tetrominoes[e].matrix.w) - fa.tetrominoes[e].matrix.dy;
				o = Math.max(Math.ceil(n) + d, o), i.push(`${Math.ceil(n)+d}x${t+l}`), s.push([Math.ceil(n) + d, t + l])
			}
			return {
				besty: o,
				shadowTiles: i,
				shadowTilesArr: s
			}
		}
		let cn = null;

		function mn() {
			let e = [];
			switch (u.bagtype) {
				case "total mayhem":
					for (let t = 0; t < 7; t++) e.push(fa.minotypes[Math.floor(v.nextFloat() * fa.minotypes.length)]);
					break;
				case "classic":
					for (let t = 0; t < 7; t++) {
						let t = Math.floor(v.nextFloat() * (fa.minotypes.length + 1));
						(t === cn || t >= fa.minotypes.length) && (t = Math.floor(v.nextFloat() * fa.minotypes.length)), cn = t, e.push(fa.minotypes[t])
					}
					break;
				case "pairs":
					const t = [...fa.minotypes];
					v.shuffleArray(t), e = [t[0], t[0], t[0], t[1], t[1], t[1]], v.shuffleArray(e);
					break;
				case "14-bag":
					e = [...fa.minotypes, ...fa.minotypes], v.shuffleArray(e);
					break;
				case "7-bag":
				default:
					e = [...fa.minotypes], v.shuffleArray(e)
			}
			U.push(...e)
			window.bagArray = e;
		}
		let vn = null,
			In = null,
			wn = null,
			Bn = null;

		function Tn(e, t, n, a, o) {
			F && !F._destroyed && (n = n / 360 * 2 * Math.PI, (e !== vn || o) && (vn = e, F.x = mt(800) + e), (t !== In || o) && (In = t, F.y = mt(400) + t), (n !== wn || o) && (wn = n, F.rotation = n), (a !== Bn || o) && (Bn = a, F.scale.set(a)))
		}

		function Sn(e, t, n) {
			return e << 16 | t << 8 | n
		}

		function Cn(e = !1, n = 1) {
			if (i()) return;
			if (we.push(n), we.length > 10 && we.shift(), Ie = we.reduce((e, t) => e + t) / we.length, !be) return;
			if ("minimal" === G.video.graphics) {
				const t = 400 * (He = $e),
					n = Ne = Oe;
				return void Tn(mt(800 * (De = Ae)), mt(t), 0, n, e)
			}
			if ("tiny" === ut) {
				De = Ae + (De - Ae) * Math.pow(.9, n), He = $e + (He - $e) * Math.pow(.9, n), Ne = Oe + (Ne - Oe) * Math.pow(.9, n), Math.abs(De - Ae) < ("low" !== G.video.graphics && "minimal" !== G.video.graphics ? .01 : 1) && (De = Ae), Math.abs(He - $e) < ("low" !== G.video.graphics && "minimal" !== G.video.graphics ? .01 : 1) && (He = $e), Math.abs(Ne - Oe) < .01 && (Ne = Oe);
				const t = 400 * He,
					a = Ne;
				if (Tn(mt(800 * De), mt(t), 0, a, e), "high" !== G.video.caching) {
					const e = Sn(Math.round(je), Math.round(We), Math.round(Ge)),
						t = Sn(Math.round(Ye), Math.round(Ve), Math.round(Ze));
					he.forEach(t => {
						t.destroyed || t.tint != e && (t.tint = e)
					}), fe.forEach(t => {
						t.destroyed || t.style.fill != e && (t.style.fill = e)
					}), _e.forEach(e => {
						e.destroyed || e.style.fill != t && (e.style.fill = t)
					});
					const n = u.display_fire && rt >= 500 ? t : e;
					Ee.forEach(e => {
						e.destroyed || e.style.fill != n && (e.style.fill = n)
					})
				}
				return Fe = 0, Me = 0, Se = 0, Ce = 0, Re = 0, je = Pe, We = Ue, Ge = ze, Ye = qe, Ve = Xe, void(Ze = Ke)
			}
			let a = Math.pow(.55 + .2 * G.video.bounciness, n),
				o = Math.pow(.82 + .08 * G.video.bounciness, n),
				s = Math.pow(.55 + .2 * G.video.shakiness, n),
				r = Math.pow(.35 + .5 * G.video.shakiness, n);
			ke *= a, Le *= a, xe *= o, Be *= s, Te *= r, ke += Fe, Le += Me, xe += Se, Be += Ce, Te += Re, Fe *= a, Me *= a, Se *= o, Ce *= s, Re *= r;
			let l = Math.random() * Be - Be / 2 + Math.sin((t ? t.getFrame() : 0) / 1.5 * Math.max(1, (Te + 120) / 150)) * Math.min(30, Te),
				d = Math.random() * Be - Be / 2;
			0 != G.video.bounciness && 0 !== m || (ke = 0, Le = 0, xe = 0, Be = 0), 0 != G.video.shakiness && 0 !== m || (l = 0, d = 0), !1 !== G.video.spin && 0 !== m || (xe = 0), De = Ae + (De - Ae) * Math.pow(.9, n), He = $e + (He - $e) * Math.pow(.9, n), Ne = Oe + (Ne - Oe) * Math.pow(.9, n);
			const c = 400 * He,
				g = Ne;
			if (Tn(mt(800 * De) + Math.round(mt(ke + l) * Ne), mt(c) + Math.round(mt(Le + d) * Ne), xe, g, e), je = Pe + (je - Pe) * Math.pow(.9, n), We = Ue + (We - Ue) * Math.pow(.9, n), Ge = ze + (Ge - ze) * Math.pow(.9, n), Ye = qe + (Ye - qe) * Math.pow(.9, n), Ve = Xe + (Ve - Xe) * Math.pow(.9, n), Ze = Ke + (Ze - Ke) * Math.pow(.9, n), "high" !== G.video.caching) {
				const e = Sn(Math.round(je), Math.round(We), Math.round(Ge)),
					t = Sn(Math.round(Ye), Math.round(Ve), Math.round(Ze));
				he.forEach(t => {
					t.destroyed || (t.tint = e)
				}), fe.forEach(t => {
					t.destroyed || (t.style.fill = e)
				}), _e.forEach(e => {
					e.destroyed || (e.style.fill = t)
				});
				const n = u.display_fire && rt >= 500 ? t : e;
				Ee.forEach(e => {
					e.destroyed || (e.style.fill = n)
				})
			}
		}
		const Rn = {};

		function On(e, t) {
			if (i()) return;
			if ("off" === G.video.actiontext) return;
			if ("minimal" === G.video.graphics) return;
			const n = fa.splashStyles[e];
			if (n.persistent && (Rn[e] = t), "full" === ut) {
				if ("tspin" === e && (n.color = fa.intColors[s.colorMap[gt.type]], n.strColor = fa.colors[s.colorMap[gt.type]]), ge[e] && (ge[e].obj.destroy(), ra.stop(ge[e].animation), ge[e] = void 0), "" !== t) {
					const a = new PIXI.TheoryType(t.toString(), {
						fontSize: mt(n.size),
						wordWrapWidth: 32e3 / n.size,
						lineHeight: mt(n.size),
						fontWeight: .4,
						fill: n.color,
						letterSpacing: 0,
						align: "right",
						fontURL: "res/font/hun.fnt",
						imageURL: "res/font/hun.png"
					});
					if (a.position.set(mt(-630 - (u.display_impending ? da.x / la : 0)), mt(n.y)), F.addChild(a), animid = ra.animate(a, n.animation, n.animationDuration, n.animationEasing), ge[e] = {
							obj: a,
							animation: animid
						}, "ultra" === G.video.graphics && n.ultra) {
						const e = Qn(k, mt(u.display_impending ? da.x / -la : 0), mt(n.y));
						n.ultra(e.x, e.y, n)
					}
				}
				return ge[e]
			}
		}
		let Dn = 0;

		function Pn(e, t, n, a) {
			if (i()) return;
			if ("full" !== ut) return;
			const o = fa.shoutStyles[e],
				s = ++Dn;
			let r;
			o.hasShadow && "minimal" !== G.video.graphics && ((r = new PIXI.TheoryType(t.toString(), {
				fontSize: mt(o.size),
				wordWrapWidth: 32e3 / o.size,
				lineHeight: mt(o.size),
				fontWeight: .3,
				fill: o.shadowColor,
				letterSpacing: 0,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			})).alpha = .8, r.blendMode = PIXI.BLEND_MODES.SCREEN, r.pivot.set(mt(315), mt(o.size / 2)), void 0 !== n && void 0 !== a ? r.position.set(mt(da.x * (.75 + n)), mt(da.x * (3.5 + a))) : r.position.set(mt(5.25 * da.x), mt(13 * da.x + o.y)), F.addChild(r));
			const l = new PIXI.TheoryType(t.toString(), {
				fontSize: mt(o.size),
				wordWrapWidth: 32e3 / o.size,
				lineHeight: mt(o.size),
				fontWeight: .3,
				fill: o.color,
				letterSpacing: 0,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			let d, c;
			return l.blendMode = PIXI.BLEND_MODES.SCREEN, l.pivot.set(mt(315), mt(o.size / 2)), void 0 !== n && void 0 !== a ? l.position.set(mt(da.x * (.75 + n)), mt(da.x * (3.5 + a))) : l.position.set(mt(5.25 * da.x), mt(13 * da.x + o.y)), F.addChild(l), "ultra" === G.video.graphics && o.ultra && setTimeout(() => {
				const e = Qn(F, mt(void 0 === n ? 5.25 * da.x : da.x * (.75 + n)), mt(void 0 === a ? 13 * da.x + o.y : da.x * (3.5 + a)));
				o.ultra(e.x, e.y, o)
			}, 10), "minimal" !== G.video.graphics ? d = ra.animate(l, o.animation, o.animationDuration, o.animationEasing, () => {
				l.destroy()
			}) : setTimeout(() => {
				l.destroy()
			}, 1e3 * (o.flatAnimationDuration || 0) || 1e3 * o.animationDuration), o.hasShadow && "minimal" !== G.video.graphics && (c = ra.animate(r, o.animationShadow, o.animationShadowDuration, o.animationShadowEasing, () => {
				r.destroy()
			})), pe[s] = {
				obj: l,
				animation: "minimal" !== G.video.graphics ? d : null,
				shadowObj: o.hasShadow && "minimal" !== G.video.graphics ? r : null,
				shadowAnimation: o.hasShadow && "minimal" !== G.video.graphics ? c : null
			}, pe[s]
		}

		function Un(e, t, n) {
			if (i()) return;
			if ("full" !== ut) return;
			if (!u.physical && !n) return;
			const a = document.createElement("div");
			a.className = `ns shout ${e}`, a.textContent = t, document.getElementsByClassName("globalshouts")[0].appendChild(a), setTimeout(() => {
				a.remove()
			}, 5e3), "ultra" === G.video.graphics && Hn && fa.globalShoutStyles[e] && fa.globalShoutStyles[e]()
		}
		let qn = null;
		let Xn = !1,
			Yn = null,
			Vn = 0;
		let Zn = null;

		function Jn() {
			i() || (F && !F._destroyed && F.destroy(), h = !0, oa.unregisterStartingWith(e), I = !0, b = !0, Ia = Ia.filter(t => t.IID !== e), t.unhook(), t && "keyboard" === t.type() && (Ln.opacity(1), Ln.scale(1)), vo())
		}

		function ta(e = 0) {
			if ("none" === u.spinbonuses) return !1;
			if ("stupid" === u.spinbonuses) return !on(gt.type, gt.x, gt.y + 1, gt.r) && "normal";
			if ("t" !== gt.type) return "all" === u.spinbonuses && (!(on(gt.type, gt.x - 1, gt.y, gt.r) || on(gt.type, gt.x + 1, gt.y, gt.r) || on(gt.type, gt.x, gt.y - 1, gt.r) || on(gt.type, gt.x, gt.y + 1, gt.r)) && "normal");
			if ("rotate" !== gt.last) return !1;
			let t = 0,
				n = 0;
			if (sn(gt.x - 1, gt.y - 1) && (t++, 3 !== gt.r && 0 !== gt.r || n++), sn(gt.x + 1, gt.y - 1) && (t++, 0 !== gt.r && 1 !== gt.r || n++), sn(gt.x + 1, gt.y + 1) && (t++, 1 !== gt.r && 2 !== gt.r || n++), sn(gt.x - 1, gt.y + 1) && (t++, 2 !== gt.r && 3 !== gt.r || n++), t < 3) return !1;
			let a = "normal";
			return 2 !== n && (a = "mini"), 4 === gt.lastkick && (a = "normal"), a
		}

		function na(e, t) {
			if (u.usezenconfig && "off" === ve.leveling) return 0;
			return e / (1e4 + 1e4 * (Math.log2(t + 1) - 1))
		}

		function ia(e, n = 1) {
			if (gt.safelock > 0 && gt.safelock--, gt.sleep || gt.deep_sleep) return;
			let o = X * n;
			Lt && (xt.sdf == (u.version >= 15 ? 41 : 21) ? o = (u.version >= 15 ? 400 : 20) * n : (o *= xt.sdf, o = Math.max(o, u.version >= 13 ? .05 * xt.sdf : .42))), void 0 !== e && (o = e, a(() => {
				"keyboard" === t.type() && W.pulse(...W.HARDDROP), yt.playIngame("harddrop", ut, De, Ne, !1, u.physical, m)
			})), !u.infinitemovement && gt.lockresets >= (u.lockresets || 15) && !on(gt.type, gt.x, gt.y + 1, gt.r) && (o = 20, gt.forcelock = !0), !u.infinitemovement && pt > (u.lockresets || 15) + 15 && (o += .5 * n * (pt - ((u.lockresets || 15) + 15)));
			let i = o;
			for (; o > 0;) {
				const t = Math.ceil(gt.y);
				if (!sa(Math.min(1, o), i)) {
					void 0 !== e && (gt.forcelock = !0), ca(void 0 !== e, n);
					break
				}
				o -= Math.min(1, o), t !== Math.ceil(gt.y) && (gt.last = "fall", Lt && (_.score += fa.scoring.SOFTDROP, u.zenlevels && (_.zenprogress += na(fa.scoring.SOFTDROP, _.zenlevel)), a(() => {
					yt.playIngame("softdrop", ut, De, Ne, !1, u.physical, m)
				})))
			}
		}

		function sa(e, t) {
			let n = Math.floor(1e13 * gt.y) / 1e13 + e;
			n % 1 == 0 && (n += 1e-5);
			let o = Math.floor(1e13 * gt.y) / 1e13 + 1;
			if (o % 1 == 0 && (o -= 2e-5), !on(gt.type, gt.x, o, gt.r)) return !1;
			if (on(gt.type, gt.x, n, gt.r)) {
				const e = gt.highesty,
					o = gt.y;
				return gt.y = n, gt.highesty = Math.ceil(Math.max(gt.highesty, n)), gt.floored = !1, Math.ceil(n) !== Math.ceil(o) && (re = !0), (n > e || u.infinitemovement) && (gt.lockresets = 0, pt = 0), t >= Number.MAX_SAFE_INTEGER && (_.score += fa.scoring.HARDDROP, u.zenlevels && (_.zenprogress += na(fa.scoring.HARDDROP, _.zenlevel)), a(() => {
					"full" === ut && Ja(L, gt.type, gt.x, gt.y, gt.r, 1, mt(da.x), mt(da.x), .3, 260, 280, 400, 50)
				})), !0
			}
			return t >= Number.MAX_SAFE_INTEGER && a(() => {
				Me += 4 * Ie, "full" === ut && 0 !== m && (kn.splash(270, .05, 1, .1, 40, "#FFFFFF"), Ja(L, gt.type, gt.x, gt.y, gt.r, 15, mt(da.x), mt(da.x), .5, 200, 340, 400, 50))
			}), !1
		}

		function ca(e = !1, t = 1) {
			gt.locking += u.version >= 15 ? t : 1, gt.floored || (gt.floored = !0, a(() => {
				yt.playIngame("hit", ut, De, Ne, !1, u.physical, m)
			})), (gt.locking > (u.locktime || 30) || gt.forcelock) && ma(e), gt.lockresets > (u.lockresets || 15) && !u.infinitemovement && ma(e)
		}

		function ma(e = !1) {
			gt.sleep = !0;
			const n = ln();
			_.piecesplaced++, !e && xt.safelock && (gt.safelock = 7), a(() => {
				yt.playIngame("floor", ut, De, Ne, !1, u.physical, m),
					function (e, t, n, a, o) {
						if (i()) return;
						if ("full" !== ut) return;
						if ("low" === G.video.graphics || "minimal" === G.video.graphics || 0 === m) return;
						for (let i = 0; i < fa.tetrominoes[t].matrix.data[o].length; i++) {
							if (0 === fa.tetrominoes[t].matrix.data[o][i]) continue;
							const s = i % fa.tetrominoes[t].matrix.w - fa.tetrominoes[t].matrix.dx,
								r = Math.floor(i / fa.tetrominoes[t].matrix.w) - fa.tetrominoes[t].matrix.dy,
								l = Qn(e, (n + s) * mt(da.x) + mt(da.x / 2), (Math.ceil(a) + r - 20) * mt(da.x) + mt(da.x / 2));
							_n(l.x, l.y, Ne, xe), En(l.x, l.y, Ne, xe)
						}
					}(L, gt.type, gt.x, gt.y, gt.r), Me += 2 * Ie
			});
			const o = function () {
					let e = [];
					for (let t = 0; t < 40; t++) P[t].every(e => null !== e && "gbd" !== e) && e.push(t);
					Bt.x = gt.x, Bt.y = e.length ? e[0] - 22 : gt.y - 22, Bt.offence = 0, Bt.defense = 0;
					let n = ta(e.length);
					"t" === gt.type && "stupid" !== u.spinbonuses || (n = gt.spintype);
					(function (e) {
						for (let t = 0; t < e.length; t++) P[e[t]].some(e => "gb" === e || "gbd" === e) && _.garbage.cleared++
					})(e), e.length && function (e) {
						let t = [...P];
						e.sort((function (e, t) {
							return t - e
						}));
						for (let n = 0; n < e.length; n++) t.splice(e[n], 1), a(() => {
							Za(e[n])
						});
						for (; t.length < 40;) {
							let e = [];
							for (let t = 0; t < 10; t++) e.push(null);
							t.unshift(e)
						}
						P = t, se = !0
					}(e);
					return function (e, n) {
							let o = !1;
							_.lines += e, u.levels && Aa(e);
							e ? (_.combo++, _.topcombo = Math.max(_.combo, _.topcombo), !i() && _.combo > 1 && On("combo", `${_.combo-1} ${aa("COMBO")}`), 4 === e ? (o = !0, a(() => {
								_.btb ? ("keyboard" === t.type() && W.pulse(...W.CLEARB2B), yt.playIngame("clearbtb", ut, De, Ne, !0, u.physical, m)) : ("keyboard" === t.type() && W.pulse(...W.CLEARQUAD), yt.playIngame("clearquad", ut, De, Ne, !0, u.physical, m))
							})) : n ? (o = !0, a(() => {
								"keyboard" === t.type() && W.pulse(...W.CLEARSPIN), yt.playIngame("clearspin", ut, De, Ne, !0, u.physical, m)
							})) : a(() => {
								"keyboard" === t.type() && W.pulse(...W.CLEARLINE), yt.playIngame("clearline", ut, De, Ne, !0, u.physical, m)
							}), Me += 8 * e * Ie, (e > 1 || 1 === e && n) && a(() => {
								On("clear", ya.cleartypes[e])
							}), o ? (_.btb++, _.topbtb = Math.max(_.btb, _.topbtb), a(() => {
								"full" === ut && 0 !== m && kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FFFFFF"), _.btb > 1 && (u.b2bchaining || On("also", `${ya.extra.btb}${_.btb>2?` ${aa("X")}${_.btb-1}`:""}`))
							})) : (!i() && u.b2bchaining && _.btb > 2 ? (On("also_failed", `B2B ${aa("X")}0`), On("also_permanent", ""), On("also_permanent_up", "")) : !i() && u.b2bchaining && (On("also_permanent", ""), On("also_permanent_up", "")), _.btb = 0, !i() && u.b2bchaining && $ >= 2 && yt.playIngame("btb_break", ut, De, Ne, !1, u.physical, m))) : (!i() && _.combo > 3 && yt.playIngame("combobreak", ut, De, Ne, !1, u.physical, m), _.combo = 0, _.currentcombopower = 0);
							n && (a(() => {
								yt.playIngame("spinend", ut, De, Ne, !1, u.physical, m), "full" === ut && 0 !== m && (On("tspin", ya.tspins[n].replace("%%PIECE%%", gt.type.toUpperCase())), kn.splash(0, .05, 2, .1, 80, "#FFFFFF"), kn.splash(180, .05, 2, .1, 80, "#FFFFFF"))
							}), _.tspins++);
							let s = 0,
								r = 0;
							switch (e) {
								case 0:
									"mini" === n ? (s = fa.scoring.TSPIN_MINI, r = fa.garbage.TSPIN_MINI, _.clears.minitspins++) : "normal" === n && (s = fa.scoring.TSPIN, r = fa.garbage.TSPIN, _.clears.realtspins++);
									break;
								case 1:
									"mini" === n ? (s = fa.scoring.TSPIN_MINI_SINGLE, r = fa.garbage.TSPIN_MINI_SINGLE, _.clears.minitspinsingles++) : "normal" === n ? (s = fa.scoring.TSPIN_SINGLE, r = fa.garbage.TSPIN_SINGLE, _.clears.tspinsingles++) : (s = fa.scoring.SINGLE, r = fa.garbage.SINGLE, _.clears.singles++);
									break;
								case 2:
									"mini" === n ? (s = fa.scoring.TSPIN_MINI_DOUBLE, r = fa.garbage.TSPIN_MINI_DOUBLE, _.clears.minitspindoubles++) : "normal" === n ? (s = fa.scoring.TSPIN_DOUBLE, r = fa.garbage.TSPIN_DOUBLE, _.clears.tspindoubles++) : (s = fa.scoring.DOUBLE, r = fa.garbage.DOUBLE, _.clears.doubles++);
									break;
								case 3:
									n ? (s = fa.scoring.TSPIN_TRIPLE, r = fa.garbage.TSPIN_TRIPLE, _.clears.tspintriples++) : (s = fa.scoring.TRIPLE, r = fa.garbage.TRIPLE, _.clears.triples++);
									break;
								case 4:
									n ? (s = fa.scoring.TSPIN_QUAD, r = fa.garbage.TSPIN_QUAD, _.clears.tspinquads++) : (s = fa.scoring.QUAD, r = fa.garbage.QUAD, _.clears.quads++)
							}
							if (e && _.btb > 1)
								if (s *= fa.scoring.BACKTOBACK_MULTIPLIER, u.b2bchaining) {
									const e = fa.garbage.BACKTOBACK_BONUS * (Math.floor(1 + Math.log1p((_.btb - 1) * fa.garbage.BACKTOBACK_BONUS_LOG)) + (_.btb - 1 == 1 ? 0 : (1 + Math.log1p((_.btb - 1) * fa.garbage.BACKTOBACK_BONUS_LOG) % 1) / 3));
									if (r += e, Math.floor(e) >= 2 && Pa(20 * Math.floor(e - 1) - 10), a(() => {
											Math.floor(e) > $ && Math.floor(e) >= 2 ? (On("also_permanent", ""), On("also_failed", ""), On("also_permanent_up", `B2B ${aa("X")}${_.btb-1}`)) : (On("also_permanent_up", ""), On("also_failed", ""), On("also_permanent", `B2B ${aa("X")}${_.btb-1}`))
										}), Math.floor(e) > $ && ($ = Math.floor(e), a(() => {
											2 === $ ? yt.playIngame("btb_1", ut, De, 1 * Ne, !1, u.physical, m) : 3 === $ ? yt.playIngame("btb_2", ut, De, 1.25 * Ne, !1, u.physical, m) : $ >= 4 && yt.playIngame("btb_3", ut, De, 1.5 * Ne, !1, u.physical, m)
										})), !i() && $ >= 3 && "full" === ut) {
										const e = Qn(k, 0, 0);
										hn(e.x - mt(da.x / la) * po, e.y + mt(10 * da.x), "#FFD964", 50, .1, .1, 0, mt(20 * da.x), 1, 90, 270, 0, mt(550), mt(50), .15, 1.5, .5), hn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y + mt(10 * da.x), "#FFD964", 50, .1, .1, 0, mt(20 * da.x), 1, -90, 90, 0, mt(550), mt(50), .15, 1.5, .5)
									}
								} else r += fa.garbage.BACKTOBACK_BONUS;
							else e && _.btb <= 1 && ($ = 0);
							_.combo > 1 && (s += fa.scoring.COMBO * (_.combo - 1), r *= 1 + fa.garbage.COMBO_BONUS * (_.combo - 1));
							_.combo > 2 && (r = Math.max(Math.log1p(fa.garbage.COMBO_MINIFIER * (_.combo - 1) * fa.garbage.COMBO_MINIFIER_LOG), r));
							s *= _.level, _.score += s, u.zenlevels && (_.zenprogress += na(s, _.zenlevel));
							const l = Math.floor(r * u.garbagemultiplier);
							_.combo > 2 && (_.currentcombopower = Math.max(_.currentcombopower, l));
							e && !i() && _.combo > 1 && yt.playIngame(`combo_${Math.min(16,_.combo-1)}${_.currentcombopower>=7?"_power":""}`, ut, De, Ne * (_.currentcombopower >= 7 ? l >= 7 ? 2.2 : 1.75 : 1), !1, u.physical, m);
							e && _.combo > 1 && _.currentcombopower >= 7 && Pa(5);
							e ? $a(l) : Da()
						}(e.length, n),
						function () {
							P.every(e => e.every(e => null === e)) && (a(() => {
								yt.playIngame("allclear", ut, De, Ne, !0, u.physical, m), "full" === ut && 0 !== m && ("minimal" !== G.video.graphics && "off" !== G.video.actiontext && "some" !== G.video.actiontext && Pn("allclear", ya.extra.clear), kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FFFFFF"))
							}), _.score += fa.scoring.ALL_CLEAR * _.level, u.zenlevels && (_.zenprogress += na(fa.scoring.ALL_CLEAR * _.level, _.zenlevel)), _.clears.allclear++, $a(Math.floor(fa.garbage.ALL_CLEAR * u.garbagemultiplier)))
						}(),
						function () {
							if (i()) return;
							if ("minimal" === G.video.graphics) return;
							Bt.offence && Bt.defense ? (Pn("defense", Bt.defense, Bt.x - 1, Bt.y), Pn("offdefplus", "+", Bt.x, Bt.y), Pn("offence", Bt.offence, Bt.x + 1, Bt.y)) : Bt.offence ? Pn("offence", Bt.offence, Bt.x, Bt.y) : Bt.defense && Pn("defense", Bt.defense, Bt.x, Bt.y);
							if (Bt.offence) {
								if (it += Bt.offence, st = 60, "full" === ut && !1 !== G.video.spikes && it >= 10 && 0 !== m) {
									On("spike", `${it} ${aa("SPIKE")}`);
									const e = Qn(k, 5 * mt(da.x), 11 * mt(da.x));
									gn(e.x, e.y, "#FFFFFF", "#FFFFFF", 10, 10 * mt(da.x), 20 * mt(da.x), 1, 250, 290, 50, 200, 2, 1);
									const t = Qn(k, mt(da.x * Bt.x), mt(da.x * Bt.y));
									un(t.x, t.y, 1 + Math.min(it - 10, 22.5) / 2.5), Bt.offence >= 4 && yt.playIngame(`thunder${Math.floor(6*Math.random())+1}`, ut, De, Ne, !0, u.physical, m)
								}
								it >= 10 && Pa(5), Bt.offence >= 10 && Pa(3 * Bt.offence)
							}
						}(), e.length
				}(),
				s = o ? u.lineclear_are || 0 : u.are || 0,
				r = Math.max(0, gt.keys - fa.finesse[gt.type][gt.r.toString()][gt.x + 1]);
			if (_.finesse.faults += r, r > 0 ? (_.finesse.combo = 0, a(() => {
					"full" === ut && "keyboard" === t.type() && u.pro_alert && (u.display_finesse || u.display_finesse_l) && (yt.playIngame("finessefault", ut, De, Ne, !1, u.physical, m), Ce += 1.5 * Ie), "full" === ut && "keyboard" === t.type() && u.pro_retry && u.can_retry && (Ce += 50 * Ie, qa("retry", !0), yt.play("detonate2"))
				})) : (_.finesse.combo++, _.finesse.perfectpieces++), n && (o && !1 !== u.clutch ? a(() => {
					if (G.video.siren) {
						yt.playIngame("clutch", ut, De, Ne, !1, u.physical, m);
						const e = Qn(k, 5 * mt(da.x), 0);
						gn(e.x, e.y, "#FFE87F", "#FFE87F", 50, 10 * mt(da.x), 0, 1, 240, 300, mt(300), mt(50), .05, 4.25, .5), gn(e.x, e.y, "#FFFFFF", "#FFFFFF", 50, 10 * mt(da.x), 0, 1, 240, 300, mt(300), mt(50), .05, 4.25, .5), "minimal" !== G.video.graphics && "off" !== G.video.actiontext && "some" !== G.video.actiontext && Pn("clutch", "CLUTCH")
					}
				}) : u.topoutisclear ? Ga("topout_clear") : Ga("topout")), u.zenlevels && _.combo <= 2 && _.zenprogress >= 1) return re = !0, void Xa();
			s ? (re = !0, qt(s, () => {
				ua()
			})) : ua()
		}

		function ua(e) {
			an = [], gt.locking = 0, gt.forcelock = !1, gt.lockresets = 0, gt.floored = !1, gt.type = null == e ? function () {
				for (; U.length < 7;) mn();
				return U.shift()
			}() : e, gt.aox = s.additional_offsets[gt.type][s.spawn_rotation[gt.type]][0], gt.aoy = s.additional_offsets[gt.type][s.spawn_rotation[gt.type]][1], gt.x = 4 + gt.aox, gt.y = 17.96 + gt.aoy, gt.highesty = 18, gt.r = s.spawn_rotation[gt.type], gt.spintype = !1, gt.sleep = !1, gt.last = null, gt.keys = 0, pt = 0, ht = 0, q = void 0 !== e, null == e && !1 !== u.display_next && a(() => {
				yt.playIngame(U[0], ut, De, Ne, !1, u.physical, m)
			}), on(gt.type, gt.x, gt.y, gt.r) ? S = !1 : u.topoutisclear ? Ga("topout_clear") : Ga(S ? "garbagesmash" : "topout"), re = !0, le = !0, de = !0, gt.ihs && (q || void 0 !== u.display_hold && !u.display_hold || Fa()), 0 !== gt.irs && ha((s.spawn_rotation[gt.type] + gt.irs) % 4), gt.irs = 0, gt.ihs = !1, Va()
		}

		function ga(e) {
			if ("keydown" === e.type && !e.data.key.startsWith("menu")) {
				if (e.data.subframe > n && (xa(!1, e.data.subframe - n), ia(void 0, e.data.subframe - n), n = e.data.subframe), u.noreplay || l.pushEvent("keydown", e.data), "moveLeft" === e.data.key) return _.inputs++, gt.keys++, vt = !0, kt = -1, _t = e.data.hoisted ? xt.das : 0, u.version >= 12 && (Et = xt.arr), void va(!0, u.version >= 15 ? 0 : 1);
				if ("moveRight" === e.data.key) return _.inputs++, gt.keys++, wt = !0, kt = 1, bt = e.data.hoisted ? xt.das : 0, u.version >= 12 && (It = xt.arr), void La(!0, u.version >= 15 ? 0 : 1);
				if ("softDrop" === e.data.key) return _.inputs++, gt.keys = -999, void(Lt = !0);
				if ("exit" === e.data.key) return Y = !0, void(V = 0);
				if ("retry" === e.data.key) {
					if (i()) return;
					return J = !0, void(Q = 0)
				}
				if (!gt.deep_sleep)
					if (gt.sleep) {
						if ("rotateCCW" === e.data.key) {
							_.inputs++;
							let e = gt.irs - 1;
							e < 0 && (e = 3), gt.irs = e
						}
						if ("rotateCW" === e.data.key) {
							_.inputs++;
							let e = gt.irs + 1;
							e > 3 && (e = 0), gt.irs = e
						}
						if ("rotate180" === e.data.key && u.allow180) {
							_.inputs++;
							let e = gt.irs + 2;
							e > 3 && (e -= 4), gt.irs = e
						}
						"hold" === e.data.key && (_.inputs++, gt.ihs = !0)
					} else {
						if ("rotateCCW" === e.data.key) {
							_.inputs++, gt.keys++;
							let e = gt.r - 1;
							e < 0 && (e = 3), ha(e)
						}
						if ("rotateCW" === e.data.key) {
							_.inputs++, gt.keys++;
							let e = gt.r + 1;
							e > 3 && (e = 0), ha(e)
						}
						if ("rotate180" === e.data.key && u.allow180) {
							_.inputs++, gt.keys += 2;
							let e = gt.r + 2;
							e > 3 && (e -= 4), ha(e)
						}
						"hardDrop" === e.data.key && !1 !== u.allow_harddrop && 0 === gt.safelock && (_.inputs++, ia(Number.MAX_SAFE_INTEGER, 1)), "hold" === e.data.key && (_.inputs++, q || void 0 !== u.display_hold && !u.display_hold || Fa())
					}
			}
		}

		function pa(e) {
			if ("keyup" === e.type && !e.data.key.startsWith("menu")) {
				if (e.data.subframe > n && (xa(!1, e.data.subframe - n), ia(void 0, e.data.subframe - n), n = e.data.subframe), u.noreplay || l.pushEvent("keyup", e.data), "moveLeft" === e.data.key) return vt = !1, void(_t = 0);
				if ("moveRight" === e.data.key) return wt = !1, void(bt = 0);
				if ("softDrop" !== e.data.key) {
					if ("exit" === e.data.key) return Y = !1, void(V = 0);
					if ("retry" === e.data.key) {
						if (i()) return;
						return J = !1, void(Q = 0)
					}
				} else Lt = !1
			}
		}

		function ha(e) {
			const n = gt.r,
				o = n + "" + e;
			let r = 0;
			if (r = e > n ? 1 : -1, 0 === e && 3 === n && (r = 1), 3 === e && 0 === n && (r = -1), on(gt.type, gt.x + (s.additional_offsets[gt.type][e][0] - gt.aox), gt.y + (s.additional_offsets[gt.type][e][1] - gt.aoy), e)) return gt.x += s.additional_offsets[gt.type][e][0] - gt.aox, gt.y += s.additional_offsets[gt.type][e][1] - gt.aoy, gt.aox = s.additional_offsets[gt.type][e][0], gt.aoy = s.additional_offsets[gt.type][e][1], gt.r = e, gt.last = "rotate", gt.lastkick = 0, gt.spintype = ta(), pt++, ht++, a(() => {
				yt.playIngame("rotate", ut, De, Ne, !1, u.physical, m)
			}), (++gt.lockresets < 15 || u.infinitemovement) && (gt.locking = 0), !i() && ta() && (yt.playIngame("spin", ut, De, Ne, !1, u.physical, m), "keyboard" === t.type() && W.pulse(...W.SPIN), "full" === ut && Qa(L, gt.type, gt.x, gt.y, gt.r, 1, 1), Se += r / 4 * Ie), void(re = !0);
			if ("o" === gt.type && !s.allow_o_kick) return;
			let l = s.kicks[o];
			"i" === gt.type && (l = s.i_kicks[o]);
			for (let n = 0; n < l.length; n++) {
				const o = l[n];
				let d = Math.floor(gt.y) + .1 + o[1] + (s.additional_offsets[gt.type][e][1] - gt.aoy);
				if (!u.infinitemovement && ht > (u.lockresets || 15) + 15 && (d = gt.y + o[1] + (s.additional_offsets[gt.type][e][1] - gt.aoy)), on(gt.type, gt.x + o[0] + (s.additional_offsets[gt.type][e][0] - gt.aox), d, e)) {
					if (s.center_column && ["l", "j", "t"].includes(gt.type)) {
						let e = !0;
						for (let t = 0; t < s.center_column.length; t++)
							if (sn(gt.x - gt.aox + s.center_column[t][0], gt.y - gt.aoy + s.center_column[t][1])) {
								e = 0 !== s.center_column[t][0];
								break
							} if (!e) continue
					}
					return gt.x += o[0] + (s.additional_offsets[gt.type][e][0] - gt.aox), gt.y = d, gt.aox = s.additional_offsets[gt.type][e][0], gt.aoy = s.additional_offsets[gt.type][e][1], gt.r = e, gt.spintype = ta(), gt.last = "rotate", gt.lastkick = n + 1, pt++, ht++, a(() => {
						yt.playIngame("rotate", ut, De, Ne, !1, u.physical, m)
					}), (++gt.lockresets < 15 || u.infinitemovement) && (gt.locking = 0), !i() && ta() && (yt.playIngame("spin", ut, De, Ne, !1, u.physical, m), "keyboard" === t.type() && W.pulse(...W.SPIN), "full" === ut && Qa(L, gt.type, gt.x, gt.y, gt.r, 1, 1), Se += r / 4 * Ie), void(re = !0)
				}
			}
		}

		function va(e, t = 1) {
			if (!vt || wt && -1 !== kt) return;
			let n = t;
			const o = Math.max(0, xt.das - _t);
			if ((_t += e ? 0 : t) < xt.das && !e) return;
			if (n = Math.max(0, n - o), gt.sleep || gt.deep_sleep) return;
			let s = 1;
			if (!e) {
				if ((Et += u.version >= 15 ? n : t) < xt.arr) return;
				s = 0 == xt.arr ? 10 : Math.floor(Et / xt.arr), Et -= xt.arr * s
			}
			for (let e = 0; e < s; e++) on(gt.type, gt.x - 1, gt.y, gt.r) ? (gt.x--, gt.last = "move", a(() => {
				yt.playIngame("move", ut, De, Ne, !1, u.physical, m)
			}), re = !0, (++gt.lockresets < 15 || u.infinitemovement) && (gt.locking = 0), i() || on(gt.type, gt.x - 1, gt.y, gt.r) || yt.playIngame("sidehit", ut, De, Ne, !1, u.physical, m)) : a(() => {
				e < Math.max(1, 10 * G.video.bounciness - 10) && (Fe -= .5 * Ie)
			})
		}

		function La(e, t = 1) {
			if (!wt || vt && 1 !== kt) return;
			let n = t;
			const o = Math.max(0, xt.das - bt);
			if ((bt += e ? 0 : t) < xt.das && !e) return;
			if (n = Math.max(0, n - o), gt.sleep || gt.deep_sleep) return;
			let s = 1;
			if (!e) {
				if ((It += u.version >= 15 ? n : t) < xt.arr) return;
				s = 0 == xt.arr ? 10 : Math.floor(It / xt.arr), It -= xt.arr * s
			}
			for (let e = 0; e < s; e++) on(gt.type, gt.x + 1, gt.y, gt.r) ? (gt.x++, gt.last = "move", a(() => {
				yt.playIngame("move", ut, De, Ne, !1, u.physical, m)
			}), re = !0, (++gt.lockresets < 15 || u.infinitemovement) && (gt.locking = 0), i() || on(gt.type, gt.x + 1, gt.y, gt.r) || yt.playIngame("sidehit", ut, De, Ne, !1, u.physical, m)) : a(() => {
				e < Math.max(1, 10 * G.video.bounciness - 10) && (Fe += .5 * Ie)
			})
		}

		function xa(e, t = 1) {
			va(e, t), La(e, t)
		}
		let Ba = !0,
			Ta = !0;

		function Fa() {
			const e = gt.type;
			ua(z), z = e, de = !0, a(() => {
				yt.playIngame("hold", ut, De, Ne, !1, u.physical, m)
			})
		}
		let Ma = [];

		function Sa(e) {
			"ige" === e.type && (void 0 === e.id && (e = e.data), Ma.includes(e.id) || (Ma.push(e.id), u.noreplay || l.pushEvent("ige", e), "attack" === e.data.type && Oa(e.data.lines, e.data.column, e.data.sender)))
		}

		function Ca(e) {
			"targets" === e.type && (void 0 === e.id && (e = e.data), u.noreplay || l.pushEvent("targets", e), C = e.data)
		}

		function Ra(e) {
			"end" === e.type && qa(e.data.reason, !0)
		}

		function Aa(e, t = !1, n = 1) {
			if (t) _.level = n, X = Math.min(Number.MAX_SAFE_INTEGER - 1, 1 / 60 / Math.pow(Math.max(1e-9, (u.gbase || .8) - (_.level - 1) * (u.gspeed || .007)), _.level - 1)), _.level_lines = 0, _.level_lines_needed = u.levelstatic ? u.levelstaticspeed || 10 : Math.ceil(_.level * (u.levelspeed || 1) * 5), u.masterlevels && _.level > 20 && (u.locktime = 30 - Math.min(25, _.level - 20)), u.masterlevels && _.level > 45 && (u.lockresets = 15 - Math.min(10, _.level - 45));
			else if (_.level_lines += e, _.level_lines >= _.level_lines_needed) {
				for (; _.level_lines >= _.level_lines_needed;) _.level_lines -= _.level_lines_needed, _.level++, X = Math.min(Number.MAX_SAFE_INTEGER - 1, 1 / 60 / Math.pow(Math.max(1e-9, (u.gbase || .8) - (_.level - 1) * (u.gspeed || .007)), _.level - 1)), _.level_lines_needed = u.levelstatic ? u.levelstaticspeed || 10 : Math.ceil(_.level * (u.levelspeed || 1) * 5), u.masterlevels && _.level > 20 && (u.locktime = 30 - Math.min(25, _.level - 20)), u.masterlevels && _.level > 45 && (u.lockresets = 15 - Math.min(10, _.level - 45));
				a(() => {
					yt.playIngame("levelup", ut, De, Ne, !1, u.physical, m);
					let e = _.level;
					u.masterlevels && _.level > 20 && (e = `M${_.level-20}`), "minimal" !== G.video.graphics && "off" !== G.video.actiontext && "some" !== G.video.actiontext && Pn("levelup", e), "full" === ut && 0 !== m && kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FFFFFF"), u.display_progress && u.levels && !u.absolute_lines && uo("progress", 15)
				})
			}
		}

		function $a(e) {
			if (!u.hasgarbage) return;
			_.garbage.attack += e;
			const n = !!M.length;
			for (n && !i() && yt.playIngame("offset", ut, De, Ne / (u.physical ? 1.5 : 5), !1, u.physical, m); e > 0 && M.length;) M[0].lines--, M[0].lines || M.shift(), e--, Bt.defense++;
			e > 0 && (!i() && n && yt.playIngame("counter", ut, De, Ne / (u.physical ? 1.5 : 5), !1, u.physical, m), !i() && A > 0 && yt.playIngame("exchange", ut, De, Ne / (u.physical ? 1.5 : 5), !1, u.physical, m), function (e) {
				if ((e = Math.floor(e / Math.max(1, C.length))) < 1) return;
				if (Bt.offence += e, _.garbage.sent += e, i())(u.ongarbage || (() => {}))(eo(), e, C);
				else if (C.forEach(t => {
						! function (e, t) {
							if (i()) return;
							if (!u.physical && Ht.games.self && t == Ht.games.self.context.listenID) return;
							if (("low" === G.video.graphics || "minimal" === G.video.graphics) && "tiny" === ut || 0 === m) return;
							let n = "medium";
							e < 3 && (n = "small");
							e > 5 && (n = "large");
							yt.playIngame(`garbage_out_${n}`, ut, De, 2 * Ne, !1, u.physical, m);
							const a = $n(360 * Math.random(), 100, 80),
								o = ea(k, mt(da.x * Bt.x), mt(da.x * Bt.y), Ne);
							let s = Ht.getPosOf(t);
							if (null === s) return;
							for (let t = 0; t < Math.min(u.physical ? 8 : 1, e); t++) Mn(o.x, o.y, s.pos.x, s.pos.y, Math.min(40, u.physical ? 4 : 2 * e) * Ne, Math.min(40, u.physical ? 2 : 1 * e) * s.scale, u.garbagespeed, BezierEasing(1, .02, .75, .81), BezierEasing(.02, .6, .89, .78), a, 10 + 30 * Math.random(), 20 + 60 * Math.random(), e * (.2 * Math.random() - .1), !0, !u.physical);
							qt(u.garbagespeed, () => {
								yt.playIngame("impact", ut, De, Ne, !1, u.physical, m)
							})
						}(e, t)
					}), u.usezenconfig)
					if (ve.garbagemode.startsWith("backfire_")) {
						let t = e;
						if ("backfire_half" === ve.garbagemode && (t = Math.floor(e / 2)), "backfire_double" === ve.garbagemode && (t = Math.floor(2 * e)), t < 1) return;
						Oa(t, Math.floor(10 * Math.random()))
					} else if (ve.garbagemode.startsWith("unclear_")) {
					let n = e;
					if ("unclear_half" === ve.garbagemode && (n = Math.floor(e / 2)), "unclear_double" === ve.garbagemode && (n = Math.floor(2 * e)), n < 1) return;
					const a = Math.floor(10 * Math.random());
					"keyboard" === t.type() && W.pulse(...W.GARBAGERISE), yt.playIngame("garbagerise", ut, De, Ne, !1, u.physical, m);
					for (let e = 0; e < n; e++) Ce += 2 * Ie, Ha(a)
				}
			}(e))
		}

		function Oa(e, n, a = null) {
			let o = "medium";
			if (e < 3 && (o = "small"), e > 5 && (o = "large"), u.physical && !i()) {
				yt.playIngame(`garbage_in_${o}`, ut, De, Ne, !1, u.physical, m);
				const t = $n(360 * Math.random(), 100, 80),
					n = ea(k, mt(5 * da.x), mt(10 * da.x), Ne);
				let i = null;
				null !== a && (i = Ht.getPosOf(a)), null === i && (i = {
					pos: ea(k, mt(5 * da.x), mt(-10 * da.x), Ne),
					scale: Ne
				}), Mn(i.pos.x, i.pos.y, n.x, n.y, Math.min(40, 2 * e), Math.min(40, 4 * e), u.garbagespeed, BezierEasing(1, .02, .75, .81), BezierEasing(.02, .6, .89, .78), t, 5 + 15 * Math.random(), 10 + 30 * Math.random(), e * (.1 * Math.random() - .05), !0), A++
			}
			if (D += e, _.garbage.received += e, E.name = a, a && !i()) {
				const e = Ht.find(a);
				e && (N = [e.context.listenID])
			}
			qt(u.garbagespeed, () => {
				i() || (u.physical && yt.playIngame("impact", ut, De, Ne, !1, u.physical, m), "keyboard" === t.type() && W.pulse(...W[`damage_${o}`.toUpperCase()]), yt.playIngame(`damage_${o}`, ut, De, Ne, !1, u.physical, m), A--),
					function (e, t, n = null) {
						M.push({
							lines: e,
							column: t,
							sender: n
						}), Re += Math.min(40, 1.25 * e) * Ie
					}(e, n, a)
			})
		}

		function Da(e = !1) {
			if (u.hasgarbage) {
				M.length && !i() && ("keyboard" === t.type() && W.pulse(...W.GARBAGERISE), yt.playIngame("garbagerise", ut, De, Ne, !1, u.physical, m));
				for (let t = 0; t < (e ? 400 : Math.floor(Math.min(u.garbagecapmax || 40, u.garbagecap))) && 0 !== M.length; t++) {
					if (Ce += (t >= 40 ? 0 : 2) * Ie, M[0].lines--, !Ha(M[0].column, e)) break;
					M[0].lines || M.shift()
				}
			}
		}

		function Ha(e, t = !1) {
			let n = [...P];
			if (S = !0, !n[0].every(e => null === e)) return t || (u.topoutisclear ? Ga("topout_clear") : Ga("garbagesmash")), !1;
			n.shift();
			const a = [];
			for (let t = 0; t < 10; t++) a.push(t === e ? null : "gb");
			return n.push(a), P = n, se = !0, !0
		}

		function Na() {
			if (!on(gt.type, gt.x, gt.y, gt.r)) {
				if (!on(gt.type, gt.x, gt.y - 1, gt.r)) return void(u.topoutisclear ? Ga("topout_clear") : Ga("garbagesmash"));
				gt.y -= 1, re = !0
			}
		}

		function Pa(t) {
			if (!u.display_fire) return;
			let n = rt >= 500;
			if ((rt = Math.min(700, rt + t)) >= 500 && !n) {
				if ("full" === ut && !i() && "minimal" !== G.video.graphics && !1 !== G.video.fire) {
					yt.playIngame("fire", ut, De, Ne, !1, u.physical, m);
					const t = oa.get(`${e}firebg`);
					if (t) {
						const e = Qn(t.obj, mt(5 * da.x), mt(13));
						pn(e.x, e.y, "#FFFFFFF", 50, .85, .06, 0, 0, .05, 175, 185, 0, 1e3, 0, .05, 0, .02, !1, !0), pn(e.x, e.y, "#FFFFFFF", 50, .85, .06, 0, 0, .05, -5, 5, 0, 1e3, 0, .05, 0, .02, !1, !0), yn(e.x, e.y, "#FFFFFFF", 50, .85, .06, 0, 0, .05, 175, 185, 0, 1e3, 0, .05, 0, .02, !1, !0), yn(e.x, e.y, "#FFFFFFF", 50, .85, .06, 0, 0, .05, -5, 5, 0, 1e3, 0, .05, 0, .02, !1, !0)
					}
				}
				dt = 300, rt = Math.min(700, rt + 14)
			}
		}
		const Ua = "#*********_##########_##########_##########_##########_##########_##########_##########_##########_##########_########_########_########_########_########_########_########_########_########_#########";

		function za() {
			return !u.map && function (e) {
				if ((e = e.replace(/[\s\n\r]/g, "")).length % 10 != 0) return !1;
				const t = 40 - e.length / 10;
				for (let n = 0; n < e.length; n++) {
					const a = t + Math.floor(n / 10),
						o = n % 10;
					let i = e[n];
					if ("*" !== i) {
						if ("_" === i && null !== P[a][o]) return !1;
						if ("_" !== i && null === P[a][o]) return !1
					}
				}
				return !0
			}(Ua)
		}

		function ja() {
			"keyboard" === t.type() && za() && (yt.play("allclear"), d({
				msg: "you did a thing!",
				color: "#FFAE00",
				icon: "achievement"
			}), r.post("/api/users/award", {
				type: "secretgrade"
			}, !0))
		}
		let Wa = !1;

		function Ga(e) {
			gt.deep_sleep || (O <= 0 && !u.infinitestock ? qa(e) : (gt.sleep = !0, gt.deep_sleep = !0, qt(1, () => {
				f = !0
			}), ja(), a(() => {
				if ("keyboard" === t.type() && W.pulse(...W.TOPOUT), Wa = !0, yt.playIngame("losestock", ut, De, Ne, !1, u.physical, m), Ce += 100 * Ie, "full" === ut && (kn.splash(270, .05, 20, .1, 80, "#FF2200"), kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FF2200")), !1 !== G.video.siren && "full" === ut) {
					const e = Qn(k, 0, 0);
					bn(e.x - mt(da.x / la) * po, e.y, "#FF8800", "#880000", 3, 1, 215, 235, 300, 150, .2, !0), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y, "#FF8800", "#880000", 3, 1, 305, 325, 300, 150, .2, !0), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y + mt(20 * da.x), "#FF8800", "#880000", 3, 1, 35, 55, 300, 150, .2, !0), bn(e.x - mt(da.x / la) * po, e.y + mt(20 * da.x), "#FF8800", "#880000", 3, 1, 125, 145, 300, 150, .2, !0)
				}
			}), qt(90, () => {
				u.infinitestock || O--, gt.deep_sleep = !1, f = !1, Jt(), u.zenlevels && (_.lines = 0, _.inputs = 0, _.time.frameoffset = t.getFrame(), _.piecesplaced = 0, _.garbage.sent = 0, _.garbage.attack = 0, _.garbage.cleared = 0, _.combo = 0, _.currentcombopower = 0, _.btb = 0, _.finesse.combo = 0, _.finesse.faults = 0, _.finesse.perfectpieces = 0, u.b2bchaining && (On("also_permanent", ""), On("also_permanent_up", ""))), ua(), "keyboard" === t.type() && W.pulse(...W.CLEAR), a(() => {
					u.infinitestock || function () {
						if (i()) return;
						if (!T.children.length) return;
						let e = T.children[T.children.length - 1];
						if ("full" === ut && ("high" === G.video.graphics || "ultra" === G.video.graphics)) {
							const t = Qn(e, mt(30), mt(30));
							gn(t.x, t.y, "#FFFFFF", "#FFFFFF", 100, mt(15), mt(15))
						}
						e.destroy(), ra.animate(T, {
							0: {
								x: "inherit"
							},
							1: {
								x: `${mt(da.x/2)*(10-O)}`
							}
						}, 1, BezierEasing(.17, .67, .35, 1))
					}(), Wa = !1, Ce += 50 * Ie, yt.playIngame("shatter", ut, De, Ne, !1, u.physical, m)
				})
			})))
		}

		function qa(e, a = !1) {
			if ((!gt.deep_sleep || a) && !gt.hibernated) {
				if (gt.sleep = !0, gt.deep_sleep = !0, gt.hibernated = !0, K = !1, Z = !1, p = !1, ne = e, u.noreplay || l.pushEvent("end", {
						reason: e,
						export: eo()
					}), i()) return "topout" === e && (u.onfail || (() => {}))(eo()), "garbagesmash" === e && (u.onfail || (() => {}))(eo()), "forfeit" === e && (u.onfail || (() => {}))(eo()), "clear" === e && (u.onfinish || (() => {}))(eo()), "topout_clear" === e && (u.onfinish || (() => {}))(eo()), void(u.onstop || (() => {}))(eo());
				if (u.zenlevels && (et.saveZen({
						map: Tt(),
						level: _.zenlevel,
						progress: _.zenprogress,
						score: _.score
					}), u.usezenconfig && document.getElementById("zen_panel").classList.add("hidden")), L.visible = !1, St(!0), u.physical && "forfeit" !== e && document.getElementById("forfeit").classList.add("hidden"), u.physical && "retry" !== e && document.getElementById("retry").classList.add("hidden"), b = !0, u.neverstopbgm || "retry" === e && u.bgmnoreset || ft.stop(200), u.physical && !u.display_replay && document.body.classList.remove("ingame_phys"), ja(), "topout" === e) {
					!u.physical && u.hasgarbage && t && "socket" === t.type() && Da(!0), "keyboard" === t.type() && W.pulse(...W.TOPOUT), yt.playIngame("topout", ut, De, Ne, !1, u.physical, 1), Je = !1, be = !1;
					const e = Math.sign(Math.random() - .5);
					if (ra.animate(F, {
							0: {
								y: "inherit",
								rotation: 0
							},
							1: {
								y: mt(800) + window.innerHeight,
								rotation: .2 * e
							}
						}, 1, BezierEasing(.37, .06, .75, .56)), "full" === ut && (kn.splash(270, .05, 20, .1, 80, "#FF2200"), kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FF2200")), !1 !== G.video.siren && "full" === ut) {
						const e = Qn(k, 0, 0);
						bn(e.x - mt(da.x / la) * po, e.y, "#FF8800", "#880000", 3, 1, 215, 235, 300, 150, .2, !0), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y, "#FF8800", "#880000", 3, 1, 305, 325, 300, 150, .2, !0), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y + mt(20 * da.x), "#FF8800", "#880000", 3, 1, 35, 55, 300, 150, .2, !0), bn(e.x - mt(da.x / la) * po, e.y + mt(20 * da.x), "#FF8800", "#880000", 3, 1, 125, 145, 300, 150, .2, !0)
					}
					E.type = "sizzle", (u.onfail || (() => {}))(eo()), setTimeout(() => {
						Jn()
					}, 1e3)
				}
				if ("garbagesmash" === e) {
					if (!u.physical && u.hasgarbage && t && "socket" === t.type() && Da(!0), yt.playIngame("topout", ut, De, Ne, !1, u.physical, 1), "keyboard" === t.type() && W.pulse(...W.GARBAGESMASH), yt.playIngame("garbagesmash", ut, De, Ne, !1, u.physical, 1), Ce += 100 * Ie, "full" === ut && (kn.splash(270, .05, 20, .1, 80, "#FF2200"), kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FF2200")), !1 !== G.video.siren && "full" === ut) {
						const e = Qn(k, 0, 0);
						bn(e.x - mt(da.x / la) * po, e.y, "#FF8800", "#880000", 3, 1, 215, 235, 300, 150, .2, !0), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y, "#FF8800", "#880000", 3, 1, 305, 325, 300, 150, .2, !0), bn(e.x + mt(10 * da.x) + mt(da.x / la) * ho, e.y + mt(20 * da.x), "#FF8800", "#880000", 3, 1, 35, 55, 300, 150, .2, !0), bn(e.x - mt(da.x / la) * po, e.y + mt(20 * da.x), "#FF8800", "#880000", 3, 1, 125, 145, 300, 150, .2, !0)
					}
					E.type = "spark";
					let e = 40 - rn();
					M.forEach(t => {
						e += t.lines
					}), e >= 40 && (E.type = "spike"), (u.onfail || (() => {}))(eo()), setTimeout(() => {
						Je = !1, be = !1;
						const e = Math.sign(Math.random() - .5);
						ra.animate(F, {
							0: {
								y: "inherit",
								rotation: 0
							},
							1: {
								y: mt(800) + window.innerHeight,
								rotation: .3 * e
							}
						}, 1, BezierEasing(.37, .06, .75, .56))
					}, 250), setTimeout(() => {
						Jn()
					}, 1250)
				}
				if ("clear" === e) {
					yt.playIngame("finish", ut, De, Ne, !1, u.physical, 1), Je = !1, be = !1, _.time.locked = !0, "keyboard" === t.type() && W.pulse(...W.CLEAR), ra.animate(F, {
						0: {
							"scale.x": "inherit",
							"scale.y": "inherit",
							alpha: 1
						},
						1: {
							"scale.x": 5,
							"scale.y": 5,
							alpha: 0
						}
					}, 5, BezierEasing(.1, .16, .94, .06)), "full" === ut && (kn.circlesplash(mt(10 * da.x), .2, 500, .1, 250, "#FFFFFF"), Un("finish", "FINISH"));
					const e = 1e3 * (t.getFrame() + n) / 60;
					(u.onfinish || (() => {}))(eo({
						seed: u.seed,
						finalTime: e
					})), Rt(e), setTimeout(() => {
						Jn()
					}, 1e4)
				}
				if ("topout_clear" === e && ("keyboard" === t.type() && W.pulse(...W.TOPOUT), yt.playIngame("gameover", ut, De, Ne, !1, u.physical, 1), Ce += 100 * Ie, "full" === ut && (kn.splash(270, .05, 20, .1, 80, "#FF2200"), kn.circlesplash(mt(10 * da.x), .2, 500, .1, 250, "#FF2200"), Un("gameover", "GAME OVER")), setTimeout(() => {
						Je = !1, be = !1, _.time.locked = !0, ra.animate(F, {
							0: {
								"scale.x": "inherit",
								"scale.y": "inherit",
								alpha: 1
							},
							1: {
								"scale.x": .5,
								"scale.y": .5,
								alpha: 0
							}
						}, 5, BezierEasing(.1, .16, .94, .06));
						const e = 1e3 * (t.getFrame() + n) / 60;
						(u.onfinish || (() => {}))(eo({
							seed: u.seed,
							finalTime: e
						})), Rt(e)
					}, 250), setTimeout(() => {
						Jn()
					}, 1e4)), "winner" === e && (yt.playIngame("finish", ut, De, Ne, !1, u.physical, 1), Je = !1, be = !1, _.time.locked = !0, "keyboard" === t.type() && W.pulse(...W.CLEAR), ra.animate(F, {
						0: {
							"scale.x": "inherit",
							"scale.y": "inherit",
							alpha: 1
						},
						1: {
							"scale.x": 2,
							"scale.y": 2,
							alpha: 0
						}
					}, 3, BezierEasing(.1, .16, .94, .06)), "full" === ut && kn.circlesplash(mt(10 * da.x), .2, 500, .1, 250, "#FFFFFF"), (u.onfinish || (() => {}))(eo()), setTimeout(() => {
						Jn()
					}, 3500)), "forfeit" === e && (Je = !1, be = !1, ra.animate(F, {
						0: {
							"scale.x": "inherit",
							"scale.y": "inherit",
							alpha: 1
						},
						1: {
							"scale.x": 0,
							"scale.y": 0,
							alpha: .5
						}
					}, 1, BezierEasing(.22, .09, .84, .23)), document.getElementById("forfeit").classList.add("hidden"), (u.onquit || (() => {}))(eo()), setTimeout(() => {
						kn.circlesplash(mt(16), .3, 100, .1, 50, "#FFFFFF"), yt.playIngame("detonated", ut, De, Ne, !1, u.physical, 1)
					}, 1e3), setTimeout(() => {
						Jn()
					}, 5e3)), "retry" === e && (Je = !1, be = !1, ra.animate(F, {
						0: {
							"scale.x": "inherit"
						},
						1: {
							"scale.x": 0
						}
					}, u.stride ? .05 : .25, BezierEasing(.36, .01, .75, .3)), document.getElementById("retry").classList.add("hidden"), setTimeout(() => {
						Jn()
					}, u.stride ? 50 : 1e3), setTimeout(() => {
						u.fromretry || (u.countdown_interval *= .75), u.precountdown = 500, u.prestart = 0, u.mission = "", u.zoominto = "fast", u.fromretry = !0, u.physical = !0, u.bgmnoreset && g && (u.onstart = () => {}), (ye = new ka).createGameHolder(ut), ye.bindEventSource(new Ea({
							type: "keyboard"
						})), ye.setGame(u), ye.startGame()
					}, u.stride ? 50 : 250), et.reportAbortedGame()), "drop" === e && (Je = !1, be = !1, (u.onquit || (() => {}))(eo()), ra.animate(F, {
						0: {
							"scale.x": "inherit",
							"scale.y": "inherit",
							alpha: 1
						},
						1: {
							"scale.x": 0,
							"scale.y": 0,
							alpha: .5
						}
					}, .5, BezierEasing(.36, .01, .75, .3)), setTimeout(() => {
						kn.circlesplash(mt(16), .3, 100, .1, 50, "#FFFFFF"), yt.playIngame("detonated", ut, De, Ne, !1, u.physical, 1)
					}, 500), setTimeout(() => {
						Jn()
					}, 550)), "dropnow" === e) return Je = !1, be = !1, ra.animate(F, {
					0: {
						"scale.x": "inherit",
						"scale.y": "inherit",
						alpha: 1
					},
					1: {
						"scale.x": 0,
						"scale.y": 0,
						alpha: .5
					}
				}, .5, BezierEasing(.36, .01, .75, .3)), setTimeout(() => {
					kn.circlesplash(mt(16), .3, 100, .1, 50, "#FFFFFF"), yt.playIngame("detonated", ut, De, Ne, !1, u.physical, 1)
				}, 500), void setTimeout(() => {
					Jn()
				}, 550);
				"disconnect" === e && (Je = !1, be = !1, (u.onfail || (() => {}))(eo()), ra.animate(F, {
					0: {
						"scale.x": "inherit",
						"scale.y": "inherit",
						alpha: "inherit"
					},
					1: {
						"scale.x": 2,
						"scale.y": 0,
						alpha: 0
					}
				}, .25, BezierEasing(.09, .73, .23, .9)), setTimeout(() => {
					Jn()
				}, 300)), (u.onend || (() => {}))(eo()), (u.onstop || (() => {}))(eo())
			}
		}

		function Xa() {
			gt.sleep = !0, gt.deep_sleep = !0, qt(1, () => {
				f = !0
			}), K = !1, Z = !1, document.getElementById("zen_panel").classList.add("noop"), Pn("zenlevel", ya.extra.zenlevel), kn.circlesplash(mt(10 * da.x), .2, 200, .1, 250, "#FFFFFF"), ft.stop(3e3), yt.playIngame("warp", ut, De, 1.25 * Ne, !1, u.physical, 1);
			const e = new PIXI.Graphics;
			e.beginFill(14540253, 1), e.drawRect(0, 0, innerWidth, innerHeight), e.endFill(), e.position.set(0, 0), e.alpha = 0, Gt.addChild(e);
			const n = new PIXI.Graphics;
			n.beginFill(14540253, 1), n.drawRect(innerWidth / -2, -2, innerWidth, 4), n.endFill(), n.position.set(innerWidth / 2, innerHeight / 2), n.alpha = 0, n.scale.x = 0, Gt.addChild(n), ra.animate(F, {
				0: {
					"scale.x": "inherit",
					"scale.y": "inherit",
					rotation: 0
				},
				1: {
					"scale.x": 0,
					"scale.y": 0,
					rotation: -1
				}
			}, 3.1, BezierEasing(.93, 0, .83, -.89)), setTimeout(() => {
				if ("ultra" === G.video.graphics) {
					const e = new PIXI.filters.PixelateFilter(1),
						t = new PIXI.filters.TwistFilter(innerWidth, 0);
					t.offset = new PIXI.Point(innerWidth / 2, innerHeight / 2);
					const n = new PIXI.filters.TwistFilter(innerWidth / 3, 0);
					n.offset = new PIXI.Point(innerWidth / 2, innerHeight / 2), Fn.filters = [e, t, n], ra.animate(t, {
						0: {
							angle: 0
						},
						1: {
							angle: -3
						}
					}, 2.1, BezierEasing(.61, .01, .94, .04)), ra.animate(n, {
						0: {
							angle: 0
						},
						1: {
							angle: 10
						}
					}, 2.1, BezierEasing(.61, .01, .94, .04)), ra.animate(e, {
						0: {
							size: 1
						},
						1: {
							size: 100
						}
					}, 2.1, BezierEasing(.61, .01, .94, .04)), setTimeout(() => {
						Ln.scale(3)
					}, 1950)
				}
			}, 1e3), setTimeout(() => {
				ra.animate(xn, {
					0: {
						alpha: "inherit"
					},
					1: {
						alpha: 0
					}
				}, .5, BezierEasing(.5, .5, .5, .5))
			}, 2600), setTimeout(() => {
				ra.animate(e, {
					0: {
						alpha: 0
					},
					1: {
						alpha: 1
					}
				}, .2, BezierEasing(.5, .5, .5, .5)), ra.animate(n, {
					0: {
						alpha: 0,
						"scale.x": 0
					},
					1: {
						alpha: 1,
						"scale.x": 1
					}
				}, .2, BezierEasing(.5, .5, .5, .5)), pn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 20, .8, .1, innerWidth, 0, .05, 0, 360, 0, 100, 0, 4.4, 0, .1, !1, !1, !0), pn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 20, .2, .1, innerWidth, 0, 1, 0, 360, 0, 10, 0, 4.4, 0, .1, !1, !1, !0), pn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 10, .1, .1, innerWidth, 0, 1, 270, 270, 0, 2500, 2500, 4.4, 0, .5, !1, !1, !0), yn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 10, 6, .1, innerWidth, 0, .02, 265, 275, 0, 5e3, 5e3, 4.4, 0, .5, !1, !1, !0), yn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 10, 6, .1, innerWidth, 0, .02, 85, 95, 0, 5e3, 5e3, 4.4, 0, .5, !1, !1, !0), pn(.1 * innerWidth, innerHeight / 2, "#DDDDDD", 5, .1, .1, innerWidth / 5, 0, 1, 110, 150, 0, 2500, 2500, 4.4, 0, .5, !1, !1, !0), pn(.3 * innerWidth, innerHeight / 2, "#DDDDDD", 5, .1, .1, innerWidth / 5, 0, 1, 90, 130, 0, 2500, 2500, 4.4, 0, .5, !1, !1, !0), pn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 5, .1, .1, innerWidth / 5, 0, 1, 70, 110, 0, 2500, 2500, 4.4, 0, .5, !1, !1, !0), pn(.7 * innerWidth, innerHeight / 2, "#DDDDDD", 5, .1, .1, innerWidth / 5, 0, 1, 50, 90, 0, 2500, 2500, 4.4, 0, .5, !1, !1, !0), pn(.9 * innerWidth, innerHeight / 2, "#DDDDDD", 5, .1, .1, innerWidth / 5, 0, 1, 30, 70, 0, 2500, 2500, 4.4, 0, .5, !1, !1, !0)
			}, 2900), setTimeout(() => {
				_.zenlevel++, _.zenprogress = 0, Ln.opacity(0), f = !1, Fn.filters = null, _.lines = 0, _.inputs = 0, _.piecesplaced = 0, _.garbage.sent = 0, _.garbage.attack = 0, _.garbage.cleared = 0, _.combo = 0, _.currentcombopower = 0, _.btb = 0, _.finesse.combo = 0, _.finesse.faults = 0, _.finesse.perfectpieces = 0, u.b2bchaining && (On("also_permanent", ""), On("also_permanent_up", ""));
				const t = P.reduce((e, t) => e + (t.some(e => "gb" === e) ? 1 : 0), 0);
				for (let e = 0; e < t; e++) P.pop(), P.unshift(Array(10).fill(null)), an = [], re = !0, se = !0;
				et.saveZen({
					map: Tt(),
					level: _.zenlevel,
					progress: _.zenprogress,
					score: _.score
				}), ra.animate(e, {
					0: {
						alpha: 1
					},
					1: {
						alpha: 0
					}
				}, 1, BezierEasing(.5, .5, .5, .5))
			}, 3100), setTimeout(() => {
				Ln.scale(1), ie(!0), ra.animate(e, {
					0: {
						alpha: 0
					},
					.2: {
						alpha: 1
					},
					1: {
						alpha: .2
					}
				}, .4, BezierEasing(.5, .5, .5, .5)), pn(.5 * innerWidth, innerHeight / 2, "#DDDDDD", 20, .2, .1, innerWidth, 0, 1, 0, 360, 0, 200, 0, .4, 0, .1, !1, !1, !0)
			}, 6400), setTimeout(() => {
				ra.animate(e, {
					0: {
						alpha: .2
					},
					1: {
						alpha: 1
					}
				}, .6, BezierEasing(.5, .5, .5, .5)), ra.animate(n, {
					0: {
						"scale.y": 1
					},
					1: {
						"scale.y": 300
					}
				}, .6, BezierEasing(.46, .06, .79, .09))
			}, 6800), setTimeout(() => {
				n.destroy(), h || (F.rotation = 0, ra.animate(F, {
					0: {
						"scale.x": 0,
						"scale.y": 0
					},
					1: {
						"scale.x": 1,
						"scale.y": 1
					}
				}, 3, BezierEasing(.24, .59, .32, .96))), ra.animate(e, {
					0: {
						alpha: 1
					},
					1: {
						alpha: 0
					}
				}, 1, BezierEasing(.5, .5, .5, .5)), xn.alpha = Math.min(1, 10 * G.video.background), Ln.opacity(.9)
			}, 7400), setTimeout(() => {
				e.destroy(), h || (gt.sleep = !1, gt.deep_sleep = !1, _.time.frameoffset = t.getFrame(), K = !0, Z = !0, ua(), bo(), ft.playSmoothOrRandom("RANDOMcalm")), Ln.opacity(1), document.getElementById("zen_panel").classList.remove("noop")
			}, 10400)
		}

		function Ka(e = !1) {
			if (u.usezenconfig) {
				switch (ve.gravitymode) {
					case "subzero":
						X = 0, u.infinitemovement = !0, u.locktime = 999999999;
						break;
					case "off":
						X = 0, u.infinitemovement = !1, u.locktime = 30;
						break;
					case "relaxed":
						X = .015 + .035 * BezierEasing(.78, .21, .86, .43)(Math.min(1, Math.max(0, _.zenprogress))), u.infinitemovement = !1, u.locktime = 30;
						break;
					case "engaging":
						X = .05 + .2 * BezierEasing(.78, .21, .86, .43)(Math.min(1, Math.max(0, _.zenprogress))), u.infinitemovement = !1, u.locktime = 30;
						break;
					case "spicy":
						X = .25 + 2.25 * BezierEasing(.78, .21, .86, .43)(Math.min(1, Math.max(0, _.zenprogress))), u.infinitemovement = !1, u.locktime = 30;
						break;
					case "static":
						X = ve.gravitystatic, u.infinitemovement = !1, u.locktime = 30
				}
				if (e) {
					let e = !1;
					switch (ve.counters) {
						case "off":
							u.display_finesse = !1, u.display_finesse_l = !1, u.display_stopwatch = !1, u.display_lines = !1, u.display_keys = !1, u.display_pieces = !1, u.display_attack = !1, u.display_vs = !1;
							break;
						case "versus":
							e = !0, u.display_finesse = !1, u.display_finesse_l = !1, u.display_stopwatch = !1, u.display_lines = !1, u.display_keys = !1, u.display_pieces = !0, u.display_attack = !0, u.display_vs = !0;
							break;
						case "time":
							u.display_finesse = !0, u.display_finesse_l = !1, u.display_stopwatch = !0, u.display_lines = !0, u.display_keys = !1, u.display_pieces = !0, u.display_attack = !1, u.display_vs = !1;
							break;
						case "speed":
							u.display_finesse = !0, u.display_finesse_l = !1, u.display_stopwatch = !1, u.display_lines = !1, u.display_keys = !0, u.display_pieces = !0, u.display_attack = !1, u.display_vs = !1;
							break;
						case "efficiency":
							e = !0, u.display_finesse = !1, u.display_finesse_l = !0, u.display_stopwatch = !1, u.display_lines = !1, u.display_keys = !0, u.display_pieces = !1, u.display_attack = !1, u.display_vs = !0
					}
					switch (ve.leveling) {
						case "off":
							u.display_progress = !1;
							break;
						case "on":
							u.display_progress = !0
					}
					switch (ve.garbagemode) {
						case "off":
							u.display_impending = !1;
							break;
						case "backfire_half":
						case "backfire_full":
						case "backfire_double":
							u.display_impending = !0, e = !0;
							break;
						case "unclear_half":
						case "unclear_full":
						case "unclear_double":
							u.display_impending = !1, e = !0;
							break;
						case "cheeselayer":
							u.display_impending = !1, Va();
							break;
						case "cheesetimer":
							u.display_impending = !1
					}
					u.hasgarbage = e, bo()
				} else gt.sleep || gt.deep_sleep || "cheesetimer" !== ve.garbagemode || t.getFrame() % (60 * ve.cheesetimer_interval) != 0 || ((null === Ya || 100 * Math.random() <= ve.cheesemessiness) && (Ya = Math.floor(10 * Math.random())), Ce += 2 * Ie, re = !0, "keyboard" === t.type() && W.pulse(...W.GARBAGERISE), yt.playIngame("garbagerise", ut, De, Ne, !1, u.physical, m), Ha(Ya), an = [], Na())
			}
		}
		let Ya = null;

		function Va() {
			if (!u.usezenconfig) return;
			if ("cheeselayer" !== ve.garbagemode) return;
			const e = P.reduce((e, t) => e + (t.some(e => "gb" === e) ? 1 : 0), 0),
				n = Math.min(20, Math.max(0, Math.floor(ve.cheeselayer_height)));
			if (e < n) {
				"keyboard" === t.type() && W.pulse(...W.GARBAGERISE), yt.playIngame("garbagerise", ut, De, Ne, !1, u.physical, m);
				for (let t = 0; t < n - e; t++)(null === Ya || 100 * Math.random() <= ve.cheesemessiness) && (Ya = Math.floor(10 * Math.random())), Ce += 2 * Ie, Ha(Ya), an = [], Na()
			} else if (e > n) {
				"keyboard" === t.type() && W.pulse(...W.GARBAGERISE), yt.playIngame("garbagerise", ut, De, Ne, !1, u.physical, m);
				for (let t = 0; t < e - n; t++) P.pop(), P.unshift(Array(10).fill(null)), Ce += 2 * Ie, an = []
			}
		}

		function Za(e) {
			if (i()) return;
			if ("low" === G.video.graphics || "minimal" === G.video.graphics || "tiny" === ut || 0 === m) return;
			const t = Qn(k, mt(5 * da.x), (e - 20) * mt(da.x) + mt(da.x));
			if (gn(t.x, t.y, "#FFFFFF", "#FFFFFF", "full" === ut ? 10 : 1, mt(10 * da.x), mt(da.x), 1, 175, 185, 500, 50, .1, .5), gn(t.x, t.y, "#FFFFFF", "#FFFFFF", "full" === ut ? 10 : 1, mt(10 * da.x), mt(da.x), 1, 355, 365, 500, 50, .1, .5), "full" === ut) {
				kn.splash(90, .05, 2, .1, 80, "#FFFFFF"), kn.splash(270, .05, 2, .1, 80, "#FFFFFF");
				for (var n = 0; n < 10; n++) {
					const t = Qn(k, n * mt(da.x) + mt(da.x / 2), (e - 20) * mt(da.x) + mt(da.x / 2));
					An(fa.colors[s.colorMap[P[e][n]]]);
					gn(t.x, t.y, fa.colors[s.colorMap[P[e][n]]], "#FFFFFF", 10, mt(3), mt(3)), gn(t.x, t.y, "#FFFFFF", "#FFFFFF", 2.5, mt(3), mt(3)), fn(t.x, t.y, Ne, "#FFFFFF", fa.colors[s.colorMap[P[e][n]]], 1, 0, 0, 1, xe, xe, !1), fn(t.x, t.y, Ne, fa.colors[s.colorMap[P[e][n]]], fa.colors[s.colorMap[P[e][n]]], 1, 0, 0, .5, 250 + xe, 290 + xe, 200, 500)
				}
			}
		}

		function Ja(e, t, n, a, o, r, l, d, c, u = 0, g = 360, p = 200, h = 50) {
			if (!i() && ("high" === G.video.graphics || "ultra" === G.video.graphics) && 0 !== m)
				for (let i = 0; i < fa.tetrominoes[t].matrix.data[o].length; i++) {
					if (0 === fa.tetrominoes[t].matrix.data[o][i]) continue;
					const m = i % fa.tetrominoes[t].matrix.w - fa.tetrominoes[t].matrix.dx,
						y = Math.floor(i / fa.tetrominoes[t].matrix.w) - fa.tetrominoes[t].matrix.dy,
						f = Qn(e, (n + m) * mt(da.x) + mt(da.x / 2), (Math.ceil(a) + y - 20) * mt(da.x) + mt(da.x / 2));
					gn(f.x, f.y, fa.colors[s.colorMap[t]], fa.colors[s.colorMap[t]], r, l, d, c, u, g, p, h)
				}
		}

		function Qa(e, t, n, a, o, r, l) {
			if (!i() && "low" !== G.video.graphics && "minimal" !== G.video.graphics && 0 !== m)
				for (let i = 0; i < fa.tetrominoes[t].matrix.data[o].length; i++) {
					if (0 === fa.tetrominoes[t].matrix.data[o][i]) continue;
					const d = i % fa.tetrominoes[t].matrix.w - fa.tetrominoes[t].matrix.dx,
						c = Math.floor(i / fa.tetrominoes[t].matrix.w) - fa.tetrominoes[t].matrix.dy,
						m = Qn(e, (n + d) * mt(da.x) + mt(da.x / 2), (Math.ceil(a) + c - 20) * mt(da.x) + mt(da.x / 2));
					fn(m.x, m.y, Ne, fa.colors[s.colorMap[t]], fa.colors[s.colorMap[t]], r, 0, 0, l, 0, 360, 200, 0)
				}
		}
		function upcomingp(e){
            var x = 0;
            for(var i = 0; i < e.length; i++){
                x += e[i].lines;
            }
            return x;
        }
		function eo(e = {}) {
			const n = Math.max(1, t.getFrame() / 60),
				a = (_.garbage.attack + _.garbage.cleared) / Math.max(1, _.piecesplaced) * (_.piecesplaced / n) * 100;
			return {
				successful: y,
				gameoverreason: ne,
				replay: l,
				source: t,
				options: u,
				stats: _,
				targets: C,
				upcoming: upcomingp(M), 
				fire: rt,
				NotStart: te,
                NotStart2: ee,
                game: {
                    board: JSON.stringify(P),
					bag: U,
					hold: {
						piece: z,
						locked: q
					},
					g: X,
					controlling: {
						ldas: _t,
						ldasiter: Et,
						lshift: vt,
						rdas: bt,
						rdasiter: It,
						rshift: wt,
						lastshift: kt,
						softdrop: Lt
					},
					handling: xt,
					playing: p
				},
				killer: E,
				assumptions: e,
				aggregatestats: {
					apm: (_.garbage.attack || 0) / (t.getFrame() / 3600 || 1),
					pps: (_.piecesplaced || 0) / (t.getFrame() / 60 || 1),
					vsscore: a
				}
			}
		}

		function to(e, t, n, a, o, i = !1) {
			const s = new PIXI.Container;
			s.visible = !1, s.position.set(mt(i ? 10 * da.x + 10 : -315), mt(o)), e.addChild(s);
			const r = new PIXI.TheoryType(n.toString(), {
				fontSize: mt(20),
				wordWrapWidth: 800,
				lineHeight: mt(20),
				fontWeight: .5,
				fill: 16777215,
				align: i ? "left" : "right",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			r.position.set(0, mt(0)), s.addChild(r), fe.push(r);
			const l = new PIXI.TheoryType(a.toString(), {
				fontSize: mt(38),
				wordWrapWidth: 16e3 / 38,
				lineHeight: mt(38),
				fontWeight: .4,
				fill: 16777215,
				align: i ? "left" : "right",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			return l.position.set(0, mt(36)), s.addChild(l), fe.push(l), me[t] && me[t].holder && !me[t].holder._destroyed && me[t].holder.parent && !me[t].holder.parent._destroyed && me[t].holder.destroy(), me[t] = {
				holder: s,
				lbl: r,
				counter: l,
				right: i
			}, me[t]
		}

		function no(e, t) {
			me[e] && me[e].counter.text != t.toString() && (me[e].counter.text = t.toString())
		}

		function ao(e, t) {
			me[e] && (me[e].holder.y = mt(t))
		}

		function oo(e, t) {
			me[e] && (me[e].holder.visible = t)
		}

		function io(e, t, n, a, o = !1, i = !1, s = null, r = null) {
			const l = new PIXI.Container;
			l.visible = !1, l.position.set(mt(o ? 10 * da.x : -da.x / la), 0), e.addChild(l);
			const d = new PIXI.Graphics;
			d.beginFill(0, void 0 === G.video.boardopacity ? .85 : G.video.boardopacity), d.drawRect(0, 0, mt(da.x / la), mt(20 * da.x)), d.endFill(), d.position.set(0, 0), l.addChild(d);
			const c = new PIXI.Container;
			c.position.set(0, 0), l.addChild(c);
			const m = new PIXI.Sprite(Gn.barborder);
			m.position.set(mt(-1.5) - 1, mt(-1.5) - 1), l.addChild(m), he.push(m);
			let u = null;
			return i && ((u = new PIXI.Graphics).lineStyle(mt(3), 16777215, 1), u.moveTo(0, 0), u.lineTo(mt(da.x / la), 0), u.position.set(0, mt(20 * da.x)), l.addChild(u), he.push(u)), ue[t] && ue[t].holder && !ue[t].holder._destroyed && ue[t].holder.parent && !ue[t].holder.parent._destroyed && ue[t].holder.destroy(), ue[t] = {
				holder: l,
				content: c,
				right: o,
				count: -1,
				tickercount: 0,
				tickertarget: 0,
				ticker: u,
				target: a,
				customcolors: s,
				sparkcolor: r,
				max: n,
				blast: 0
			}, ro(t, a), lo(t, 0), ue[t]
		}
		const so = [16711680, 16760832, 2079488, 27903, 7078143, 16741117];

		function ro(e, t) {
			if (!ue[e]) return;
			if (ue[e].count == t) return;
			ue[e].count = t, nn(ue[e].content);
			let n = 0;
			for (t > 12 * ue[e].max && (t = 6 * ue[e].max + t % ue[e].max * 6); t > 0;) {
				const a = go(t, ue[e].max),
					o = new PIXI.Graphics;
				o.beginFill(ue[e].customcolors ? ue[e].customcolors[n % 6] : so[n % 6], 1), o.drawRect(0, 0, mt(da.x / la), a), o.endFill(), o.position.set(0, mt(20 * da.x)), o.pivot.set(0, a), ue[e].content.addChild(o), t -= ue[e].max, n++
			}
		}

		function lo(e, t) {
			ue[e] && ue[e].ticker && ue[e].tickercount != t && (ue[e].tickercount = t, t <= 0 || t > ue[e].max ? ue[e].ticker.visible = !1 : (ue[e].ticker.visible = !0, ue[e].ticker.position.set(0, mt(20 * da.x) - mt(20 * da.x) * (t / ue[e].max))))
		}

		function co(e, t) {
			ue[e] && ue[e].target != t && (ue[e].target = t)
		}

		function mo(e, t) {
			ue[e] && ue[e].max != t && (ue[e].max = t)
		}

		function uo(e, t) {
			ue[e] && (ue[e].blast = t)
		}

		function go(e, t) {
			return e = e / t * 20, t = 20, mt(da.x * (Math.min(t, e) + (e - Math.min(t, e)) / t / 3))
		}
		let po = 0,
			ho = 0;

		function yo(t, n) {
			if (!h && ue[t] && ue[t].holder.visible !== n)
				if (ue[t].holder.visible = n, Object.keys(me).forEach(e => {
						const a = me[e];
						a.right === ue[t].right && (a.right ? a.holder.x += mt(da.x / la) * (n ? 1 : -1) : a.holder.x -= mt(da.x / la) * (n ? 1 : -1))
					}), ue[t].right) {
					ho += n ? 1 : -1;
					const t = oa.get(`${e}next`);
					t && (t.obj.x += mt(da.x / la) * (n ? 1 : -1));
					const a = oa.get(`${e}nextbg`);
					a && (a.obj.x += mt(da.x / la) * (n ? 1 : -1));
					const o = oa.get(`${e}nextfg`);
					o && (o.obj.x += mt(da.x / la) * (n ? 1 : -1));
					const i = oa.get(`${e}nexttext`);
					i && (i.obj.x += mt(da.x / la) * (n ? 1 : -1))
				} else {
					po += n ? 1 : -1;
					const t = oa.get(`${e}hold`);
					t && (t.obj.x -= mt(da.x / la) * (n ? 1 : -1));
					const a = oa.get(`${e}holdbg`);
					a && (a.obj.x -= mt(da.x / la) * (n ? 1 : -1));
					const o = oa.get(`${e}holdfg`);
					o && (o.obj.x -= mt(da.x / la) * (n ? 1 : -1));
					const i = oa.get(`${e}holdtext`);
					i && (i.obj.x -= mt(da.x / la) * (n ? 1 : -1))
				}
		}
		let fo = null;

		function _o(e) {
			if (!u.display_username) return;
			fo && (fo.bg.destroy(), fo.fg.destroy());
			const t = new PIXI.Graphics;
			t.beginFill(0, .75), t.drawRect(0, 0, mt(10 * da.x + 4), mt(26)), t.endFill(), t.position.set(e.data.global.x - mt(5 * da.x + 2), e.data.global.y + 32), Gt.addChild(t);
			const n = new PIXI.TheoryType(u.username.toUpperCase(), {
				fontSize: mt(19),
				wordWrapWidth: 825,
				lineHeight: mt(19),
				fontWeight: .4,
				fill: 14540253,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			n.position.set(e.data.global.x - mt(5 * da.x), e.data.global.y + 32 + mt(20)), Gt.addChild(n), ra.animate(t, {
				0: {
					alpha: 0,
					"pivot.y": 32
				},
				.1: {
					alpha: 1,
					"pivot.y": 0
				},
				.75: {
					alpha: 1,
					"pivot.y": 0
				},
				1: {
					alpha: 0,
					"pivot.y": 0
				}
			}, 5, BezierEasing(0, .34, .86, .46)), ra.animate(n, {
				0: {
					alpha: 0,
					"pivot.y": 32
				},
				.1: {
					alpha: 1,
					"pivot.y": 0
				},
				.75: {
					alpha: 1,
					"pivot.y": 0
				},
				1: {
					alpha: 0,
					"pivot.y": 0
				}
			}, 5, BezierEasing(0, .34, .86, .46), () => {
				fo.bg.destroy(), fo.fg.destroy(), fo = null
			}), fo = {
				bg: t,
				fg: n
			}
		}

		function Eo(e) {
			fo && (fo.bg.position.set(e.data.global.x - mt(5 * da.x + 2), e.data.global.y + 32), fo.fg.position.set(e.data.global.x - mt(5 * da.x), e.data.global.y + 32 + mt(20)))
		}

		function vo() {
			fo && (fo.bg.destroy(), fo.fg.destroy(), fo = null)
		}

		function bo(t) {
			if (i()) return;
			if (!p) return;
			t && (ut = t);
			let n = !1;
			F && (n = F.visible, F.destroy(), F = null, at = !1, Zn = null), vo(), he = [], fe = [], _e = [];
			const a = new PIXI.Container;
			a.position.set(mt(800), mt(400)), a.pivot.set(mt(5 * da.x), mt(10 * da.x)), a.visible = n, Nn.addChild(a), "tiny" === ut && (a.interactive = !0, a.interactiveChildren = !1, a.on("click", () => {
				!1 !== u.manual_allowed && Ct && Ht && Ht.find(u.username) && Ct.setManual(Ht.find(u.username).context.listenID), Ht && (Ht.setSpectating(u.username), Ht.order())
			}), a.on("mouseover", _o), a.on("mousemove", Eo), a.on("mouseout", vo)), io(a, "impending", 20, 0, !1, !0), io(a, "progress", 40, 0, !0, !1, [12078599, 16763904, 12078599, 16763904, 12078599, 16763904], "#B84E07");
			const o = new PIXI.Sprite(Gn.boxbg);
			o.position.set(-1, -1), o.alpha = void 0 === G.video.boardopacity ? .85 : G.video.boardopacity, a.addChild(o), o.interactive = !0, o.on("click", () => {
				!1 !== u.manual_allowed && Ct && Ht && Ht.find(u.username) && Ct.setManual(Ht.find(u.username).context.listenID), Ht && (Ht.setSpectating(u.username), Ht.order())
			}), "full" !== ut && (o.on("mouseover", _o), o.on("mousemove", Eo), o.on("mouseout", vo));
			const s = new PIXI.Container;
			s.position.set(0, 0), a.addChild(s);
			const r = new PIXI.Graphics;
			r.beginFill(0, .75), r.drawRect(0, 0, mt(10 * da.x + 4), mt(26)), r.endFill(), r.visible = !1, r.position.set(mt(-2), mt(20 * da.x + 10)), oa.register(r, `${e}usernamebg`), a.addChild(r);
			const l = new PIXI.Graphics;
			l.beginFill(16777215, 1), l.drawRect(0, 0, mt(10 * da.x + 4), mt(26)), l.endFill(), l.visible = !1, l.alpha = 0, l.position.set(mt(5 * da.x - 2), mt(20 * da.x + 10)), l.pivot.set(mt(5 * da.x - 2), 0), oa.register(l, `${e}firebg`), a.addChild(l), he.push(l);
			const d = new PIXI.Container;
			d.position.set(0, 0), a.addChild(d);
			const c = new PIXI.Container;
			if (c.position.set(0, mt(20 * da.x + (u.display_username ? 36 : 10))), a.addChild(c), "tiny" !== ut) {
				const t = new PIXI.Graphics;
				t.beginFill(0, void 0 === G.video.boardopacity ? .85 : G.video.boardopacity), t.drawRect(0, 0, mt(156), mt(28 + 3 * da.x * (u.nextcount || 5))), t.endFill(), t.position.set(mt(10 * da.x), 0), oa.register(t, `${e}nextbg`), a.addChild(t);
				const n = new PIXI.Sprite(Gn[`nextfg_${u.nextcount||5}`]);
				n.position.set(mt(10 * da.x) - mt(1.5) - 1, mt(-1.5) - 1), oa.register(n, `${e}nextfg`), a.addChild(n), he.push(n)
			}
			const m = new PIXI.Container;
			if (m.position.set(mt(10 * da.x + 2), mt(27)), oa.register(m, `${e}next`), a.addChild(m), "tiny" !== ut) {
				const t = new PIXI.Graphics;
				t.lineStyle(0, 0, 0), t.beginFill(0, void 0 === G.video.boardopacity ? .85 : G.video.boardopacity), t.drawRect(0, 0, mt(156), mt(118)), t.endFill(), t.position.set(mt(-156), 0), oa.register(t, `${e}holdbg`), a.addChild(t);
				const n = new PIXI.Sprite(Gn.holdfg);
				n.position.set(mt(-156) - mt(1.5) - 1, mt(-1.5) - 1), oa.register(n, `${e}holdfg`), a.addChild(n), he.push(n)
			}
			const g = new PIXI.Container;
			if (g.position.set(mt(-154), mt(27)), oa.register(g, `${e}hold`), a.addChild(g), "full" === ut) {
				const t = new PIXI.Graphics;
				t.lineStyle(mt(2), 16711680, 1), t.moveTo(0, 0), t.lineTo(mt(10 * da.x), 0), t.visible = !1, t.position.set(0, 0), oa.register(t, `${e}skyline`), a.addChild(t)
			}
			const h = new PIXI.Container;
			h.position.set(0, 0), a.addChild(h);
			const y = new PIXI.Sprite(Gn.boxborder);
			if (y.position.set(mt(-1.5) - 1, mt(-1.5) - 1), oa.register(y, `${e}boxborder`), a.addChild(y), he.push(y), "full" === ut) {
				const t = new PIXI.TheoryType("", {
					fontSize: mt(138),
					wordWrapWidth: 113,
					lineHeight: mt(138),
					fontWeight: .4,
					fill: 3355443,
					align: "center",
					fontURL: "res/font/hun.fnt",
					imageURL: "res/font/hun.png"
				});
				t.visible = !1, t.blendMode = PIXI.BLEND_MODES.SCREEN, t.position.set(0, mt(6.25 * da.x)), oa.register(t, `${e}backerfg`), a.addChild(t);
				const n = new PIXI.Graphics;
				n.beginFill(2236962, .2), n.drawRect(0, 0, mt(10 * da.x), mt(2 * da.x)), n.endFill(), n.visible = !1, n.position.set(0, mt(2.5 * da.x)), oa.register(n, `${e}replaybg`), a.addChild(n);
				const o = new PIXI.TheoryType("REPLAY", {
					fontSize: mt(46),
					wordWrapWidth: 340,
					lineHeight: mt(46),
					fontWeight: .4,
					fill: 2631720,
					align: "center",
					fontURL: "res/font/hun.fnt",
					imageURL: "res/font/hun.png"
				});
				o.visible = !1, o.position.set(0, mt(4.1 * da.x)), oa.register(o, `${e}replayfg`), a.addChild(o);
				const i = new PIXI.TheoryType("NEXT", {
					fontSize: mt(22),
					wordWrapWidth: mt(1600),
					lineHeight: mt(22),
					fontWeight: .5,
					fill: 526344,
					align: "left",
					fontURL: "res/font/hun.fnt",
					imageURL: "res/font/hun.png"
				});
				i.position.set(mt(10 * da.x + 1), mt(20)), oa.register(i, `${e}nexttext`), a.addChild(i), _e.push(i);
				const s = new PIXI.TheoryType("HOLD", {
					fontSize: mt(22),
					wordWrapWidth: mt(1600),
					lineHeight: mt(22),
					fontWeight: .5,
					fill: 526344,
					align: "left",
					fontURL: "res/font/hun.fnt",
					imageURL: "res/font/hun.png"
				});
				s.position.set(mt(-155), mt(20)), oa.register(s, `${e}holdtext`), a.addChild(s), _e.push(s)
			}
			const f = new PIXI.TheoryType("UNKNOWN", {
				fontSize: mt(19),
				wordWrapWidth: 825,
				lineHeight: mt(19),
				fontWeight: .4,
				fill: 14540253,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			f.visible = !1, f.position.set(0, mt(20 * da.x + 30)), oa.register(f, `${e}usernamefg`), a.addChild(f), Ee.push(f);
			const _ = new PIXI.TheoryType("0", {
				fontSize: mt(19),
				wordWrapWidth: 825,
				lineHeight: mt(19),
				fontWeight: .4,
				fill: 16777215,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			_.visible = !1, _.position.set(0, mt(20 * da.x + 20)), oa.register(_, `${e}zenscorefg`), a.addChild(_), Ee.push(_);
			const E = new PIXI.TheoryType("1", {
				fontSize: mt(38),
				wordWrapWidth: 413,
				lineHeight: mt(38),
				fontWeight: .4,
				fill: 16777215,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			E.visible = !1, E.position.set(0, mt(20 * da.x + 56)), oa.register(E, `${e}zenlevelfg`), a.addChild(E), Ee.push(E);
			const v = new PIXI.TheoryType("", {
				fontSize: mt(19),
				wordWrapWidth: 825,
				lineHeight: mt(19),
				fontWeight: .4,
				fill: 16777215,
				align: "center",
				fontURL: "res/font/hun.fnt",
				imageURL: "res/font/hun.png"
			});
			v.visible = !1, v.position.set(0, mt(20 * da.x + 80)), oa.register(v, `${e}zenlevelhierofg`), a.addChild(v), Ee.push(v), "full" === ut && (to(a, "timer", "time", `0:00${aa(".000")}`, 560), to(a, "kills", "KO's", "0", 560), to(a, "attack", "attack", `0${aa(",0.00/M")}`, 560), to(a, "lines", "lines", `0${aa("/40")}`, 480), to(a, "pieces", "pieces", `0${aa(",0.00/S")}`, 400), to(a, "level", "level", "1", 320), to(a, "finesse_l", "finesse", `0${aa(",100.00%,0F")} }`, 200), to(a, "keys", "inputs", `0${aa(",0.00/P")}`, 160), to(a, "score", "score", "0", 510, !0), to(a, "placement", "placement", `${aa("#")}1`, 510, !0), to(a, "finesse", "finesse", `0${aa(",100.00%")}`, 510, !0), to(a, "finesse_faults", "0 faults", "", 570, !0), to(a, "vs", "VS score", "0.00", 510, !0)), Io(a),
				function (e, t, n, a, o, s) {
					if (i()) return;
					w = e, ae = !0, k = t, se = !0, L = n, re = !0, x = a, le = !0, B = o, de = !0, T = s, ce = !0
				}(s, d, h, m, g, c), Qt(), Ft(), Cn(!0), "tiny" === ut && "low" !== G.video.caching && (F.cacheAsBitmap = !0), Object.keys(Rn).forEach(e => {
					On(e, Rn[e])
				}), "full" === ut && (Kn = !0)
		}

		function Io(e) {
			i() || (F = e)
		}
		return {
			IID: e,
			createGameHolder: function (e) {
				i() || (bo(e), ct(!1))
			},
			bindHolder: function (e) {
				i() || Io(e)
			},
			getPos: function () {
				return {
					pos: ea(k, mt(5 * da.x), mt(10 * da.x), Ne),
					scale: Ne
				}
			},
			getPosTransformed: function () {
				return {
					pos: Qn(k, mt(5 * da.x), mt(10 * da.x)),
					scale: Ne
				}
			},
			flushCanvases: function () {
				i() || bo()
			},
			bindEventSource: function (e) {
				t = e, e.bind(ga), e.bind(pa), e.bind(Sa), e.bind(Ca), i() || e.bind(Ra)
			},
			bindRollingReplay: function (e) {
				l.bindRolling(e)
			},
			setListenID: function (e) {
				l.setListenID(e)
			},
			setGame: function (e) {
				(u = e).version || (u.version = ba), u.version < ba && !i() && d({
						msg: "this replay is outdated and may not play properly",
						color: "#FFD800",
						icon: "warning",
						timeout: 7500
					}), u.seed_random && (u.seed = Math.floor(2147483646 * Math.random() + 1)), _.seed = u.seed, v = new Wt(u.seed || 0), X = u.g || 0, u.garbagespeed = u.garbagespeed || 20, u.garbagecap = u.garbagecap || 8, O = Math.min(10, Math.max(0, u.stock || 0)), u.kickset = u.kickset || "SRS", s = fa.kicksets[u.kickset] || fa.kicksets.SRS, u.score && (_.score = u.score), u.zenlevels && (_.zenlevel = u.zenlevel, _.zenprogress = u.zenprogress),
					function () {
						let e = [];
						for (let t = 0; t < 40; t++) {
							let t = [];
							for (let e = 0; e < 10; e++) t.push(null);
							e.push(t)
						}
						P = e
					}(), u.map && function (e) {
						const t = (e = e.replace(/[\s\n\r]/g, "").toLowerCase()).split("?");
						e = t[0];
						let n = t[1] || "";
						if (z = t[2] || null, n = n.replace(/[^zlosijt]/g, ""), e.length % 10 != 0) return;
						if (n && n.length)
							for (U = n.split(""); U.length < 7;) mn();
						const a = 40 - e.length / 10;
						for (let t = 0; t < e.length; t++) {
							const n = a + Math.floor(t / 10),
								o = t % 10;
							let i = e[t];
							"_" === i && (i = null), "#" === i && (i = "gb"), "@" === i && (i = "gbd"), P[n][o] = i
						}
					}(u.map), xt = u.handling ? {
						arr: Math.floor(10 * Math.max(0, Math.min(u.handling.arr, 5))) / 10,
						das: Math.floor(10 * Math.max(1, Math.min(u.handling.das, 20))) / 10,
						sdf: Math.floor(Math.max(5, Math.min(u.handling.sdf, 41))),
						safelock: u.version >= 12 && !1 !== u.handling.safelock
					} : {
						arr: Math.floor(10 * Math.max(0, Math.min(G.handling.arr, 5))) / 10,
						das: Math.floor(10 * Math.max(1, Math.min(G.handling.das, 20))) / 10,
						sdf: Math.floor(Math.max(5, Math.min(G.handling.sdf, 41))),
						safelock: !1 !== G.handling.safelock
					}, u.room_handling && (xt.arr = Math.floor(10 * Math.max(0, Math.min(u.room_handling_arr, 5))) / 10, xt.das = Math.floor(10 * Math.max(1, Math.min(u.room_handling_das, 20))) / 10, xt.sdf = Math.floor(Math.max(5, Math.min(u.room_handling_sdf, 41)))), void 0 === u.objective && (u.objective = {
						type: "none"
					}), u.levels ? Aa(0, !0, u.startinglevel || 1) : _.level = u.startinglevel || 1, void 0 === u.physical && (u.physical = !0), u.can_retry && "keyboard" === t.type() && (t.bindHyperRetry(() => {
						ee && !u.retryisclear && (ee = !1, qa("retry", !0), yt.play("detonate2"))
					}), setTimeout(() => {
						t.bindHyperForfeit(() => {
							te && (te = !1, qa("forfeit", !0), yt.play("detonate2"))
						})
					}, 1e3)), u.nextcount ? u.nextcount = Math.min(5, Math.max(1, Math.floor(parseInt(u.nextcount)))) : u.nextcount = 5, mn(), a(() => {
						PIXI.Ticker.shared.add(jt), PIXI.Ticker.shared.add(Xt), Ft(), 5 !== u.nextcount && bo(), Ia.push(this), u.usezenconfig && document.getElementById("zen_panel").classList.remove("hidden")
					})
			},
			startGame: function () {
				a(() => {
					let e = (u.stride ? u.mission ? 500 : 0 : u.precountdown || 0) + (u.prestart || 0),
						n = u.prestart || 0;
					if (u.physical && !u.display_replay && document.body.classList.add("ingame_phys"), u.usezenconfig && Ka(!0), setTimeout(() => {
							p && (!u.stride && u.mission && (u.physical || u.force_mission) && (Un(u.mission_type || "mission", u.mission, !0), yt.playIngame(u.mission_type || "mission", ut, De, Ne, !1, u.physical || u.force_mission, m)), F.visible = !0, "slow" === u.zoominto ? ra.animate(F, {
								0: {
									"pivot.y": mt(25 * da.x + 1600)
								},
								1: {
									"pivot.y": mt(10 * da.x)
								}
							}, .5, BezierEasing(.06, .18, .42, 1.16)) : "fast" === u.zoominto ? ra.animate(F, {
								0: {
									"scale.x": 0
								},
								1: {
									"scale.x": 1
								}
							}, u.stride ? .05 : .25, BezierEasing(.06, .18, .45, .98)) : "cinematic" === u.zoominto && ra.animate(F, {
								0: {
									alpha: .5,
									"scale.x": 0,
									"scale.y": 0,
									"pivot.x": mt(5 * da.x + (0 === Ae ? 0 : Ae > 0 ? 300 : -300))
								},
								1: {
									alpha: 1,
									"scale.x": "inherit",
									"scale.y": "inherit",
									"pivot.x": mt(5 * da.x)
								}
							}, 6, BezierEasing(.47, .66, .54, .98)))
						}, n), u.countdown) {
						let t = u.stride ? 1 : u.countdown_count || 3,
							a = u.stride ? 1e3 : u.countdown_interval || 1e3,
							o = u.stride ? u.mission ? 500 : 0 : u.precountdown || 0;
						e += t * a;
						for (let e = t; e > 0; e--) setTimeout(() => {
							if (p) {
								if (u.stride) return Pn("countdown_stride", "ready"), (u.physical || u.force_mission) && yt.playIngame("countdown5", ut, De, Ne, !1, u.physical || u.force_mission, m), void setTimeout(() => {
									Pn("countdown_stride", "set"), (u.physical || u.force_mission) && yt.playIngame("countdown4", ut, De, Ne, !1, u.physical || u.force_mission, m)
								}, 500);
								Pn("countdown", e), (u.physical || u.force_mission) && yt.playIngame(`countdown${Math.min(e,5)}`, ut, De, Ne, !1, u.physical || u.force_mission, m)
							}
						}, n + (t - e) * a + o)
					}
					setTimeout(() => {
						p && (ee = !1, te = !1, u.countdown && (Pn(u.stride ? "countdown_stride" : "countdown", "GO!"), (u.physical || u.force_mission) && yt.playIngame("go", ut, De, Ne, !1, u.physical || u.force_mission, m)), t.readyEventQueue(), u.anchorseed && !i() && u.physical && et.anchorSeed(u.seed), (u.onstart || (() => {}))(), g = !0, _.time.start = performance.now(), _.time.zero = !1, ua(), u.noreplay || l.pushEvent("start", {}))
					}, e), l.pushEvent("full", eo())
				}), o(() => {
					u.noreplay || (l.pushEvent("start", {}), l.pushEvent("full", eo())), _.time.zero = !1, ua()
				})
				if(t.type() == "keyboard"){
				    window.lol = this;

                } else{
					window.otherPlayer = this;
				};
			},
			getBag: function() {
                mn();
                return window.bagArray;
			},
			
			export: function () {
				return eo()
			},
			end: function () {
				qa("drop", !0)
			},
			endNow: function () {
				qa("dropnow", !0)
			},
			endLose: function (e = !1) {
				e && Da(!0), qa("topout", !0)
			},
			endWin: function () {
				qa("winner", !0)
			},
			endClear: function () {
				qa("clear", !0)
			},
			queueEndWin: function () {
				let e = !1;
				const n = () => {
					0 !== t.amountToCatchUp() ? (e = !1, qt(1, () => {
						n()
					})) : e ? qa("winner", !0) : (e = !0, setTimeout(n, 50))
				};
				n()
			},
			queueEndLose: function (e = !1) {
				let n = !1;
				const a = () => {
					0 !== t.amountToCatchUp() ? (n = !1, qt(1, () => {
						a()
					})) : n ? (e && Da(!0), qa("topout", !0)) : (n = !0, setTimeout(a, 50))
				};
				a()
			},
			destroy: function () {
				i() || Jn()
			},
			doFrame: function () {
				i() && i() && Kt()
			},
			playbackSpeed: function (e) {
				if (void 0 === e) return c;
				c = e
			},
			location: function (e, t, n) {
				Ae = e, $e = t, Oe = n
			},
			changeDisplayMode: function (e) {
				ut !== e && (ut = e, bo(), Pt = zt - 1)
			},
			on: function (e, t) {
				u[`on${e}`] = t
			},
			tamper: function (e = ["t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t"]) {
				U = e
			},
			setTargeted: function (e) {
				ot = !!e
			},
			setTargets: function (e) {
				t.pushTargets(e)
			},
			attack: function (e, t) {
				u.hasgarbage = !0, Oa(e, t)
			},
			highest: function () {
				return rn()
			},
			garbagestats: function () {
				return {
					garbagereceived: D,
					lastattacker: N
				}
			},
			displayOffDef: function (e, t) {
				e && Pn("offence", e, 3.5, 5), t && Pn("defense", t, 5.5, 5), e && t && Pn("offdefplus", "+", 4.5, 5)
			},
			kev: function (e) {
				R = e.playercount, e.killer.name == u.username && (Pa(150 + e.fire / 700 * 200), _.kills++)
			},
			fire: function (e) {
				Pa(e)
			},
			pullZenConfig: function () {
				Ka(!0)
			},
			levelZen: function () {
				Xa()
			}
		}
	}
})();